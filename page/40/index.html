<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="RS,GPS,GIS,QGIS,Opticks,QT,OpenCV,OSG" />
       
      <meta name="description" content="地理信息系统，遥感科学，卫星导航定位技术综合研究。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 帕拉丁的游鱼</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="帕拉丁的游鱼" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">帕拉丁的游鱼</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java突击：02-List"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/14/Java%E7%AA%81%E5%87%BB%EF%BC%9A02-List/"
    >Java突击：02-List</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/14/Java%E7%AA%81%E5%87%BB%EF%BC%9A02-List/" class="article-date">
  <time datetime="2023-04-14T09:17:57.000Z" itemprop="datePublished">2023-04-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="ArrayList和LinkedList的区别？分别用在什么场景？"><a href="#ArrayList和LinkedList的区别？分别用在什么场景？" class="headerlink" title="ArrayList和LinkedList的区别？分别用在什么场景？"></a>ArrayList和LinkedList的区别？分别用在什么场景？</h1><p>答：</p>
<p>①ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。<br>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列<br>②当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>③当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。<br>④从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。<br>⑤ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。</p>
<p>场景：<br>链表，插入删除快，查找修改慢。 适用于频繁增删的场景。<br>数组，查找快，插入删除慢。 适用于频繁查找和修改的场景。</p>
<p>3.1. 接口继承关系和实现<br>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。 </p>
<ol>
<li><p>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 </p>
</li>
<li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </p>
</li>
<li><p>Map：是映射表的基础接口 </p>
</li>
<li><ol start="2">
<li>List<br>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。 </li>
</ol>
</li>
<li><p>2.1. ArrayList（数组）<br>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进<br>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 </p>
</li>
</ol>
<p>3.2.2. Vector（数组实现、线程同步）<br>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 </p>
<p>3.2.3. LinkList（链表）<br>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 </p>
<p>3.3. Set<br>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>法。</p>
<p>3.3.1.1. HashSet（Hash 表）<br>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。<br>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 </p>
<p>3.3.1.2. TreeSet（二叉树） </p>
<ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。 </li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 </li>
</ol>
<p>3.3.1.3. LinkHashSet（HashSet+LinkedHashMap）<br> 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。<br> LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 </p>
<p>3.4. Map</p>
<p> 3.4.1. HashMap（数组+链表+红黑树）<br>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 </p>
<p>3.4.1.1. JAVA7 实现<br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 </p>
<ol>
<li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，等于 capacity * loadFactor  </li>
</ol>
<p>3.4.1.2. JAVA8 实现 </p>
<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 </p>
<p>3.4.2. ConcurrentHashMap<br>3.4.2.1. Segment 段 </p>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。 </p>
<p>3.4.2.2. 线程安全（Segment 继承 ReentrantLock 加锁） </p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。  </p>
<p>3.4.2.3. 并行度（默认 16） </p>
<p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p>
<p>3.4.2.4. Java8 实现 （引入了红黑树） </p>
<p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。  </p>
<p>3.4.3. HashTable（线程安全）<br>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 </p>
<p>3.4.4. TreeMap（可排序）<br>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。<br>参考：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a> </p>
<p>3.4.5. LinkHashMap（记录插入顺序）<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/List/" rel="tag">List</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Java突击：01-JVM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/13/Java%E7%AA%81%E5%87%BB%EF%BC%9A01-JVM/"
    >Java突击：01-JVM</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/13/Java%E7%AA%81%E5%87%BB%EF%BC%9A01-JVM/" class="article-date">
  <time datetime="2023-04-13T13:49:13.000Z" itemprop="datePublished">2023-04-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>JVM面试题</p>
<h1 id="1、内存模型以及分区，需要详细到每个区放什么。"><a href="#1、内存模型以及分区，需要详细到每个区放什么。" class="headerlink" title="1、内存模型以及分区，需要详细到每个区放什么。"></a>1、内存模型以及分区，需要详细到每个区放什么。</h1><p>JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面， class 类信息常量池（static 常量和 static 变量）等放在方法区 new:</p>
<ul>
<li>方法区：<br>主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。</li>
<li>堆：<br>初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。</li>
<li>栈：<br>栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。</li>
<li>本地方法栈：<br>主要为 Native 方法服务程序计数器：记录当前线程执行的行号</li>
</ul>
<h1 id="2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。"><a href="#2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。" class="headerlink" title="2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。"></a>2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</h1><p>堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包 含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候， 就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</p>
<h1 id="3-GC-的两种判定方法"><a href="#3-GC-的两种判定方法" class="headerlink" title="3. GC 的两种判定方法"></a>3. GC 的两种判定方法</h1><p>引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A） 的情况。引用链法： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GCROOT 就说明，不能到达 GC ROOT 就说明可以回收。</p>
<h1 id="4-Minor-GC-与-Full-GC-分别在什么时候发生？"><a href="#4-Minor-GC-与-Full-GC-分别在什么时候发生？" class="headerlink" title="4. Minor GC 与 Full GC 分别在什么时候发生？"></a>4. Minor GC 与 Full GC 分别在什么时候发生？</h1><p>首先区分一下Minor GC和Full GC。<br>Minor GC是新生代GC，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死的，所以Minor GC非常平凡，一般回收速度也比较i快。</p>
<p>Major GC/Full GC 是老年代GC，指的是发生在老年代的GC，出现Major GC一般经常会伴有Minor GC，Major GC的速度比Minor GC慢的多。</p>
<p>何时发生？<br>(1)Minor GC发生：当jvm无法为新的对象分配空间的时候就会发生Minor gc，所以分配对象的频率越高，也就越容易发生Minor gc。<br>(2)Full GC：发生GC有两种情况：<br>①当老年代无法分配内存的时候，会导致MinorGC。<br>②当发生Minor GC的时候可能触发Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次Minor GC以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生Full GC。</p>
<h1 id="5-类加载的几个过程："><a href="#5-类加载的几个过程：" class="headerlink" title="5. 类加载的几个过程："></a>5. 类加载的几个过程：</h1><p>加载、验证、准备、解析、初始化。然后是使用和卸载了</p>
<p>通过全限定名来加载生成 class 对象到内存中，然后进行验证这个 class 文件，包括文件格式校验、元数据验证，字节码校验等。准备是对这个对象分配内存。解析是将符号引用转化为直接引用（指针引用），初始化就是开始执行构造器的代码</p>
<h1 id="6-JVM-内存分哪几个区，每个区的作用是什么"><a href="#6-JVM-内存分哪几个区，每个区的作用是什么" class="headerlink" title="6.JVM 内存分哪几个区，每个区的作用是什么"></a>6.JVM 内存分哪几个区，每个区的作用是什么</h1><p>java 虚拟机主要分为以下几个区:</p>
<ul>
<li><p>方法区：<br>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。该区域是被线程共享的。方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p>
</li>
<li><p>虚拟机栈:<br>虚拟机栈也就是我们平常所称的栈内存,它为 java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。虚拟机栈是线程私有的，它的生命周期与线程相同。局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p>
</li>
<li><p>本地方法栈：<br>本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</p>
</li>
</ul>
<p>*堆<br>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p>
<p>*程序计数器<br>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码，指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。</p>
<h1 id="7-如和判断一个对象是否存活-或者-GC-对象的判定方法）"><a href="#7-如和判断一个对象是否存活-或者-GC-对象的判定方法）" class="headerlink" title="7.如和判断一个对象是否存活?(或者 GC 对象的判定方法）"></a>7.如和判断一个对象是否存活?(或者 GC 对象的判定方法）</h1><p>判断一个对象是否存活有两种方法:</p>
<p>1.引用计数法<br>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.<br>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p>
<p>2.可达性算法(引用链法)<br>该算法的思想是：从一个被称为 GC Roots的对象开始向下搜索，如果一个对象到 GCRoots 没有任何引用链相连时，则说明此对象不可用。<br>在 java 中可以作为 GC Roots 的对象有以下几种:<br>虚拟机栈中引用的对象方法区类静态属性引用的对象方法区常量池引用的对象本地方法栈 JNI 引用的对象<br>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记<br>如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。<br>如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 FQueue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</p>
<h1 id="8-java-中垃圾收集的方法有哪些"><a href="#8-java-中垃圾收集的方法有哪些" class="headerlink" title="8.java 中垃圾收集的方法有哪些?"></a>8.java 中垃圾收集的方法有哪些?</h1><p>标记-清除:<br>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想是从根对象开始遍历所有可达对象，并将其标记为“非垃圾”，然后清除未被标记的对象，即“垃圾”。具体来说，标记清除算法包含以下两个阶段：</p>
<p>标记阶段：从根对象开始遍历所有可达对象，并将其标记为“非垃圾”。<br>清除阶段：扫描整个堆，将未被标记的对象进行回收（或者放入空闲链表等待下一次分配）。</p>
<p>通过这种方式，标记清除算法可以有效地回收不再使用的内存空间，提高程序的内存利用效率。这种方法很简单，但是会有两个主要问题：<br>1.效率不高，标记和清除的效率都很低；<br>2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。</p>
<p>复制算法:<br>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。<br>于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。<br>每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)</p>
<p>标记-整理：<br>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</p>
<p>分代收集：<br>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理或者 标记-清除。</p>
<h1 id="9-什么是类加载器，类加载器有哪些"><a href="#9-什么是类加载器，类加载器有哪些" class="headerlink" title="9.什么是类加载器，类加载器有哪些?"></a>9.什么是类加载器，类加载器有哪些?</h1><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<p>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH） 来加载 Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</p>
<h1 id="10-类加载器双亲委派模型机制？"><a href="#10-类加载器双亲委派模型机制？" class="headerlink" title="10. 类加载器双亲委派模型机制？"></a>10. 类加载器双亲委派模型机制？</h1><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h1 id="11-什么情况下会发生栈内存溢出？"><a href="#11-什么情况下会发生栈内存溢出？" class="headerlink" title="11.什么情况下会发生栈内存溢出？"></a>11.什么情况下会发生栈内存溢出？</h1><p>1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；<br>2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；<br>3、调整参数-xss去调整jvm栈的大小</p>
<h1 id="12-怎么打破双亲委派模型？"><a href="#12-怎么打破双亲委派模型？" class="headerlink" title="12.怎么打破双亲委派模型？"></a>12.怎么打破双亲委派模型？</h1><p>自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法；</p>
<h1 id="13-强引用、软应用、弱引用、虚引用的区别？"><a href="#13-强引用、软应用、弱引用、虚引用的区别？" class="headerlink" title="13.强引用、软应用、弱引用、虚引用的区别？"></a>13.强引用、软应用、弱引用、虚引用的区别？</h1><p>强引用：<br>强引用是我们使用最广泛的引用，如果一个对象具有强引用，那么垃圾回收期绝对不会回收它，当内存空间不足时，垃圾回收器宁愿抛出OutOfMemoryError，也不会回收具有强引用的对象；我们可以通过显示的将强引用对象置为null，让gc认为该对象不存在引用，从而来回收它；</p>
<p>软引用：<br>软应用是用来描述一些有用但不是必须的对象，在java中用SoftReference来表示，当一个对象只有软应用时，只有当内存不足时，才会回收它；<br>软引用可以和引用队列联合使用，如果软引用所引用的对象被垃圾回收器所回收了，虚拟机会把这个软引用加入到与之对应的引用队列中；</p>
<p>弱引用：<br>弱引用是用来描述一些可有可无的对象，在java中用WeakReference来表示，在垃圾回收时，一旦发现一个对象只具有软引用的时候，无论当前内存空间是否充足，都会回收掉该对象；<br>弱引用可以和引用队列联合使用，如果弱引用所引用的对象被垃圾回收了，虚拟机会将该对象的引用加入到与之关联的引用队列中；</p>
<p>虚引用：<br>虚引用就是一种可有可无的引用，无法用来表示对象的生命周期，任何时候都可能被回收，虚引用主要使用来跟踪对象被垃圾回收的活动，虚引用和软引用与弱引用的区别在于：虚引用必须和引用队列联合使用；在进行垃圾回收的时候，如果发现一个对象只有虚引用，那么就会将这个对象的引用加入到与之关联的引用队列中，程序可以通过发现一个引用队列中是否已经加入了虚引用，来了解被引用的对象是否需要被进行垃圾回收；</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JVM在一些互联网大厂是面试必问的一个技术点，所以在面试时一定要注重重点，想一些高并发高可用的技术。面试时要掌握节奏，说一些让面试官眼前一亮的技术，有些基础的东西能少说就少说，毕竟面试官面了这么多早就听够了，越是稀少的越是能激发面试官的兴趣，然后掌握在自己的节奏中。</p>
<h1 id="1、Java-是如何实现跨平台的？"><a href="#1、Java-是如何实现跨平台的？" class="headerlink" title="1、Java 是如何实现跨平台的？"></a>1、Java 是如何实现跨平台的？</h1><p>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p>
<p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p>
<h1 id="2、什么是-JVM-？"><a href="#2、什么是-JVM-？" class="headerlink" title="2、什么是 JVM ？"></a>2、什么是 JVM ？</h1><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p>
<p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。<br>JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h1 id="3、JVM-由哪些部分组成？"><a href="#3、JVM-由哪些部分组成？" class="headerlink" title="3、JVM 由哪些部分组成？"></a>3、JVM 由哪些部分组成？</h1><p>解析：这是对 JVM 体系结构的考察</p>
<p>答：JVM 的结构基本上由 4 部分组成：</p>
<p>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p>
<p>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p>
<p>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p>
<p>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</p>
<h1 id="4、类加载器是有了解吗？"><a href="#4、类加载器是有了解吗？" class="headerlink" title="4、类加载器是有了解吗？"></a>4、类加载器是有了解吗？</h1><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p>
<p>答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p>
<p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<h1 id="5、面试官：Java-虚拟机是如何判定两个-Java-类是相同的？"><a href="#5、面试官：Java-虚拟机是如何判定两个-Java-类是相同的？" class="headerlink" title="5、面试官：Java 虚拟机是如何判定两个 Java 类是相同的？"></a>5、面试官：Java 虚拟机是如何判定两个 Java 类是相同的？</h1><p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p>
<h1 id="6、类似-Xms、-Xmn这些参数的含义：答："><a href="#6、类似-Xms、-Xmn这些参数的含义：答：" class="headerlink" title="6、类似-Xms、-Xmn这些参数的含义：答："></a>6、类似-Xms、-Xmn这些参数的含义：答：</h1><p>堆内存分配：<br>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br>非堆内存分配：<br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>-Xmn2G：设置年轻代大小为2G。<br>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>(1) 基本概念： </p>
<p> JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 </p>
<p>(2) 运行过程：<br>   我们都知道Java源文件，通过编译器，能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。 </p>
<p>也就是如下：    </p>
<p> ① Java源文件—-&gt;编译器—-&gt;字节码文件<br> ② 字节码文件—-&gt;JVM—-&gt;机器码<br> 每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p>
<h2 id="2-1-线程"><a href="#2-1-线程" class="headerlink" title="2.1. 线程"></a>2.1. 线程</h2><p>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。<br>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。<br>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。 </p>
<p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p>
<p>虚拟机线程（VM thread）<br>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</p>
<p>周期性任务线程<br>这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</p>
<p>GC 线程<br>这些线程支持 JVM 中不同的垃圾回收活动。 </p>
<p>编译器线程<br>这些线程在运行时将字节码动态编译成本地平台相关的机器码。 </p>
<p>信号分发线程<br>这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</p>
<h2 id="2-2-JVM-内存区域"><a href="#2-2-JVM-内存区域" class="headerlink" title="2.2. JVM 内存区域"></a>2.2. JVM 内存区域</h2><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。<br>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。  </p>
<p>线程共享区域随虚拟机的启动/关闭而创建/销毁。<br>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p>
<h3 id="2-2-1-程序计数器-线程私有"><a href="#2-2-1-程序计数器-线程私有" class="headerlink" title="2.2.1. 程序计数器(线程私有)"></a>2.2.1. 程序计数器(线程私有)</h3><pre><code>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。 
正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。 
这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。  
</code></pre>
<h3 id="2-2-2-虚拟机栈-线程私有"><a href="#2-2-2-虚拟机栈-线程私有" class="headerlink" title="2.2.2. 虚拟机栈(线程私有)"></a>2.2.2. 虚拟机栈(线程私有)</h3><pre><code>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 
栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。  
</code></pre>
<h3 id="2-2-3-本地方法区-线程私有"><a href="#2-2-3-本地方法区-线程私有" class="headerlink" title="2.2.3. 本地方法区(线程私有)"></a>2.2.3. 本地方法区(线程私有)</h3><pre><code>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 
</code></pre>
<h3 id="2-2-4-堆（Heap-线程共享）-运行时数据区"><a href="#2-2-4-堆（Heap-线程共享）-运行时数据区" class="headerlink" title="2.2.4. 堆（Heap-线程共享）-运行时数据区"></a>2.2.4. 堆（Heap-线程共享）-运行时数据区</h3><pre><code>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。
</code></pre>
<h3 id="2-2-5-方法区-永久代（线程共享）"><a href="#2-2-5-方法区-永久代（线程共享）" class="headerlink" title="2.2.5. 方法区/永久代（线程共享）"></a>2.2.5. 方法区/永久代（线程共享）</h3><pre><code>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。 
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池 （Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。
</code></pre>
<h2 id="2-3-JVM-运行时内存"><a href="#2-3-JVM-运行时内存" class="headerlink" title="2.3. JVM 运行时内存"></a>2.3. JVM 运行时内存</h2><pre><code>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。 
</code></pre>
<h3 id="2-3-1-新生代"><a href="#2-3-1-新生代" class="headerlink" title="2.3.1. 新生代"></a>2.3.1. 新生代</h3><pre><code>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。 
</code></pre>
<p>2.3.1.1. Eden 区<br>    Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 </p>
<p>2.3.1.2. ServivorFrom<br>    上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 </p>
<p>2.3.1.3. ServivorTo<br>    保留了一次 MinorGC 过程中的幸存者。 </p>
<p>2.3.1.4. MinorGC 的过程（复制-&gt;清空-&gt;互换） </p>
<pre><code>MinorGC 采用复制算法。 

1：eden、servicorFrom 复制到 ServicorTo，年龄+1 
首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）； 

2：清空 eden、servicorFrom 
然后，清空 Eden 和 ServicorFrom 中的对象； 

3：ServicorTo 和 ServicorFrom 互换 
最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。 
</code></pre>
<h3 id="2-3-2-老年代"><a href="#2-3-2-老年代" class="headerlink" title="2.3.2. 老年代"></a>2.3.2. 老年代</h3><pre><code>主要存放应用程序中生命周期长的内存对象。 
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。 
MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。 
</code></pre>
<h3 id="2-3-3-永久代"><a href="#2-3-3-永久代" class="headerlink" title="2.3.3. 永久代"></a>2.3.3. 永久代</h3><pre><code>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 
</code></pre>
<p>2.3.3.1. JAVA8 与元数据<br>    在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>
<h2 id="2-4-垃圾回收与算法"><a href="#2-4-垃圾回收与算法" class="headerlink" title="2.4. 垃圾回收与算法"></a>2.4. 垃圾回收与算法</h2><h3 id="2-4-1-如何确定垃圾"><a href="#2-4-1-如何确定垃圾" class="headerlink" title="2.4.1. 如何确定垃圾"></a>2.4.1. 如何确定垃圾</h3><p>2.4.1.1. 引用计数法<br>       在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。 </p>
<p>2.4.1.2. 可达性分析 </p>
<pre><code> 为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。 
</code></pre>
<h3 id="2-4-2-标记清除算法（Mark-Sweep）"><a href="#2-4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="2.4.2. 标记清除算法（Mark-Sweep）"></a>2.4.2. 标记清除算法（Mark-Sweep）</h3><pre><code>  最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图 

  从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。 
</code></pre>
<h3 id="2-4-3-复制算法（copying）"><a href="#2-4-3-复制算法（copying）" class="headerlink" title="2.4.3. 复制算法（copying）"></a>2.4.3. 复制算法（copying）</h3><pre><code>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：  

这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。 
</code></pre>
<h3 id="2-4-4-标记整理算法-Mark-Compact"><a href="#2-4-4-标记整理算法-Mark-Compact" class="headerlink" title="2.4.4. 标记整理算法(Mark-Compact)"></a>2.4.4. 标记整理算法(Mark-Compact)</h3><pre><code>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：
</code></pre>
<h3 id="2-4-5-分代收集算法"><a href="#2-4-5-分代收集算法" class="headerlink" title="2.4.5. 分代收集算法"></a>2.4.5. 分代收集算法</h3><pre><code>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。
</code></pre>
<p>2.4.5.1. 新生代与复制算法</p>
<pre><code>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。  
</code></pre>
<p>2.4.5.2. 老年代与标记复制算法  </p>
<pre><code>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 

1. JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 
2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。 
3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。 
4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 
5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 
6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。
</code></pre>
<h2 id="2-5-JAVA-四中引用类型"><a href="#2-5-JAVA-四中引用类型" class="headerlink" title="2.5. JAVA 四中引用类型"></a>2.5. JAVA 四中引用类型</h2><h3 id="2-5-1-强引用"><a href="#2-5-1-强引用" class="headerlink" title="2.5.1. 强引用"></a>2.5.1. 强引用</h3><pre><code>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。 
</code></pre>
<h3 id="2-5-2-软引用"><a href="#2-5-2-软引用" class="headerlink" title="2.5.2. 软引用"></a>2.5.2. 软引用</h3><pre><code>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 
</code></pre>
<h3 id="2-5-3-弱引用"><a href="#2-5-3-弱引用" class="headerlink" title="2.5.3. 弱引用"></a>2.5.3. 弱引用</h3><pre><code>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
</code></pre>
<h3 id="2-5-4-虚引用"><a href="#2-5-4-虚引用" class="headerlink" title="2.5.4. 虚引用"></a>2.5.4. 虚引用</h3><pre><code>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。 
</code></pre>
<h2 id="2-6-GC-分代收集算法-VS-分区收集算法"><a href="#2-6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="2.6. GC 分代收集算法 VS 分区收集算法"></a>2.6. GC 分代收集算法 VS 分区收集算法</h2><h3 id="2-6-1-分代收集算法"><a href="#2-6-1-分代收集算法" class="headerlink" title="2.6.1. 分代收集算法"></a>2.6.1. 分代收集算法</h3><pre><code>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法 
</code></pre>
<p>2.6.1.1. 在新生代-复制算法<br>    每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. </p>
<p>2.6.1.2. 在老年代-标记整理算法 </p>
<pre><code>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.  
</code></pre>
<h3 id="2-6-2-分区收集算法"><a href="#2-6-2-分区收集算法" class="headerlink" title="2.6.2. 分区收集算法"></a>2.6.2. 分区收集算法</h3><pre><code>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。 
</code></pre>
<h2 id="2-7-GC-垃圾收集器"><a href="#2-7-GC-垃圾收集器" class="headerlink" title="2.7. GC 垃圾收集器"></a>2.7. GC 垃圾收集器</h2><pre><code>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下： 
</code></pre>
<h3 id="2-7-1-Serial-垃圾收集器（单线程、复制算法）"><a href="#2-7-1-Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="2.7.1. Serial 垃圾收集器（单线程、复制算法）"></a>2.7.1. Serial 垃圾收集器（单线程、复制算法）</h3><pre><code>Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。 Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。 
</code></pre>
<h3 id="2-7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#2-7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="2.7.2. ParNew 垃圾收集器（Serial+多线程）"></a>2.7.2. ParNew 垃圾收集器（Serial+多线程）</h3><pre><code>ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。 
ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】 
ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。 
</code></pre>
<h3 id="2-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#2-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）"></a>2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）</h3><pre><code>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。 
</code></pre>
<h3 id="2-7-4-Serial-Old-收集器（单线程标记整理算法-）"><a href="#2-7-4-Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="2.7.4. Serial Old 收集器（单线程标记整理算法 ）"></a>2.7.4. Serial Old 收集器（单线程标记整理算法 ）</h3><pre><code>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。 
在 Server 模式下，主要有两个用途： 
1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。 
2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。 
新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：

新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图： 
</code></pre>
<h3 id="2-7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#2-7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="2.7.5. Parallel Old 收集器（多线程标记整理算法）"></a>2.7.5. Parallel Old 收集器（多线程标记整理算法）</h3><pre><code>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。 

在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 ParallelScavenge和年老代 Parallel Old 收集器的搭配策略。 
新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：  
</code></pre>
<h3 id="2-7-6-CMS-收集器（多线程标记清除算法）"><a href="#2-7-6-CMS-收集器（多线程标记清除算法）" class="headerlink" title="2.7.6. CMS 收集器（多线程标记清除算法）"></a>2.7.6. CMS 收集器（多线程标记清除算法）</h3><pre><code>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 
最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 
CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： 
</code></pre>
<p>2.7.6.1. 初始标记 </p>
<p>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p>
<p>2.7.6.2. 并发标记 </p>
<p>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 </p>
<p>2.7.6.3. 重新标记 </p>
<p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 </p>
<p>2.7.6.4. 并发清除 </p>
<p>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 </p>
<p>CMS 收集器工作过程：</p>
<h3 id="2-7-7-G1-收集器"><a href="#2-7-7-G1-收集器" class="headerlink" title="2.7.7. G1 收集器"></a>2.7.7. G1 收集器</h3><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是： </p>
<ol>
<li>基于标记-整理算法，不产生内存碎片。 </li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。 </li>
</ol>
<h2 id="2-8-JAVA-IO-NIO"><a href="#2-8-JAVA-IO-NIO" class="headerlink" title="2.8. JAVA IO/NIO"></a>2.8. JAVA IO/NIO</h2><h3 id="2-8-1-阻塞-IO-模型"><a href="#2-8-1-阻塞-IO-模型" class="headerlink" title="2.8.1. 阻塞 IO 模型"></a>2.8.1. 阻塞 IO 模型</h3><p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。 </p>
<h3 id="2-8-2-非阻塞-IO-模型"><a href="#2-8-2-非阻塞-IO-模型" class="headerlink" title="2.8.2. 非阻塞 IO 模型"></a>2.8.2. 非阻塞 IO 模型</h3><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下： </p>
<p>while(true){<br> data = socket.read();<br> if(data!= error){<br> //处理数据<br> break;<br> }<br>}<br>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。 </p>
<h3 id="2-8-3-多路复用-IO-模型"><a href="#2-8-3-多路复用-IO-模型" class="headerlink" title="2.8.3. 多路复用 IO 模型"></a>2.8.3. 多路复用 IO 模型</h3><pre><code>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。 
另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。 
不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 
</code></pre>
<h3 id="2-8-4-信号驱动-IO-模型"><a href="#2-8-4-信号驱动-IO-模型" class="headerlink" title="2.8.4. 信号驱动 IO 模型"></a>2.8.4. 信号驱动 IO 模型</h3><pre><code>   在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。 
</code></pre>
<h3 id="2-8-5-异步-IO-模型"><a href="#2-8-5-异步-IO-模型" class="headerlink" title="2.8.5. 异步 IO 模型"></a>2.8.5. 异步 IO 模型</h3><pre><code>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。 
也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。 

   注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。 更多参考： http://www.importnew.com/19816.html 
</code></pre>
<h3 id="2-8-6-JAVA-IO-包"><a href="#2-8-6-JAVA-IO-包" class="headerlink" title="2.8.6. JAVA IO 包"></a>2.8.6. JAVA IO 包</h3><p>2.8.2. JAVA NIO<br>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 </p>
<p>NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 </p>
<p>2.8.2.1. NIO 的缓冲区</p>
<p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的<br>数据。 </p>
<p>2.8.2.2. NIO 的非阻塞 </p>
<p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h3 id="2-8-3-Channel"><a href="#2-8-3-Channel" class="headerlink" title="2.8.3. Channel"></a>2.8.3. Channel</h3><p>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有： </p>
<ol>
<li>FileChannel </li>
<li>DatagramChannel </li>
<li>SocketChannel </li>
<li>ServerSocketChannel </li>
</ol>
<p>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。<br>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。 </p>
<h3 id="2-8-4-Buffer"><a href="#2-8-4-Buffer" class="headerlink" title="2.8.4. Buffer"></a>2.8.4. Buffer</h3><p>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。 </p>
<pre><code>   上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。 
    在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：
</code></pre>
<p>ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer</p>
<h3 id="2-8-5-Selector"><a href="#2-8-5-Selector" class="headerlink" title="2.8.5. Selector"></a>2.8.5. Selector</h3><pre><code>  Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。
</code></pre>
<h2 id="2-9-JVM-类加载机制"><a href="#2-9-JVM-类加载机制" class="headerlink" title="2.9. JVM 类加载机制"></a>2.9. JVM 类加载机制</h2><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。</p>
<p>2.9.1.1. 加载 </p>
<p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 </p>
<p>2.9.1.2. 验证 </p>
<p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p>
<p>2.9.1.3. 准备 </p>
<p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br>public static int v = 8080;<br>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器<client>方法之中。<br>但是注意如果声明为：<br>public static final int v = 8080;<br>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。 </client></p>
<p>2.9.1.4. 解析 </p>
<p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：</p>
<ol>
<li>CONSTANT_Class_info </li>
<li>CONSTANT_Field_info </li>
<li>CONSTANT_Method_info </li>
</ol>
<p>等类型的常量。 </p>
<p>2.9.1.5. 符号引用 </p>
<p>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 </p>
<p>2.9.1.6. 直接引用 </p>
<p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 </p>
<p>2.9.1.7. 初始化 </p>
<p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 </p>
<p>2.9.1.8. 类构造器<client> </client></p>
<p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。<br>注意以下几种情况不会执行类初始化： </client></client></client></client></client></p>
<ol>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 </li>
<li>定义对象数组，不会触发该类的初始化。 </li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 </li>
<li>通过类名获取 Class 对象，不会触发类的初始化。 </li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 </li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 </li>
</ol>
<h3 id="2-9-2-类加载器"><a href="#2-9-2-类加载器" class="headerlink" title="2.9.2. 类加载器"></a>2.9.2. 类加载器</h3><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器： </p>
<p>2.9.2.1. 启动类加载器(Bootstrap ClassLoader) </p>
<ol>
<li>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。 </li>
</ol>
<p>2.9.2.2. 扩展类加载器(Extension ClassLoader) </p>
<ol start="2">
<li>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。 </li>
</ol>
<p>2.9.2.3. 应用程序类加载器(Application ClassLoader)： </p>
<ol start="3">
<li>负责加载用户路径（classpath）上的类库。<br>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。   </li>
</ol>
<h3 id="2-9-3-双亲委派"><a href="#2-9-3-双亲委派" class="headerlink" title="2.9.3. 双亲委派"></a>2.9.3. 双亲委派</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。<br>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。  </p>
<h3 id="2-9-4-OSGI（动态模型系统）"><a href="#2-9-4-OSGI（动态模型系统）" class="headerlink" title="2.9.4. OSGI（动态模型系统）"></a>2.9.4. OSGI（动态模型系统）</h3><p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。 </p>
<p>2.9.4.1. 动态改变构造 </p>
<p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。 </p>
<p>2.9.4.2. 模块化编程与热插拔 </p>
<p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。<br>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。  </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-kiwix"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/12/kiwix/"
    >kiwix</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/12/kiwix/" class="article-date">
  <time datetime="2023-04-12T12:49:27.000Z" itemprop="datePublished">2023-04-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/">知识分享</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>今天给大家分享一款离线版维基百科工具。</p>
<h1 id="Kiwix"><a href="#Kiwix" class="headerlink" title="Kiwix"></a>Kiwix</h1><p>Kiwix是一款离线网页浏览器，它是为维基百科离线化而设计的。</p>
<p>用户不需要连接因特网，就可以直接访问/随身携带完整的维基百科，因为所有的资料都储存在你的电脑、U盘等存储。</p>
<p>下载链接: <a target="_blank" rel="noopener" href="https://www.kiwix.org/en/download/">https://www.kiwix.org/en/download/</a> </p>
<h1 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h1><p>在使用Kiwix之前，我们需要先前往Kiwix的数据库页面，下载数据包。</p>
<p>资料地址：<a target="_blank" rel="noopener" href="https://download.kiwix.org/zim/wikipedia/">https://download.kiwix.org/zim/wikipedia/</a></p>
<p>我们可以用浏览器的「Ctrl F」快捷键，比如想找中文维基百科的全部内容，搜「_zh_all」就能直接定位找到；想搜索计算机相关的，就搜「computer」。</p>
<p>kwⅸ提供体育、化学、物理、历史等等不同的分类。如果设备的空间不够，可以直接下载自己感兴趣的文件。</p>
<p>“zh”表示中文zim文件。</p>
<ul>
<li>mini：默认完整版本，包含除视频和音频外所有内容。文件内容最完整，文件也最大。</li>
<li>maxi：和maxi版本相比，此版本缺少图片资料，因此占用空间比maxi版本小。约省75%存储。</li>
<li>nopic：只有文章介绍和信息框，约省95%存储，适合内存较紧张的设备使用。</li>
</ul>
<p>因此所有zim中，“all_maxi”的文件最大，不过也最完整，比如zh_all_maxi有21G，推荐pc端使用。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wiki/" rel="tag">wiki</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E7%A7%91/" rel="tag">百科</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-GO入门14：Windows下环境配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/11/GO%E5%85%A5%E9%97%A814%EF%BC%9AWindows%E4%B8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
    >GO入门14：Windows下环境配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/11/GO%E5%85%A5%E9%97%A814%EF%BC%9AWindows%E4%B8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2023-04-11T03:40:26.000Z" itemprop="datePublished">2023-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>安装包下载地址为：<a target="_blank" rel="noopener" href="https://go.dev/dl/%E3%80%82">https://go.dev/dl/。</a></p>
<p>如果打不开可以使用这个地址：<a target="_blank" rel="noopener" href="https://golang.google.cn/dl/%E3%80%82">https://golang.google.cn/dl/。</a></p>
<h1 id="Windows-系统下安装"><a href="#Windows-系统下安装" class="headerlink" title="Windows 系统下安装"></a>Windows 系统下安装</h1><p>Windows 下可以使用 .msi 后缀(在下载列表中可以找到该文件，如go1.4.2.windows-amd64.msi)的安装包来安装。</p>
<p>默认情况下 .msi 文件会安装在 c:\Go 目录下。你可以将 c:\Go\bin 目录添加到 Path 环境变量中。添加后你需要重启命令窗口才能生效。</p>
<p>环境变量设置好后，可以通过 go env 命令来进行测试。</p>
<pre><code>C:\Users\Administrator&gt;go env
set GO111MODULE=
set GOARCH=amd64
set GOBIN=
set GOCACHE=C:\Users\Administrator\AppData\Local\go-build
set GOENV=C:\Users\Administrator\AppData\Roaming\go\env
set GOEXE=.exe
set GOFLAGS=
set GOHOSTARCH=amd64
set GOHOSTOS=windows
set GONOPROXY=
set GONOSUMDB=
set GOOS=windows
set GOPATH=C:\Users\Administrator\go
set GOPRIVATE=
set GOPROXY=https://proxy.golang.org,direct
set GOROOT=c:\go
. . .
</code></pre>
<p>上面只显示了部分结果，如果执行go env 命令后，出现类似上面的结果，说明我们的Go开发包已经安装成功了。</p>
<h2 id="配置GOPROXY"><a href="#配置GOPROXY" class="headerlink" title="配置GOPROXY"></a>配置GOPROXY</h2><p>Go1.12版本之后，开始使用go mod模式来管理依赖环境了</p>
<p>由于国内访问不到默认的GOPROXY配置链接，所以我们需要换一个PROXY，这里推荐使用 <a target="_blank" rel="noopener" href="https://goproxy.io/">https://goproxy.io</a> 或 <a target="_blank" rel="noopener" href="https://goproxy.cn/">https://goproxy.cn</a> 。</p>
<p>可以执行下面的命令修改GOPROXY：</p>
<pre><code>go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>
<h2 id="GO-MOD设置"><a href="#GO-MOD设置" class="headerlink" title="GO MOD设置"></a>GO MOD设置</h2><p>要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。</p>
<pre><code>GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。
GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。
GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。
</code></pre>
<p>通过以下命令修改</p>
<pre><code>go env -w GO111MODULE=on
</code></pre>
<p>使用go module模式新建项目时，我们需要通过go mod init 项目名命令对项目进行初始化，该命令会在项目根目录下生成go.mod文件。例如，我们使用hello作为我们第一个Go项目的名称，执行如下命令。</p>
<pre><code>go mod init hello
</code></pre>
<p>运行之前可以使用​go mod tidy​命令将所需依赖添加到go.mod文件中，并且能去掉项目中不需要的依赖。</p>
<h1 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h1><p>创建工作目录 C:&gt;Go_WorkSpace。</p>
<p>文件名: test.go，代码如下：</p>
<pre><code>package main

import &quot;fmt&quot;

func main() &#123;
   fmt.Println(&quot;Hello, World!&quot;)
&#125;
</code></pre>
<p>使用 go 命令执行以上代码输出结果如下：</p>
<pre><code>C:\Go_WorkSpace&gt;go run test.go

Hello, World!
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GO/" rel="tag">GO</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-GO入门13：结构体、数组、切片"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/10/GO%E5%85%A5%E9%97%A813%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/"
    >GO入门13：结构体、数组、切片</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/10/GO%E5%85%A5%E9%97%A813%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/" class="article-date">
  <time datetime="2023-04-10T13:30:05.000Z" itemprop="datePublished">2023-04-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>数组如作为函数参数，需要转为切片。<br>GO语言的切片等价于其他语言的vector。</p>
<pre><code>package main

import &quot;fmt&quot;

type Books struct &#123;
    title   string
    author  string
    subject string
    book_id int
&#125;

func main() &#123;
    var Book1 Books /* 声明 Book1 为 Books 类型 */
    var Book2 Books /* 声明 Book2 为 Books 类型 */

    /* book 1 描述 */
    Book1.title = &quot;Go 语言&quot;
    Book1.author = &quot;www.runoob.com&quot;
    Book1.subject = &quot;Go 语言教程&quot;
    Book1.book_id = 6495407

    /* book 2 描述 */
    Book2.title = &quot;Python 教程&quot;
    Book2.author = &quot;www.runoob.com&quot;
    Book2.subject = &quot;Python 语言教程&quot;
    Book2.book_id = 6495700

    var BookArr [2]Books
    BookArr[0] = Book1
    BookArr[1] = Book2

    var BookSlice []Books
    BookSlice = append(BookSlice, Book1, Book2)
    BookSlice = append(BookSlice, Books&#123;&quot;Go++ 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)

    /* 打印 Book1 信息 */
    printBook(&amp;Book1)
    printBook(&amp;Book2)
    printBooks(BookArr[:])
    printBooks(BookSlice)
&#125;

func printBook(book *Books) &#123;
    fmt.Println(&quot;printBook----&quot;)
    fmt.Printf(&quot;Book title : %s\n&quot;, book.title)
    fmt.Printf(&quot;Book author : %s\n&quot;, book.author)
    fmt.Printf(&quot;Book subject : %s\n&quot;, book.subject)
    fmt.Printf(&quot;Book book_id : %d\n&quot;, book.book_id)
    fmt.Println()
&#125;

func printBooks(arr []Books) &#123;
    fmt.Println(&quot;printBooks----&quot;)
    for i := 0; i &lt; len(arr); i++ &#123;
        book := arr[i]
        fmt.Printf(&quot;Book title : %s\n&quot;, book.title)
        fmt.Printf(&quot;Book author : %s\n&quot;, book.author)
        fmt.Printf(&quot;Book subject : %s\n&quot;, book.subject)
        fmt.Printf(&quot;Book book_id : %d\n&quot;, book.book_id)
    &#125;
    fmt.Println()
&#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GO/" rel="tag">GO</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-GO入门12：字符串替换"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/09/GO%E5%85%A5%E9%97%A812%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/"
    >GO入门12：字符串替换</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/09/GO%E5%85%A5%E9%97%A812%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/" class="article-date">
  <time datetime="2023-04-09T09:10:57.000Z" itemprop="datePublished">2023-04-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>1、引入strings包</p>
<pre><code>import &quot;strings&quot;
</code></pre>
<p>2、func Replace</p>
<pre><code>func Replace(s, old, new string, n int) string
</code></pre>
<p>在s字符串中，把old字符串替换为new字符串，n表示替换的次数，小于0表示全部替换</p>
<pre><code>//替换两次
fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;k&quot;, &quot;ky&quot;, 2)) 
//全部替换
fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;oink&quot;, &quot;moo&quot;, -1))

//输出结果
oinky oinky oink
moo moo moo
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GO/" rel="tag">GO</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/39/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/38/">38</a><a class="page-number" href="/page/39/">39</a><span class="page-number current">40</span><a class="page-number" href="/page/41/">41</a><a class="page-number" href="/page/42/">42</a><span class="space">&hellip;</span><a class="page-number" href="/page/55/">55</a><a class="extend next" rel="next" href="/page/41/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> paladin1893
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="帕拉丁的游鱼"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>