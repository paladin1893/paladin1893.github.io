<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="RS,GPS,GIS,QGIS,Opticks,QT,OpenCV,OSG" />
       
      <meta name="description" content="地理信息系统，遥感科学，卫星导航定位技术综合研究。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 帕拉丁的游鱼</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="帕拉丁的游鱼" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">帕拉丁的游鱼</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-计算当前年月"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/20/%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%B9%B4%E6%9C%88/"
    >vue获取时间年月日代码示例</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/20/%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%B9%B4%E6%9C%88/" class="article-date">
  <time datetime="2023-12-20T02:22:00.000Z" itemprop="datePublished">2023-12-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="vue获取时间年月日"><a href="#vue获取时间年月日" class="headerlink" title="vue获取时间年月日"></a>vue获取时间年月日</h1><p>在Vue中获取当前时间的年月日，可以通过计算属性或者方法来实现。以下是一个简单的例子：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    当前日期: &#123;&#123; currentDate &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  computed: &#123;
    currentDate() &#123;
      const now = new Date();
      const year = now.getFullYear();
      const month = (now.getMonth() + 1).toString().padStart(2, &#39;0&#39;);
      const day = now.getDate().toString().padStart(2, &#39;0&#39;);
      return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>在这个例子中，currentDate是一个计算属性，它返回一个格式化的日期字符串（例如：”2023-03-31”）。getFullYear()方法用于获取当前年份，getMonth()方法返回的月份是从0开始的，因此需要加1，getDate()方法用于获取当前是哪一天。padStart(2, ‘0’)确保月份和日期始终保持两位数字的格式。</p>
<h1 id="uvue获取时间年月日"><a href="#uvue获取时间年月日" class="headerlink" title="uvue获取时间年月日"></a>uvue获取时间年月日</h1><p>在UVue中获取当前时间的年月日，你可以使用JavaScript的Date对象。以下是一个简单的例子，展示了如何在UVue组件中获取并显示当前的年月日：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;当前日期: &#123;&#123; currentDate &#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      currentDate: this.getCurrentDate()
    &#125;;
  &#125;,
  methods: &#123;
    getCurrentDate() &#123;
      const now = new Date();
      const year = now.getFullYear();
      const month = (now.getMonth() + 1).toString().padStart(2, &#39;0&#39;);
      const day = now.getDate().toString().padStart(2, &#39;0&#39;);
      return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在这个例子中，我们定义了一个getCurrentDate方法，它创建了一个新的Date对象，然后使用getFullYear、getMonth和getDate方法来获取当前的年、月、日，并将它们格式化为YYYY-MM-DD的字符串。我们还使用了padStart方法来确保月份和日期始终是两位数字。然后，我们在组件的数据对象中返回这个方法的结果，并在模板中显示它。</p>
<h1 id="vue获取当日范围"><a href="#vue获取当日范围" class="headerlink" title="vue获取当日范围"></a>vue获取当日范围</h1><p>在Vue中获取当日的日期范围，可以通过计算当日的开始时间戳和结束时间戳来实现。以下是一个简单的例子，展示了如何在Vue组件中获取当日的日期范围：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;今日开始时间戳: &#123;&#123; todayStart &#125;&#125;&lt;/p&gt;
    &lt;p&gt;今日结束时间戳: &#123;&#123; todayEnd &#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      todayStart: 0,
      todayEnd: 0
    &#125;;
  &#125;,
  created() &#123;
    this.getTodayRange();
  &#125;,
  methods: &#123;
    getTodayRange() &#123;
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth();
      const day = now.getDate();
 
      const start = new Date(year, month, day, 0, 0, 0);
      const end = new Date(year, month, day, 23, 59, 59);
 
      this.todayStart = start.getTime();
      this.todayEnd = end.getTime();
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>这段代码中，我们在Vue组件的data函数中定义了todayStart和todayEnd两个属性来存储计算得出的当日开始和结束时间戳。在created生命周期钩子中调用了getTodayRange方法，该方法计算了当日的开始和结束时间，并将它们的时间戳分别赋值给todayStart和todayEnd。在模板中展示了这两个属性的值。</p>
<h1 id="时间转字符串"><a href="#时间转字符串" class="headerlink" title="时间转字符串"></a>时间转字符串</h1><p>代码如下，提供了两个方法</p>
<pre><code>let timeStartStr1 = this.timeFormat(&#123;date:this.timeStart&#125;)
let timeEndStr1 = this.timeFormat(&#123;date:this.timeEnd&#125;)

let timeStartStr = this.formatDate(&#123;date:this.timeStart, formatStr:&#39;yyyy-MM-dd HH:mm:ss&#39;&#125;)
let timeEndStr = this.formatDate(&#123;date:this.timeEnd, formatStr:&#39;yyyy-MM-dd HH:mm:ss&#39;&#125;)

console.log(typeof this.timeStart,&quot;this.timeStart&quot;,this.timeStart)
console.log(typeof this.timeEnd,&quot;this.timeEnd&quot;,this.timeEnd)

console.log(typeof timeStartStr,&quot;timeStartStr&quot;,timeStartStr)
console.log(typeof timeEndStr,&quot;timeEndStr&quot;,timeEndStr)

this.datetimerange = [timeStartStr, timeEndStr]
              
timeFormat(params) &#123;
    let defalutParams = &#123;
      date: new Date(new Date().getTime()),
    &#125;;
    params = &#123; ...defalutParams, ...params &#125;;
    
    let date = new Date(new Date(params.date).getTime());
    
    // 获取年份
    let Y = date.getFullYear() + &#39;-&#39;
    //获取当前年的月份 月份要 + 1 （0代表1月）date.getMonth() + 1
    let M = date.getMonth() + 1 &lt; 10 ? &#39;0&#39; + (date.getMonth() + 1) + &#39;-&#39; : (date.getMonth() + 1) +&#39;-&#39;
    //获取当前日（1 - 31）
    let D = date.getDate() &lt; 10 ? &#39;0&#39; + (date.getDate()) + &#39; &#39; : (date.getDate()) + &#39; &#39;
    //获取当前小时（0-23）
    let h = date.getHours() &lt; 10 ? (&#39;0&#39; + date.getHours() + &#39;:&#39;) : (date.getHours() + &#39;:&#39;);
    //获取当前分钟（0-59）
    let m = date.getMinutes() &lt; 10 ? (&#39;0&#39; + date.getMinutes() + &#39;:&#39;) : (date.getMinutes() + &#39;:&#39;);
    //获取当前秒数（0-59）
    let s = date.getSeconds() &lt; 10 ? (&#39;0&#39; + date.getSeconds()) : date.getSeconds();
    
    return (Y + M + D + h + m + s)
&#125;,
formatDate(params) &#123;
  let defalutParams = &#123;
    date: new Date(new Date().getTime()),
    formatStr: &#39;yyyy-MM-dd HH:mm:ss&#39;
  &#125;;
  params = &#123; ...defalutParams, ...params &#125;;

  let date = new Date(new Date(params.date).getTime());
  let formatStr = params.formatStr;
  
  // 获取年份
  formatStr = formatStr.replace(new RegExp(&#39;yyyy&#39;), `$&#123;date.getFullYear()&#125;`);
  //获取当前年的月份 月份要 + 1 （0代表1月）date.getMonth() + 1
  const month = date.getMonth() + 1;
  formatStr = formatStr.replace(new RegExp(&#39;MM&#39;), `$&#123;month &gt; 9 ? month : &#39;0&#39; + month&#125;`);
  //获取当前日（1 - 31）
  const day = date.getDate();
  formatStr = formatStr.replace(new RegExp(&#39;dd&#39;), `$&#123;day &gt; 9 ? day : &#39;0&#39; + day&#125;`);
  //获取当前小时（0-23）
  const hour = date.getHours();
  formatStr = formatStr.replace(new RegExp(&#39;HH&#39;), `$&#123;hour &gt; 9 ? hour : &#39;0&#39; + hour&#125;`);
  //获取当前分钟（0-59）
  const min = date.getMinutes();
  formatStr = formatStr.replace(new RegExp(&#39;mm&#39;), `$&#123;min &gt; 9 ? min : &#39;0&#39; + min&#125;`);
  //获取当前秒数（0-59）
  const sec = date.getSeconds();
  formatStr = formatStr.replace(new RegExp(&#39;ss&#39;), `$&#123;sec &gt; 9 ? sec : &#39;0&#39; + sec&#125;`);

  return formatStr;
&#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Dev-cpp及其衍生系列"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/19/Dev-cpp%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%B3%BB%E5%88%97/"
    >Dev-cpp及其衍生系列</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/19/Dev-cpp%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%B3%BB%E5%88%97/" class="article-date">
  <time datetime="2023-12-19T02:22:00.000Z" itemprop="datePublished">2023-12-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="http://wxdsgn.sourceforge.net/">http://wxdsgn.sourceforge.net/</a><br>wxDev-C++ is an opensource wxWidgets Dialog designer that mimics the Delphi/Borland C++ Builder designer.</p>
<p>wxDev-C++，last update: 2012</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/dev-cpp/">https://sourceforge.net/projects/dev-cpp/</a><br>这个是最老的，2005年就停了</p>
<p>Dev-cpp有相当历史，可以追溯到win98时代，1998年就已经发布第一版本了，其中4.9.9.2版本是最经典的。</p>
<p>Dev-C++ is a full-featured Integrated Development Environment (IDE) for Win32. It uses GCC, Mingw or Cygwin as compiler and libraries set. It supports Windows 98, NT, 2000 &amp; XP.</p>
<p>This is the original Dev-C++ software as published by Colin Laplace and this repository is frozen to version 4.9.9.2.</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/orwelldevcpp/">https://sourceforge.net/projects/orwelldevcpp/</a><br>这个是上一代的，2016年就停了<br>A new and improved fork of Bloodshed Dev-C++，last update: 2016</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/embarcadero-devcpp/">https://sourceforge.net/projects/embarcadero-devcpp/</a><br><a target="_blank" rel="noopener" href="https://github.com/Embarcadero/Dev-Cpp/">https://github.com/Embarcadero/Dev-Cpp/</a><br>这个是最新的，2020年才开始更新，项目名称改成了“Dev-C++ for Windows 10/8/7”，软件更新为：Embarcadero Dev-C++ ，Embarcadero 这个名字应该不陌生，他也是c++ builder的东家啊～看来devC++已经归属他的门下了</p>
<p>Embarcadero Dev-C++ is a new and improved fork (sponsored by Embarcadero) of Bloodshed Dev-C++ and Orwell Dev-C++. It is a full-featured Integrated Development Environment (IDE) and code editor for the C/C++ programming language. It uses Mingw port of GCC (GNU Compiler Collection) as its compiler. Embarcadero Dev-C++ can also be used in combination with Cygwin or any other GCC based compiler. Embarcadero Dev-C++ is built using the latest version of Embarcadero Delphi. Embarcadero Dev-C++ has a low memory footprint because it is a native Windows application and does not use Electron.</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/redpanda-cpp">https://sourceforge.net/projects/redpanda-cpp</a><br><a target="_blank" rel="noopener" href="https://royqh.net/devcpp/">https://royqh.net/devcpp/</a></p>
<p>小熊猫Dev-C++，Red Panda Dev C++ C/C++ 集成开发环境，Red Panda Dev C++，是一个小巧的开源C/C++ 集成开发环境，基于 Dev-C++ 开发，非常适合于C/C++ 语言的初学者使用。</p>
<p>Red Panda C++ is a lightweight yet powerful C/C++/GNU Assembly IDE.<br>It provides users with coding experiences like vs code and CLion, but is much lightweighted than them.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-css命名规范"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/18/css%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"
    >css命名规范</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/18/css%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" class="article-date">
  <time datetime="2023-12-18T02:22:00.000Z" itemprop="datePublished">2023-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>BEM 命名规范</p>
<p>什么是 BEM 命名规范 </p>
<p>Bem 是块(block)、元素(element)、修饰符(modifier)的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。</p>
<pre><code>- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。
-- 双中线 代表不同的状态，类型。
__ 双下划线: 双下划线用来连接块和块的子元素
_ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态
</code></pre>
<p>BEM 是一个简单又非常有用的命名约定。让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确，而且更加严密。</p>
<p>书写方式</p>
<pre><code>.block &#123;&#125; /** 代表了更高级别的抽象或组件。 **/
.block__element &#123;&#125; /** 代表 .block 的后代，用于形成一个完整的 .block 的整体。 **/
.block-name &#123; &#125;     /** 代表 .blocak 连字符  **/
.block--modifier &#123;&#125; /** 代表 .block 的不同状态或不同版本。 ** /
</code></pre>
<p>推荐写法</p>
<pre><code>.form &#123; &#125;
.form--theme-xmas &#123; &#125;
.form--simple &#123; &#125;
.form__input &#123; &#125;
.form__submit &#123; &#125;
.form__submit--disabled &#123; &#125;
 
//对应的HTML结构如下：
&lt;form class=&quot;form form--theme-xmas form--simple&quot;&gt;
  &lt;input class=&quot;form__input&quot; type=&quot;text&quot; /&gt;
  &lt;input
    class=&quot;form__submit form__submit--disabled&quot;
    type=&quot;submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>常用的css命名</p>
<p>常用的CSS命名规则</p>
<pre><code>头：header
内容：content/container
尾：footer
导航：nav
侧栏：sidebar
栏目：column
页面外围控制整体?丫挚矶龋?rapper
左右中：left right center
登录条：loginbar
标志：logo
广告：banner
页面主体：main
热点：hot
新闻：news
下载：download
子导航：subnav
菜单：menu
子菜单：submenu
搜索：search
友情链接：friendlink
页脚：footer
版权：copyright
滚动：scroll
内容：content
标签：tags
文章列表：list
提示信息：msg
小技巧：tips
栏目标题：title
加入：joinus
指南：guide
服务：service
注册：regsiter
状态：status
投票：vote
合作伙伴：partner
 
注释的写法:
/* Header */
内容区
/* End Header */
 
id的命名:
1)页面结构
 
容器: container
页头：header
内容：content/container
页面主体：main
页尾：footer
导航：nav
侧栏：sidebar
栏目：column
页面外围控制整体?丫挚矶龋?rapper
左右中：left right center
 
(2)导航
 
导航：nav
主导航：mainnav
子导航：subnav
顶导航：topnav
边导航：sidebar
左导航：leftsidebar
右导航：rightsidebar
菜单：menu
子菜单：submenu
标题: title
摘要: summary
 
(3)功能
 
标志：logo
广告：banner
登陆：login
登录条：loginbar
注册：register
搜索：search
功能区：shop
标题：title
加入：joinus
状态：status
按钮：btn
滚动：scroll
标?页：tab
文章列表：list
提示信息：msg
当前的: current
小技巧：tips
图标: icon
注释：note
指南：guild
服务：service
热点：hot
新闻：news
下载：download
投票：vote
合作伙伴：partner
友情链接：link
版权：copyright
</code></pre>
<p>注意事项::</p>
<p>1.一律小写;<br>2.尽量用英文;<br>3.不加中??和下划线;<br>4.尽量不缩写，除非一看就明白的单词。</p>
<p>CSS样式表文件命名</p>
<pre><code>主要的 master.css
模块 module.css
基本共用 base.css
布局、版面 layout.css
主题 themes.css
专栏 columns.css
文字 font.css
表单 forms.css
补丁 mend.css
打印 print.css
</code></pre>
<p>————————————————</p>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27104997/article/details/124474762">https://blog.csdn.net/qq_27104997/article/details/124474762</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-css中的减号或下划线"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/17/css%E4%B8%AD%E7%9A%84%E5%87%8F%E5%8F%B7%E6%88%96%E4%B8%8B%E5%88%92%E7%BA%BF/"
    >css中的减号或下划线</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/17/css%E4%B8%AD%E7%9A%84%E5%87%8F%E5%8F%B7%E6%88%96%E4%B8%8B%E5%88%92%E7%BA%BF/" class="article-date">
  <time datetime="2023-12-17T02:22:00.000Z" itemprop="datePublished">2023-12-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在CSS中，减号（-）和下划线（_）通常用于命名选择器和属性。它们在命名选择器和属性时具有不同的作用。</p>
<p>减号（-）：</p>
<p>在命名选择器中，减号用于连接多个单词，创建一个复合选择器。例如，.my-class表示一个类选择器，可以应用于HTML元素中的任何具有class=”my-class”属性的元素。</p>
<p>在命名属性时，减号用于创建自定义属性。例如，data-my-attribute表示一个自定义属性，可以在HTML元素中使用data-my-attribute=”value”的方式进行设置和获取。</p>
<p>下划线（_）：</p>
<p>在命名选择器中，下划线通常用于表示状态或修饰符。例如，.is-active表示一个具有活动状态的元素，.is-hidden表示一个隐藏的元素。</p>
<p>在命名属性时，下划线通常用于表示私有属性或内部属性。例如，_my-property表示一个私有属性，用于内部使用。</p>
<p>这些命名约定主要用于提高代码的可读性和可维护性。通过使用减号和下划线，可以更清晰地表示选择器和属性的用途和含义。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html">https://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html</a></p>
<p>CSS样式名中的下划线与连字符</p>
<p>这篇Blog将要讨论，在CSS的className中使用连字符“-”还是使用下划线“_”作为分隔符更适合？</p>
<p>在切入主题之前，先看看Google在Webmaster Tools中URL structure章节中所说的一段话：</p>
<p>Consider using punctuation in your URLs. The URL <a target="_blank" rel="noopener" href="http://www.example.com/green-dress.html">http://www.example.com/green-dress.html</a> is much more useful to us than <a target="_blank" rel="noopener" href="http://www.example.com/greendress.html">http://www.example.com/greendress.html</a>. We recommend that you use hyphens (-) instead of underscores (_) in your URLs.</p>
<p>这段话的意思是，出于URL语义化的考虑，Google建议站点URL中使用连字符“-”来代替下划线“_”做分隔符。不知道是否是因为Google的这份文档，我们可以看到越来越多的国内外网站URL中开始使用“-”来作为分隔符，例如：</p>
<p><a target="_blank" rel="noopener" href="http://net.tutsplus.com/articles/general/9-confusing-naming-conventions-for-beginners/">http://net.tutsplus.com/articles/general/9-confusing-naming-conventions-for-beginners/</a></p>
<p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/1686337/hyphens-or-underscores-in-css-and-html-identifiers">http://stackoverflow.com/questions/1686337/hyphens-or-underscores-in-css-and-html-identifiers</a></p>
<p>以及我正在使用WordPress编辑的这篇BLOG的编辑地址是：<a target="_blank" rel="noopener" href="http://yekai.net/wp-admin/post.php?post=338&amp;action=edit">http://yekai.net/wp-admin/post.php?post=338&amp;action=edit</a></p>
<p>申请过域名的人都知道，一个英文域名中，合法的字符只有数字0-9、字母a-z、符号“-”和“.”两个。其中“.”号用作域名层级分隔符，“-”号作为单词分隔符。从牛津词典中可以看到对连字符hyphen的解释：</p>
<p>更多hyphen的应用场景，以及hyphen和dash以及minus符号的差异，感兴趣的同学可以去看wiki看看。</p>
<p>结论显而易见，在英语中分隔符号即是hyphen的语义。</p>
<p>这就不难理解，为什么当初在CSS1.0的草案中明确指出，在className中除了连字符“-”以外，包括下划线“_”在内的其他符号必须使用“\”符号转义之后才能使用。同时也不难理解为什么CSS属性的写法是“background-color”而不是“background_color”或者“backgroundColor”了。</p>
<p>然而现实情况却并非如当初CSS1的规范制订的那样完美，很多开发者在写className中却因为某些原因，使用了“_”作为分隔符，并将此作为自己的代码规范。这使得W3C不得不在2001年CSS2的一次修订版本中将“_”定义为className中的合法字符，无须转义均可支持。这也是为什么在2001年前的浏览器如navigator 4.x、IE 5.x不支持className中的“_”未转义写法，而IE6及后来的firefox、chrome均能支持这种写法。</p>
<p>从某种程度上来说，W3C标准对现实的妥协，也是导致前端开发工程师面对浏览器差异化的杯具结局的原因之一。至于W3C支持className中的“_”作为分隔符的原因就不难想象了：正如这种写法的支持者所说，在JS中下划线“_”才是公认的分隔符。例如，DOM中有一个id为“kaiye”的节点，在IE6中你可以通过document.all.kaiye集合获取到这个节点的引用。但如果这个ID被命名为“kai-ye”，使用document.all.kai-ye显然会抛出一个异常，因为基本在所有的编程语言中“-”代表的是“减号运算符”，JS也不例外，正如这篇《Web开发中初学者容易混淆的9个命名约定》中所说。正是由于这点原因，导致在id属性命名时，开发者通常会避免使用“-”，为了保持代码风格统一，className中也使用“_”作为分隔符。事实上，W3C并没有规定class属性和id属性命名约定必须相同，className中的“-”分隔符更是和运算符减号“-”风马牛不相及，CSS不是编程语言又何来减号运算符的冲突问题？</p>
<p>同时这种命名约定却无形中挖了一个坑：通常在JS的命名约定中，你可以使用 _kaiye 来声明这是一个私有变量，但如果你在CSS中沿用这种命名习惯使用 _kaiye 来作为className将会导致这段声明在IE6中无效。不幸的是，我亲眼见到有人掉到这个坑里了，并且一定会有更多人因为这种命名约定掉到这个坑里，这也是我坚持不在className中使用“_”最重要的原因。</p>
<p>08年当我刚入职支付宝那会，我跟着小黑做了支付宝的第一个浏览器兼容性项目─“Firefox交易流程兼容性项目”。我们修改了上百个交易创建、修改、付款、完成的页面，修复了其中大量HTML、CSS、JS的兼容性写法，并同时将记录汇总成一张bugfix list。结果发现为了使支付宝兼容Firefox，我们对DOM做的最多的修改是，将标签P修改为DIV，对JS修改最多的是将 document.all 的写法换成 document.getElementById 。这意味着如果你的产品需要提供更好的用户体验，兼容更多的浏览器，你应该像许多JS框架那样使用W3C标准的写法来编写你的JS。getElementById就是获取DOM对象的最佳实践，而这个方法接受的唯一参数是一个字符串，这个字符串允许你包含任意字符，当然也包括连字符“-”。也就是说，document.all方法将不会出现在一个需要跨浏览器支持的产品中，你可以在ID属性中使用“-”作为分隔符。</p>
<p>Google、Yahoo、淘宝、豆瓣在他们的新CSS代码规范中推荐使用“-”作为className分隔符，这个自然就不难理解了。</p>
<p>说到这里我们再对“_”的语义进行一番探讨。Oxford Dictionary对underscore的定义是underline，在单词下面画条线表示强调，这个其实也是<u>标签的来历。从wikipedia上可以看到underscore符号最先用于打字机中，用来给某个单词划线。第二种用法是，当需要打空格，而不能使用空格的时候，会使用underscore来代替。例如URL、filename、编程语言中的变量、表单填写项绘制等等。从这一点来看，className中的“_”可以给一个“空格”的语义。只是className中真正的空格符，作为class属性和CSS选择器时是两种完全不同的用法。</u></p>
<p>为了避免“-”运算符的问题，开发者通常使用“_”来作为filename中的分隔符，以方便模块文件能进行正常的import、include操作。这大概是为何大多数URL仍然使用“_”分隔居多的原因。然而，为了遵守英语通用语义规则，为了提升只懂英文不懂编程的普通人的理解体验，Google制定了前文所提到的“推荐使用连字符”的SEO建议，MAC OSX操作系统推荐使用空格和连字符进行文件命名，Linux系统以及大多数编程语言的命名都提供了通过引号的方式规避文件名中“-”的冲突问题。而“_”分隔符就像“该字段不能为空”的错误提示一样充满着程序员的语言习惯。</p>
<p>回到主题，在CSS的className中到底应该使用“-”还是“_”？虽然说“-”更符合语义，看起来代码更美观，但“_”也有它存在的合理性─开发者的习惯延续，以及双击全选的特性。就像stackoverflow上这个问题的最佳答案所说的那样：</p>
<p>I think its just personal preference.</p>
<p>而改变一个习惯通常不是一件容易的事情，对自己来说是如此，更别提改变他人。出于我前面所提到的那个坑（通常在JS的命名约定中，你可以使用 _kaiye 来声明这是一个私有变量，但如果你在CSS中沿用这种命名习惯使用 _kaiye 来作为className将会导致这段声明在IE6中无效。）以及语义化的原因，在IE6还未消亡的现在，我无法说服自己使用“_”来作分隔符，甚至我觉得，不仅仅是className，CSS、JS、图片、HTML的filename都应该使用“-”作为分隔符，因为这些资源均是普通用户看得到的URL。</p>
<p>那么你的习惯呢？如果把自己当作一名前端开发新人，你又会如何选择呢？</p>
<p>——————–20110613 update:———————-</p>
<p>今天下午借W3C来公司交流的机会，私底下偷偷问Michael Smith，“Hyphen or underscore, which one do you prefer? ”，他的回答是“Neither, I like camelcase.”同时，从ytzong那里得知在CSS-tricks上这个问题讨论得也很happy，并且有了一个可供参考的投票结果。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-为什么航天器、导弹喜欢用单片机，而不是嵌入式系统？"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%88%AA%E5%A4%A9%E5%99%A8%E3%80%81%E5%AF%BC%E5%BC%B9%E5%96%9C%E6%AC%A2%E7%94%A8%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9F/"
    >为什么航天器、导弹喜欢用单片机，而不是嵌入式系统？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%88%AA%E5%A4%A9%E5%99%A8%E3%80%81%E5%AF%BC%E5%BC%B9%E5%96%9C%E6%AC%A2%E7%94%A8%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9F/" class="article-date">
  <time datetime="2023-12-16T02:22:00.000Z" itemprop="datePublished">2023-12-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/">知识分享</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>为什么航天器、导弹喜欢用单片机，而不是嵌入式系统？</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357508551">https://zhuanlan.zhihu.com/p/357508551</a></p>
<p>一、前言<br>前几天和一个在某研究所的发小聊天，他说：现在的航空、航天和导弹等武器装备中，控制系统几乎都是用单片机，而不是嵌入式系统。</p>
<p>乍一听，和我们的直觉有矛盾啊：那么高大上的设备，其中的控制逻辑一定很复杂，不用嵌入式系统怎么来完成那么复杂的功能控制啊？然后仔细了解了一下，才明白答案是：安全+可控。</p>
<p>这篇文章我们就来聊一下关于单片机与嵌入式、操作系统与 RTOS 之间的那些事！通过这篇文章，让你操作系统的实时性有一个系统、全面的理解！</p>
<p>二、关于单片机与嵌入式系统之间界定</p>
<p>说实话，关于它俩的区分，没有人可以给出一个标准的、正确的答案。每个人理解的单片机与嵌入式系统，都是略有差别的。</p>
<p>抛开硬件，从应用程序开发的角度来看，我是这样来理解的：</p>
<p>单片机：可以直接使用状态机来实现程序框架，也可以利用一些 RTOS(ucOS、FreeRTOS、vxWorks、RT-Thread)等来完成一些调度功能。</p>
<p>嵌入式系统：利用嵌入式 Linux 操作系统以及一些变种来编写应用程序。</p>
<p>我知道自己的理解可能是不对的，至少不严谨、范围狭隘，既然没有标准答案，那姑且引用维基百科中的定义吧，毕竟概念是死的，更重要的是我们如何根据实际的需要来进行选择。</p>
<ol>
<li>单片机<br>单片机，全称单片微型计算机（single-chip microcomputer），又称微控制器单元 MCU（microcontroller unit）。<br>把中央处理器、存储器、定时/计数器、各种输入输出接口等都集成在一块集成电路芯片上的微型计算机。<br>由于其发展非常迅速，旧的单片机的定义已不能满足，所以在很多应用场合被称为范围更广的微控制器；</li>
<li>嵌入式系统<br>嵌入式系统（Embedded System），是一种嵌入机械或电气系统内部、具有专一功能和实时计算性能的计算机系统。<br>嵌入式系统常被用于高效控制许多常见设备，被嵌入的系统通常是包含数字硬件和机械部件的完整设备，例如汽车的防锁死刹车系统。<br>现代嵌入式系统通常是基于微控制器（如含集成内存和/或外设接口的中央处理单元）的，但在较复杂的系统中普通微处理器（使用外部存储芯片和外设接口电路）也很常见。</li>
<li>嵌入式Linux<br>嵌入式Linux（英语：Embedded Linux）是一类嵌入式操作系统的概称，这类型的操作系统皆以Linux内核为基础，被设计来使用于嵌入式设备。<br>与电脑端运行的linux系统本质上是一样的，虽然经过了一些功能上的裁剪，但是本质上是一样的，主要利用 Linux 内核中的的任务调度、内存管理、硬件抽象等功能。</li>
<li>RTOS<br>实时操作系统（RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。<br>实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</li>
</ol>
<p>三、非实时、软实时、硬实时</p>
<p>首先要明白什么叫实时性？实时性考虑的不是速度、性能、吞吐量，而是确定性，也就是说：当一个事件发生的时候，可以确定性的保证在多长时间内得到处理，只要能满足这个要求，就可以成为硬实时。比如：</p>
<p>操作系统1：当中断发生时，可以保证在 1 秒内得到这里，那么它就是硬实时系统，虽然响应时间长，但它是确定的；<br>操作系统2：当中断发生时，几乎都可以在 1 毫秒内完成，那么那就不能成为硬实系统，虽然响应时间短，但是它不确定。<br>也看到有文章说：应该取消软实时这个模棱两可的说法，要么是实时，要么是非实时！</p>
<p>操作系统包含的功能很多：任务调度、内存管理、文件管理等等，其中最核心的就是任务调度，这也是非实时、软实时、硬实时的最大区别。</p>
<p>也就是说，衡量实时性的指标就是：</p>
<ol>
<li>中断延时：一个外部事件引发的中断发生时，到相应的中断处理程序第一条指令被执行时，所经过的时间；</li>
<li>任务抢占延时：当一个高优先级的任务准备就绪时，从正在执行的低优先级任务中抢夺 CPU 资源所经过的时间；</li>
</ol>
<p>不同的操作系统，其任务调度机制也是不一样的，而这个调度机制的策略，又是与实际的使用场景相关的。因此，并不存在哪个好、哪个不好这样的说法，合适的就是最好的！</p>
<p>比如：我们的桌面系统，需要考虑的是多任务、并发，需要同时执行多个程序，哪个程序慢一点，用户无所谓，甚至觉察不到；但是对于一个导弹控制系统，当一个外部传感器输入信号，触发一个事件时，对应的处理必须立刻执行，否则耽搁 1 毫秒，结果可能就是差之千里！</p>
<p>四、x86 Linux 系统的调度策略</p>
<p>我们日常使用的 PC 机，它的主要目标是并行执行多任务，强调的是吞吐率(尽可能多的执行很多应用程序的代码)，因此，采用的是分时操作系统，也就是每个任务都有一个时间片，当一个任务分配的时间片用完了，就自动换出（调度），然后执行下一个任务。</p>
<p>我们平常在写 x86 平台上写普通的客户端程序时，很少需要指定应用程序的调度策略和优先级，使用的是系统默认的调度机制。反过来说，也就是在某些需要的场合下，是可以设置进程的调度策略和优先级的。</p>
<p>例如在 Linux 系统中，可以通过 sched_setscheduler() 系统函数 设置 3 种调度策略：</p>
<p>SCHED_OTHER: 系统默认的调度策略，计算动态优先级（counter+20-nice），当时间片用完之后放在就绪队列尾；<br>SCHED_FIFO: 实时调度策略，根据优先级进行调度，一旦占用CPU就一直执行，直到自己放弃执行或者有更高优先级的任务需要执行；<br>SCHED_RR: 也是实时调度策略，在 SCHED_FIFO 的基础上添加了时间片。在执行时，可以被更高优先级的任务打断，如果没有更高优先级的任务，那么当任务的执行时间片用完之后，就会查找相同优先级的任务来执行。</p>
<ol>
<li>为什么 Linux 系统是软实时的？<br>可能有小伙伴会有疑问：既然 Linux 系统中提供了 SCHED_FIFO 基于优先级的调度策略，为什么仍然不能称之为真正的硬实时操作系统？这就要从 Linux 的发展历史说起了。</li>
</ol>
<p>Linux 操作系统在设计之初，就是为了桌面应用而开发的，在那个时代，多个终端(电传打字机和屏幕)连接到同一个电脑主机，需要处理的是多任务、并行操作，并不需要考虑实时性，因此，在 Linux 内核中的一些基因，严重影响了它的实时性，例如有如下几个因素：</p>
<p>(1) 内核不可抢占</p>
<p>我们知道，一个应用程序在执行时，可以在用户态和内核态执行(当调用一个系统函数，例如：write 时，就会进入内核态执行)，此时任务是不可抢占的。</p>
<p>即使有优先级更高的任务准备就绪，当前的任务也不能立刻停止执行。而是必须等到当前这个任务返回到用户态，或者在内核态中需要等待某个资源而睡眠时，高优先级任务才可以执行。</p>
<p>因此，这就很显然无法保证高优先级任务的实时性了。</p>
<p>(2) 自旋锁</p>
<p>自旋锁是用于多线程同步的一种锁，用来对共享资源的一种同步机制，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>
<p>自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的，也就是说，只能在阻塞很短的时间才适合使用自旋锁。</p>
<p>但是，在自旋锁期间，任务抢占将会失效，这就是说，即使自旋锁的阻塞时间很短，但是这仍然会增加任务抢占延时，让调度变得不确定。</p>
<p>(3) 中断的优先级是最高的</p>
<p>任何时刻，只要中断发生，就会立刻执行中断服务程序，也就是中断的优先级是最高的。只有当所有的外部中断和软终端都处理结束了，正常的任务才能得到执行。</p>
<p>这看起来是好事情，但是想一想，如果有比中断优先级更高的任务呢？假如系统在运行中，网口持续接收到数据，那么中断就一直被执行，那么其他任务就可能一直得不到执行的机会，这是影响 Linux 系统实时性的巨大挑战。</p>
<p>(4) 同步操作时关闭中断</p>
<p>如果去看 Linux 内核的代码，可以看到在很多地方都执行了关中断指令，如果在这期间发生了中断，那么中断响应时间就没法保证了。</p>
<ol start="2">
<li>Linux 系统如何改成硬实时？<br>以上描述的几个因素，对 Linux 实现真正的实时性构成了很大的障碍，但是现实世界又的确有很多场合需要 Linux 具有硬实时，那么就要针对上面的每一个因素提出解决方案。</li>
</ol>
<p>目前主流的解决方案有 2 个：</p>
<p>单内核解决方案：给 Linux 内核打补丁，解决上面提到的几个问题，例如：RT-Preempt;<br>双内核解决方案：在硬件抽象层之上，运行 2 个内核：实时内核 + Linux 内核，它们分别向上层提供 API 函数，例如：Xenomai;<br>这 2 种解决方案分别有不同的实现，从调研情况来看，RT-Preempt 和 Xenomai 是使用比较多的，下面分别来看一下他们的优缺点。</p>
<p>（1）RT-Preempt<br>这种方式主要是对 Linux 内核进行打补丁，解决了上面所说的几个问题：内核不可抢占、自旋锁、关中断以及终端优先级的问题。</p>
<p>至于每一个问题是如何解决的，由于篇幅关系，这里就不介绍了，感兴趣的小伙伴如果需要的话，可以深入了解一下。</p>
<p>由于是直接在 Linux 内核上打补丁(以后肯定会合并到主分支中的)，因此对于应用程序开发来说，操作系统向上层提供的 API 接口函数可以保持不变，这对应用程序开发来说是一件好事情。</p>
<p>（2）Xenomai<br>Xenomai是一个 Linux 内核的实时开发框架，它希望通过无缝地集成到 Linux 环境中来给用户空间应用程序提供全面的，与接口无关的硬实时性能。下面是 Xenomai 的架构图：</p>
<p>在硬件抽象层之上，是 2 个并列的域(内核)，这 2 个内核分别向上层提供自己的 API 接口函数。</p>
<p>图中 glibc 是 Linux 系统提供的库函数，应用程序通过调用库函数和系统调用来编写程序。</p>
<p>Xenomai 也提供了相应的库函数 libcobalt ，这个库函数是需要我们在用户层编译、安装的，就像安装第三方库一样。</p>
<p>此外，Xenomai 还参考不同的操作系统风格，提供了好几套 API 函数(之前的说法是：皮肤)，API 接口函数在这里：</p>
<p>从图中可以看到，Alchemy API 这套接口提供的功能更完善，提供了：定时器、内存管理、条件变量、事件、互斥锁、消息队列、任务(可以理解为线程)等 API 函数。 这一套 API 函数中具体的功能与 POSIX 标准大体相同，在一些细节上存在一些差异。</p>
<p>由于 Xenomai 向应用层提供的 API 函数是独立的一套，因此，如果我们需要创建实时任务，那么就要调用这一套接口函数来创建任务，包括使用其中的一些资源(例如：内存分配)。而且文档中也提出了一些注意点，例如：某些资源不能在 Xenomai 与 Linux 系统之间混用。</p>
<p>五、RTOS 的优势</p>
<p>上面已经说到，Linux 桌面系统的主要目标是吞吐量，在单位时间内执行更多的代码。</p>
<p>但是对于单片机来说，首要目标不是吞吐量，而是确定性，因此衡量一个实时操作系统坚固性的重要指标，是系统从接收一个任务，到完成该任务所需的时间。也就是说，任务调度才是第一考量要素。</p>
<p>在单片机开发中，一般有 2 种编程模型：基于状态机(裸跑)，基于 RTOS。</p>
<p>如果基于状态机，就不存在任务调度问题了，因为只有一个执行序列，所有的操作都是串行执行的，唯一需要注意的控制流程就是中断处理。</p>
<p>如果基于 RTOS，主要利用的就是任务调度，实现真正的硬实时。这方面最牛逼的就是VxWorks了，当然价格也是非常可观的，有些公司购买之后，甚至会把除了任务调度模块之外的其他模块全部重写一遍，这也足以证明了 VxWorks 在任务调度处理上的确很厉害，这也是它的看家本领!</p>
<p>当然，对于简单、需要严格控制执行序列的关键程序来说，使用有限状态机的编程框架，一切都在自己的掌握中。只要代码中没有 bug，那么理论上，一切行为都是在控制之中的，这也是为什么很多军事设备上使用单片机的原因！</p>
<p>六、总结</p>
<p>关于任务调度的问题，是一个操作系统的重中之重，其中需要学习的内容还有很多，最近刚买了一本陈海波老师的新书，也就是华为的鸿蒙系统背后的灵魂人物。</p>
<p>如果有新的学习心得，再跟大家分享。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%A9%E8%81%94%E7%BD%91/" rel="tag">物联网</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-配电与配网的异同"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/15/%E9%85%8D%E7%94%B5%E4%B8%8E%E9%85%8D%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C/"
    >配电与配网的异同</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/15/%E9%85%8D%E7%94%B5%E4%B8%8E%E9%85%8D%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C/" class="article-date">
  <time datetime="2023-12-15T02:22:00.000Z" itemprop="datePublished">2023-12-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/">知识分享</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>配网与配电有何区别<br>2023年11月09日<br>一、配网和配电的定义</p>
<p>配电是指将高压电能经过变压器逐级降压，最终输送给终端用户的一种电力传输方式。而配网则是指在配电系统中，将电能从配电变压器输送到终端用户，负责能量的传输和分配。简单来说，配电强调的是输电，而配网强调的是分电。</p>
<p>二、配网和配电的功能</p>
<p>配网的主要功能是将电力从变电站输送到城市和建筑物中，并为用户提供安全、可靠、高效、低成本的电力服务。配电则主要分为高压配电和低压配电，负责将电源的能量分配到用户终端并控制供电质量以保证稳定供电。</p>
<p>三、配网和配电的应用范围</p>
<p>配电主要是指把电压由高压状态变成响应的低压状态后，送入工业、农业、商业以及居民区域。而配网则负责把电能从配电变压器输送到用户终端，包括城市道路照明、商业建筑、工业用电等等。</p>
<p>四、配电和配网的发展趋势</p>
<p>随着社会的进步和经济的发展，人们对电力的需求不断增长，配电和配网也不断发展和完善。未来，配网技术将走向更加智能化和数字化，通过大数据和人工智能等新技术，实现对电力供应和需求的实时监测和智能调控，提高电力的可靠性、可持续性和效率。配电也将趋向一体化和集成化，探索新的电力生产和传输模式，提高电力的质量和效益。</p>
<p>总之，配电和配网虽然存在一定的联系和关联，但它们的职能和作用有所不同。未来，随着科技的发展和社会的需求，配电和配网也会愈加完善和智能化，为人们生活和经济发展带来更多的便利和效益。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%94%B5%E5%8A%9B/" rel="tag">电力</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> paladin1893
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="帕拉丁的游鱼"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>