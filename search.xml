<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么航天器、导弹喜欢用单片机，而不是嵌入式系统？</title>
    <url>/2023/12/16/%E9%85%8D%E7%94%B5%E4%B8%8E%E9%85%8D%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为什么航天器、导弹喜欢用单片机，而不是嵌入式系统？</p>
<p><a href="https://zhuanlan.zhihu.com/p/357508551">https://zhuanlan.zhihu.com/p/357508551</a></p>
<p>一、前言<br>前几天和一个在某研究所的发小聊天，他说：现在的航空、航天和导弹等武器装备中，控制系统几乎都是用单片机，而不是嵌入式系统。</p>
<p>乍一听，和我们的直觉有矛盾啊：那么高大上的设备，其中的控制逻辑一定很复杂，不用嵌入式系统怎么来完成那么复杂的功能控制啊？然后仔细了解了一下，才明白答案是：安全+可控。</p>
<p>这篇文章我们就来聊一下关于单片机与嵌入式、操作系统与 RTOS 之间的那些事！通过这篇文章，让你操作系统的实时性有一个系统、全面的理解！</p>
<p>二、关于单片机与嵌入式系统之间界定</p>
<p>说实话，关于它俩的区分，没有人可以给出一个标准的、正确的答案。每个人理解的单片机与嵌入式系统，都是略有差别的。</p>
<p>抛开硬件，从应用程序开发的角度来看，我是这样来理解的：</p>
<p>单片机：可以直接使用状态机来实现程序框架，也可以利用一些 RTOS(ucOS、FreeRTOS、vxWorks、RT-Thread)等来完成一些调度功能。</p>
<p>嵌入式系统：利用嵌入式 Linux 操作系统以及一些变种来编写应用程序。</p>
<p>我知道自己的理解可能是不对的，至少不严谨、范围狭隘，既然没有标准答案，那姑且引用维基百科中的定义吧，毕竟概念是死的，更重要的是我们如何根据实际的需要来进行选择。</p>
<ol>
<li>单片机<br>单片机，全称单片微型计算机（single-chip microcomputer），又称微控制器单元 MCU（microcontroller unit）。<br>把中央处理器、存储器、定时/计数器、各种输入输出接口等都集成在一块集成电路芯片上的微型计算机。<br>由于其发展非常迅速，旧的单片机的定义已不能满足，所以在很多应用场合被称为范围更广的微控制器；</li>
<li>嵌入式系统<br>嵌入式系统（Embedded System），是一种嵌入机械或电气系统内部、具有专一功能和实时计算性能的计算机系统。<br>嵌入式系统常被用于高效控制许多常见设备，被嵌入的系统通常是包含数字硬件和机械部件的完整设备，例如汽车的防锁死刹车系统。<br>现代嵌入式系统通常是基于微控制器（如含集成内存和/或外设接口的中央处理单元）的，但在较复杂的系统中普通微处理器（使用外部存储芯片和外设接口电路）也很常见。</li>
<li>嵌入式Linux<br>嵌入式Linux（英语：Embedded Linux）是一类嵌入式操作系统的概称，这类型的操作系统皆以Linux内核为基础，被设计来使用于嵌入式设备。<br>与电脑端运行的linux系统本质上是一样的，虽然经过了一些功能上的裁剪，但是本质上是一样的，主要利用 Linux 内核中的的任务调度、内存管理、硬件抽象等功能。</li>
<li>RTOS<br>实时操作系统（RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。<br>实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</li>
</ol>
<p>三、非实时、软实时、硬实时</p>
<p>首先要明白什么叫实时性？实时性考虑的不是速度、性能、吞吐量，而是确定性，也就是说：当一个事件发生的时候，可以确定性的保证在多长时间内得到处理，只要能满足这个要求，就可以成为硬实时。比如：</p>
<p>操作系统1：当中断发生时，可以保证在 1 秒内得到这里，那么它就是硬实时系统，虽然响应时间长，但它是确定的；<br>操作系统2：当中断发生时，几乎都可以在 1 毫秒内完成，那么那就不能成为硬实系统，虽然响应时间短，但是它不确定。<br>也看到有文章说：应该取消软实时这个模棱两可的说法，要么是实时，要么是非实时！</p>
<p>操作系统包含的功能很多：任务调度、内存管理、文件管理等等，其中最核心的就是任务调度，这也是非实时、软实时、硬实时的最大区别。</p>
<p>也就是说，衡量实时性的指标就是：</p>
<ol>
<li>中断延时：一个外部事件引发的中断发生时，到相应的中断处理程序第一条指令被执行时，所经过的时间；</li>
<li>任务抢占延时：当一个高优先级的任务准备就绪时，从正在执行的低优先级任务中抢夺 CPU 资源所经过的时间；</li>
</ol>
<p>不同的操作系统，其任务调度机制也是不一样的，而这个调度机制的策略，又是与实际的使用场景相关的。因此，并不存在哪个好、哪个不好这样的说法，合适的就是最好的！</p>
<p>比如：我们的桌面系统，需要考虑的是多任务、并发，需要同时执行多个程序，哪个程序慢一点，用户无所谓，甚至觉察不到；但是对于一个导弹控制系统，当一个外部传感器输入信号，触发一个事件时，对应的处理必须立刻执行，否则耽搁 1 毫秒，结果可能就是差之千里！</p>
<p>四、x86 Linux 系统的调度策略</p>
<p>我们日常使用的 PC 机，它的主要目标是并行执行多任务，强调的是吞吐率(尽可能多的执行很多应用程序的代码)，因此，采用的是分时操作系统，也就是每个任务都有一个时间片，当一个任务分配的时间片用完了，就自动换出（调度），然后执行下一个任务。</p>
<p>我们平常在写 x86 平台上写普通的客户端程序时，很少需要指定应用程序的调度策略和优先级，使用的是系统默认的调度机制。反过来说，也就是在某些需要的场合下，是可以设置进程的调度策略和优先级的。</p>
<p>例如在 Linux 系统中，可以通过 sched_setscheduler() 系统函数 设置 3 种调度策略：</p>
<p>SCHED_OTHER: 系统默认的调度策略，计算动态优先级（counter+20-nice），当时间片用完之后放在就绪队列尾；<br>SCHED_FIFO: 实时调度策略，根据优先级进行调度，一旦占用CPU就一直执行，直到自己放弃执行或者有更高优先级的任务需要执行；<br>SCHED_RR: 也是实时调度策略，在 SCHED_FIFO 的基础上添加了时间片。在执行时，可以被更高优先级的任务打断，如果没有更高优先级的任务，那么当任务的执行时间片用完之后，就会查找相同优先级的任务来执行。</p>
<ol>
<li>为什么 Linux 系统是软实时的？<br>可能有小伙伴会有疑问：既然 Linux 系统中提供了 SCHED_FIFO 基于优先级的调度策略，为什么仍然不能称之为真正的硬实时操作系统？这就要从 Linux 的发展历史说起了。</li>
</ol>
<p>Linux 操作系统在设计之初，就是为了桌面应用而开发的，在那个时代，多个终端(电传打字机和屏幕)连接到同一个电脑主机，需要处理的是多任务、并行操作，并不需要考虑实时性，因此，在 Linux 内核中的一些基因，严重影响了它的实时性，例如有如下几个因素：</p>
<p>(1) 内核不可抢占</p>
<p>我们知道，一个应用程序在执行时，可以在用户态和内核态执行(当调用一个系统函数，例如：write 时，就会进入内核态执行)，此时任务是不可抢占的。</p>
<p>即使有优先级更高的任务准备就绪，当前的任务也不能立刻停止执行。而是必须等到当前这个任务返回到用户态，或者在内核态中需要等待某个资源而睡眠时，高优先级任务才可以执行。</p>
<p>因此，这就很显然无法保证高优先级任务的实时性了。</p>
<p>(2) 自旋锁</p>
<p>自旋锁是用于多线程同步的一种锁，用来对共享资源的一种同步机制，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>
<p>自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的，也就是说，只能在阻塞很短的时间才适合使用自旋锁。</p>
<p>但是，在自旋锁期间，任务抢占将会失效，这就是说，即使自旋锁的阻塞时间很短，但是这仍然会增加任务抢占延时，让调度变得不确定。</p>
<p>(3) 中断的优先级是最高的</p>
<p>任何时刻，只要中断发生，就会立刻执行中断服务程序，也就是中断的优先级是最高的。只有当所有的外部中断和软终端都处理结束了，正常的任务才能得到执行。</p>
<p>这看起来是好事情，但是想一想，如果有比中断优先级更高的任务呢？假如系统在运行中，网口持续接收到数据，那么中断就一直被执行，那么其他任务就可能一直得不到执行的机会，这是影响 Linux 系统实时性的巨大挑战。</p>
<p>(4) 同步操作时关闭中断</p>
<p>如果去看 Linux 内核的代码，可以看到在很多地方都执行了关中断指令，如果在这期间发生了中断，那么中断响应时间就没法保证了。</p>
<ol start="2">
<li>Linux 系统如何改成硬实时？<br>以上描述的几个因素，对 Linux 实现真正的实时性构成了很大的障碍，但是现实世界又的确有很多场合需要 Linux 具有硬实时，那么就要针对上面的每一个因素提出解决方案。</li>
</ol>
<p>目前主流的解决方案有 2 个：</p>
<p>单内核解决方案：给 Linux 内核打补丁，解决上面提到的几个问题，例如：RT-Preempt;<br>双内核解决方案：在硬件抽象层之上，运行 2 个内核：实时内核 + Linux 内核，它们分别向上层提供 API 函数，例如：Xenomai;<br>这 2 种解决方案分别有不同的实现，从调研情况来看，RT-Preempt 和 Xenomai 是使用比较多的，下面分别来看一下他们的优缺点。</p>
<p>（1）RT-Preempt<br>这种方式主要是对 Linux 内核进行打补丁，解决了上面所说的几个问题：内核不可抢占、自旋锁、关中断以及终端优先级的问题。</p>
<p>至于每一个问题是如何解决的，由于篇幅关系，这里就不介绍了，感兴趣的小伙伴如果需要的话，可以深入了解一下。</p>
<p>由于是直接在 Linux 内核上打补丁(以后肯定会合并到主分支中的)，因此对于应用程序开发来说，操作系统向上层提供的 API 接口函数可以保持不变，这对应用程序开发来说是一件好事情。</p>
<p>（2）Xenomai<br>Xenomai是一个 Linux 内核的实时开发框架，它希望通过无缝地集成到 Linux 环境中来给用户空间应用程序提供全面的，与接口无关的硬实时性能。下面是 Xenomai 的架构图：</p>
<p>在硬件抽象层之上，是 2 个并列的域(内核)，这 2 个内核分别向上层提供自己的 API 接口函数。</p>
<p>图中 glibc 是 Linux 系统提供的库函数，应用程序通过调用库函数和系统调用来编写程序。</p>
<p>Xenomai 也提供了相应的库函数 libcobalt ，这个库函数是需要我们在用户层编译、安装的，就像安装第三方库一样。</p>
<p>此外，Xenomai 还参考不同的操作系统风格，提供了好几套 API 函数(之前的说法是：皮肤)，API 接口函数在这里：</p>
<p>从图中可以看到，Alchemy API 这套接口提供的功能更完善，提供了：定时器、内存管理、条件变量、事件、互斥锁、消息队列、任务(可以理解为线程)等 API 函数。 这一套 API 函数中具体的功能与 POSIX 标准大体相同，在一些细节上存在一些差异。</p>
<p>由于 Xenomai 向应用层提供的 API 函数是独立的一套，因此，如果我们需要创建实时任务，那么就要调用这一套接口函数来创建任务，包括使用其中的一些资源(例如：内存分配)。而且文档中也提出了一些注意点，例如：某些资源不能在 Xenomai 与 Linux 系统之间混用。</p>
<p>五、RTOS 的优势</p>
<p>上面已经说到，Linux 桌面系统的主要目标是吞吐量，在单位时间内执行更多的代码。</p>
<p>但是对于单片机来说，首要目标不是吞吐量，而是确定性，因此衡量一个实时操作系统坚固性的重要指标，是系统从接收一个任务，到完成该任务所需的时间。也就是说，任务调度才是第一考量要素。</p>
<p>在单片机开发中，一般有 2 种编程模型：基于状态机(裸跑)，基于 RTOS。</p>
<p>如果基于状态机，就不存在任务调度问题了，因为只有一个执行序列，所有的操作都是串行执行的，唯一需要注意的控制流程就是中断处理。</p>
<p>如果基于 RTOS，主要利用的就是任务调度，实现真正的硬实时。这方面最牛逼的就是VxWorks了，当然价格也是非常可观的，有些公司购买之后，甚至会把除了任务调度模块之外的其他模块全部重写一遍，这也足以证明了 VxWorks 在任务调度处理上的确很厉害，这也是它的看家本领!</p>
<p>当然，对于简单、需要严格控制执行序列的关键程序来说，使用有限状态机的编程框架，一切都在自己的掌握中。只要代码中没有 bug，那么理论上，一切行为都是在控制之中的，这也是为什么很多军事设备上使用单片机的原因！</p>
<p>六、总结</p>
<p>关于任务调度的问题，是一个操作系统的重中之重，其中需要学习的内容还有很多，最近刚买了一本陈海波老师的新书，也就是华为的鸿蒙系统背后的灵魂人物。</p>
<p>如果有新的学习心得，再跟大家分享。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>单片机</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>配电与配网的异同</title>
    <url>/2023/12/15/%E9%85%8D%E7%94%B5%E4%B8%8E%E9%85%8D%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>配网与配电有何区别<br>2023年11月09日<br>一、配网和配电的定义</p>
<p>配电是指将高压电能经过变压器逐级降压，最终输送给终端用户的一种电力传输方式。而配网则是指在配电系统中，将电能从配电变压器输送到终端用户，负责能量的传输和分配。简单来说，配电强调的是输电，而配网强调的是分电。</p>
<p>二、配网和配电的功能</p>
<p>配网的主要功能是将电力从变电站输送到城市和建筑物中，并为用户提供安全、可靠、高效、低成本的电力服务。配电则主要分为高压配电和低压配电，负责将电源的能量分配到用户终端并控制供电质量以保证稳定供电。</p>
<p>三、配网和配电的应用范围</p>
<p>配电主要是指把电压由高压状态变成响应的低压状态后，送入工业、农业、商业以及居民区域。而配网则负责把电能从配电变压器输送到用户终端，包括城市道路照明、商业建筑、工业用电等等。</p>
<p>四、配电和配网的发展趋势</p>
<p>随着社会的进步和经济的发展，人们对电力的需求不断增长，配电和配网也不断发展和完善。未来，配网技术将走向更加智能化和数字化，通过大数据和人工智能等新技术，实现对电力供应和需求的实时监测和智能调控，提高电力的可靠性、可持续性和效率。配电也将趋向一体化和集成化，探索新的电力生产和传输模式，提高电力的质量和效益。</p>
<p>总之，配电和配网虽然存在一定的联系和关联，但它们的职能和作用有所不同。未来，随着科技的发展和社会的需求，配电和配网也会愈加完善和智能化，为人们生活和经济发展带来更多的便利和效益。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt实现简单的显示网页（QtWebkit、QtWebEngine、QAxWidget）</title>
    <url>/2023/12/14/Qt%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%EF%BC%88QtWebkit%E3%80%81QtWebEngine%E3%80%81QAxWidget%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>首先先说说QtWebkit、QtWebEngine、QAxWidget三种方式显示网页的应用场景<br>QtWebkit：在Qt5.6以前，都是使用QtWebkit组件，但Qt5.6以后，移除了QtWebkit这个组件<br>QtWebEngine：Qt5.6以后的MSVC版本，引进了基于Chromium的浏览器引擎 QtWebEngine<br>QAxWidget：Qt5.6以后的mingw版本，由于移除了QtWebkit，mingw版本不能使用QtWebEngine，因此只能使用QAxWidget控件</p>
<h1 id="QtWebkit"><a href="#QtWebkit" class="headerlink" title="QtWebkit"></a>QtWebkit</h1><p>QtWebKit提供一个Web浏览器引擎，可以轻松地将来自万维网的内容嵌入到Qt应用程序中。同时，可以使用本机控件增强Web内容。<br>QtWebKit提供用于呈现超文本标记语言(HTML)、可扩展超文本标记语言(XHTML)和可伸缩矢量图形(SVG)文档的工具，这些文档使用级联样式表(CSS)样式，并使用JavaScript编写脚本。<br>JavaScript执行环境与Qt对象模型之间的桥梁使定制成为可能QObjects写剧本。有关详细文档，请参阅QtWebkit桥，通过与Qt网络模块的集成，可以透明地从Web服务器、本地文件系统甚至Qt资源系统加载Web页面。<br>除了提供纯呈现功能之外，还可以通过使用contenteditable属性设置在HTML元素上。<br>QtWebKit已经得到了增强，在移动领域也变得更有吸引力。有关更多信息，请参见QtWebKit Go Mobile.<br>QtWebKit是基于开放源码WebKit引擎。更多关于WebKit本身可以在WebKit开源项目网站。<br>关于交互部分需要与JavaScript联合使用，下面只简单的介绍如何显示网页。</p>
<pre><code>QWebView view;
view.load(QUrl(https://blog.csdn.net/qq_36651243));
view.show();
</code></pre>
<h1 id="QtWebEngine"><a href="#QtWebEngine" class="headerlink" title="QtWebEngine"></a>QtWebEngine</h1><p>QtWebEngine模块提供了一个Web浏览器引擎，可以方便地在没有本地Web引擎的平台上将来自万维网的内容嵌入到Qt应用程序中。<br>QtWebEngine提供C+类和QML类型，用于呈现HTML、XHTML和SVG文档，样式为级联样式表(CSS)，并使用JavaScript编写脚本。用户可以通过使用contenteditable属性设置在HTML元素上。</p>
<p>小编开发环境：Qt5.9.6+VS2015</p>
<pre><code>QWebEngineView *LiveView = new QWebEngineView;
LiveView-&gt;settings()-&gt;setAttribute(QWebEngineSettings::PluginsEnabled, true);
LiveView-&gt;setAttribute(Qt::WA_DeleteOnClose);
LiveView-&gt;load(QUrl(&quot;https://blog.csdn.net/qq_36651243&quot;));
//LiveView-&gt;setWindowFlags(Qt::FramelessWindowHint);   //去除边框
//LiveView-&gt;setAttribute(Qt::WA_TranslucentBackground, true); //透明
LiveView-&gt;resize(1024, 768);
LiveView-&gt;show();
</code></pre>
<h1 id="QAxWidget"><a href="#QAxWidget" class="headerlink" title="QAxWidget"></a>QAxWidget</h1><p>QAxWidget可以使用它应该包装的ActiveX控件的名称，或者使用指向ActiveX控件的现有接口指针，将其实例化为空对象。ActiveX控件的属性、方法和事件，这些属性、方法和事件仅使用QAxBase受支持的数据类型，可作为Qt属性、槽和信号使用。基类QAxBase控件直接访问ActiveX的API。IUnknown指针。</p>
<p>小编开发环境：Qt5.9.6+VS2015<br>使用QAxWidget前需要注意两点：<br>1.QAxContainer.lib,QAxServer.lib库不可缺。<br>2.开发机本身具有相应的IE游览器（注册表文件一致）</p>
<p>QAxContainer.lib,QAxServer.lib引用方式：</p>
<p>关于注册表文件：</p>
<pre><code>QAxWidget *flash = new QAxWidget(0, 0);      //QAxWidget使用的是ActiveX插件
flash-&gt;resize(600, 400);                    //设置该控件的初始大小
flash-&gt;setControl(QString::fromUtf8(&quot;&#123;8856F961-340A-11D0-A96B-00C04FD705A2&#125;&quot;));//注册组件ID
flash-&gt;setProperty(&quot;DisplayAlerts&quot;, false);//不显示警告信息
flash-&gt;setProperty(&quot;DisplayScrollBars&quot;, true);//不显示滚动条
QString webstr = QString(&quot;www.baidu.com&quot;);//设置要打开的网页
flash-&gt;dynamicCall(&quot;Navigate(const QString&amp;)&quot;, webstr);//显示网页
flash-&gt;show();
</code></pre>
<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><p><a href="https://doc.qt.io/archives/qt-4.8/qtwebkit-module.html">https://doc.qt.io/archives/qt-4.8/qtwebkit-module.html</a><br><a href="https://doc.qt.io/archives/qt-5.11/qtwebengine-overview.html">https://doc.qt.io/archives/qt-5.11/qtwebengine-overview.html</a><br><a href="https://doc.qt.io/archives/qt-5.11/qaxwidget.html">https://doc.qt.io/archives/qt-5.11/qaxwidget.html</a><br><a href="https://doc.qt.io/qt-5/qtwebenginewidgets-qtwebkitportingguide.html">https://doc.qt.io/qt-5/qtwebenginewidgets-qtwebkitportingguide.html</a></p>
<p>————————————————</p>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_36651243/article/details/93173395">https://blog.csdn.net/qq_36651243/article/details/93173395</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS加载XYZ地图</title>
    <url>/2023/12/13/QGIS%E5%8A%A0%E8%BD%BDXYZ%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、添加XYZ-Tiles步骤，"><a href="#一、添加XYZ-Tiles步骤，" class="headerlink" title="一、添加XYZ Tiles步骤，"></a>一、添加XYZ Tiles步骤，</h1><p>第一步<br>在左侧面板中，右键 xyzTiles<br>点击 New Connection</p>
<p>第二步<br>点击New Connection后，出现弹窗</p>
<p>Name字段自定义命名，<br>url 输入<a href="http://www.google.cn/maps/vt?lyrs=s@820&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">http://www.google.cn/maps/vt?lyrs=s@820&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>点击OK，<br>然后把xyzTile下面新建的Google图层，拖拽到下面Layer层中，就显示出来了。然后在其上新建图层，浏览查看，都没问题啦。</p>
<h1 id="二、常用-Tiles-如下："><a href="#二、常用-Tiles-如下：" class="headerlink" title="二、常用 Tiles 如下："></a>二、常用 Tiles 如下：</h1><p>高德街道地图：<br><a href="https://wprd01.is.autonavi.com/appmaptile?x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=7">https://wprd01.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=7</a></p>
<p>高德卫星影像<br><a href="https://webst01.is.autonavi.com/appmaptile?style=6&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://webst01.is.autonavi.com/appmaptile?style=6&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>高德路网<br><a href="https://wprd01.is.autonavi.com/appmaptile?x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=8&amp;ltype=11">https://wprd01.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=8&amp;ltype=11</a></p>
<h1 id="三、其他："><a href="#三、其他：" class="headerlink" title="三、其他："></a>三、其他：</h1><p>谷歌街道地图：<br><a href="http://mt2.google.com/vt/lyrs=m&amp;scale=2&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">http://mt2.google.com/vt/lyrs=m&amp;scale=2&amp;hl=zh-CN&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>谷歌卫星地图：<br><a href="http://mt2.google.com/vt/lyrs=y&amp;scale=2&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">http://mt2.google.com/vt/lyrs=y&amp;scale=2&amp;hl=zh-CN&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>Google Maps:<br><a href="https://mt1.google.com/vt/lyrs=r&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://mt1.google.com/vt/lyrs=r&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>Google Satellite Hybrid:<br><a href="https://mt1.google.com/vt/lyrs=y&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>Google Satellite<br><a href="https://mt1.google.com/vt/lyrs=s&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>Google Terrain:<br><a href="https://mt1.google.com/vt/lyrs=t&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://mt1.google.com/vt/lyrs=t&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>Google Roads:<br><a href="https://mt1.google.com/vt/lyrs=h&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://mt1.google.com/vt/lyrs=h&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>Google Road<br><a href="https://mt1.google.com/vt/lyrs=m&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D">https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}</a></p>
<p>openstreetmap：<br><a href="http://a.tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png">http://a.tile.openstreetmap.org/{z}/{x}/{y}.png</a></p>
<p>OpenStreetMap<br><a href="http://tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png">http://tile.openstreetmap.org/{z}/{x}/{y}.png</a></p>
<p>OpenTopoMap<br><a href="https://tile.opentopomap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png">https://tile.opentopomap.org/{z}/{x}/{y}.png</a></p>
<p>Bing Aerial<br><a href="http://ecn.t3.tiles.virtualearth.net/tiles/a%7Bq%7D.jpeg?g=1">http://ecn.t3.tiles.virtualearth.net/tiles/a{q}.jpeg?g=1</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>windows好用的小工具</title>
    <url>/2023/12/12/windows%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、<br><a href="https://hub.nuaa.cf/zetaloop/ExplorerPatcher">https://hub.nuaa.cf/zetaloop/ExplorerPatcher</a><br><a href="https://hub.nuaa.cf/valinet/ExplorerPatcher">https://hub.nuaa.cf/valinet/ExplorerPatcher</a></p>
<p>2、<br>Windows11轻松设置<br>Windows10径松设置（仅支持特64位Win10)<br>软件作者：快乐无极<br>软件版本：v1.08Beta<br>发布日期：2023-12-25<br>发布说明：比版本发布于PCBeta远景论坛Windows11版块。<br>本人的远景论坛ID号为：coolcool2013<br>比软件仅为测试使用Windows11/10而编写，使用者需自行承担风险。<br>本软件完全免费使用。如果能打赏便是对我最大的鼓励。<br>反馈联系邮箱：<a href="mailto:&#x6f;&#x79;&#x6b;&#115;&#x6f;&#x66;&#x74;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;">&#x6f;&#x79;&#x6b;&#115;&#x6f;&#x66;&#x74;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;</a></p>
<p><a href="https://bbs.pcbeta.com/viewthread-1972024-1-2.html">https://bbs.pcbeta.com/viewthread-1972024-1-2.html</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows使用cmd命令添加、删除和修改静态路由：route</title>
    <url>/2023/12/11/windows%E4%BD%BF%E7%94%A8cmd%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9Aroute/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、添加一条路由表<br>route add 192.168.20.0 mask 255.255.255.0 192.168.4.1 metric 2 if 2<br>命令说明：添加一条路由记录，所有到192.168.20.0/24网段的数据包，都通过2号接口（网卡）走192.168.4.1的网关，优先级为2。</p>
<p>route add -p 192.168.100.0 mask 255.255.255.248 192.168.1.1 metric 3 if 2<br>#作用同上，-p参数表：该记录为永久路由，不会因为重启机器而丢失。<br>2、删除一条路由表<br>route delete 192.168.10.0<br>【语法】</p>
<p>route delete 网络目的地址 [mask] [子网掩码]<br>route delete 112* ——-&gt;删除路由时用这种模糊匹配，表示删除以112开头的IP路由表中的所有路由；<br>命令说明：如果有两条192.168.10.0路由记录，即路由表中存在相同的“目的网络号”，则会将两条记录同时删除。如果只想删除其中某一条的话，请在删除后用route add命令再添加上其中一条。</p>
<p>3、修改一条现有路由记录<br>route change 162.0.0.0 mask 255.255.0.0 162.54.10.5 metric 2 if 2<br>命令说明：CHANGE参数只能修改路由条目的“网关”和“跳数”。</p>
<p>4、查看路由表<br>route print -4/-6</p>
<p>路由表列说明：</p>
<p>第一列是网络目的地址。列出了路由器连接的所有的网段。</p>
<p>第二行网络掩码列提供这个网段本身的子网掩码，而不是连接到这个网段的网卡的子网掩码。这基本上能够让路由器确定目的网络的地址类。</p>
<p>第三列是网关。一旦路由器确定它要把这个数据包转发到哪一个目的网络，路由器就要查看网关列表。网关表告诉路由器这个数据包应该转发到哪一个IP地址才能达到目的网络。</p>
<p>第四列接口列告诉路由器哪一个网卡连接到了合适的目的网络。从技术上说，接口列仅告诉路由器分配给网卡的IP地址。那个网卡把路由器连接到目的网络。然而，路由器很聪明，知道这个地址绑定到哪一个物理网卡。</p>
<p>第五列是测量，或跳数。测量本身是一种科学。该值越小的，可信度越高<br>【例子】</p>
<p>Network Destination Netmask Gateway Interface Metric<br>0.0.0.0 0.0.0.0 116.69.106.120 116.69.106.1 1<br>上面信息表示发向任意网段的数据通过本机接口116.69.106.1被送往一个默认的网关：116.69.106.120，它的管理距离是1，管理距离指的是在路径选择的过程中信息的可信度，管理距离越小的，可信度越高。</p>
<p>5、查看广播信息<br>arp -a<br>##查看查看与本地电脑连接的mac地址跟IP地址，即当前电脑上的ARP映射表。可以看到当前的ARP的映射关系是动态的还是静态的。</p>
<p>arp -s w.x.y.z aa-bb-cc-dd-ee-ff<br>##添加静态ARP实现ARP绑定。其中w.x.y.z代表要绑定的IP地址，aa-bb-cc-dd-ee-ff代表其MAC地址</p>
<p>arp -d InetAddr[IfaceAddr]<br>##删除指定的IP地址项，此处的InetAddr代表IP地址，要删除所有项，请使用星号（*）通配符代替。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title>route add -p 命令详解</title>
    <url>/2023/12/10/route%20add%20-p%20%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>route add</code>命令用于添加一条静态路由信息。在使用时，可以指定不同的子网掩码和其他参数来定义目的网络的路由条目。以下是一些示例用法：</p>
<p>要添加一个指向特定目标的默认路由，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">route add 0.0.0.0 mask 0.0.0.0 [目标网关地址]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若要在指定的子网掩码（如255.255.0.0）下为目标网络添加一个路由，可以使用类似的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">route add [目标网络前缀] mask [子网掩码] [目标网关地址]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于具有特定Metric值的路由，可以使用<code>metric</code>参数进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">route add [目标网络前缀] mask [子网掩码] metric [Metric值] [目标网关地址]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，<code>route add -p</code>命令用于添加一条永久路由。这通常用在网络中有多个网关地址的情况下，以便能够通过不同的网关访问同一组网络。</p>
<p>例如，如果要将所有需要发送到130.0.0.0/8地址段的数据包都转发给134.32.80.1这个网关，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">route add -p 130.0.0.0 mask 255.0.0.0 134.32.80.1 metric 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，“-p”表示这是一个永久路由，而“130.0.0.0/8”是一个目标网络的前缀，其子网掩码被设置为“255.0.0.0”，目标网关地址是“134.32.80.1”，并且Metric值为“10”。</p>
<p>需要注意的是，路由跳数（Metric值）通常是可选的，但在某些情况下可能需要指定以确保正确的路由优先级。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup命令</title>
    <url>/2023/12/09/github%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E7%BD%91%E5%9D%80%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>hub.yzuu.cf/<br>hub.nuaa.cf/<br>hub.fgit.ml/</p>
<p>使用chrome浏览器，不要使用360系列的浏览器。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup命令</title>
    <url>/2023/12/08/nohup%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nohup命令</p>
<p>后台运行：</p>
<pre><code>sh test.sh &amp;
</code></pre>
<p>关闭终端也运行：</p>
<pre><code>nohup sh test.sh &amp;
</code></pre>
<p>一般使用：</p>
<pre><code>nohup sh test.sh &gt; nohup.out  2&gt;&amp;1 &amp;
</code></pre>
<p>2&gt;&amp;1 解释：<br>将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 nohup.out 文件中。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「小赵小赵福星高照～」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/attemptendeavor/article/details/125501870">https://blog.csdn.net/attemptendeavor/article/details/125501870</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
        <tag>OSGeo4W</tag>
      </tags>
  </entry>
  <entry>
    <title>交互设计师必须get的场景化设计大解密，附详细案例</title>
    <url>/2023/12/07/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%BF%85%E9%A1%BBget%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8C%96%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%A7%A3%E5%AF%86%EF%BC%8C%E9%99%84%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>交互设计师必须get的场景化设计大解密，附详细案例<br><a href="https://www.zcool.com.cn/article/ZMTA1NTk0NA==.html">https://www.zcool.com.cn/article/ZMTA1NTk0NA==.html</a></p>
<p>一、什么是场景化设计</p>
<p>「场景」在百度百科里的定义是：戏剧、电影中的场面，泛指情景。情景又指(1) 感情与景色。(2) 情形；景象。(3) 环境：假设是在这个情景。在戏剧或影视剧里，场景由人物，时空，事件（行为），环境（社会环境和自然环境）等要素构成。</p>
<p>互联网中的「场景」我把它分为两类，一类是为了实现用户目标而产生的场景，这种类型的场景需要明确用户目标，可能并不需要涵盖用户是怎么实现目标的，这类场景指根据用户的精准需求，为其提供精准服务，用明确的差异化服务给用户提供一个使用产品的动机。比如微博和微信，微信定位是熟人社交，微博则是陌生人社交；另一类是更加精细化的场景，这类场景需要明确用户操作流程。本文主要针对第二类场景展开。</p>
<p>场景化设计指基于对场景的分析，得出用户痛点与需求，结合前后场景预判用户目标，通过设计提高用户效率，给予用户惊喜与感动。</p>
<p>场景要素包括：4W+1H，即Who人、When时间、Where地点、What事件、How环境，什么人，在什么时候，在什么地方，做了什么事情，所处的环境如何。其中Where又包括线上地点和线下地点，线下指现实中的定位，可以通过手机信号塔数据（GPS），Wifi连接等获取；线上指用户所处的具体页面。</p>
<p>如：用户（who）早上上班（when）在地铁上（where）看电子书（what），地铁上人多嘈杂且操作不方便（how）。再比如用户（who）中午（when）在办公室里（where）点外卖（what），肚子很饿还不知道吃什么（how）。五要素就像口诀，帮助我们全面快速的描述场景。</p>
<p>二、有哪些场景化设计的例子</p>
<p>为帮助大家更好的理解场景化设计，这里基于上面提到的场景五要素举一些例子：</p>
<p>人是变量：用户不同，看到的信息不同。随着大数据和智能推荐技术的普及，越来越多的产品通过挖掘不同用户的喜好，生成用户画像，为每位用户提供“千人千面”的个性化内容。这样的产品大家都很熟悉，比如抖音，淘宝，微博，今日头条。</p>
<p>时间是变量：时间不同，看到的信息不同。比如小米MIUI11的效率革新功能「智能出行」，当在出行类app上定好行程后，MIUI11就会自动将该行程记录在负一屏显示并同步日历，同时会根据出行的时间点，在通知栏实时更新提示：<br>再比如在Google Maps的app里开启导航时，如果目的地在预计到达时间还没有开门，或者快要/已经关门了的话，会有个弹窗提醒。</p>
<p>还有蚂蚁森林的页面会根据用户打开的时间进行变化（白天与夜晚模式）等等，这些都是充分考虑了场景中时间这一变量，才有如此高效暖心的设计。</p>
<p>地点是变量：同一个用户，在不同地点看到的信息不同。比如，大众点评APP当用户从常住地北京（where）定位成非常住地杭州（where）时，根据用户的上个场景与当前场景预测用户可能处于旅游状态，从而预测用户下一步的目标是在杭州「吃喝玩乐」，所以首页和攻略页的内容都发生了变化，为用户推荐旅行地的「吃喝玩乐」。<br>环境是变量：不同环境看到的信息不同，比如设备环境发生变化时：Ios13中的备忘录页面，将「添加」按钮移到了右下角，为什么？因为手机屏幕越来越大，把按钮从右上角移到右下角，更有利于用户单手操作。<br>再比如：我们在驾驶环境下，要保持注意力集中，避免或减少分心驾驶导致的交通事故，所以基于驾驶环境ios11上线了驾驶模式功能，当iphone与车内的USB或蓝牙连接，或iphone感知到人的移动速度时，iphone就会自动进入驾驶模式，在该模式下，任何人发短信，我们都不会收到提示，对方会收到“我正在驾驶，稍后回复您”的自动回复，同时，iphone会追加一条短信，提示对方只要回复“紧急”关键词，我们就能立刻接收到他们的消息提示。<br>三、为什么要基于场景做设计？<br>通过上面的举例想必大家已经了解到了基于场景做设计的好处。由于与用户的空间相隔，设计师无法感知用户在真实场景中使用产品的具体情况。通过场景化设计的方法，对用户使用场景进行分析与预期，可以帮助设计师找到用户与场景的内在联系，探索新的功能及交互方式。</p>
<p>四、怎么进行场景化设计</p>
<p>可以概括为以下四步：<br>1、根据用户使用流程和行为路径穷尽场景<br>根据用户的使用流程和行为路径列举场景，这里以乘坐飞机（手机购票）为例，列举乘坐飞机涉及到的关键场景：<br>①乘客（who）在航旅纵横页面（where）购票（what），航班多查找起来麻烦（how）。<br>②乘客（who）起大早拖着疲惫的身体（how）在去往机场的路上（where），又遇到早高峰堵车，内心焦躁烦闷（how）。<br>③起飞前（when）乘客（who）在机场（where）过安检（what），安检流程复杂，又检测出不符合登机规定的物品，让人心烦，手忙脚乱（how）。<br>④起飞前（when），乘客（who）在候机口（where）候机（what），人多嘈杂，没有座位，还背着繁重的行李，还要时刻关注航班信息（how）。<br>⑤起飞前40分钟（when），乘客（who）背着行李排着队（how），将登机牌（纸质/电子）和身份证出示给工作人员（what），工作人员（who）站在入口处（where）开始检查每位乘客的登机牌和身份证（what）。<br>⑥检完票后（when），乘客（who）拿着身份证和登机牌，背着行李（how）乘坐摆渡车（what），摆渡车上嘈杂、拥挤（how）。<br>⑦下摆渡车后（when），乘客拿出登机牌，背着行李（how）排队检票登机（what），工作人员（who）站在飞机前（where）开始检查每位乘客的登机牌（what）。<br>⑧在起飞前30分钟（when），乘客（who）登机（what），背着行李在狭窄拥挤的通道里（how）寻找自己的座位（what）。找到座位后，将沉重的行李艰难的（how）放到上方的置物架上（what）。放好行李后，坐到自己的座位上（what），系好安全带（what），调节座椅靠背（what），等待飞机起飞（what）。<br>⑨飞行过程中（when），气流导致飞机颠簸，乘客感到恐慌不适（how）。飞行过程中，乘客通过看电影，看书，睡觉打发时间（what）。<br>⑩到达目的地（when），乘客（who）从高处置物架上（how）取下行李（what），拿着沉重的行李（how）排队下飞机（what）。此时乘客对目的地的天气等其他情况都不清楚。<br>⑪乘客走出飞机到达航站楼后，在陌生的机场（where），跟着标牌指示艰难的找到自己的行李（what）。拿着行李跟着指示牌（how）困难的找出口（what）。</p>
<p>通过对关键场景的详细描述，我们将摸不着的用户场景像过电影一样在眼前一一呈现，有利于我们发现很多想不到或者通过调研得不到的细节，帮助我们发现用户真正的痛点与需求，洞察设计机会点。</p>
<p>2、根据场景挖掘机会点<br>完成了第一步的场景列举，我们对流程中涉及的场景有了深刻的了解，下一步就是对场景的判断与分析，挖掘机会点。机会点挖掘有两个方向，一是通过分析当前场景存在的痛点和需求挖掘机会点，二是通过对用户下一步目标的预判寻找机会点。<br>①通过分析当前场景存在的痛点和需求挖掘机会点<br>举例说明1：支付宝「朋友」界面，当用户输入某数值时，输入框上方会自动显示「给对方转账***元」按钮，用户可点击该按钮完成转账。这是因为经常有用户误以为输入数值发送即完成了转账，导致很多尴尬出现。基于该场景下的痛点与需求，支付宝做了这个改进，贴心又好用。<br>举例说明2：ios系统在切换APP操作时，会将一些金融类APP虚化，以此来保证用户信息安全。这一设计细节也是充分考虑了用户在切换APP时的场景，解除了用户在公告场合担心被窥屏而泄露个人财富信息的担忧。<br>还有，当我们用耳机听音乐或播放视频时，拔下耳机，声音就会自动停掉，这样就算在安静的场合听音乐或者看视频，耳机不小心掉下来也不会发出尴尬的声音，这些都是充分考虑了用户当前使用时的场景，才做出如何贴心的设计。</p>
<p>②通过对用户下一步目标的预判寻找机会点<br>第二个方法是通过对用户当前场景的分析，预判用户下一步的行为与目标，从而寻找当前场景的机会点。<br>如何预期用户下一步目标？有三个方法：<br>1）通过成组动作进行预期，如复制—粘贴，编辑—保存。<br>2）通过用户认知流程预判，如，浏览时反向滑动→结束浏览/回到顶部；再比如谷歌翻译在发音时，第一遍是正常语速，第二遍语速变慢，第三遍又恢复到常速，是不是很贴心，很符合用户期望？<br>3）通过产品使用流程进行预期，如订外卖—取外卖—评价。<br>举例说明1：在谷歌浏览器，当我们打开多个浏览窗口时，通常需要手动一个个地关闭标签页。chrome充分考虑到了用户的该使用场景，当用户关闭一个标签页时，预期用户会关闭下一个标签页，所以当关闭一个标签时，相邻标签会自动靠近，保证关闭的按钮始终位于鼠标的当前位置，这样用户就不用移动鼠标关闭下一个标签页，提高了用户的使用效率。<br>3、机会点转化为落地的设计方案<br>在将机会点转化为具体的设计时，有两个可作为依据的设计原则，分别为高效，情感化。<br>实现高效有以下几个方法：<br>①行动点前置，通过对用户下一目标的预测，将用户目标在当前场景展示，缩短操作流程，达到高效的目标。如淘宝首页的tab栏会根据每个用户的浏览记录预测用户目标，千人千面个性化展现，缩短了用户查找商品的路径，提高商品购买效率。<br>②行动点置换，还是拿淘宝举例，淘宝底部的第一个导航，当用户滑动首页下方的商品流时，该按钮由首页变成置顶。<br>③行动点相关提示，意思是根据用户当前目标或下一步目标进行相关的提示。如支付宝朋友页面，当上滑时，会出现「找人转账」的提示，点击进入朋友列表的纯净模式（去掉了服务通知等跟转账无用的列表），提高了用户寻找的效率。<br>再比如，网易邮箱，当邮件中提到附件，但是没有上传附件时，点击发送后，系统弹出下方的提示，解决了用户常常忘记添加附件的困扰。<br>④突出行动点，根据用户当前目标或下一步目标突出关键按钮，帮助用户快速找到关键操作，吸引用户点击，降低了用户思考成本，提升效率。运用这个方法进行设计的例子太多了，比如淘宝的商品详情页用红色突出购买按钮等。<br>⑤直接执行，根据用户当前目标或下一步目标直接执行。比如滴滴的扫一扫界面，当检测到光线较暗时，手电筒会自动打开，提高了扫一扫的效率。<br>情感化<br>唐纳德·诺曼在《情感化设计》中提到设计的三个层次，分别为：本能的设计，行为的设计，反思的设计，情感化设计是能打动人的，它能传递感情，勾起回忆，给人惊喜，情感化设计帮助产品与用户之间建立情感的纽带，能强化用户对品牌的认知，培养对品牌的忠诚度。</p>
<p>情感化设计的步骤依次为：提炼影响产品的的情感指标→聚焦用户对产品的情感诉求→产出设计方案→验证设计价值（来源于周姮—知乎蚂蚁金服体验技术部的一次分享）。</p>
<p>举例说明1：在谷歌表格每列的开头依次输入「Pride」五个字母后，表格会变成彩虹样式</p>
<p>举例说明2：网易云音乐在用户生日时会变成「生日快乐」的蛋糕样式，点击进去的音乐列表，第一首歌是生日歌，让人心里暖暖的。<br>4、设计检验<br>最后一步就是设计方案的验证，设计方案能否帮助用户缩短操作流程？降低用户思考成本？帮助用户高效的完成任务？是否能打动用户给他们带来惊喜与温暖？通过可用性测试及上线后的数据反馈，帮助我们更好的优化设计方案。<br>文章较长，我们再回顾一下：<br>一、什么是场景化设计？<br>场景五要素：4W+1H，即Who人、When时间、Where地点、What事件 、How环境，什么人，在什么时候，在什么地方，做了什么事情，所处的环境如何。<br>二、有哪些场景化设计的例子？<br>三、为什么要进行场景化设计？<br>四、怎么进行场景化设计？<br>1、根据使用流程和行为路径穷尽场景<br>2、根据场景挖掘设计机会点<br>3、将机会点转化为落地的设计方案<br>4、设计检验<br>好了，今天就说到这，文章较长，希望大家能耐心消化。<br>说明：文章部分内容引用了阿里中国站UED团队博客里的分享。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
        <tag>OSGeo4W</tag>
      </tags>
  </entry>
  <entry>
    <title>HEX、DEC、OCT 和 BIN 的含义</title>
    <url>/2023/12/06/HEX%E3%80%81DEC%E3%80%81OCT%20%E5%92%8C%20BIN%20%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HEX、DEC、OCT-和-BIN含义如下："><a href="#HEX、DEC、OCT-和-BIN含义如下：" class="headerlink" title="HEX、DEC、OCT 和 BIN含义如下："></a>HEX、DEC、OCT 和 BIN含义如下：</h1><p>HEX，英文全称 Hexadecimal，表示十六进制。</p>
<p>DEC，英文全称 Decimal，表示十进制。</p>
<p>OCT，英文全称 Octal，表示八进制。</p>
<p>BIN，英文全称 Binary，表示二进制。</p>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>十六进制（简写为 hex 或下标 16）是一种基数为 16 的计数系统，是一种逢 16 进 1 的进位制。通常用数字 0、1、2、3、4、5、6、7、8、9 和字母 A、B、C、D、E、F（a、b、c、d、e、f）表示，其中: A<del>F 表示 10</del>15，这些称作十六进制数字。</p>
<p>十进制数是组成以10为基础的数字系统，有 0，1，2，3， 4， 5， 6， 7， 8， 9 十个基本数字组成。十进制，英文名称为 Decimal System，来源于希腊文 Decem，意为十。十进制计数是由印度教教徒在 1500 年前发明的，由阿拉伯人传承至 11 世纪。</p>
<p>八进制，Octal，缩写 OCT 或 O，一种以 8 为基数的计数法，采用 0，1，2，3，4，5，6，7 八个数字，逢八进 1。一些编程语言中常常以数字 0 开始表明该数字是八进制。八进制的数和二进制数可以按位对应（八进制一位对应二进制三位），因此常应用在计算机语言中。</p>
<p>二进制是计算技术中广泛采用的一种数制。 二进制数据是用 0 和 1 两个数码来表示的数。 它的基数为2，进位规则是”逢二进一”，借位规则是”借一当二”。 二进制数（binaries）是逢2进位的进位制，0、1是基本算符 ；计算机运算基础采用二进制。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
        <tag>OSGeo4W</tag>
      </tags>
  </entry>
  <entry>
    <title>OSGeo4W 镜像仓库</title>
    <url>/2023/12/05/OSGeo4W%20%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>注意：本仓库手动同步，不保证所有内容是最新的！</p>
<p>使用方法</p>
<p>打开 OSGeo4W Setup ，在 “Choose A Download Site” 页面的 User URL 中输入地址 <a href="http://gwmodel.whu.edu.cn/mirrors/osgeo4w">http://gwmodel.whu.edu.cn/mirrors/osgeo4w</a> ，点击 Add 按钮，然后选择该镜像进行安装</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
        <tag>OSGeo4W</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot指定配置文件启动</title>
    <url>/2023/12/04/%E9%80%9A%E8%BF%87%20Maven%20%E4%BB%93%E5%BA%93%E5%AE%89%E8%A3%85%20Spire%20%E7%B3%BB%E5%88%97%20Java%20%E4%BA%A7%E5%93%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只需简单配置，您就可以轻松将 Java 产品的 JAR 包通过 Maven 仓库安装到的 Maven 项目中。我们所有 Java 产品均可通过 Maven 安装。下面将详细说明如何在 Maven 程序中添加对 JAR 包的依赖。</p>
<p>首先，在 pom.xml 文件中配置 Maven 仓库路径。</p>
<pre><code>&lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;com.e-iceblue&lt;/id&gt;
            &lt;name&gt;e-iceblue&lt;/name&gt;
            &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
        &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p>然后，在 pom.xml 文件中指定 Spire 产品的 Maven 依赖。如下列举了几种产品的配置方式，可参考使用。</p>
<p>如果需要在同一个程序项目中操作多种文件格式，例如：同时操作 Word、Excel 和 PDF 或者其他多种文件格式时，请使用集合包 Spire.Office for Java。否则，在同一程序中使用多个 Spire Jar 包会引起程序冲突，导致异常报错。</p>
<p>配置 Spire.PDF for Java</p>
<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.pdf&lt;/artifactId&gt;
        &lt;version&gt;10.1.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Spire.Doc for Java</p>
<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.doc&lt;/artifactId&gt;
        &lt;version&gt;12.1.10&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Spire.XLS for Java</p>
<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.xls&lt;/artifactId&gt;
        &lt;version&gt;14.1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Spire.Presentation for Java</p>
<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.presentation&lt;/artifactId&gt;
        &lt;version&gt;8.12.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Spire.Office for Java</p>
<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.office&lt;/artifactId&gt;
        &lt;version&gt;9.1.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>如需配置 Spire 产品的免费版本 jar 包，只需更改 artifactId 和 version 信息即可，如下配置方法：</p>
<p>配置 Free Spire.PDF for Java</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt;
        &lt;version&gt;5.1.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Free Spire.Doc for Java</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.doc.free&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Free Spire.XLS for Java</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.xls.free&lt;/artifactId&gt;
        &lt;version&gt;5.1.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Free Spire.Presentation for Java</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.presentation.free&lt;/artifactId&gt;
        &lt;version&gt;5.1.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置 Free Spire.Office for Java</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.office.free&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot指定配置文件启动</title>
    <url>/2023/12/03/springboot%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IDE开发工具启动"><a href="#IDE开发工具启动" class="headerlink" title="IDE开发工具启动"></a>IDE开发工具启动</h1><p>在JetBrains IDEA开发工具的配置</p>
<p>1.启动类启动方式</p>
<p>idea active profiles方式</p>
<p>2.main方法启动方式</p>
<p>在IDEA中的program arguments配置此项–spring.profiles.active=dev命令</p>
<p>3.JVM启动方式</p>
<p>在IDEA中的VM options配置此项-Dspring.profiles.active=dev命令</p>
<h1 id="jar包启动"><a href="#jar包启动" class="headerlink" title="jar包启动"></a>jar包启动</h1><p>1.指定配置环境</p>
<p>nohup java -jar -Dfile.encoding=utf-8 -Dspring.profiles.active=dev example.jar &gt;/dev/null 2&gt;&amp;1 &amp;<br>该启动时方式会去加载Jar包中resource目录下application-dev.yml或application-dev.properties文件。同时需要注意的是通IDEA的启动方式一样。</p>
<p>2.指定配置文件<br>yml文件</p>
<pre><code>nohup java -jar -Dfile.encoding=utf-8 -Dspring.config.location=classpath:/application-dev.yml example.jar &gt;/dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p>properties文件</p>
<pre><code>nohup java -jar -Dfile.encoding=utf-8 -Dspring.config.location=classpath:/application-dev.properties example.jar &gt;/dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p>若配置文件在Jar包外面，-Dspring.config.location=后面不用classpath，直接使用配置文件的相对或绝对路径即可：例如 </p>
<pre><code>-Dspring.config.location=app-dev.yml-Dspring.config.location=/usr/local/soft/config/app-dev.yml
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>新型电力系统行动方案（2021-2030年），国网Vs南网 （一）</title>
    <url>/2023/12/02/%E6%96%B0%E5%9E%8B%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E8%A1%8C%E5%8A%A8%E6%96%B9%E6%A1%88%EF%BC%882021-2030%E5%B9%B4%EF%BC%89%EF%BC%8C%E5%9B%BD%E7%BD%91Vs%E5%8D%97%E7%BD%91%20%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年，国家电网有限公司发布《构建以新能源为主体的新型电力系统行动方案（2021-2030 年）》、中国南方电网有限责任公司发布《建设新型电力系统行动方案（ 2021-2030 年 ）》。</p>
<p>在两个方案中，都提及行动方案制定是“全面落实习近平总书记‘四个革命、一个合作’能源安全新战略，服务国家‘2030年碳达峰、2060年碳中和’目标要求，推动构建以新能源为主体的新型电力系统”等字样。</p>
<p>关于新型电力系统的定义和实现路径</p>
<p>国网认为,电源结构由可控连续出力的煤电装机占主导，向强不确定性、弱可控出力的新能源发电装机占主导转变。负荷特性由传统的刚性、纯消费型，向柔性、生产与消费兼具型转变。电网形态由单向逐级输电为主的传统电网，向包括交直流混联大电网、  微电网、局部直流电网和可调节负荷的能源互联网转变。技术基础由同步发电机为主导的机械电磁系统，向由电力电子设备 和同步机共同主导的混合系统转变。运行特性由源随荷动的实时平衡模式、大电网一体化控制模式，向源网荷储协同互动的非完全实时平衡模式、大电网与微电网协同控制模式转变。</p>
<p>以新能源为主体的新型电力系统承载着能源转型的历史使命，是清洁低碳、安全高效能源体系的重要组成部分，是以新能源为供给主体、以确保能源电力安全为基本前提、以满足经济社会发展电力需求为首要目标，以坚强智能电网为枢纽平台，以源网荷储互动与多能互补为支撑，具有清洁低碳、安全可控、灵活高效、智能友好、开放互动基本特征的电力系统。</p>
<p>南网则提出，建设新型电力系统是应对持续可靠供电、电网安全稳定运行、电网公司运营模式等挑战的必然选择。构建以新能源为主体的新型电力系统，将促进全行业产业链、 价值链上下游紧密协同，推动新能源技术创新发展和产业持续变革，是能源电力行业实现跨越式发展的重大战略机遇。南方电网 公司将牢牢把握建设新型电力系统的重大机遇，立足新发展阶段、 贯彻新发展理念、构建新发展格局，实施创新驱动战略，加快数 字化转型，通过数字技术与公司业务、管理深度融合，全面推动公司战略转型和高质量发展。</p>
<p>建设总体目标</p>
<p>国网预计：</p>
<p>到2035年，基本建成新型电力系统，到2050年全面建成新型电力系统。2021-2035 年是建设期。新能源装机逐步成为第一大电源，常规电源逐步转变为调节性和保障性电源。电力系统总体维持较高转动惯量和交流同步运行特点，交流与直流、大电网与微电 网协调发展。系统储能、需求响应等规模不断扩大，发电机组出力和用电负荷初步实现解耦。</p>
<p>2036-2060年是成熟期。新能源逐步成为电力电量供应主体,火电通过CCUS技术逐步实现净零排放，成为长周期调节电源。分布式电源、微电网、交直流组网与大电网融合发展。系统储能全面应用、负荷全面深入参与调节，发电机组出力和用电负荷逐步实现全面解耦。</p>
<p>为此，国网提出要实现3个方式和3个模式的转变。在公司发展方式上，按照 “一体四翼” 发展布局，由传统电网企业向能源互联网企业转变，积极培育新业务、新业态、新模式，延伸产业链、价值链。在电网发展方式上，由以大电网为主，向大电网、微电网、局部直流电网融合发展转变，推进电网数字化、透明化，满足新能源优先就地消纳和全国优化配置需要。在电源发展方式上，推动新能源发电由以集中式开发为主，向集中式与分布式开发并举转变；推动煤电由支撑性电源向调节性电源转变。在营销服务模式上，由为客户提供单向供电服务，向发供一体、多元用能、多态服务转变，打造 “供电+能效服务”模式，创新构建 “互联网+”现代客户服务模式。在调度运行模式上，由以大电源大电网为主要控制对象、源随荷动的调度模式，向源网荷储协调控制、输配微网多级协同的调度模式转变。在技术创新模式上，由以企业自主开发为主，向跨行业跨领域合作开发转变，技术领域向源网荷储全链条延伸。</p>
<p>南网提出的总体目标是：</p>
<p>2025年前，大力支持新能源接入，具备支撑新能源新增装机1亿千瓦以上的接入消纳能力，初步建立以新能源为主体的源网荷储体系和市场机制，具备新型电力系统基本特征；</p>
<p>2030年前，具备支撑新能源再新增装机1亿千瓦以上的接入消纳能力，推动新能源装机处于主导地位，源网荷储体系和市场 机制趋于完善，基本建成新型电力系统，有力支持南方五省区及 港澳地区全面实现碳达峰；</p>
<p>2060年前，新型电力系统全面建成并不断发展，全面支撑南方五省区及港澳地区碳中和目标实现。</p>
<p>重点任务一：提升清洁能源优化配置和消纳能力</p>
<p>国网在2021-2030年重点任务中，提出：加快特高压电网建设，“十四五”500千伏及以上电网建设投资约7000亿元，2025年华北、华东、华中和西南特高压网架全面建成；提高跨省跨区输送清洁能源力度，到2025年，公司经营区跨省跨区输电能力约3.0亿千瓦，2030年约3.5亿千瓦，输送清洁能源占比达到50%以上；加大配电网建设投入，“十四五”配电网建设投资超过1.2万亿元，占电网建设总投资的60%以上。</p>
<p>南网提出加快新能源接入电网建设。重点推进广东、广西海上风电，云南大滇中地区新能源，贵州黔西、黔西北地区新能源等配套工 程建设；建设“强简有序、灵活可靠、先进适用”的配电网，支 持分布式新能源接入。通过努力，到2025年，具备支撑新能源新增装机1亿千瓦以上的接入消纳能力，非化石能源占比达到60%以上；到2030年，具备支撑新能源再新增装机1亿千瓦以上的接入消纳能力。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>国家电网：构建以新能源为主体的新型电力系统行动方案（2021-2030年）</title>
    <url>/2023/12/01/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%BB%A5%E6%96%B0%E8%83%BD%E6%BA%90%E4%B8%BA%E4%B8%BB%E4%BD%93%E7%9A%84%E6%96%B0%E5%9E%8B%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E8%A1%8C%E5%8A%A8%E6%96%B9%E6%A1%88%EF%BC%882021-2030%20%E5%B9%B4%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为深入贯彻习近平总书记关于碳达峰、碳中和重要讲话和指示精神，按照中央财经委员会第九次会议工作部署，根据国家“十四五”规划和2035年远景目标纲要，国家电网公司研究制定了构建以新能源为主体的新型电力系统行动方案，全力推动实现“双碳”目标。</p>
<p>一、构建新型电力系统的重大意义</p>
<p>2021年3月15日，习近平总书记在中央财经委第九次会议上提出，构建以新能源为主体的新型电力系统。这是自2014年6月总书记提出“四个革命、一个合作”能源安全新战略以来，再次对能源电力发展作出的系统阐述，明确了新型电力系统在实现“双碳”目标中的基础地位，为能源电力发展指明了科学方向、提供了根本遵循。</p>
<p>国家电网公司深入学习贯彻习近平总书记重要指示和中央财经委第九次会议精神，我们深刻认识到，构建以新能源为主体的新型电力系统，是加快生态文明建设的战略选择。我国生态文明建设以降碳为重点战略方向，大力发展风电、太阳能发电等非化石能源，是能源领域降碳的主要途径。是保障国家能源安全的重要举措。能源安全关系国家安全，实现以新能源为供给主体，将大幅降低我国油气对外依存度，显著提高能源安全保障能力。是构建新发展格局的强大动力。以终端用能电气化推动能源利用节能提效，增强绿色发展内生动力，为全面建成社会主义现代化国家提供基础支撑和持续动能。是推动能源产业链转型升级的重要引擎。通过自主创新，集中突破能源电力领域核心和颠覆性技术，摆脱关键技术装备对外依赖，推动能源电力产业全链条自主可控和转型升级。</p>
<p>实现碳达峰、碳中和，能源是主战场，电力是主力军，电网是排头兵。电网连接电力生产和消费，是重要的网络平台，是能源转型的中心环节。国家电网公司将充分发挥“大国重器”和“顶梁柱”作用，自觉肩负起责任使命，在构建以新能源为主体的新型电力系统、推动能源绿色低碳发展中争做引领者、推动者、先行者。</p>
<p>二、新型电力系统特征、内涵和实施路径</p>
<p>随着碳达峰、碳中和进程加快推进，能源生产加速清洁化、能源消费高度电气化、能源配置日趋平台化、能源利用日益高效化。能源格局的深刻调整，必将给电力系统带来深刻变化。</p>
<p>电源结构由可控连续出力的煤电装机占主导，向强不确定性、弱可控出力的新能源发电装机占主导转变。负荷特性由传统的刚性、纯消费型，向柔性、生产与消费兼具型转变。电网形态由单向逐级输电为主的传统电网，向包括交直流混联大电网、微电网、局部直流电网和可调节负荷的能源互联网转变。技术基础由同步发电机为主导的机械电磁系统，向由电力电子设备和同步机共同主导的混合系统转变。运行特性由源随荷动的实时平衡模式、大电网一体化控制模式，向源网荷储协同互动的非完全实时平衡模式、大电网与微电网协同控制模式转变。</p>
<p>以新能源为主体的新型电力系统承载着能源转型的历史使命，是清洁低碳、安全高效能源体系的重要组成部分，是以新能源为供给主体、以确保能源电力安全为基本前提、以满足经济社会发展电力需求为首要目标，以坚强智能电网为枢纽平台，以源网荷储互动与多能互补为支撑，具有清洁低碳、安全可控、灵活高效、智能友好、开放互动基本特征的电力系统。</p>
<p>清洁低碳，形成清洁主导、电为中心的能源供应和消费体系，生产侧实现多元化清洁化低碳化、消费侧实现高效化减量化电气化。安全可控，新能源具备主动支撑能力，分布式、微电网可观可测可控，大电网规模合理、结构坚强，构建安全防御体系，增强系统韧性、弹性和自愈能力。灵活高效，发电侧、负荷侧调节能力强，电网侧资源配置能力强，实现各类能源互通互济、灵活转换，提升整体效率。智能友好，高度数字化、智慧化、网络化，实现对海量分散发供用对象的智能协调控制，实现源网荷储各要素友好协同。开放互动，适应各类新技术、新设备以及多元负荷大规模接入，与电力市场紧密融合，各类市场主体广泛参与、充分竞争、主动响应、双向互动。</p>
<p>按照国家“双碳”目标和电力发展规划，预计到2035年，基本建成新型电力系统，到2050年全面建成新型电力系统。</p>
<p>2021-2035年是建设期。新能源装机逐步成为第一大电源，常规电源逐步转变为调节性和保障性电源。电力系统总体维持较高转动惯量和交流同步运行特点，交流与直流、大电网与微电网协调发展。系统储能、需求响应等规模不断扩大，发电机组出力和用电负荷初步实现解耦。2036-2060年是成熟期。新能源逐步成为电力电量供应主体，火电通过CCUS技术逐步实现净零排放，成为长周期调节电源。分布式电源、微电网、交直流组网与大电网融合发展。系统储能全面应用、负荷全面深入参与调节，发电机组出力和用电负荷逐步实现全面解耦。</p>
<p>构建新型电力系统，是一项极具挑战性、开创性的战略性工程，坚强智能电网是基础，源网荷储协同是关键，推动科技创新是引领，发挥制度优势是保证。国家电网公司将积极面对发展机遇和挑战，贯彻新发展理念，坚持系统观念，转变发展方式，落实国家战略，强化规划引领，统筹计划安排，全力推进构建新型电力系统。</p>
<p>在公司发展方式上，按照“一体四翼”发展布局，由传统电网企业向能源互联网企业转变，积极培育新业务、新业态、新模式，延伸产业链、价值链。在电网发展方式上，由以大电网为主，向大电网、微电网、局部直流电网融合发展转变，推进电网数字化、透明化，满足新能源优先就地消纳和全国优化配置需要。在电源发展方式上，推动新能源发电由以集中式开发为主，向集中式与分布式开发并举转变；推动煤电由支撑性电源向调节性电源转变。</p>
<p>在营销服务模式上，由为客户提供单向供电服务，向发供一体、多元用能、多态服务转变，打造“供电+能效服务”模式，创新构建“互联网+”现代客户服务模式。在调度运行模式上，由以大电源大电网为主要控制对象、源随荷动的调度模式，向源网荷储协调控制、输配微网多级协同的调度模式转变。在技术创新模式上，由以企业自主开发为主，向跨行业跨领域合作开发转变，技术领域向源网荷储全链条延伸。</p>
<p>三、2021-2030年重点任务</p>
<p>（一）加强各级电网协调发展，提升清洁能源优化配置和消纳能力</p>
<p>1.加快特高压电网建设。在受端，扩展和完善华北、华东特高压网架，加快建设华中特高压网架，实现500千伏合理分层分区，构建风光水火资源优化配置平台。在送端，推进西南特高压网架建设，完善西北、东北750/500千伏网架，支撑跨区直流安全高效运行。“十四五”500千伏及以上电网建设投资约7000亿元，2025年华北、华东、华中和西南特高压网架全面建成。</p>
<p>2.提高跨省跨区输送清洁能源力度。“十四五”，将持续提升已建输电通道利用效率，作为电网发展主要内容和重点任务，实现已建通道满功率运行，提升输电能力3527万千瓦。优化已建通道配套电源结构，提高输送清洁能源比重。“十四五”规划建成7回、开工建设一批、研究储备一批特高压直流，新增输电能力5600万千瓦。到2025年，公司经营区跨省跨区输电能力约3.0亿千瓦，2030年约3.5亿千瓦，输送清洁能源占比达到50以上。</p>
<p>3.加大配电网建设投入。加强配电网规划体系建设，全面落实公司新版《配电网规划设计技术导则》，深化应用网格化规划方法，大力推广配电网典型模式、标准接线，提高配电网规划精细度和精准度，适应分布式电源、微电网、多元负荷规模化发展需要。落实国家区域协调发展、乡村振兴和新型城镇化战略，实施农村电网巩固提升工程，推进国际领先城市电网建设，按期完成“煤改电”配套和老旧小区、城中村改造等重点任务。“十四五”配电网建设投资超过1.2万亿元，占电网建设总投资的60以上，2025年城乡供电可靠率分别达到99.97、99.88。</p>
<p>（二）加强电网数字化转型，提升能源互联网发展水平</p>
<p>4.提升配电网智慧化水平。加大中压配电网智能终端部署、配电通信网建设和配电自动化实用化，并向低压配电网延伸，大幅提高可观性可测性可控性。推动应用新型储能、需求侧响应，通过多能互补、源网荷储一体化协调控制技术，提高配电网调节能力和适应能力，促进电力电量分层分级分群平衡。2025年，基本建成安全可靠、绿色智能、灵活互动、经济高效的智慧配电网。</p>
<p>5.打造电网数字化平台。加快信息采集、感知、处理、应用等环节建设，构建连接全社会用户、各环节设备的智慧物联体系，推广人工智能、国网链、北斗等共性平台和创新应用，提高全息感知和泛在互联能力，实现电网、设备、客户状态的动态采集、实时感知和在线监测。加快国网云平台建设，推广网上电网等业务应用，打造数字孪生电网，加快推动电网向能源互联网升级。</p>
<p>6.构建能源互联网生态圈。推动新能源云成为国家级能源云，完善新能源资源优化、碳中和支撑服务、新能源工业互联网、新型电力系统科技创新四大平台。建设能源大数据中心，推动能源数据统一汇聚与共享应用。建设能源工业云网，为产业链上下游企业提供“上云用数赋智”服务。依托电网平台，加大数据共享和价值挖掘，拓展新业务新业态新模式。</p>
<p>（三）加强调节能力建设，提升系统灵活性水平</p>
<p>7.加快建设抽水蓄能电站。落实公司加快抽水蓄能开发建设6项重要举措，推动抽水蓄能电站科学布局，向社会开放抽蓄项目，引导社会资本投资建设，多开多投。加快已开工的4133万千瓦抽水蓄能电站建设，“十四五”新开工2000万千瓦以上抽蓄电站，2025年公司经营区抽水蓄能装机超过5000万千瓦，2030年达到1亿千瓦。</p>
<p>8.全力配合推进火电灵活性改造。推动各省明确改造规模、具体项目、进度安排，2025年力争“三北”地区累计完成2.2亿、东中部地区累计完成1亿千瓦改造任务。推动各省全面启动调峰辅助服务市场建设，尽快建立健全调峰、调频辅助服务机制，调动火电参与灵活性改造和调峰积极性。</p>
<p>9.支持新型储能规模化应用。按照国家政策要求，大力支持电源侧储能建设，积极服务用户侧储能发展，提供技术咨询和并网服务。对符合国家规定的项目优先并网、充分利用。积极推动并参与制定新型储能规划设计、建设安装、并网调试、运行监测等全环节标准体系。2025年，公司经营区新型储能容量超过3000万千瓦，2030年1亿千瓦左右。</p>
<p>10.扩大可调节负荷资源库。开展可调节负荷资源普查。建成27家省级智慧能源服务平台，聚合各类资源，积极参与需求响应市场、辅助服务市场和现货市场。推动各省出台需求响应支持政策和市场机制，通过市场机制合理分配成本和收益。配合政府编制有序用电方案，达到最大负荷20以上且覆盖最大电力缺口。到2025年、2030年，可调节负荷容量分别达到5900万、7000万千瓦。</p>
<p>（四）加强电网调度转型升级，提升驾驭新型电力系统能力</p>
<p>11.构建新型电力系统安全稳定控制体系。攻克新型电力系统基础理论和稳定机理，建设以多时间尺度、平台化、智能化为特征的电网仿真平台，掌握“双高”电力系统运行特性。构建新型电力系统故障防御体系，建设自主可控新一代变电站二次系统，推动安自装置标准化应用，巩固完善“三道防线”。结合IT新技术，建设“人机融合、群智开放、多级协同、自主可控”的新一代调度技术支持系统。</p>
<p>12.建设适应电力绿色低碳转型的平衡控制和新能源调度体系。提高新能源预测精度，推广长周期资源评估和功率预测技术。研究适应分布式新能源大规模接入的负荷预测技术及标准。加强电网统一调度，充分发挥源网荷储各类调节资源作用，保障电力可靠有序供应。2025年，省级电网负荷、新能源、分布式日前预测准确率整体提升至97、90、85以上。</p>
<p>13.建设适应分布式电源发展的新型配电调度体系。建设贯穿国分省地县的分布式电源调度管理系统，构建全景观测、精准控制、主配协同的新型有源配电网调度模式。推广5G+智能电网调控应用，满足海量分布式电源调度通信需求，实现广域源网荷储资源协调控制。研究基于先进通信的配电网保护配置、主动配电网运行分析及协调控制等技术，全面升级配电网二次系统，实现方式灵活调节和故障快速隔离。</p>
<p>（五）加强源网协调发展，提升新能源开发利用水平</p>
<p>14.做好新能源接网服务工作。针对新能源与送出工程建设周期不匹配问题，开辟风电、太阳能发电等新能源配套电网工程建设“绿色通道”，加快接网工程建设，确保电网电源同步投产。深化应用新能源云，为新能源规划、建设、并网、消纳、补贴等全流程业务提供一站式服务，实现全环节工作高效化透明化。到2025年，公司经营区风电、太阳能发电总装机容量将达到8亿千瓦以上，2030年达到12亿千瓦以上。</p>
<p>15.支持分布式新能源和微电网发展。配合政府部门做好分布式电源规划，明确分省、分地市、分县的开发规模。完善公司服务分布式新能源发展指导意见，继续做好一站式全流程免费服务，实现“应并尽并、愿并尽并”。研究微电网功能定位、发展模式、运行机制，完善标准体系，制订典型设计，提供“三零”“三省”并网服务。到2025年，公司经营区分布式新能源装机达到1.8亿千瓦以上，2030年达到3.5亿千瓦以上。</p>
<p>16.不断扩大清洁能源交易规模。“十四五”，推广中长期交易+现货交易+应急调度的新能源消纳模式，开展绿电交易、发电权交易、新能源优先替代等多种形式交易，强化市场协同运营。2025年、2030年，公司经营区新能源发电量占总发电量比例分别超过15、20。</p>
<p>（六）加强全社会节能提效，提升终端消费电气化水平</p>
<p>17.推动低碳节能生产和改造。落实国家能源双控政策，密切跟踪重点省份“两高”企业调整和转移情况，严格用户并网审核，严禁不符合环保要求项目并网，严格执行差别性电价政策。开展“两高”企业用能监测和分析，为政府监管考核提供支撑。全面实施电网节能管理，开展绿色采购和绿色建造。加强六氟化硫气体数字化管控。</p>
<p>18.持续拓展电能替代广度深度。在工业、建筑、交通等领域，大力推进以电代煤、以电代油、以电代气。推动1000吨及以上码头岸电设施全覆盖、长江船舶靠港使用岸电常态化。推动燃煤自备电厂清洁替代，科学稳妥推进北方“煤改电”清洁取暖。做好充换电网络布局规划，形成高效、稳定、可持续的车网互动业务模式和市场运作机制。2021-2030年，累计替代电量超过1万亿千瓦时。</p>
<p>19.开展综合能源服务。聚焦公共建筑、工业企业和农业农村等领域，积极拓展综合能源实体项目和增值服务。以能效提升、分布式新能源开发利用为重点，开展楼宇建筑能源托管、供冷供暖、智能运维等业务。依托省级智慧能源服务平台，定期向客户推送用电能效账单、综合能效诊断报告。“十四五”，力争实现10千伏及以上高压供电客户能效服务能力全覆盖。</p>
<p>（七）加强能源电力技术创新，提升运行安全和效率水平</p>
<p>20.实施科技攻关行动计划。制定并加快实施“新型电力系统科技攻关行动计划”，以“三加强”（加强源网荷储协同发展、绿色低碳市场体系构建、电力系统可观可测可控能力建设）、“三提升”（提升新能源发电主动支撑、系统安全稳定运行、终端互动调节）为攻关方向，统筹推进基础理论研究、关键技术攻关、标准研制、成果应用和工程示范。联合能源电力行业上下游高校院所、企业协同攻关，深化产研用协同，打造开放共享创新平台。2021-2030年，安排研发经费投入3000亿元以上。</p>
<p>21.加快关键技术攻关。重点突破新能源发电主动支撑、智能调度运行控制、市场运营协同、多能互补运行等技术，开展多尺度电力电量平衡、源网荷储协调规划等理论研究，推进大容量电化学储能、需求侧互动响应、柔性输电等技术进步和规模化应用，试验示范直流组网、氢能绿色制取与高效利用、超导输电等技术。</p>
<p>22.开展关键装备和标准研制。制定国家电网技术成熟度评价体系，遴选出一批前景广阔、成熟度高的新技术新产品，加快推广应用。编制“新型电力系统技术标准体系框架”，重点开展新型电力系统构建及运行控制、分布式新能源及微电网、新能源和储能并网、需求响应等标准制订。超前布局标准国际化方向。</p>
<p>23.推进新型电力系统示范区建设。选择西藏藏中、新疆南疆、河北张家口作为地区级示范区，重点研究送端高比例新能源电力系统构建方案，推广“新能源+储能+调相机”发展模式。选择福建、浙江、青海作为省级示范区，重点研究送受端大电网与分布式、微电网融合发展方案，以及适应新能源发展的政策和市场机制。</p>
<p>（八）加强配套政策机制建设，提升支撑和保障能力</p>
<p>24.推动健全电力价格形成机制。研究新型电力系统构建新增成本和疏导问题，配合政府部门健全价格体系，按照“谁受益、谁承担”原则，由各市场主体共同承担转型成本。通过输配电价合理疏导电网建设运营成本，还原电力商品价值属性。研究碳价体系，计算其他行业向电力行业转移的减碳成本，推动建立向受益行业合理分摊传导电力系统成本的机制。</p>
<p>25.推进全国统一电力市场建设。加快推动建设竞争充分、开放有序的统一电力市场，在全国范围优化配置清洁能源。完善中长期、现货和辅助服务衔接机制，探索容量市场交易机制，开展绿色电力交易，推动可再生能源参与电力市场。研究电力市场和碳市场协同机制、碳价格与电价联动机制。建立公司碳管理体系，促进绿色低碳产业发展，拓展碳金融、绿色金融业务。2030年，初步建成适应新能源为主体的全国统一电力市场。</p>
<p>26.构建能源电力安全预警体系。预判重点行业用电需求增长，滚动分析未来2年电力供需和电网安全形势，及时向政府部门汇报和预警。推动建立政府、企业和社会各负其责的燃料供应储备体系，确保极端情景下电力供应。开展客户安全在线诊断，完善重要输电通道、关键信息基础设施安全预案，强化市场运营风险管控，建设全场景网络安全防护体系。</p>
<p>（九）加强组织领导和交流合作，提升全行业发展凝聚力</p>
<p>27.强化工作组织落实责任。充分发挥公司碳达峰、碳中和领导小组统筹协调作用，充实领导小组办公室力量，建立一体谋划、一体部署、一体推进、一体考核的协同工作机制，实现全公司“一盘棋”。各部门、各机构、各单位细化分解工作任务，落实责任分工，全力推进各项工作。</p>
<p>28.深化宣传引导与开放合作。加强信息公开和对外宣传，积极与政府机构、行业协会、科研院所、产业链上下游企业研讨交流，集思广益、群策群力、凝聚共识、形成合力，推动新型电力系统高质量发展。</p>
<p><a href="http://mm.chinapower.com.cn/xw/zyxw/20210728/90959.html">http://mm.chinapower.com.cn/xw/zyxw/20210728/90959.html</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>国务院关于印发2030年前碳达峰行动方案的通知</title>
    <url>/2023/11/30/%E5%9B%BD%E5%8A%A1%E9%99%A2%E5%85%B3%E4%BA%8E%E5%8D%B0%E5%8F%912030%E5%B9%B4%E5%89%8D%E7%A2%B3%E8%BE%BE%E5%B3%B0%E8%A1%8C%E5%8A%A8%E6%96%B9%E6%A1%88%E7%9A%84%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>国务院关于印发2030年前碳达峰</p>
<p>行动方案的通知</p>
<p>国发〔2021〕23号</p>
<p>各省、自治区、直辖市人民政府，国务院各部委、各直属机构：</p>
<p>现将《2030年前碳达峰行动方案》印发给你们，请认真贯彻执行。</p>
<p>国务院</p>
<p>2021年10月24日</p>
<p>（本文有删减）</p>
<p>2030年前碳达峰行动方案</p>
<p>为深入贯彻落实党中央、国务院关于碳达峰、碳中和的重大战略决策，扎实推进碳达峰行动，制定本方案。</p>
<p>一、总体要求</p>
<p>（一）指导思想。以习近平新时代中国特色社会主义思想为指导，全面贯彻党的十九大和十九届二中、三中、四中、五中全会精神，深入贯彻习近平生态文明思想，立足新发展阶段，完整、准确、全面贯彻新发展理念，构建新发展格局，坚持系统观念，处理好发展和减排、整体和局部、短期和中长期的关系，统筹稳增长和调结构，把碳达峰、碳中和纳入经济社会发展全局，坚持“全国统筹、节约优先、双轮驱动、内外畅通、防范风险”的总方针，有力有序有效做好碳达峰工作，明确各地区、各领域、各行业目标任务，加快实现生产生活方式绿色变革，推动经济社会发展建立在资源高效利用和绿色低碳发展的基础之上，确保如期实现2030年前碳达峰目标。</p>
<p>（二）工作原则。</p>
<p>——总体部署、分类施策。坚持全国一盘棋，强化顶层设计和各方统筹。各地区、各领域、各行业因地制宜、分类施策，明确既符合自身实际又满足总体要求的目标任务。</p>
<p>——系统推进、重点突破。全面准确认识碳达峰行动对经济社会发展的深远影响，加强政策的系统性、协同性。抓住主要矛盾和矛盾的主要方面，推动重点领域、重点行业和有条件的地方率先达峰。</p>
<p>——双轮驱动、两手发力。更好发挥政府作用，构建新型举国体制，充分发挥市场机制作用，大力推进绿色低碳科技创新，深化能源和相关领域改革，形成有效激励约束机制。</p>
<p>——稳妥有序、安全降碳。立足我国富煤贫油少气的能源资源禀赋，坚持先立后破，稳住存量，拓展增量，以保障国家能源安全和经济发展为底线，争取时间实现新能源的逐渐替代，推动能源低碳转型平稳过渡，切实保障国家能源安全、产业链供应链安全、粮食安全和群众正常生产生活，着力化解各类风险隐患，防止过度反应，稳妥有序、循序渐进推进碳达峰行动，确保安全降碳。</p>
<p>二、主要目标</p>
<p>“十四五”期间，产业结构和能源结构调整优化取得明显进展，重点行业能源利用效率大幅提升，煤炭消费增长得到严格控制，新型电力系统加快构建，绿色低碳技术研发和推广应用取得新进展，绿色生产生活方式得到普遍推行，有利于绿色低碳循环发展的政策体系进一步完善。到2025年，非化石能源消费比重达到20%左右，单位国内生产总值能源消耗比2020年下降13.5%，单位国内生产总值二氧化碳排放比2020年下降18%，为实现碳达峰奠定坚实基础。</p>
<p>“十五五”期间，产业结构调整取得重大进展，清洁低碳安全高效的能源体系初步建立，重点领域低碳发展模式基本形成，重点耗能行业能源利用效率达到国际先进水平，非化石能源消费比重进一步提高，煤炭消费逐步减少，绿色低碳技术取得关键突破，绿色生活方式成为公众自觉选择，绿色低碳循环发展政策体系基本健全。到2030年，非化石能源消费比重达到25%左右，单位国内生产总值二氧化碳排放比2005年下降65%以上，顺利实现2030年前碳达峰目标。</p>
<p>三、重点任务</p>
<p>将碳达峰贯穿于经济社会发展全过程和各方面，重点实施能源绿色低碳转型行动、节能降碳增效行动、工业领域碳达峰行动、城乡建设碳达峰行动、交通运输绿色低碳行动、循环经济助力降碳行动、绿色低碳科技创新行动、碳汇能力巩固提升行动、绿色低碳全民行动、各地区梯次有序碳达峰行动等“碳达峰十大行动”。</p>
<p>（一）能源绿色低碳转型行动。</p>
<p>能源是经济社会发展的重要物质基础，也是碳排放的最主要来源。要坚持安全降碳，在保障能源安全的前提下，大力实施可再生能源替代，加快构建清洁低碳安全高效的能源体系。</p>
<p>1．推进煤炭消费替代和转型升级。加快煤炭减量步伐，“十四五”时期严格合理控制煤炭消费增长，“十五五”时期逐步减少。严格控制新增煤电项目，新建机组煤耗标准达到国际先进水平，有序淘汰煤电落后产能，加快现役机组节能升级和灵活性改造，积极推进供热改造，推动煤电向基础保障性和系统调节性电源并重转型。严控跨区外送可再生能源电力配套煤电规模，新建通道可再生能源电量比例原则上不低于50%。推动重点用煤行业减煤限煤。大力推动煤炭清洁利用，合理划定禁止散烧区域，多措并举、积极有序推进散煤替代，逐步减少直至禁止煤炭散烧。</p>
<p>2．大力发展新能源。全面推进风电、太阳能发电大规模开发和高质量发展，坚持集中式与分布式并举，加快建设风电和光伏发电基地。加快智能光伏产业创新升级和特色应用，创新“光伏+”模式，推进光伏发电多元布局。坚持陆海并重，推动风电协调快速发展，完善海上风电产业链，鼓励建设海上风电基地。积极发展太阳能光热发电，推动建立光热发电与光伏发电、风电互补调节的风光热综合可再生能源发电基地。因地制宜发展生物质发电、生物质能清洁供暖和生物天然气。探索深化地热能以及波浪能、潮流能、温差能等海洋新能源开发利用。进一步完善可再生能源电力消纳保障机制。到2030年，风电、太阳能发电总装机容量达到12亿千瓦以上。</p>
<p>3．因地制宜开发水电。积极推进水电基地建设，推动金沙江上游、澜沧江上游、雅砻江中游、黄河上游等已纳入规划、符合生态保护要求的水电项目开工建设，推进雅鲁藏布江下游水电开发，推动小水电绿色发展。推动西南地区水电与风电、太阳能发电协同互补。统筹水电开发和生态保护，探索建立水能资源开发生态保护补偿机制。“十四五”、“十五五”期间分别新增水电装机容量4000万千瓦左右，西南地区以水电为主的可再生能源体系基本建立。</p>
<p>4．积极安全有序发展核电。合理确定核电站布局和开发时序，在确保安全的前提下有序发展核电，保持平稳建设节奏。积极推动高温气冷堆、快堆、模块化小型堆、海上浮动堆等先进堆型示范工程，开展核能综合利用示范。加大核电标准化、自主化力度，加快关键技术装备攻关，培育高端核电装备制造产业集群。实行最严格的安全标准和最严格的监管，持续提升核安全监管能力。</p>
<p>5．合理调控油气消费。保持石油消费处于合理区间，逐步调整汽油消费规模，大力推进先进生物液体燃料、可持续航空燃料等替代传统燃油，提升终端燃油产品能效。加快推进页岩气、煤层气、致密油（气）等非常规油气资源规模化开发。有序引导天然气消费，优化利用结构，优先保障民生用气，大力推动天然气与多种能源融合发展，因地制宜建设天然气调峰电站，合理引导工业用气和化工原料用气。支持车船使用液化天然气作为燃料。</p>
<p>6．加快建设新型电力系统。构建新能源占比逐渐提高的新型电力系统，推动清洁电力资源大范围优化配置。大力提升电力系统综合调节能力，加快灵活调节电源建设，引导自备电厂、传统高载能工业负荷、工商业可中断负荷、电动汽车充电网络、虚拟电厂等参与系统调节，建设坚强智能电网，提升电网安全保障水平。积极发展“新能源+储能”、源网荷储一体化和多能互补，支持分布式新能源合理配置储能系统。制定新一轮抽水蓄能电站中长期发展规划，完善促进抽水蓄能发展的政策机制。加快新型储能示范推广应用。深化电力体制改革，加快构建全国统一电力市场体系。到2025年，新型储能装机容量达到3000万千瓦以上。到2030年，抽水蓄能电站装机容量达到1.2亿千瓦左右，省级电网基本具备5%以上的尖峰负荷响应能力。</p>
<p>（二）节能降碳增效行动。</p>
<p>落实节约优先方针，完善能源消费强度和总量双控制度，严格控制能耗强度，合理控制能源消费总量，推动能源消费革命，建设能源节约型社会。</p>
<p>1．全面提升节能管理能力。推行用能预算管理，强化固定资产投资项目节能审查，对项目用能和碳排放情况进行综合评价，从源头推进节能降碳。提高节能管理信息化水平，完善重点用能单位能耗在线监测系统，建立全国性、行业性节能技术推广服务平台，推动高耗能企业建立能源管理中心。完善能源计量体系，鼓励采用认证手段提升节能管理水平。加强节能监察能力建设，健全省、市、县三级节能监察体系，建立跨部门联动机制，综合运用行政处罚、信用监管、绿色电价等手段，增强节能监察约束力。</p>
<p>2．实施节能降碳重点工程。实施城市节能降碳工程，开展建筑、交通、照明、供热等基础设施节能升级改造，推进先进绿色建筑技术示范应用，推动城市综合能效提升。实施园区节能降碳工程，以高耗能高排放项目（以下称“两高”项目）集聚度高的园区为重点，推动能源系统优化和梯级利用，打造一批达到国际先进水平的节能低碳园区。实施重点行业节能降碳工程，推动电力、钢铁、有色金属、建材、石化化工等行业开展节能降碳改造，提升能源资源利用效率。实施重大节能降碳技术示范工程，支持已取得突破的绿色低碳关键技术开展产业化示范应用。</p>
<p>3．推进重点用能设备节能增效。以电机、风机、泵、压缩机、变压器、换热器、工业锅炉等设备为重点，全面提升能效标准。建立以能效为导向的激励约束机制，推广先进高效产品设备，加快淘汰落后低效设备。加强重点用能设备节能审查和日常监管，强化生产、经营、销售、使用、报废全链条管理，严厉打击违法违规行为，确保能效标准和节能要求全面落实。</p>
<p>4．加强新型基础设施节能降碳。优化新型基础设施空间布局，统筹谋划、科学配置数据中心等新型基础设施，避免低水平重复建设。优化新型基础设施用能结构，采用直流供电、分布式储能、“光伏+储能”等模式，探索多样化能源供应，提高非化石能源消费比重。对标国际先进水平，加快完善通信、运算、存储、传输等设备能效标准，提升准入门槛，淘汰落后设备和技术。加强新型基础设施用能管理，将年综合能耗超过1万吨标准煤的数据中心全部纳入重点用能单位能耗在线监测系统，开展能源计量审查。推动既有设施绿色升级改造，积极推广使用高效制冷、先进通风、余热利用、智能化用能控制等技术，提高设施能效水平。</p>
<p>（三）工业领域碳达峰行动。</p>
<p>工业是产生碳排放的主要领域之一，对全国整体实现碳达峰具有重要影响。工业领域要加快绿色低碳转型和高质量发展，力争率先实现碳达峰。</p>
<p>1．推动工业领域绿色低碳发展。优化产业结构，加快退出落后产能，大力发展战略性新兴产业，加快传统产业绿色低碳改造。促进工业能源消费低碳化，推动化石能源清洁高效利用，提高可再生能源应用比重，加强电力需求侧管理，提升工业电气化水平。深入实施绿色制造工程，大力推行绿色设计，完善绿色制造体系，建设绿色工厂和绿色工业园区。推进工业领域数字化智能化绿色化融合发展，加强重点行业和领域技术改造。</p>
<p>2．推动钢铁行业碳达峰。深化钢铁行业供给侧结构性改革，严格执行产能置换，严禁新增产能，推进存量优化，淘汰落后产能。推进钢铁企业跨地区、跨所有制兼并重组，提高行业集中度。优化生产力布局，以京津冀及周边地区为重点，继续压减钢铁产能。促进钢铁行业结构优化和清洁能源替代，大力推进非高炉炼铁技术示范，提升废钢资源回收利用水平，推行全废钢电炉工艺。推广先进适用技术，深挖节能降碳潜力，鼓励钢化联产，探索开展氢冶金、二氧化碳捕集利用一体化等试点示范，推动低品位余热供暖发展。</p>
<p>3．推动有色金属行业碳达峰。巩固化解电解铝过剩产能成果，严格执行产能置换，严控新增产能。推进清洁能源替代，提高水电、风电、太阳能发电等应用比重。加快再生有色金属产业发展，完善废弃有色金属资源回收、分选和加工网络，提高再生有色金属产量。加快推广应用先进适用绿色低碳技术，提升有色金属生产过程余热回收水平，推动单位产品能耗持续下降。</p>
<p>4．推动建材行业碳达峰。加强产能置换监管，加快低效产能退出，严禁新增水泥熟料、平板玻璃产能，引导建材行业向轻型化、集约化、制品化转型。推动水泥错峰生产常态化，合理缩短水泥熟料装置运转时间。因地制宜利用风能、太阳能等可再生能源，逐步提高电力、天然气应用比重。鼓励建材企业使用粉煤灰、工业废渣、尾矿渣等作为原料或水泥混合材。加快推进绿色建材产品认证和应用推广，加强新型胶凝材料、低碳混凝土、木竹建材等低碳建材产品研发应用。推广节能技术设备，开展能源管理体系建设，实现节能增效。</p>
<p>5．推动石化化工行业碳达峰。优化产能规模和布局，加大落后产能淘汰力度，有效化解结构性过剩矛盾。严格项目准入，合理安排建设时序，严控新增炼油和传统煤化工生产能力，稳妥有序发展现代煤化工。引导企业转变用能方式，鼓励以电力、天然气等替代煤炭。调整原料结构，控制新增原料用煤，拓展富氢原料进口来源，推动石化化工原料轻质化。优化产品结构，促进石化化工与煤炭开采、冶金、建材、化纤等产业协同发展，加强炼厂干气、液化气等副产气体高效利用。鼓励企业节能升级改造，推动能量梯级利用、物料循环利用。到2025年，国内原油一次加工能力控制在10亿吨以内，主要产品产能利用率提升至80%以上。</p>
<p>6．坚决遏制“两高”项目盲目发展。采取强有力措施，对“两高”项目实行清单管理、分类处置、动态监控。全面排查在建项目，对能效水平低于本行业能耗限额准入值的，按有关规定停工整改，推动能效水平应提尽提，力争全面达到国内乃至国际先进水平。科学评估拟建项目，对产能已饱和的行业，按照“减量替代”原则压减产能；对产能尚未饱和的行业，按照国家布局和审批备案等要求，对标国际先进水平提高准入门槛；对能耗量较大的新兴产业，支持引导企业应用绿色低碳技术，提高能效水平。深入挖潜存量项目，加快淘汰落后产能，通过改造升级挖掘节能减排潜力。强化常态化监管，坚决拿下不符合要求的“两高”项目。</p>
<p>（四）城乡建设碳达峰行动。</p>
<p>加快推进城乡建设绿色低碳发展，城市更新和乡村振兴都要落实绿色低碳要求。</p>
<p>1．推进城乡建设绿色低碳转型。推动城市组团式发展，科学确定建设规模，控制新增建设用地过快增长。倡导绿色低碳规划设计理念，增强城乡气候韧性，建设海绵城市。推广绿色低碳建材和绿色建造方式，加快推进新型建筑工业化，大力发展装配式建筑，推广钢结构住宅，推动建材循环利用，强化绿色设计和绿色施工管理。加强县城绿色低碳建设。推动建立以绿色低碳为导向的城乡规划建设管理机制，制定建筑拆除管理办法，杜绝大拆大建。建设绿色城镇、绿色社区。</p>
<p>2．加快提升建筑能效水平。加快更新建筑节能、市政基础设施等标准，提高节能降碳要求。加强适用于不同气候区、不同建筑类型的节能低碳技术研发和推广，推动超低能耗建筑、低碳建筑规模化发展。加快推进居住建筑和公共建筑节能改造，持续推动老旧供热管网等市政基础设施节能降碳改造。提升城镇建筑和基础设施运行管理智能化水平，加快推广供热计量收费和合同能源管理，逐步开展公共建筑能耗限额管理。到2025年，城镇新建建筑全面执行绿色建筑标准。</p>
<p>3．加快优化建筑用能结构。深化可再生能源建筑应用，推广光伏发电与建筑一体化应用。积极推动严寒、寒冷地区清洁取暖，推进热电联产集中供暖，加快工业余热供暖规模化应用，积极稳妥开展核能供热示范，因地制宜推行热泵、生物质能、地热能、太阳能等清洁低碳供暖。引导夏热冬冷地区科学取暖，因地制宜采用清洁高效取暖方式。提高建筑终端电气化水平，建设集光伏发电、储能、直流配电、柔性用电于一体的“光储直柔”建筑。到2025年，城镇建筑可再生能源替代率达到8%，新建公共机构建筑、新建厂房屋顶光伏覆盖率力争达到50%。</p>
<p>4．推进农村建设和用能低碳转型。推进绿色农房建设，加快农房节能改造。持续推进农村地区清洁取暖，因地制宜选择适宜取暖方式。发展节能低碳农业大棚。推广节能环保灶具、电动农用车辆、节能环保农机和渔船。加快生物质能、太阳能等可再生能源在农业生产和农村生活中的应用。加强农村电网建设，提升农村用能电气化水平。</p>
<p>（五）交通运输绿色低碳行动。</p>
<p>加快形成绿色低碳运输方式，确保交通运输领域碳排放增长保持在合理区间。</p>
<p>1．推动运输工具装备低碳转型。积极扩大电力、氢能、天然气、先进生物液体燃料等新能源、清洁能源在交通运输领域应用。大力推广新能源汽车，逐步降低传统燃油汽车在新车产销和汽车保有量中的占比，推动城市公共服务车辆电动化替代，推广电力、氢燃料、液化天然气动力重型货运车辆。提升铁路系统电气化水平。加快老旧船舶更新改造，发展电动、液化天然气动力船舶，深入推进船舶靠港使用岸电，因地制宜开展沿海、内河绿色智能船舶示范应用。提升机场运行电动化智能化水平，发展新能源航空器。到2030年，当年新增新能源、清洁能源动力的交通工具比例达到40%左右，营运交通工具单位换算周转量碳排放强度比2020年下降9.5%左右，国家铁路单位换算周转量综合能耗比2020年下降10%。陆路交通运输石油消费力争2030年前达到峰值。</p>
<p>2．构建绿色高效交通运输体系。发展智能交通，推动不同运输方式合理分工、有效衔接，降低空载率和不合理客货运周转量。大力发展以铁路、水路为骨干的多式联运，推进工矿企业、港口、物流园区等铁路专用线建设，加快内河高等级航道网建设，加快大宗货物和中长距离货物运输“公转铁”、“公转水”。加快先进适用技术应用，提升民航运行管理效率，引导航空企业加强智慧运行，实现系统化节能降碳。加快城乡物流配送体系建设，创新绿色低碳、集约高效的配送模式。打造高效衔接、快捷舒适的公共交通服务体系，积极引导公众选择绿色低碳交通方式。“十四五”期间，集装箱铁水联运量年均增长15%以上。到2030年，城区常住人口100万以上的城市绿色出行比例不低于70%。</p>
<p>3．加快绿色交通基础设施建设。将绿色低碳理念贯穿于交通基础设施规划、建设、运营和维护全过程，降低全生命周期能耗和碳排放。开展交通基础设施绿色化提升改造，统筹利用综合运输通道线位、土地、空域等资源，加大岸线、锚地等资源整合力度，提高利用效率。有序推进充电桩、配套电网、加注（气）站、加氢站等基础设施建设，提升城市公共交通基础设施水平。到2030年，民用运输机场场内车辆装备等力争全面实现电动化。</p>
<p>（六）循环经济助力降碳行动。</p>
<p>抓住资源利用这个源头，大力发展循环经济，全面提高资源利用效率，充分发挥减少资源消耗和降碳的协同作用。</p>
<p>1．推进产业园区循环化发展。以提升资源产出率和循环利用率为目标，优化园区空间布局，开展园区循环化改造。推动园区企业循环式生产、产业循环式组合，组织企业实施清洁生产改造，促进废物综合利用、能量梯级利用、水资源循环利用，推进工业余压余热、废气废液废渣资源化利用，积极推广集中供气供热。搭建基础设施和公共服务共享平台，加强园区物质流管理。到2030年，省级以上重点产业园区全部实施循环化改造。</p>
<p>2．加强大宗固废综合利用。提高矿产资源综合开发利用水平和综合利用率，以煤矸石、粉煤灰、尾矿、共伴生矿、冶炼渣、工业副产石膏、建筑垃圾、农作物秸秆等大宗固废为重点，支持大掺量、规模化、高值化利用，鼓励应用于替代原生非金属矿、砂石等资源。在确保安全环保前提下，探索将磷石膏应用于土壤改良、井下充填、路基修筑等。推动建筑垃圾资源化利用，推广废弃路面材料原地再生利用。加快推进秸秆高值化利用，完善收储运体系，严格禁烧管控。加快大宗固废综合利用示范建设。到2025年，大宗固废年利用量达到40亿吨左右；到2030年，年利用量达到45亿吨左右。</p>
<p>3．健全资源循环利用体系。完善废旧物资回收网络，推行“互联网+”回收模式，实现再生资源应收尽收。加强再生资源综合利用行业规范管理，促进产业集聚发展。高水平建设现代化“城市矿产”基地，推动再生资源规范化、规模化、清洁化利用。推进退役动力电池、光伏组件、风电机组叶片等新兴产业废物循环利用。促进汽车零部件、工程机械、文办设备等再制造产业高质量发展。加强资源再生产品和再制造产品推广应用。到2025年，废钢铁、废铜、废铝、废铅、废锌、废纸、废塑料、废橡胶、废玻璃等9种主要再生资源循环利用量达到4.5亿吨，到2030年达到5.1亿吨。</p>
<p>4．大力推进生活垃圾减量化资源化。扎实推进生活垃圾分类，加快建立覆盖全社会的生活垃圾收运处置体系，全面实现分类投放、分类收集、分类运输、分类处理。加强塑料污染全链条治理，整治过度包装，推动生活垃圾源头减量。推进生活垃圾焚烧处理，降低填埋比例，探索适合我国厨余垃圾特性的资源化利用技术。推进污水资源化利用。到2025年，城市生活垃圾分类体系基本健全，生活垃圾资源化利用比例提升至60%左右。到2030年，城市生活垃圾分类实现全覆盖，生活垃圾资源化利用比例提升至65%。</p>
<p>（七）绿色低碳科技创新行动。</p>
<p>发挥科技创新的支撑引领作用，完善科技创新体制机制，强化创新能力，加快绿色低碳科技革命。</p>
<p>1．完善创新体制机制。制定科技支撑碳达峰碳中和行动方案，在国家重点研发计划中设立碳达峰碳中和关键技术研究与示范等重点专项，采取“揭榜挂帅”机制，开展低碳零碳负碳关键核心技术攻关。将绿色低碳技术创新成果纳入高等学校、科研单位、国有企业有关绩效考核。强化企业创新主体地位，支持企业承担国家绿色低碳重大科技项目，鼓励设施、数据等资源开放共享。推进国家绿色技术交易中心建设，加快创新成果转化。加强绿色低碳技术和产品知识产权保护。完善绿色低碳技术和产品检测、评估、认证体系。</p>
<p>2．加强创新能力建设和人才培养。组建碳达峰碳中和相关国家实验室、国家重点实验室和国家技术创新中心，适度超前布局国家重大科技基础设施，引导企业、高等学校、科研单位共建一批国家绿色低碳产业创新中心。创新人才培养模式，鼓励高等学校加快新能源、储能、氢能、碳减排、碳汇、碳排放权交易等学科建设和人才培养，建设一批绿色低碳领域未来技术学院、现代产业学院和示范性能源学院。深化产教融合，鼓励校企联合开展产学合作协同育人项目，组建碳达峰碳中和产教融合发展联盟，建设一批国家储能技术产教融合创新平台。</p>
<p>3．强化应用基础研究。实施一批具有前瞻性、战略性的国家重大前沿科技项目，推动低碳零碳负碳技术装备研发取得突破性进展。聚焦化石能源绿色智能开发和清洁低碳利用、可再生能源大规模利用、新型电力系统、节能、氢能、储能、动力电池、二氧化碳捕集利用与封存等重点，深化应用基础研究。积极研发先进核电技术，加强可控核聚变等前沿颠覆性技术研究。</p>
<p>4．加快先进适用技术研发和推广应用。集中力量开展复杂大电网安全稳定运行和控制、大容量风电、高效光伏、大功率液化天然气发动机、大容量储能、低成本可再生能源制氢、低成本二氧化碳捕集利用与封存等技术创新，加快碳纤维、气凝胶、特种钢材等基础材料研发，补齐关键零部件、元器件、软件等短板。推广先进成熟绿色低碳技术，开展示范应用。建设全流程、集成化、规模化二氧化碳捕集利用与封存示范项目。推进熔盐储能供热和发电示范应用。加快氢能技术研发和示范应用，探索在工业、交通运输、建筑等领域规模化应用。</p>
<p>（八）碳汇能力巩固提升行动。</p>
<p>坚持系统观念，推进山水林田湖草沙一体化保护和修复，提高生态系统质量和稳定性，提升生态系统碳汇增量。</p>
<p>1．巩固生态系统固碳作用。结合国土空间规划编制和实施，构建有利于碳达峰、碳中和的国土空间开发保护格局。严守生态保护红线，严控生态空间占用，建立以国家公园为主体的自然保护地体系，稳定现有森林、草原、湿地、海洋、土壤、冻土、岩溶等固碳作用。严格执行土地使用标准，加强节约集约用地评价，推广节地技术和节地模式。</p>
<p>2．提升生态系统碳汇能力。实施生态保护修复重大工程。深入推进大规模国土绿化行动，巩固退耕还林还草成果，扩大林草资源总量。强化森林资源保护，实施森林质量精准提升工程，提高森林质量和稳定性。加强草原生态保护修复，提高草原综合植被盖度。加强河湖、湿地保护修复。整体推进海洋生态系统保护和修复，提升红树林、海草床、盐沼等固碳能力。加强退化土地修复治理，开展荒漠化、石漠化、水土流失综合治理，实施历史遗留矿山生态修复工程。到2030年，全国森林覆盖率达到25%左右，森林蓄积量达到190亿立方米。</p>
<p>3．加强生态系统碳汇基础支撑。依托和拓展自然资源调查监测体系，利用好国家林草生态综合监测评价成果，建立生态系统碳汇监测核算体系，开展森林、草原、湿地、海洋、土壤、冻土、岩溶等碳汇本底调查、碳储量评估、潜力分析，实施生态保护修复碳汇成效监测评估。加强陆地和海洋生态系统碳汇基础理论、基础方法、前沿颠覆性技术研究。建立健全能够体现碳汇价值的生态保护补偿机制，研究制定碳汇项目参与全国碳排放权交易相关规则。</p>
<p>4．推进农业农村减排固碳。大力发展绿色低碳循环农业，推进农光互补、“光伏+设施农业”、“海上风电+海洋牧场”等低碳农业模式。研发应用增汇型农业技术。开展耕地质量提升行动，实施国家黑土地保护工程，提升土壤有机碳储量。合理控制化肥、农药、地膜使用量，实施化肥农药减量替代计划，加强农作物秸秆综合利用和畜禽粪污资源化利用。</p>
<p>（九）绿色低碳全民行动。</p>
<p>增强全民节约意识、环保意识、生态意识，倡导简约适度、绿色低碳、文明健康的生活方式，把绿色理念转化为全体人民的自觉行动。</p>
<p>1．加强生态文明宣传教育。将生态文明教育纳入国民教育体系，开展多种形式的资源环境国情教育，普及碳达峰、碳中和基础知识。加强对公众的生态文明科普教育，将绿色低碳理念有机融入文艺作品，制作文创产品和公益广告，持续开展世界地球日、世界环境日、全国节能宣传周、全国低碳日等主题宣传活动，增强社会公众绿色低碳意识，推动生态文明理念更加深入人心。</p>
<p>2．推广绿色低碳生活方式。坚决遏制奢侈浪费和不合理消费，着力破除奢靡铺张的歪风陋习，坚决制止餐饮浪费行为。在全社会倡导节约用能，开展绿色低碳社会行动示范创建，深入推进绿色生活创建行动，评选宣传一批优秀示范典型，营造绿色低碳生活新风尚。大力发展绿色消费，推广绿色低碳产品，完善绿色产品认证与标识制度。提升绿色产品在政府采购中的比例。</p>
<p>3．引导企业履行社会责任。引导企业主动适应绿色低碳发展要求，强化环境责任意识，加强能源资源节约，提升绿色创新水平。重点领域国有企业特别是中央企业要制定实施企业碳达峰行动方案，发挥示范引领作用。重点用能单位要梳理核算自身碳排放情况，深入研究碳减排路径，“一企一策”制定专项工作方案，推进节能降碳。相关上市公司和发债企业要按照环境信息依法披露要求，定期公布企业碳排放信息。充分发挥行业协会等社会团体作用，督促企业自觉履行社会责任。</p>
<p>4．强化领导干部培训。将学习贯彻习近平生态文明思想作为干部教育培训的重要内容，各级党校（行政学院）要把碳达峰、碳中和相关内容列入教学计划，分阶段、多层次对各级领导干部开展培训，普及科学知识，宣讲政策要点，强化法治意识，深化各级领导干部对碳达峰、碳中和工作重要性、紧迫性、科学性、系统性的认识。从事绿色低碳发展相关工作的领导干部要尽快提升专业素养和业务能力，切实增强推动绿色低碳发展的本领。</p>
<p>（十）各地区梯次有序碳达峰行动。</p>
<p>各地区要准确把握自身发展定位，结合本地区经济社会发展实际和资源环境禀赋，坚持分类施策、因地制宜、上下联动，梯次有序推进碳达峰。</p>
<p>1．科学合理确定有序达峰目标。碳排放已经基本稳定的地区要巩固减排成果，在率先实现碳达峰的基础上进一步降低碳排放。产业结构较轻、能源结构较优的地区要坚持绿色低碳发展，坚决不走依靠“两高”项目拉动经济增长的老路，力争率先实现碳达峰。产业结构偏重、能源结构偏煤的地区和资源型地区要把节能降碳摆在突出位置，大力优化调整产业结构和能源结构，逐步实现碳排放增长与经济增长脱钩，力争与全国同步实现碳达峰。</p>
<p>2．因地制宜推进绿色低碳发展。各地区要结合区域重大战略、区域协调发展战略和主体功能区战略，从实际出发推进本地区绿色低碳发展。京津冀、长三角、粤港澳大湾区等区域要发挥高质量发展动力源和增长极作用，率先推动经济社会发展全面绿色转型。长江经济带、黄河流域和国家生态文明试验区要严格落实生态优先、绿色发展战略导向，在绿色低碳发展方面走在全国前列。中西部和东北地区要着力优化能源结构，按照产业政策和能耗双控要求，有序推动高耗能行业向清洁能源优势地区集中，积极培育绿色发展动能。</p>
<p>3．上下联动制定地方达峰方案。各省、自治区、直辖市人民政府要按照国家总体部署，结合本地区资源环境禀赋、产业布局、发展阶段等，坚持全国一盘棋，不抢跑，科学制定本地区碳达峰行动方案，提出符合实际、切实可行的碳达峰时间表、路线图、施工图，避免“一刀切”限电限产或运动式“减碳”。各地区碳达峰行动方案经碳达峰碳中和工作领导小组综合平衡、审核通过后，由地方自行印发实施。</p>
<p>4．组织开展碳达峰试点建设。加大中央对地方推进碳达峰的支持力度，选择100个具有典型代表性的城市和园区开展碳达峰试点建设，在政策、资金、技术等方面对试点城市和园区给予支持，加快实现绿色低碳转型，为全国提供可操作、可复制、可推广的经验做法。</p>
<p>四、国际合作</p>
<p>（一）深度参与全球气候治理。大力宣传习近平生态文明思想，分享中国生态文明、绿色发展理念与实践经验，为建设清洁美丽世界贡献中国智慧、中国方案、中国力量，共同构建人与自然生命共同体。主动参与全球绿色治理体系建设，坚持共同但有区别的责任原则、公平原则和各自能力原则，坚持多边主义，维护以联合国为核心的国际体系，推动各方全面履行《联合国气候变化框架公约》及其《巴黎协定》。积极参与国际航运、航空减排谈判。</p>
<p>（二）开展绿色经贸、技术与金融合作。优化贸易结构，大力发展高质量、高技术、高附加值绿色产品贸易。加强绿色标准国际合作，推动落实合格评定合作和互认机制，做好绿色贸易规则与进出口政策的衔接。加强节能环保产品和服务进出口。加大绿色技术合作力度，推动开展可再生能源、储能、氢能、二氧化碳捕集利用与封存等领域科研合作和技术交流，积极参与国际热核聚变实验堆计划等国际大科学工程。深化绿色金融国际合作，积极参与碳定价机制和绿色金融标准体系国际宏观协调，与有关各方共同推动绿色低碳转型。</p>
<p>（三）推进绿色“一带一路”建设。秉持共商共建共享原则，弘扬开放、绿色、廉洁理念，加强与共建“一带一路”国家的绿色基建、绿色能源、绿色金融等领域合作，提高境外项目环境可持续性，打造绿色、包容的“一带一路”能源合作伙伴关系，扩大新能源技术和产品出口。发挥“一带一路”绿色发展国际联盟等合作平台作用，推动实施《“一带一路”绿色投资原则》，推进“一带一路”应对气候变化南南合作计划和“一带一路”科技创新行动计划。</p>
<p>五、政策保障</p>
<p>（一）建立统一规范的碳排放统计核算体系。加强碳排放统计核算能力建设，深化核算方法研究，加快建立统一规范的碳排放统计核算体系。支持行业、企业依据自身特点开展碳排放核算方法学研究，建立健全碳排放计量体系。推进碳排放实测技术发展，加快遥感测量、大数据、云计算等新兴技术在碳排放实测技术领域的应用，提高统计核算水平。积极参与国际碳排放核算方法研究，推动建立更为公平合理的碳排放核算方法体系。</p>
<p>（二）健全法律法规标准。构建有利于绿色低碳发展的法律体系，推动能源法、节约能源法、电力法、煤炭法、可再生能源法、循环经济促进法、清洁生产促进法等制定修订。加快节能标准更新，修订一批能耗限额、产品设备能效强制性国家标准和工程建设标准，提高节能降碳要求。健全可再生能源标准体系，加快相关领域标准制定修订。建立健全氢制、储、输、用标准。完善工业绿色低碳标准体系。建立重点企业碳排放核算、报告、核查等标准，探索建立重点产品全生命周期碳足迹标准。积极参与国际能效、低碳等标准制定修订，加强国际标准协调。</p>
<p>（三）完善经济政策。各级人民政府要加大对碳达峰、碳中和工作的支持力度。建立健全有利于绿色低碳发展的税收政策体系，落实和完善节能节水、资源综合利用等税收优惠政策，更好发挥税收对市场主体绿色低碳发展的促进作用。完善绿色电价政策，健全居民阶梯电价制度和分时电价政策，探索建立分时电价动态调整机制。完善绿色金融评价机制，建立健全绿色金融标准体系。大力发展绿色贷款、绿色股权、绿色债券、绿色保险、绿色基金等金融工具，设立碳减排支持工具，引导金融机构为绿色低碳项目提供长期限、低成本资金，鼓励开发性政策性金融机构按照市场化法治化原则为碳达峰行动提供长期稳定融资支持。拓展绿色债券市场的深度和广度，支持符合条件的绿色企业上市融资、挂牌融资和再融资。研究设立国家低碳转型基金，支持传统产业和资源富集地区绿色转型。鼓励社会资本以市场化方式设立绿色低碳产业投资基金。</p>
<p>（四）建立健全市场化机制。发挥全国碳排放权交易市场作用，进一步完善配套制度，逐步扩大交易行业范围。建设全国用能权交易市场，完善用能权有偿使用和交易制度，做好与能耗双控制度的衔接。统筹推进碳排放权、用能权、电力交易等市场建设，加强市场机制间的衔接与协调，将碳排放权、用能权交易纳入公共资源交易平台。积极推行合同能源管理，推广节能咨询、诊断、设计、融资、改造、托管等“一站式”综合服务模式。</p>
<p>六、组织实施</p>
<p>（一）加强统筹协调。加强党中央对碳达峰、碳中和工作的集中统一领导，碳达峰碳中和工作领导小组对碳达峰相关工作进行整体部署和系统推进，统筹研究重要事项、制定重大政策。碳达峰碳中和工作领导小组成员单位要按照党中央、国务院决策部署和领导小组工作要求，扎实推进相关工作。碳达峰碳中和工作领导小组办公室要加强统筹协调，定期对各地区和重点领域、重点行业工作进展情况进行调度，科学提出碳达峰分步骤的时间表、路线图，督促将各项目标任务落实落细。</p>
<p>（二）强化责任落实。各地区各有关部门要深刻认识碳达峰、碳中和工作的重要性、紧迫性、复杂性，切实扛起责任，按照《中共中央国务院关于完整准确全面贯彻新发展理念做好碳达峰碳中和工作的意见》和本方案确定的主要目标和重点任务，着力抓好各项任务落实，确保政策到位、措施到位、成效到位，落实情况纳入中央和省级生态环境保护督察。各相关单位、人民团体、社会组织要按照国家有关部署，积极发挥自身作用，推进绿色低碳发展。</p>
<p>（三）严格监督考核。实施以碳强度控制为主、碳排放总量控制为辅的制度，对能源消费和碳排放指标实行协同管理、协同分解、协同考核，逐步建立系统完善的碳达峰碳中和综合评价考核制度。加强监督考核结果应用，对碳达峰工作成效突出的地区、单位和个人按规定给予表彰奖励，对未完成目标任务的地区、部门依规依法实行通报批评和约谈问责。各省、自治区、直辖市人民政府要组织开展碳达峰目标任务年度评估，有关工作进展和重大问题要及时向碳达峰碳中和工作领导小组报告。</p>
<p><a href="https://www.gov.cn/zhengce/zhengceku/2021-10/26/content_5644984.htm">https://www.gov.cn/zhengce/zhengceku/2021-10/26/content_5644984.htm</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网网关，原来是这么回事，感谢！</title>
    <url>/2023/11/29/%E7%89%A9%E8%81%94%E7%BD%91%E7%BD%91%E5%85%B3%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%98%AF%E8%BF%99%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%8C%E6%84%9F%E8%B0%A2%EF%BC%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>物联网网关，原来是这么回事，感谢！<br>千手修罗</p>
<h1 id="物联网网关是什么？"><a href="#物联网网关是什么？" class="headerlink" title="物联网网关是什么？"></a>物联网网关是什么？</h1><p>物联网网关是连接物联网设备和互联网的重要桥梁，它负责将物联网设备采集到的数据进行处理、存储和转发，使其能够与云端或其他设备进行通信。物联网网关的作用是实现物联网设备与云端的无缝连接和数据交换。</p>
<h1 id="为什么要搞物联网网关？"><a href="#为什么要搞物联网网关？" class="headerlink" title="为什么要搞物联网网关？"></a>为什么要搞物联网网关？</h1><p>不要物联网网关行不行？直接使用设备连接云平台不行吗？</p>
<h2 id="以下是一些情况下应该使用物联网网关："><a href="#以下是一些情况下应该使用物联网网关：" class="headerlink" title="以下是一些情况下应该使用物联网网关："></a>以下是一些情况下应该使用物联网网关：</h2><p>物联网网关通常用于连接不同类型的设备和协议，以便它们可以相互通信和交换数据，并不是所有设备都能直接联网。</p>
<p>设备和协议多样性：当需要连接多种不同类型的设备和协议时，物联网网关可以充分发挥作用，帮助设备进行互操作和数据交换。<br>安全性要求高：在需要更高安全性的环境中，物联网网关可以控制访问和加密数据传输。<br>本地过滤和分析：物联网网关可以进行本地数据过滤和分析，从而减少云上数据的传输量和延迟。<br>离线设备管理：当需要管理离线设备时，物联网网关可以作为离线设备的代理，帮助设备进行远程管理和数据上传。</p>
<h2 id="以下是一些情况下不应该使用物联网网关："><a href="#以下是一些情况下不应该使用物联网网关：" class="headerlink" title="以下是一些情况下不应该使用物联网网关："></a>以下是一些情况下不应该使用物联网网关：</h2><p>单种设备和协议：当只需要连接单一类型的设备和协议时，物联网网关的使用会增加成本和复杂性。<br>网络通信无需过滤和加密：当通信网络已经具备足够的安全性和过滤功能时，物联网网关的使用则会增加不必要的成本。</p>
<h1 id="物联网网关作用？"><a href="#物联网网关作用？" class="headerlink" title="物联网网关作用？"></a>物联网网关作用？</h1><p>物联网网关是作为物联网系统中的中间件，连接低功耗、低带宽、短距离的设备与云端服务器之间的通信，并提供对接云服务的接口和协议转换等功能。其作用如下：</p>
<p>支持多种物联网通信协议，如Zigbee、Z-Wave、BLE、WiFi等，实现设备间的相互通信和互联互通。<br>支持数据预处理和压缩，减少数据传输量和传输时间，提高整个系统的效率。<br>实现本地离线计算和云端计算的切换，能够在断网环境下进行设备之间的控制和操作。<br>提供通用API，支持对接各类物联网云平台，避免不同设备对接不同云平台的麻烦。<br>因此，物联网网关是实现物联网系统的重要一环，将设备的通信、数据的传输、云服务之间的对接等聚合在一起，使得整个系统更加高效、稳定、安全。如果设备直接连接云平台，将无法处理大量的设备数据、协议转换和设备的控制等问题，会导致系统处理能力差、易发生故障等问题。</p>
<h1 id="物联网网关技术原理"><a href="#物联网网关技术原理" class="headerlink" title="物联网网关技术原理"></a>物联网网关技术原理</h1><p>物联网网关主要由硬件和软件两部分组成。硬件方面，网关通常搭载高性能的处理器、内存、存储和各种通信接口，如Wi-Fi、以太网、蓝牙等。软件方面，网关需要运行基于Linux或Windows等操作系统的应用程序，同时还需要支持各种通信协议，如MQTT、HTTP等，以及安全性考虑。</p>
<h1 id="物联网网关的数据处理流程一般分为三步："><a href="#物联网网关的数据处理流程一般分为三步：" class="headerlink" title="物联网网关的数据处理流程一般分为三步："></a>物联网网关的数据处理流程一般分为三步：</h1><p>设备采集；<br>数据格式化；<br>网络传输；</p>
<p>首先，网关通过各种接口和传感器从物联网设备中采集数据，随后对数据进行格式化和处理，最终通过网络将数据传输到云服务平台或其他设备。</p>
<p>如上图所示：</p>
<p>北向接口与南向接口：物联网网关需要提供北向接口和南向接口。北向接口连接云端，用于将数据上传到云端，提供数据分析、处理、存储、管理等服务。南向接口连接设备端，用于实现与终端设备的通信。<br>存储：物联网网关可以存储设备和传感器的数据，并对数据进行处理和分析，以便提供实时监测和控制。<br>协议转换：不同设备和传感器可能使用不同的通信协议，物联网网关可以实现协议转换，将不同协议之间的数据转换为统一的与云台交互的协议，从而实现设备的互联互通。<br>设备管理：物联网网关可以对连接的终端设备进行管理，包括设备的配置、参数设置、故障处理等。<br>操作系统：物联网网关需要搭载操作系统才能运行，一般采用嵌入式操作系统，如Linux、Windows Embedded等。<br>硬件：物联网网关需要运行软件和驱动程序来支持其各项功能。硬件方面，通常采用ARM等处理器，具有较高的计算能力和低功耗特性。<br>物联网网关需要具备较高的安全性，以保障物联网系统的可靠运行。一般来说，物联网网关需要实现以下安全措施：</p>
<p>认证和授权：实现用户身份认证，避免未经授权的用户对系统进行操作。<br>加密通信：使用加密算法对数据进行加密，从而保证数据传输的安全性。<br>安全协议：使用各种安全协议，如TLS/SSL等，保障数据传输的完整性和机密性。<br>防火墙：设置防火墙来保障系统的安全性。<br>安全审计：监测系统的操作记录，及时发现和应对安全事件。<br>网关配置和升级：</p>
<p>物联网网关的配置和升级是系统运行的关键环节，具备以下特点：</p>
<p>灵活性：支持配置自由灵活，能够快速根据不同场景进行调整。<br>易用性：操作简单易懂，方便用户进行设置和管理。<br>实时性：支持实时配置，可在系统运行时进行快速响应。<br>可靠性：升级过程需要保证数据的完整性和一致性，防止数据丢失或损坏。<br>物联网网关升级一般分为在线升级和离线升级两种模式，离线升级需要手动传输升级包进行升级，而在线升级则可以通过网络直接进行下载和更新，是更为智能化和自动化的升级方式。在升级之前，需要提前进行备份和恢复操作，以防止数据丢失或者出现其他异常情况。同时，网关升级需要根据实际情况选择合适的升级方案，保障系统的平稳运行。</p>
<h1 id="物联网网关实战开发"><a href="#物联网网关实战开发" class="headerlink" title="物联网网关实战开发"></a>物联网网关实战开发</h1><p>物联网网关的开发主要包括硬件和软件方面的工作。在硬件方面，需要选择合适的处理器、内存和通信接口等组件，以及进行电路设计和装配等工作。在软件方面，需要编写应用程序，包括驱动程序、数据处理模块和通信模块等。</p>
<p>物联网网关的开发流程一般包括设备接入、数据处理和连接云平台等步骤。首先，需要通过各种接口将物联网设备连接到网关，随后对采集到的数据进行格式化和处理。最后，通过各种通信协议将数据上传到云服务平台，实现与云端的数据交换。</p>
<p>我们可以选择使用现有的开源网关框架进行开发，例如Eclipse Kura或者Node-RED等等，或者直接使用编程语言和通信协议来设计自己的网关。 下面结合Python代码进行一个基于MQTT协议的物联网网关实战开发的简单示例：</p>
<p>安装必要的库和依赖项 我们需要安装paho-mqtt库来支持使用Python语言来连接MQTT服务器和客户端。</p>
<pre><code>pip install paho-mqtt
</code></pre>
<p>设计网关的基本业务逻辑 本示例中，我们的网关需要订阅来自传感器的数据，并将其传送到云平台上。我们还将实现一个简单的转换逻辑，将来自不同设备的数据进行处理，例如传感器类型、数据格式等信息的解析和分离。</p>
<pre><code>import paho.mqtt.client as mqtt

# MQTT服务器地址和端口号
MQTT_HOST = &quot;localhost&quot;
MQTT_PORT = 1883

# 定义MQTT客户端回调函数
def on_connect(client, userdata, flags, rc):
    print(&quot;Connected with result code &quot; + str(rc))
    # 订阅传感器数据
    client.subscribe(&quot;sensors/#&quot;)

# 处理传感器数据
def process_sensor_data(topic, payload):
    # 解析传感器ID和数据
    sensor_id = topic.strip().split(&quot;/&quot;)[-1]
    data_type, data_value = payload.strip().split(&quot;:&quot;)
    # 打印传感器数据
    print(&quot;Received data from sensor &#123;&#125; : &#123;&#125; = &#123;&#125;&quot;.format(sensor_id, data_type, data_value))
    # TODO：数据转换和上传到云平台等操作

# 定义MQTT客户端消息回调函数
def on_message(client, userdata, msg):
    print(&quot;Received message: &quot; + msg.payload.decode())
    process_sensor_data(msg.topic, msg.payload.decode())

# 连接MQTT服务器并开始循环监听传感器数据
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(MQTT_HOST, MQTT_PORT, 60)
client.loop_forever()
</code></pre>
<p>编写传感器模拟程序来模拟传感器数据的发送 为了测试我们的物联网网关，我们需要编写一个模拟程序来模拟传感器数据的发送。这可以用Python的MQTT客户端模块来实现。</p>
<pre><code>import paho.mqtt.client as mqtt
import time
from random import randint

# MQTT服务器地址和端口号
MQTT_HOST = &quot;localhost&quot;
MQTT_PORT = 1883

def simulate_sensor():
    # 模拟传感器数据
    sensor_id = &quot;sensor-&quot; + str(randint(1, 10))
    temperature = str(randint(20, 30))
    humidity = str(randint(30, 50))

    # 发布传感器数据
    client = mqtt.Client()
    client.connect(MQTT_HOST, MQTT_PORT, 60)
    client.publish(&quot;sensors/&quot; + sensor_id, &quot;temperature:&quot; + temperature, qos=1)
    client.publish(&quot;sensors/&quot; + sensor_id, &quot;humidity:&quot; + humidity, qos=1)
    client.disconnect()
    print(&quot;Published sensor data from &quot; + sensor_id)

if __name__ == &#39;__main__&#39;:
    while True:
        simulate_sensor()
        time.sleep(5)
    
</code></pre>
<p>以上就是一个简单的物联网网关实战开发示例，用Python语言实现了基于MQTT协议的数据传输和处理功能。实际的物联网网关开发使用的技术和工具非常多样化，需要根据具体的需求和应用场景来选择最适合的解决方案。</p>
<h1 id="边缘计算与物联网网关的碰撞"><a href="#边缘计算与物联网网关的碰撞" class="headerlink" title="边缘计算与物联网网关的碰撞"></a>边缘计算与物联网网关的碰撞</h1><p>边缘计算的理解</p>
<p>边缘计算是一种分布式计算模式，它将计算和数据处理部分从传统的中央服务器转移到与数据源最近的边缘计算节点上。这些边缘计算节点包括网络边缘、物联网网关、交换机以及其他物联设备和传感器。</p>
<p>边缘计算的目标是在提供更高的数据响应速度的同时降低传输带宽和存储需求。与传统的云计算不同，边缘计算侧重于通过将嵌入式设备和传感器之类的物联网设备的计算能力转移到这些设备附近的边缘设备上来提高数据处理效率，从而降低响应时间和延迟。</p>
<p>边缘计算提供了以下优点：</p>
<p>更高的数据响应速度：边缘计算能够在更靠近数据来源的地方处理数据，因此可以更快地响应数据请求。<br>降低带宽需求：边缘计算可以在边缘设备上处理数据，从而避免将大量数据传输到中央服务器带来的带宽需求。<br>提高安全性：由于边缘设备通常是在企业或组织的边缘处，因此对于潜在的攻击者来说，它们被认为是难以访问的。<br>提高系统可靠性：除了更快的响应速度和更低的带宽需求外，边缘计算还可以从独立的边缘设备中恢复系统，从而提高基于物联网的系统的可靠性。</p>
<p>边缘计算的目的是将计算任务尽可能地靠近用户，从而减少网络延迟和带宽，提高应用的性能和用户体验。在上图中，当用户设备需要进行一些计算任务时，这些任务可以通过边缘设备进行处理，而边缘设备可以将一部分数据传输到云端设备进行处理，再将处理后的结果返回给用户设备。这种分布式计算模式可以适用于各种场景，例如智能家居、智能交通等。<br>物联网网关结合边缘计算<br>在物联网网关中使用边缘计算，需要考虑以下设计原则：</p>
<p>选择合适的边缘设备。边缘设备应该具备足够的计算能力、存储空间和通信能力，能够完成数据处理、存储和传输等任务。<br>定义合理的边缘计算模型。物联网网关应该根据具体业务需求，采用适当的边缘计算模型，如Spark、Flink、TensorFlow等，来处理数据和生成智能决策。<br>建立安全的通信和存储机制。物联网网关需要建立安全的通信和数据存储机制，保证传输过程中的数据安全和完整性，同时防止攻击者通过网关获取敏感信息或控制物联网设备。</p>
<p>相较于传统的物联网网关，基于边缘计算的物联网网关多了以下内容：</p>
<p>更强的数据处理能力。边缘计算将数据处理推向了设备端，可以更快地处理和分析海量数据。<br>更高的实时性和响应速度。边缘计算可以在设备端进行实时的数据分析和决策，减少了数据在传输过程中的延迟。<br>更好的可扩展性和灵活性。边缘计算可以灵活地根据业务需求选择不同的计算和存储模型，并且可以根据需求进行扩展和优化。<br>更高的安全性和可靠性。边缘计算可以将一部分敏感数据存储在设备端，减少了数据泄露的风险，同时也提高了系统的可靠性。<br>物联网网关可以利用边缘计算来处理和分析设备产生的数据，实现以下几个方面的功能：</p>
<p>实时数据处理：通过在网关上运行轻量级的边缘计算资源，可以快速地对设备产生的实时数据进行处理，如数据的过滤、聚合、转换等操作，从而减少数据传输和存储的开销，提高数据处理和分析的实时性和准确性。<br>数据存储和管理：通过在网关上部署数据库等相关服务，可以将设备产生的数据在本地进行存储和管理，避免了对云端数据中心的依赖，从而提高数据的可靠性和安全性。同时，还可以根据需求在本地对数据进行查询、分析和可视化展示。<br>边缘智能化：通过在网关上部署人工智能等相关技术，可以实现对设备产生的数据的智能化分析和处理，如机器学习、图像识别、自然语言处理等技术。这样可以进一步提供更加智能化和个性化的设备服务和管理。 总的来说，物联网网关利用边缘计算可以实现更加高效和智能化的设备数据处理和管理，从而提高物联网系统的实时性、可靠性、安全性和智能化程度。<br>如果想整体学习高并发知识，请看《高并发系统实战派》这本书–人人都懂，人人都会，《高并发系统实战派》–这里获取<br>总之，边缘计算实现的关键是要依靠物联网技术和计算资源将数据和计算移到离用户更近的边缘设备上，从而实现数据处理的快速、高效和安全。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Modbus RTU 协议概述</title>
    <url>/2023/11/28/Modbus%20RTU%20%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是-Modbus-RTU？"><a href="#什么是-Modbus-RTU？" class="headerlink" title="什么是 Modbus RTU？"></a>什么是 Modbus RTU？</h1><p>Modbus RTU 协议是一种开放的串行协议，广泛应用于当今的工业监控设备中。该协议使用 RS-232 或 RS-485 串行接口进行通信，并得到市场上几乎所有商业 SCADA、HMI、OPC 服务器和数据采集软件程序的支持。因此，很容易将 Modbus 兼容设备集成到新的或现有的监控应用程序中，并具有即时的软件支持。</p>
<h1 id="Modbus-主-从技术"><a href="#Modbus-主-从技术" class="headerlink" title="Modbus 主/从技术"></a>Modbus 主/从技术</h1><p>Modbus RTU 协议使用主/从技术在设备之间进行通信。这意味着，任何使用 Modbus RTU 协议的应用程序都将有一个 Modbus 主站和至少一个 Modbus 从站。Modbus Master 通常是一台运行软件的主机监控计算机，它将与一个或多个 Modbus Slave 设备进行通信。</p>
<p>Modbus 从设备是执行系统参数测量和控制系统中的开/关设备的设备。为了执行这些任务，主站向 Modbus 从站发送消息，请求执行特定任务。</p>
<p>Modbus RTU 协议使用格式化的消息在主机和从机之间进行通信。消息由系统 Master 发起并发送到 Slave 设备。然后，从站以请求的数据进行响应，或者确认它执行了请求的功能。所有进出主站的消息都包含一个两字节（16 位）CRC（循环冗余校验）校验和值，用于错误检查。如果将无效请求传输到 Modbus 从站，则会返回一个字节（8 位）错误代码值，说明请求错误的原因。</p>
<p>Modbus 主站消息包含几个重要的信息。每条消息都以接受消息的设备的从地址开始。接下来是要执行的功能编号（或命令）。后面是指定函数正确执行所需的任何数据。从地址是一个单字节（8 位）值，可用值范围在 0-247 之间。Modbus 功能号也是一个字节值，并且在协议中定义了许多标准化功能号。支持所请求功能所需的任何数据值的长度将是一个或多个字节。Modbus 从站响应消息将包含响应的从站地址、功能编号和主站请求的任何必要数据。</p>
<h1 id="Modbus-RTU-是免版税且可定制的"><a href="#Modbus-RTU-是免版税且可定制的" class="headerlink" title="Modbus RTU 是免版税且可定制的"></a>Modbus RTU 是免版税且可定制的</h1><p>Modbus RTU 协议是一种开放协议，可以免版税使用。这允许制造商在其设备中使用通用 Modbus 协议结构，并添加自定义功能以访问其硬件中的功能。虽然这可能是一个很大的好处，但它可能会导致与不支持新定义功能的商业软件程序的兼容性问题。</p>
<p>Modbus 协议包含当今市场上几乎所有 SCADA、HMI 和数据采集程序都支持的功能列表。以下是用于执行大多数 Modbus 设备读取和控制的协议功能的简要列表。从列表中，“线圈”通常是继电器或数字输出，“寄存器”代表从系统状态到模拟输入或输出信号值的任何内容。每个硬件供应商都有一个“寄存器映射”，详细说明每个寄存器位置和该寄存器的可能数据值。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>配电网在电力系统中的作用</title>
    <url>/2023/11/27/%E9%85%8D%E7%94%B5%E7%BD%91%E5%9C%A8%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电能是人民生产、生活等方面的主要能源。为了提高供电的可靠性和经济性，改善电能的质量，发电、供电和用电通常由发电厂、输配电线路、变电设备、配电设备和用户等组成有联系的总体。发电厂的电能除小部分供厂用电和附近用户外，大部分要经过升压变电站将电压升高，由高压输电线路送至距离较远的用户中心，然后经降压变电站降压，由配电网分配给用户。由此可见，配电网是电力系统的一个重要组成部分，它是由配电线路和配电变电站组成，其作用是将电能分配到工矿企业、城市和农村的用电电器中去。电压为10kV的高压大功率用户可从高压配电网络直接取得电能；380/220V的用户，需再经变压器将10kV电压再次降压后由低压配电网络供电。</p>
<p>配电网是电力系统中非常重要的一部分，它主要的作用是将输送到配电网的电能分配给终端用户和各种电器设备，提供稳定、高效的电力供应服务。具体来说，配电网在电力系统中的作用如下：</p>
<p>1、能源传输和分配：配电网通过电缆、电线和变压器等设备将输送到配电网的电能传输和分配到各个用电设备。在分配过程中还需要对电能进行升降压和分合开关等处理，以确保电能能够按照不同用电需要进行分配。</p>
<p>2、安全保护和故障处理：配电网在运行中也需要保证安全，例如在供电过程中出现电流过载以及电力负荷过大等情况，需要通过保护设备进行保护，避免发生故障和危险事故。同时一旦配电网发生故障，需要及时处理维修，以确保电力供应的可靠、高效性。</p>
<p>3、能源节约和环保：近年来，随着节能减排的需求和环保理念的普及，配电网也需要遵循能源节约和环保政策，实现低碳、绿色的能源转型。配电网也需要根据不同的用电需求，进行智能配电方案的设计，在保证高效能源供应的同时，也要注重环保。</p>
<p>4、新技术创新：配电网还需要根据新能源的发展和智能化、联网等技术的应用，不断推进新技术的创新，探索有效的新配电方案。例如，可再生能源的应用、分布式能源的发展、微电网的应用等，都是当前配电网技术创新的领域。</p>
<p>综上所述，配电网在电力系统中具有非常重要的作用，它不仅能够为用户提供稳定、高效的电力供应，也需要在技术革新和环保方向上不断推进和开拓。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux环境下运行jar文件</title>
    <url>/2023/11/26/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8Cjar%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Linux环境下运行jar文件</p>
<h1 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h1><p>命令：</p>
<pre><code>java -jar xxxx.jar
</code></pre>
<p>特点：当前ssh窗口被锁定，可按ctrl+c打断程序运行，或直接关闭窗口，程序退出。</p>
<h1 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h1><p>命令：</p>
<pre><code>java -jar xxxx.jar &amp;
</code></pre>
<p>特点：&amp;表示在后台运行。当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。</p>
<h1 id="方式三："><a href="#方式三：" class="headerlink" title="方式三："></a>方式三：</h1><p>命令：</p>
<pre><code>nohup java -jar xxxx.jar &amp;
</code></pre>
<p>特点：nohup 意思是不挂断运行命令，当账户退出或终端关闭时，程序仍然运行。当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。</p>
<h1 id="方式四："><a href="#方式四：" class="headerlink" title="方式四："></a>方式四：</h1><p>命令：</p>
<pre><code>nohup java -jar xxxx.jar &gt;/log.file &amp;
</code></pre>
<p>特点：将日志输出到log.file指定的文件内。</p>
<h2 id="shell-命令中，几个基本符号及其含义"><a href="#shell-命令中，几个基本符号及其含义" class="headerlink" title="shell 命令中，几个基本符号及其含义"></a>shell 命令中，几个基本符号及其含义</h2><pre><code>&gt;&gt;      输出重定向
2&gt;&amp;1    (2)标准错误输出   (&gt;) 重定向到  (&amp;1)标准输出
2&gt;&amp;1 标准错误输出重定向到标准输出
&amp;       标识进程为后台进程
</code></pre>
<p>0 表示stdin标准输入 1 表示stdout标准输出 2 表示stderr标准错误</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h2><p>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中</p>
<p>命令改为 nohup java -jar project.jar &gt;&gt; log.out 2&gt;&amp;1 &amp; 完美解决问题，日志追加到 log.out 文件中 ，且线程在后台不挂断运行</p>
<p>报错nohup找不到java</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 的 Systemctl 与 创建系统服务</title>
    <url>/2023/11/25/Centos7%20%E7%9A%84%20Systemctl%20%E4%B8%8E%20%E5%88%9B%E5%BB%BA%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Systemctl"><a href="#Systemctl" class="headerlink" title="Systemctl"></a>Systemctl</h1><h2 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a>systemctl 命令</h2><pre><code># 启动
systemctl start NAME.service
# 停止
systemctl stop NAME.service
# 重启
systemctl restart NAME.service
# 查看状态
systemctl status NAME.service
# 查看所有激活系统服务
systemctl list-units -t service
# 查看所有系统服务
systemctl list-units -t service -a
# 设置开机自启动
systemctl enable NAME.service
# 禁止开机自启动
systemctl disable NAME.service
# 查看服务是否是开机自启动
systemctl list-unit-files –t service
# 查看某服务是否开机自启动
systemctl is-enabled NAME.service
</code></pre>
<h2 id="systemctl-状态"><a href="#systemctl-状态" class="headerlink" title="systemctl 状态"></a>systemctl 状态</h2><pre><code>loaded：unit配置文件已处理
active（running）：一次或多次持续处理的运行
active（exited）：成功完成一次性配置
active（waiting）：运行中，等待一个事件
inactive：不运行
enable：开机启动
disable：开机不启动
static：开机不启动，但可以被另一个启用的服务激活。
</code></pre>
<h2 id="systemctl-运行级别"><a href="#systemctl-运行级别" class="headerlink" title="systemctl 运行级别"></a>systemctl 运行级别</h2><pre><code>0 ：关机：poweroff.target
1 ：单用户模式：rescue.target
2 ：默认不启用NFS的多用户：multi-user.target
3 ：完全的多用户：multi-user.target
4 ：保留：mult-user.target
5 ：图形：graphical.target
6 ：重启：reboot.target
</code></pre>
<h1 id="自建服务"><a href="#自建服务" class="headerlink" title="自建服务"></a>自建服务</h1><h2 id="1、服务存放路径"><a href="#1、服务存放路径" class="headerlink" title="1、服务存放路径"></a>1、服务存放路径</h2><p>用户级系统服务：/usr/lib/systemd/system<br>系统级系统服务：/etc/systemd/system</p>
<h2 id="2、编写一个系统服务"><a href="#2、编写一个系统服务" class="headerlink" title="2、编写一个系统服务"></a>2、编写一个系统服务</h2><p>创建系统服务文件的三个部分分别是：Unit 、 Service、 Install</p>
<h3 id="Unit："><a href="#Unit：" class="headerlink" title="Unit："></a>Unit：</h3><p>Description：描述信息<br>After：定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反；<br>Requires：依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit即无法激活；<br>Wants：依赖到的其它units，弱依赖；<br>Conflicts：定义units间的冲突关系。</p>
<h3 id="Service："><a href="#Service：" class="headerlink" title="Service："></a>Service：</h3><p>Type：定义影响ExecStart及相关参数功能的unit进程启动类型；</p>
<p>simple：默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中；<br>forking：由ExacStart启动的程序透过spawns延伸出其它子程序来作为此deamon的主要服务。原生父程序在启动结束后就会终止。<br>oneshot：与simple类似，不过这个程序在完成工作后就结束，不常驻内存；<br>dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作。因此通常也要同时设定BusName=才行；<br>notify：在启动完成后会发送一个通知消息。还需要配合NotifyAccess来让Systemd接收消息；<br>idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务。</p>
<p>EnvironmentFile：环境配置文件；<br>ExecStart：指明启动unit要运行命令或脚本的绝对路径；<br>ExecStartPre：在ExecStart之前运行的绝对路径；<br>ExecStartPost：在ExecStart之后运行的绝对路径；<br>ExecStop：指明停止unit要运行的命令或脚本的绝对路径；<br>Restart：当设定Restart=1时，则当次daemon服务意外终止后，会再次自动启动。</p>
<p>PrivateTmp:true/false表示是否给服务分配独立的临时空间</p>
<h3 id="Install："><a href="#Install：" class="headerlink" title="Install："></a>Install：</h3><p>Alias：别名，可使用systemctl command Alias.service<br>RequiredBy：被哪些units所依赖，强依赖；<br>WantedBy：被哪些units所依赖，弱依赖；<br>Also：安装本服务的时候还要安装别的相关服务。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>创建服务</p>
<pre><code>vim /usr/lib/systemd/system/wxybackend.service
</code></pre>
<p>编辑内容</p>
<pre><code>[Unit]
Description=backend service  
After=docker.service

[Service]
Type=forking
ExecStart=/home/project/xxx/syscmd.sh start
ExecReload=/home/project/xxx/syscmd.sh restart
ExecStop=/home/project/xxx/syscmd.sh stop
PrivateTmp=true

[Install]
WantedBy=multi-user.target
</code></pre>
<p>退出编辑</p>
<pre><code>：wq!
</code></pre>
<p>启动服务</p>
<pre><code>systemctl daemon-reload 
systemctl enable wxybackend.service 
systemctl start wxybackend.service
</code></pre>
<p>syscmd.sh脚本内容</p>
<pre><code>#!/bin/sh
# start 启动 stop 停止 restart 重启 status 状态
AppName=xxxx.jar
AppPath=/home/project/xxx
# JVM参数
JVM_OPTS=&quot;-Dname=$AppName  -Duser.timezone=Asia/Shanghai -Xms2048m -Xmx2048m -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=1024m -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps  -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC&quot;
APP_HOME=`pwd`
LOG_PATH=$AppPath/logs/$AppName.log

if [ &quot;$1&quot; = &quot;&quot; ];
then
    echo -e &quot;\033[0;31m 未输入操作名 \033[0m  \033[0;34m &#123;start|stop|restart|status&#125; \033[0m&quot;
    exit 1
fi

if [ &quot;$AppName&quot; = &quot;&quot; ];
then
    echo -e &quot;\033[0;31m 未输入应用名 \033[0m&quot;
    exit 1
fi

function start()
&#123;
    PID=`ps -ef |grep java|grep $AppName|grep -v grep|awk &#39;&#123;print $2&#125;&#39;`

    if [ x&quot;$PID&quot; != x&quot;&quot; ]; then
        echo &quot;$AppName is running...&quot;
    else
        #输出日志
        nohup java $JVM_OPTS -jar $AppPath/$AppName &gt;&gt; $AppPath/nohup.out 2&gt;&amp;1 &amp; 
        #不输出日志
        #nohup java $JVM_OPTS -jar $AppPath/$AppName  &amp;
        echo &quot;Start $AppName success...&quot;
        #tail -500f nohup.out
    fi
&#125;

function stop()
&#123;
    echo &quot;Stop $AppName&quot;

    PID=&quot;&quot;
    query()&#123;
        PID=`ps -ef |grep java|grep $AppName|grep -v grep|awk &#39;&#123;print $2&#125;&#39;`
    &#125;

    query
    if [ x&quot;$PID&quot; != x&quot;&quot; ]; then
        kill -TERM $PID
        echo &quot;$AppName (pid:$PID) exiting...&quot;
        while [ x&quot;$PID&quot; != x&quot;&quot; ]
        do
            sleep 1
            query
        done
        echo &quot;$AppName exited.&quot;
    else
        echo &quot;$AppName already stopped.&quot;
    fi
&#125;

function restart()
&#123;
    stop
    sleep 2
    start
&#125;

function status()
&#123;
    PID=`ps -ef |grep java|grep $AppName|grep -v grep|wc -l`
    if [ $PID != 0 ];then
        echo &quot;$AppName is running...&quot;
    else
        echo &quot;$AppName is not running...&quot;
    fi
&#125;

case $1 in
    start)
    start;;
    stop)
    stop;;
    restart)
    restart;;
    status)
    status;;
    *)

esac
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用curl执行Http请求</title>
    <url>/2023/11/24/%E4%BD%BF%E7%94%A8curl%E6%89%A7%E8%A1%8CHttp%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h1><p>curl（CommandLine Uniform Resource Locator或CommandLine URL），curl命令是在命令行方式下工作，利用URL的语法进行数据的传输或者文件的传输。是一个利用URL语法在命令行下工作的文件传输工具。curl设计为：在无用户交互下完成工作。</p>
<p>curl支持的协议包括：DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMTP、SMTPS、TELNET、TFTP。</p>
<h1 id="curl用法"><a href="#curl用法" class="headerlink" title="curl用法"></a>curl用法</h1><pre><code>curl [options…] &lt;url&gt;
</code></pre>
<h1 id="curl参数"><a href="#curl参数" class="headerlink" title="curl参数"></a>curl参数</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="H-“name-value”"><a href="#H-“name-value”" class="headerlink" title="-H “name: value”"></a>-H “name: value”</h3><pre><code>-H &quot;name: value&quot;
--header &quot;name: value&quot;
</code></pre>
<p>(HTTP)添加一个http header(http请求头)</p>
<h3 id="H-“name-”"><a href="#H-“name-”" class="headerlink" title="-H “name:”"></a>-H “name:”</h3><pre><code>-H &quot;name:&quot;
--header &quot;name:&quot;
</code></pre>
<p>(HTTP)移除一个http header(http请求头)</p>
<h3 id="A-“string”"><a href="#A-“string”" class="headerlink" title="-A “string”"></a>-A “string”</h3><pre><code>-A &quot;string&quot;
--user-agent &quot;string&quot;
</code></pre>
<p>(HTTP)设置HTTP请求头User-Agent参数<br>服务器通过User-Agent可以判断客户端使用的浏览器名称和操作系统类型，伪造此参数能导致服务器做出错误判断</p>
<h3 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h3><pre><code>-e
--referer
</code></pre>
<p>(HTTP)设置访问时的来源页面，告诉http服务从哪个页面进入到此页面<br>例如：-e “aiezu.com”相当于“-H “Referer: <a href="http://www.qq.com&quot;”;/">www.qq.com&quot;”；</a></p>
<h3 id="G"><a href="#G" class="headerlink" title="-G"></a>-G</h3><pre><code>-G
--get
</code></pre>
<p>(HTTP)使用HTTP GET方式</p>
<h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><pre><code>-d @file
-d &quot;string&quot;
--data &quot;string&quot;
--data-ascii &quot;string&quot;
--data-binary &quot;string&quot;
--data-urlencode &quot;string&quot;
</code></pre>
<p>(HTTP)使用HTTP POST方式发送“key/value对”数据<br>相当于（method=”POST”，enctype=”application/x-www-form-urlencoded”）</p>
<pre><code>-d，--data：HTTP方式POST数据
--data-ascii：HTTP方式POST ascii数据
--data-binary：HTTP方式POST二进制数据
--data-urlencode：HTTP方式POST数据（进行urlencode）
</code></pre>
<p>如果数据以“@”开头，后紧跟一个文件，将post文件内的内容；</p>
<h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><pre><code>-F name=@file
-F name=&lt;file
-F name=content
--form name=content
--form-string &lt;key=value&gt;
</code></pre>
<p>(HTTP)使用HTTP POST方式发送类似“表单字段”的多类型数据<br>相当于同时设置浏览器表单属性（method=”POST”，enctype=”multipart/form-data”），可以使用此参数上传二进制文件。<br>如果字段内容以“@”开头，剩下的部分应该是文件名，curl将会上传此文件，如：</p>
<pre><code>curl -F &quot;pic=@pic.jpg&quot; http://aiezu.com；
curl -F &quot;page=@a.html;type=text/html&quot; http://aiezu.com
curl -F &quot;page=@/tmp/a;filename=a.txt&quot; http://aiezu.com
</code></pre>
<p>如果字段内容以“&lt;”开头，剩下的部分应该是文件名，curl将从文件中获取作为此字段的值，如：curl -F “text=&lt;text.txt” <a href="http://aiezu.com;/">http://aiezu.com；</a></p>
<p>–form-string类似于“–form”，但是“@”、“&lt;”无特殊含义；</p>
<h3 id="X"><a href="#X" class="headerlink" title="-X "></a>-X <command></h3><pre><code>-X &lt;command&gt;
--request &lt;command&gt;
</code></pre>
<p>(HTTP)指定与服务器通信使用的请求方法<br>如：GET、PUT、POST、DELETE等</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="b-name-data"><a href="#b-name-data" class="headerlink" title="-b name=data"></a>-b name=data</h3><pre><code>-b name=data
--cookie name=data
</code></pre>
<p>(HTTP)发送cookie数据到HTTP服务器<br>数据格式为：”NAME1=VALUE1; NAME2=VALUE2”</p>
<p>如果行中没有“=”，将把参数值当作cookie文件名</p>
<p>这个cookie数据可以是由服务器的http响应头“Set-Cookie:”行发送过来的；</p>
<h3 id="c-filename"><a href="#c-filename" class="headerlink" title="-c filename"></a>-c filename</h3><pre><code>-c filename
--cookie-jar file name
</code></pre>
<p>(HTTP)完成操作后将服务器返回的cookies保存到指定的文件<br>指定参数值为“-”将定向到标准输出“如控制台”</p>
<h3 id="j"><a href="#j" class="headerlink" title="-j"></a>-j</h3><pre><code>-j
--junk-session-cookies
</code></pre>
<p>(HTTP)告诉curl放弃所有的”session cookies”.相当于重启浏览器</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="I"><a href="#I" class="headerlink" title="-I"></a>-I</h3><pre><code>-I
--head
</code></pre>
<p>(HTTP)只输出HTTP-header，不获取内容(HTTP/FTP/FILE)</p>
<ol>
<li>用于HTTP服务时，获取页面的http头,如：curl -I <a href="http://aiezu.com/">http://aiezu.com</a></li>
<li>用于FTP/FILE时，将会获取文件大小、最后修改时间，如：curl -I file://test.txt</li>
</ol>
<h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><pre><code>-i
--include
</code></pre>
<p>(HTTP)输出HTTP头和返回内容</p>
<h3 id="D"><a href="#D" class="headerlink" title="-D "></a>-D <file></file></h3><pre><code>-D &lt;file&gt;
--dump-header &lt;file&gt;
</code></pre>
<p>(HTTP)转储http响应头到指定文件</p>
<h1 id="curl举例"><a href="#curl举例" class="headerlink" title="curl举例"></a>curl举例</h1><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><pre><code>curl &#39;http://127.0.0.1:8888/test&#39;
curl -G &#39;http://127.0.0.1:8888/test&#39;
curl --get &#39;http://127.0.0.1:8888/test&#39;
curl -X GET &#39;http://127.0.0.1:8888/test&#39;
curl --request GET &#39;http://127.0.0.1:8888/test&#39;
</code></pre>
<p>当有参数时，请进行URL编码，否则会可能会出错</p>
<pre><code>curl -X GET &#39;http://127.0.0.1:8888/test2?date=2022-02-22 11:22:33&amp;bo=1&#39;
</code></pre>
<p>报错：HTTP Status 505 – HTTP Version Not Supported（因为参数带空格）</p>
<p>正确写法(对空格URL编码)</p>
<pre><code>curl -X GET &#39;http://127.0.0.1:8888/test2?date=2022-02-22%2011:22:33&amp;bo=1&#39;
</code></pre>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><pre><code>curl -X POST &#39;http://127.0.0.1:8888/test2?date=2022-02-22%2011:22:33&amp;bo=11&#39;
curl -X POST &#39;http://127.0.0.1:8888/test2&#39; -d &#39;date=2022-02-22 11:22:33&amp;bo=11&#39;
curl -X POST &#39;http://127.0.0.1:8888/test2&#39; --data &#39;date=2022-02-22 11:22:33&amp;bo=11&#39;
curl -X POST &#39;http://127.0.0.1:8888/test2&#39; --data-urlencode &#39;date=2022-02-22 11:22:33&#39; --data-urlencode &#39;bo=11&#39;
curl -X POST  -H &#39;Content-Type: application/x-www-form-urlencoded&#39; &#39;http://127.0.0.1:8888/test2&#39; --data-urlencode &#39;date=2022-02-22 11:22:33&#39; --data-urlencode &#39;bo=11&#39;
</code></pre>
<p>POST请求默认Content-Type: application/x-www-form-urlencoded</p>
<p>可以多次使用 -d、–data选项来指定多个传输参数，也可以使用一次 -d、–data选项来指定多个参数。当 Content-Type 为 application/x-www-form-urlencoded 时，-X POST 不可缺省。</p>
<p>POST JSON请求</p>
<pre><code>curl -X POST &#39;http://127.0.0.1:8888/test8&#39; -H &#39;Content-Type: application/json&#39; -d &#39;&#123;&quot;code&quot;: 123456789,&quot;name&quot;: 1646278385537&#125;&#39;
curl &#39;http://127.0.0.1:8888/test8&#39; -H &#39;Content-Type: application/json&#39; -d &#39;&#123;&quot;code&quot;: 123456789,&quot;name&quot;: 1646278385537&#125;&#39;
</code></pre>
<p>Content-Type：application/json 时，默认以 POST 方式提交，此时 -X POST 可以缺省。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「骑个小蜗牛」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jokerljg/article/details/126534526">https://blog.csdn.net/jokerljg/article/details/126534526</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令：ss命令</title>
    <url>/2023/11/23/Linux%E5%91%BD%E4%BB%A4%EF%BC%9Ass%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ss功能：</p>
<p>用来显示套接字信息的，类似于netstat，可以显示更多的信息，用于替代netstat。</p>
<p>ss常用选项</p>
<pre><code>-t：tcp协议的连接
-u：udp协议的链接
-w：裸套接字相关
-x：unix sock相关
-l：listen监听状态的连接
-a：所有状态的连接
-e：显示扩展信息
-m：显示套接连接使用的内存信息
-p：进程及UDP
-n：数字格式显示
-o：计时器信息
</code></pre>
<p>常用组合：</p>
<pre><code>-tan, -tanl, -tanlp, -uan
</code></pre>
<p>TCP常见状态：</p>
<p>LISTEN：监听</p>
<pre><code>ESTABLISHED：已建立连接
FIN_WAIT_1
FIN_WAIT_2
SYN_SENT
SYN_RECV
CLOSED
</code></pre>
<p>其他用法：</p>
<pre><code>ss -l 显示本地打开的所有端口
ss -pl 显示每个进程具体打开的socket
ss -t -a 显示所有tcp socket
ss -u -a 显示所有的UDP Socekt
ss -o state established &#39;( dport = :ssh or sport = :ssh )&#39; 显示所有已建立的ssh连接
ss -o state established &#39;( dport = :http or sport = :http )&#39; 显示所有已建立的HTTP连接
ss -s 列出当前socket详细信息
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS系统安装JDK1.8 详细教程</title>
    <url>/2023/11/22/CentOS%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85JDK1.8%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、下载jdk</p>
<pre><code>wget https://repo.huaweicloud.com/java/jdk/8u202-b08/jdk-8u241-linux-x64.tar.gz
</code></pre>
<p>2、创建安装目录</p>
<pre><code>mkdir /usr/local/java/
</code></pre>
<p>3、解压至安装目录</p>
<pre><code>tar -zxvf jdk-8u241-linux-x64.tar.gz -C /usr/local/java
</code></pre>
<p>4、配置环境变量</p>
<pre><code>vim /etc/profile
</code></pre>
<p>在文本末尾添加</p>
<pre><code>export JAVA_HOME=/usr/local/java/jdk1.8.0_241
export JRE_HOME=$&#123;JAVA_HOME&#125;/jre
export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib
export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH
</code></pre>
<p>5、保存并退出、按esc键、输入以下内容、按Enter键</p>
<pre><code>:wq
</code></pre>
<p>6、使环境变量生效</p>
<pre><code>source /etc/profile
</code></pre>
<p>7、添加软链接</p>
<pre><code>ln -s /usr/local/java/jdk1.8.0_241/bin/java /usr/bin/java
</code></pre>
<p>8、检查jdk是否安装成功</p>
<pre><code>java -version
</code></pre>
<p>执行结果：</p>
<pre><code>java version &quot;1.8.0_241&quot;
Java(TM) SE Runtime Environment (build 1.8.0_241-b07)
Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>JDK</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装 activeMq</title>
    <url>/2023/11/21/CentOS%20%E5%AE%89%E8%A3%85%20nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>安装依赖库</p>
<pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel pcre pcre-devel 
</code></pre>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>cd /usr/local/nginx

#创建nginx安装目录
mkdir nginx

#解压
tar -zxvf nginx-1.24.0.tar.gz

#进入解压文件夹
cd nginx-1.24.0

#添加www用户
useradd -s /sbin/nologin -M www

#指定配置
./configure --prefix=/usr/local/nginx/nginx --user=www --group=www --with-http_ssl_module --with-http_stub_status_module

#编译
make &amp;&amp; make install
</code></pre>
<h1 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h1><pre><code># 启动。默认监听80端口，启动成功之后可以浏览器访问ip:80，出现4.2中图表示centos服务器上nginx启动成功
/usr/local/nginx/nginx/sbin/nginx
# 重新载入配置文件
/usr/local/nginx/nginx/sbin/nginx -s reload           
# 重启 Nginx
/usr/local/nginx/nginx/sbin/nginx -s reopen
# 强制停止 Nginx
/usr/local/nginx/nginx/sbin/nginx -s stop      
# 优雅停止 Nginx，在退出前完成已经接受的连接请求
/usr/local/nginx/nginx/sbin/nginx -s quit 
# 检查nginx.conf文件正确性
/usr/local/nginx/nginx/sbin/nginx -t 
# 显示版本信息；
/usr/local/nginx/nginx/sbin/nginx -v
</code></pre>
<h1 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h1><p>添加到系统服务：</p>
<pre><code>#vim /usr/lib/systemd/system/nginx.service

[Unit]
Description=nginx web service
Documentation=http://nginx.org/en/docs/
After=network.target
 
[Service]
Type=forking
PIDFile=/usr/local/nginx/nginx/logs/nginx.pid
ExecStartPre=/usr/local/nginx/nginx/sbin/nginx -t -c /usr/local/nginx/nginx/conf/nginx.conf
ExecStart=/usr/local/nginx/nginx/sbin/nginx
ExecReload=/usr/local/nginx/nginx/sbin/nginx -s reload
ExecStop=/usr/local/nginx/nginx/sbin/nginx -s stop
PrivateTmp=true
 
[Install]
WantedBy=default.target
</code></pre>
<p>启动关停命令</p>
<pre><code>#重新加载系统服务
systemctl daemon-reload

#启动: 
systemctl start nginx

#停止: 
systemctl stop nginx

#重启: 
systemctl restart nginx

#重新加载配置文件: 
systemctl reload nginx.service

#查看nginx状态: 
systemctl status nginx

#开机启动: 
systemctl enable nginx
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>activeMq</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装 activeMq</title>
    <url>/2023/11/20/CentOS%20%E5%AE%89%E8%A3%85%20activeMq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Apache ActiveMQ是一个免费的开源消息代理和集成模式服务器。它支持来自JAVA、c++、C、Python、Perl、PHP等多种语言的客户端和协议。它提供了许多功能，如消息组、虚拟目的地、通配符和组合目的地等。它可以很容易地集成到spring应用程序中。</p>
<p>工欲善其事必先利其器，那么再使用这个mq之前，我们得先安装activemq，那么我们就来看一下如何安装activemq。由于activemq是基于java开发的，所以环境上必须得安装jdk。</p>
<h1 id="activeMq的安装"><a href="#activeMq的安装" class="headerlink" title="activeMq的安装"></a>activeMq的安装</h1><p>ActiveMQ为Unix系统提供了预先编译的二进制文件，可以直接使用。唯一需要的依赖项是在系统中安装JAVA。由于我们已经安装了JAVA，我们可以进一步下载ActiveMQ。您总是可以从Apache ActiveMQ的官方发布页面获得最新的稳定版本。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本次安装的版本是5.15.5.使用以下命令进行下载。</p>
<p>wget <a href="http://archive.apache.org/dist/activemq/5.15.5/apache-activemq-5.15.5-bin.tar.gz">http://archive.apache.org/dist/activemq/5.15.5/apache-activemq-5.15.5-bin.tar.gz</a></p>
<p>下载完成之后，我们接着进行解压，把该压缩包解压到/opt目录下。</p>
<pre><code>sudo tar -zvxf apache-activemq-5.15.12-bin.tar.gz -C /opt
</code></pre>
<p>接着为了方便起见，您可以创建一个与版本无关的软链接，指向当前Apache ActiveMQ版本所在的目录。这种做法对以后的更新很有帮助。这样的话，后续进行安装新的版本的话，只需要修改一下软连接对应的版本，就不要每次都把升级的文件全部移动到指定的文件夹下。</p>
<pre><code>sudo ln -s /opt/apache-activemq-5.15.12/  /opt/activemq
</code></pre>
<p>接着创建完软连接之后，我们进入到对应的/opt/activemq目录下，进行启动mq。并且查看启动状态，以及如何停止mq。</p>
<p>虽然可以使用上面的命令轻松运行ActiveMQ，但建议使用systemd服务来管理ActiveMQ进程。使用Systemd服务将确保ActiveMQ在启动时和故障时自动启动。</p>
<h2 id="创建系统服务进行启动"><a href="#创建系统服务进行启动" class="headerlink" title="创建系统服务进行启动"></a>创建系统服务进行启动</h2><p>通过以下命令来创建系统服务，在/usr/lib/systemd/system/创建一个activemq.service的文件。</p>
<pre><code>sudo vi /usr/lib/systemd/system/activemq.service
</code></pre>
<p>输入以下内容到文件中。</p>
<pre><code>[Unit]
Description=activemq message queue
After=network.target

[Service]
PIDFile=/opt/activemq/data/activemq.pid
ExecStart=/opt/activemq/bin/activemq start
ExecStop=/opt/activemq/bin/activemq stop
User=root
Group=root
Restart=always
RestartSec=9
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=activemq
 
[Install]
WantedBy=multi-user.target
</code></pre>
<p>保存完毕，接着我们来检验一下启动是否能够成功，并且是否能够停止。</p>
<p>sudo systemctl enable activemq<br>sudo systemctl start activemq<br>sudo systemctl status activemq<br>sudo systemctl stop activemq</p>
<p>6，配置通过web进行展示</p>
<p>安装完成之后，启动mq，接着我们可以通过web来访问mq的控制面板，在浏览器的地址栏输入：<a href="http://xxxxxx:8161/admin.%E5%9C%A8%E8%AE%BF%E9%97%AE%E4%B9%8B%E5%89%8D%E5%BE%97%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%8B%E7%AB%AF%E5%8F%A3%E3%80%82%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%E3%80%82">http://xxxxxx:8161/admin.在访问之前得打开一下端口。通过以下命令。</a></p>
<p>sudo firewall-cmd –zone=public –permanent –add-port=8161/tcp<br>sudo firewall-cmd –reload</p>
<p>接着我们通过浏览器来访问一下。默认用户名密码是admin，进入之后可以修改。</p>
<p>最后，听过以上步骤已经安装完成activemq。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>activeMq</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 搭建 ElasticSearch</title>
    <url>/2023/11/19/CentOS%20%E6%90%AD%E5%BB%BA%20ElasticSearch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>安装单机版 Elasticsearch</p>
<p>进入 /usr/local</p>
<h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><pre><code>mkdir elasticsearch
</code></pre>
<h1 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h1><p>下载地址：<a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0.tar.gz">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0.tar.gz</a></p>
<h1 id="进入elasticsearch，上传刚才下载的安装包，接着解压"><a href="#进入elasticsearch，上传刚才下载的安装包，接着解压" class="headerlink" title="进入elasticsearch，上传刚才下载的安装包，接着解压"></a>进入elasticsearch，上传刚才下载的安装包，接着解压</h1><pre><code>cd elasticsearch
tar -zxvf elasticsearch-7.8.0.tar.gz
</code></pre>
<h1 id="进入elasticsearch-7-8-0目录，创建两个data和logs文件夹"><a href="#进入elasticsearch-7-8-0目录，创建两个data和logs文件夹" class="headerlink" title="进入elasticsearch-7.8.0目录，创建两个data和logs文件夹"></a>进入elasticsearch-7.8.0目录，创建两个data和logs文件夹</h1><pre><code>cd elasticsearch-7.8.0
mkdir data
mkdir logs
</code></pre>
<h1 id="修改config-elasticsearch-yml配置项"><a href="#修改config-elasticsearch-yml配置项" class="headerlink" title="修改config\elasticsearch.yml配置项"></a>修改config\elasticsearch.yml配置项</h1><p>在末尾添加如下：</p>
<pre><code>cluster.name: elasticsearch
node.name: node-1
network.host: 0.0.0.0
http.port: 9200
cluster.initial_master_nodes: [&quot;node-1&quot;]
</code></pre>
<h1 id="修改-jvm-options配置项"><a href="#修改-jvm-options配置项" class="headerlink" title="修改\jvm.options配置项"></a>修改\jvm.options配置项</h1><p>第22行起，修改为如下：</p>
<pre><code>-Xms4096m
-Xmx4096m
</code></pre>
<h1 id="修改bin-elasticsearch-env，使用内置jdk"><a href="#修改bin-elasticsearch-env，使用内置jdk" class="headerlink" title="修改bin\elasticsearch-env，使用内置jdk"></a>修改bin\elasticsearch-env，使用内置jdk</h1><p>第38行起，修改为如下： </p>
<pre><code># now set the path to java
#if [ ! -z &quot;$JAVA_HOME&quot; ]; then
#  JAVA=&quot;$JAVA_HOME/bin/java&quot;
#  JAVA_TYPE=&quot;JAVA_HOME&quot;
#else
  if [ &quot;$(uname -s)&quot; = &quot;Darwin&quot; ]; then
    # macOS has a different structure
    JAVA=&quot;$ES_HOME/jdk.app/Contents/Home/bin/java&quot;
  else
    JAVA=&quot;$ES_HOME/jdk/bin/java&quot;
  fi
  JAVA_TYPE=&quot;bundled jdk&quot;
#fi
</code></pre>
<h1 id="配置linux系统环境，命令：vi-etc-security-limits-conf"><a href="#配置linux系统环境，命令：vi-etc-security-limits-conf" class="headerlink" title="配置linux系统环境，命令：vi /etc/security/limits.conf"></a>配置linux系统环境，命令：vi /etc/security/limits.conf</h1><p>在末尾添加如下：</p>
<pre><code>* soft nofile 65536
* hard nofile 131072
* soft nproc 2048
* hard nproc 4096
</code></pre>
<h1 id="修改配置sysctl-conf，命令：vi-etc-sysctl-conf"><a href="#修改配置sysctl-conf，命令：vi-etc-sysctl-conf" class="headerlink" title="修改配置sysctl.conf，命令：vi /etc/sysctl.conf"></a>修改配置sysctl.conf，命令：vi /etc/sysctl.conf</h1><p>添加下面配置：</p>
<pre><code>vm.max_map_count=655360
</code></pre>
<p>并执行命令：sysctl -p</p>
<p>注意：elasticsearch不能用root用户启动，需要创建一个普通用户去启动</p>
<h1 id="创建普通用户，给es用户授权，以便访问elasticsearch目录"><a href="#创建普通用户，给es用户授权，以便访问elasticsearch目录" class="headerlink" title="创建普通用户，给es用户授权，以便访问elasticsearch目录"></a>创建普通用户，给es用户授权，以便访问elasticsearch目录</h1><pre><code># 创建用户
adduser es 或者 useradd es
# 给用户设置密码 
passwd es
# 文件件所有者
chown -R es:es /usr/local/elasticsearch
# 如果错了，可以删除在加
userdel -r es
</code></pre>
<p>注意：修改密码会有复杂性检查，不必理会，输入两遍密码就会成功</p>
<h1 id="切换到es用户，启动elasticsearch"><a href="#切换到es用户，启动elasticsearch" class="headerlink" title="切换到es用户，启动elasticsearch"></a>切换到es用户，启动elasticsearch</h1><pre><code># su es
# bin/elasticsearch -d
</code></pre>
<p>注意：切换到es用户，需要属于密码，属于刚才创建的es密码，然后执行启动命令：bin/elasticsearch，看到如下启动成功</p>
<h1 id="测试elasticsearch"><a href="#测试elasticsearch" class="headerlink" title="测试elasticsearch"></a>测试elasticsearch</h1><pre><code>curl http://localhost:9200
</code></pre>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>elasticsearch可以以下面这种方式启动：</p>
<pre><code>bin/elasticsearch
</code></pre>
<p>在linux系统，这个命令将在前台启动进程。</p>
<p>我们也可以在后台运行，以守护进程的方式，加上-d参数</p>
<pre><code>bin/elasticsearch -d
</code></pre>
<p>在启动的时候可以指定es 进程pid写入的文件，这样可以方便的kill进程</p>
<pre><code>bin/elasticsearch -d -p pid     pid是文件
kill `cat pid`   杀死指定文件中pid的 es进程
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装最新版 gcc g++</title>
    <url>/2023/11/18/CentOS7%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%20gcc%20g++/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>在使用yum时遇到这个错误</p>
<pre><code>Another app is currently holding the yum lock; waiting for it to exit…
</code></pre>
<p>运行命令</p>
<pre><code>rm -f /var/run/yum.pid    //    强制关掉yum进程
</code></pre>
<h1 id="一、第一种方式"><a href="#一、第一种方式" class="headerlink" title="一、第一种方式"></a>一、第一种方式</h1><h2 id="1、先卸载以前的旧版本"><a href="#1、先卸载以前的旧版本" class="headerlink" title="1、先卸载以前的旧版本"></a>1、先卸载以前的旧版本</h2><p>因为centOS默认自带4点几版本的gcc 、g++编译器，是比较老的版本的，所以先把老版本卸载掉。</p>
<p>1.1、 先获取root权限<br>1.2、 查看当前的安装版本号</p>
<pre><code>rpm -q gcc
</code></pre>
<p>1.3、卸载掉旧版本</p>
<pre><code>rpm -e [第二步查到的版本号]
</code></pre>
<p>1.4、第三步可能会遇到如下错误，卸载失败</p>
<pre><code>error: Failed dependencies:
    gcc = 4.4.7-23.el6 is needed by (installed) gcc-c++-4.4.7-23.el6.x86_64
    gcc = 4.4.4 is needed by (installed) libtool-2.2.6-15.5.el6.x86_64
</code></pre>
<p>提示要卸载的版本有两个依赖，要先卸载掉这两个依赖（注意：下面要卸载的版本号要和上面提示的两个依赖的版本号一致）</p>
<pre><code>rpm -e gcc-c++-4.4.7-23.el6.x86_64
rpm -e libtool-2.2.6-15.5.el6.x86_64
</code></pre>
<p>将这两个依赖卸载完成之后再次执行第3步就可卸载成功</p>
<p>1.5、验证卸载</p>
<pre><code>[root@123 /]# gcc -v
-bash: /usr/bin/gcc: No such file or directory
[root@123 /]# g++ -v
-bash: /usr/bin/g++: No such file or directory
</code></pre>
<p>这样即为卸载成功</p>
<h2 id="2、安装最新版本的gcc-、g"><a href="#2、安装最新版本的gcc-、g" class="headerlink" title="2、安装最新版本的gcc 、g++"></a>2、安装最新版本的gcc 、g++</h2><p>在安装之前，可以先去查询一下目前gcc 、g++的版本以及区别，本文用了第11版</p>
<p>2.1、在系统中安装存储库</p>
<pre><code>yum install centos-release-scl
</code></pre>
<p>2.2、安装gcc和g++包（注意版本号：11版）</p>
<pre><code>yum install -y devtoolset-11-gcc devtoolset-11-gcc-c++
</code></pre>
<p>2.3、配置安装好的包（注意版本号：11版）</p>
<pre><code>scl enable devtoolset-11 bash
</code></pre>
<p>2.4、验证安装</p>
<pre><code>[root@123 /]# gcc -v
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/opt/rh/devtoolset-11/root/usr/libexec/gcc/x86_64-redhat-linux/11/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefix=/opt/rh/devtoolset-11/root/usr --mandir=/opt/rh/devtoolset-11/root/usr/share/man --infodir=/opt/rh/devtoolset-11/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --with-default-libstdcxx-abi=gcc4-compatible --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-11.2.1-20210728/obj-x86_64-redhat-linux/isl-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
Supported LTO compression algorithms: zlib
gcc version 11.2.1 20210728 (Red Hat 11.2.1-1) (GCC)

[root@123 /]# g++ -v
Using built-in specs.
COLLECT_GCC=g++
COLLECT_LTO_WRAPPER=/opt/rh/devtoolset-11/root/usr/libexec/gcc/x86_64-redhat-linux/11/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefix=/opt/rh/devtoolset-11/root/usr --mandir=/opt/rh/devtoolset-11/root/usr/share/man --infodir=/opt/rh/devtoolset-11/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --with-default-libstdcxx-abi=gcc4-compatible --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-11.2.1-20210728/obj-x86_64-redhat-linux/isl-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
Supported LTO compression algorithms: zlib
gcc version 11.2.1 20210728 (Red Hat 11.2.1-1) (GCC) 
</code></pre>
<p>2.5、配置环境变量</p>
<p>因为不配置环境变量的话，每打开一个客户端，就需要执行一次上面的第三步配置安装包</p>
<pre><code>//先查看gcc和g++安装位置
[root@123 /]# which gcc
/opt/rh/devtoolset-11/root/usr/bin/gcc
[root@123 /]# which g++
/opt/rh/devtoolset-11/root/usr/bin/g++
</code></pre>
<p>编辑文件</p>
<pre><code>vim /etc/profile
</code></pre>
<p>在文件后面添加下面两行内容：</p>
<pre><code>export GCC_HOME=/opt/rh/devtoolset-11/root/usr
export PATH=$&#123;GCC_HOME&#125;/bin:$PATH
</code></pre>
<p>重新加载文件</p>
<pre><code>source /etc/profile
</code></pre>
<h1 id="二、第二种方式：使用老版本编译新版本"><a href="#二、第二种方式：使用老版本编译新版本" class="headerlink" title="二、第二种方式：使用老版本编译新版本"></a>二、第二种方式：使用老版本编译新版本</h1><p>1、查看系统中有没有老版本</p>
<p>centOS自带的是4点几的版本 : gcc -v 、g++ -v 两个命令查看，我的是4.8.5版本，如果有，跳到3、官网下载想要安装的gcc版本</p>
<p>2、先用yum安装老版本gcc、g++</p>
<pre><code>sudo yum install -y gcc                //安装gcc
sudo yum install -y gcc-c++            //安装g++
</code></pre>
<p>3、官网下载想要安装的gcc版本</p>
<p><a href="http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/">http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/</a></p>
<p>4、安装gcc需要的其他库</p>
<p>mpfr、mpc、gmp三个库 编译之前还需准备以下：</p>
<p>4.1、安装m4库</p>
<pre><code>sudo yum install -y m4 //首先安装m4，否则configure gmp库时会报错**
</code></pre>
<p>4.2、安装以下三个库</p>
<p><strong>一定要按照这三个顺序安装</strong></p>
<p>4.2.1、gmp库  </p>
<p>下载地址：<a href="https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz">https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz</a></p>
<pre><code>tar -Jxvf gmp-6.2.1.tar.xz    //解压
cd gmp-6.2.1                //进入
./configure --prefix=/usr      //指定编译完后要安装的路径，可以自定，示例用/usr
make -j4                    //编译
sudo make install            //安装
</code></pre>
<p>4.2.2、mpfr库 </p>
<p>下载地址：<a href="https://www.mpfr.org/mpfr-current/mpfr-4.2.0.tar.gz">https://www.mpfr.org/mpfr-current/mpfr-4.2.0.tar.gz</a></p>
<pre><code>tar -zxvf mpfr-4.2.0.tar.gz    //解压
cd mpfr-4.2.0                //进入
./configure --prefix=/usr      //指定编译完后要安装的路径，可以自定，示例用/usr
make -j4                    //编译
sudo make install            //安装
</code></pre>
<p>4.2.3、mpc库 </p>
<p>下载地址：<a href="https://mirrors.aliyun.com/gnu/mpc/mpc-1.3.1.tar.gz?spm=a2c6h.25603864.0.0.60dd1a8cVMdT9B">https://mirrors.aliyun.com/gnu/mpc/mpc-1.3.1.tar.gz?spm=a2c6h.25603864.0.0.60dd1a8cVMdT9B</a><br>    tar -zxvf mpc-1.3.1.tar.gz    //解压<br>    cd     mpc-1.3.1                //进入<br>    ./configure –prefix=/usr      //指定编译完后要安装的路径，可以自定，示例用/usr<br>    make -j4                    //编译<br>    sudo make install            //安装</p>
<p>5、编译安装gcc、g++</p>
<p>编译gcc时需要cc1，系统中会有，但是编译时会报错找不到</p>
<p>先到根目录下找：</p>
<pre><code>cd /
sudo find -name cc1
</code></pre>
<p>我的cc1在 /usr/libexec/gcc/x86_64-redhat-linux/4.8.2/cc1</p>
<p>创建软连接到/usr/bin目录下</p>
<pre><code>sudo ln -s /usr/libexec/gcc/x86_64-redhat-linux/4.8.2/cc1 /usr/bin/cc1
</code></pre>
<p>编译过程中可能会遇到这个错误，找不到libmpfr.so.6 这个库，但是系统中会有，所以要先创建一个软连接</p>
<p>去根目录查找</p>
<pre><code>cd /
sudo find -name libmpfr.so.6 
</code></pre>
<p>我的这个文件在/usr/lib目录下</p>
<p>在编译前先创建一个软连接到/usr/lib64目录下</p>
<pre><code>//这个软连接一定要创建在/usr/lib64目录下
sudo ln -s /usr/lib/libmpfr.so.6 /usr/lib64/libmpfr.so.6    
</code></pre>
<p>编译安装gcc、g++</p>
<pre><code>tar -zxvf gcc-12.2.0.tar.gz     //解压
cd gcc-12.2.0/                    //进入
sudo ./configure --disable-multilib --prefix=/usr        
//生成makefile，--prefix指定编译完之后的安装路径
// /usr表示安装之后的gcc、g++在/usr/bin里面
//如果路径中有CMakeLists.txt，则也可以使用cmake生成makefile
//cmake . -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/usr
//--enable-multilib 允许32位编译，如果系统中有32位的环境，一般不需要
//--disable-multilib 只使用64位编译
sudo make -j4                    //编译
</code></pre>
<p>在执行sudo make -j4时，我这里出现了一个报错</p>
<p>这是由于在编译时内存不足造成的，</p>
<p>5.1、如果是虚拟机，可以扩大虚拟机的内存</p>
<p>5.2、创建swap分区（推荐）<br>建议看这篇文章<a href="https://blog.csdn.net/weixin_44796670/article/details/121234446">https://blog.csdn.net/weixin_44796670/article/details/121234446</a><br>之后再执行sudo make -j4<br>编译安装完之后根据链接文章删除swap分区即可</p>
<p>5.3、或者将sudo make -j4改为sudo make，减少同时进行的任务数量，但是编译时间会更长</p>
<p>等待编译完成，时间比较长！！！</p>
<p>6、删除创建的软连接，卸载yum安装的gcc、g++</p>
<pre><code>//删除创建的软连接
sudo rm -rf /usr/bin/cc1
sudo rm -rf /usr/lib64/libmpfr.so.6

//卸载yum安装的gcc、g++
sudo yum remove gcc gcc-c++

//gcc和g++安装到/usr/bin目录中了
sudo make install 
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「cppbugboy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45316173/article/details/122018354">https://blog.csdn.net/qq_45316173/article/details/122018354</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>gcc</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7下安装Redis5</title>
    <url>/2023/11/17/Centos7%E4%B8%8B%E5%AE%89%E8%A3%85Redis5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在安装Redis之前，请确保已经使用yum安装了以下基础组件：</p>
<pre><code>make
gcc
gcc-c++
kernel-devel
</code></pre>
<h1 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装#"></a>Redis的安装#</h1><p>开始下载Redis并进行编译安装：</p>
<pre><code>cd /usr/local/redis
wget http://download.redis.io/releases/redis-5.0.14.tar.gz
tar -zxvf redis-5.0.14.tar.gz
cd redis-5.0.14
make &amp;&amp; make PREFIX=/usr/local/redis install

mkdir /usr/local/redis/etc/
cp redis.conf /usr/local/redis/etc/

cd ..
mkdir data
#ln -s /usr/local/redis-5.0.14 /usr/local/redis
</code></pre>
<p>把Redis的sbin目录加入PATH：</p>
<pre><code># vim /etc/profile

export REDIS_HOME=/usr/local/redis
export PATH=$PATH:$&#123;REDIS_HOME&#125;/bin

# source /etc/profile
</code></pre>
<p>至此，Redis已经安装完毕。</p>
<h1 id="修改redis-conf"><a href="#修改redis-conf" class="headerlink" title="修改redis.conf"></a>修改redis.conf</h1><pre><code>69行：
#bind 127.0.0.1

88行：
protected-mode no

136行：
daemonize yes

171行：
logfile &quot;/usr/local/redis/data/redis_6379.log&quot;

263行：
dir /usr/local/redis/data

507行：
requirepass Your@Password

699行：
appendonly yes
</code></pre>
<h1 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h1><p>添加服务</p>
<pre><code>vi /usr/lib/systemd/system/redis.service
</code></pre>
<p>配置如下：</p>
<pre><code># 服务的说明
[Unit]
# 描述服务
Description=redis
# 描述服务类别
After=network.target

# 服务运行参数的设置
[Service]
# 后台运行的形式
Type=forking
# 启动命令
ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf
# 停止命令
ExecStop=/usr/local/redis/bin/redis-cli shutdown
# 自动重启
Restart=always

# 服务安装的设置
[Install]
# 用户的模式
WantedBy=multi-user.target
</code></pre>
<p>服务启动关停：</p>
<pre><code>systemctl daemon-reload
# systemctl enable/disable xxx 指令设置/取消开机启动
systemctl enable redis
systemctl start redis
systemctl stop redis
systemctl status redis
</code></pre>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>直接</p>
<pre><code>redis-cli ping
</code></pre>
<p>报错如下：</p>
<pre><code>NOAUTH Authentication required
</code></pre>
<p>正确使用：</p>
<pre><code>redis-cli
auth Your@Password
</code></pre>
<h1 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h1><p>使用</p>
<pre><code>ps -ef | grep redis
</code></pre>
<p>去查看redis的进程号，然后直接</p>
<pre><code>kill -9 redis的进程号
</code></pre>
<p>它就可以停止了</p>
<p>然后执行redis-server就可以启动了</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew&amp;Linuxbrew镜像使用帮助</title>
    <url>/2023/11/16/MQTT%E7%BD%91%E5%85%B3%E8%BF%9E%E6%8E%A5%E5%90%84%E7%B1%BB%E5%B7%A5%E4%B8%9A%E7%89%A9%E8%81%94%E8%AE%BE%E5%A4%87%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MQTT是一种轻量级的发布/订阅消息传输协议，专门为低带宽、高延迟或不稳定的网络环境设计。它支持离线消息存储，使客户端在未连接到服务器时也能接收到消息。MQTT网关是一种采用MQTT协议的网关设备，可以连接不同类型的工业物联设备，实现设备之间的数据传输和控制。随着物联网技术的不断发展，工业物联设备之间的互联互通和数据传输变得越来越重要。MQTT网关作为一种轻量级的发布/订阅消息传输协议，在连接各类工业物联设备、实现数据传输和控制方面具有广泛的应用价值。本文将介绍如何实现MQTT网关连接各类工业物联设备，实现数据传输与控制。</p>
<h1 id="实现MQTT网关连接各类工业物联设备"><a href="#实现MQTT网关连接各类工业物联设备" class="headerlink" title="实现MQTT网关连接各类工业物联设备"></a>实现MQTT网关连接各类工业物联设备</h1><p>1、选择合适的MQTT网关</p>
<p>首先，需要选择一款适合的MQTT网关。选择时需要考虑网关的硬件配置、网络接口、扩展接口以及是否支持目标云平台等因素。同时，还需要根据实际应用场景选择合适的网关尺寸、重量和防护等级等参数。</p>
<p>2、连接设备与MQTT网关</p>
<p>不同类型的工业物联设备可能有不同的连接方式，需要根据设备的通信协议和接口类型选择合适的连接方式。例如，一些设备可能使用串口或以太网接口进行连接。确保连接的可靠性和稳定性，以便实现设备与MQTT网关之间的数据传输。</p>
<p>3、配置MQTT网关参数</p>
<p>根据连接的工业物联设备的类型和数据传输需求，配置MQTT网关的参数。这些参数可能包括主题订阅、消息发布、连接参数等。确保配置的参数能够满足实际需求。</p>
<p>4、数据传输与控制</p>
<p>通过MQTT协议，MQTT网关可以与工业物联设备进行数据传输和控制。当设备需要发送数据时，可以将数据发布到特定的主题上，MQTT网关可以订阅这些主题以接收数据。同时，MQTT网关也可以向指定的主题发布命令或控制指令，以实现对设备的远程控制。</p>
<p>5、数据处理与分析</p>
<p>通过MQTT网关接收到的数据可以进行进一步的处理和分析。例如，可以解析和处理数据以监控设备运行状况、预测潜在问题、优化生产流程等。同时，也可以自定义生成报表和可视化数据，提高决策效率。</p>
<p>6、远程控制与调试</p>
<p>通过MQTT协议，MQTT网关还可以接收来自远程平台的控制指令，实现对设备的远程启停控制、远程编程调试和远程上下载程序等操作。这有助于提高运维效率与管理水平。</p>
<h1 id="实现数据传输与控制"><a href="#实现数据传输与控制" class="headerlink" title="实现数据传输与控制"></a>实现数据传输与控制</h1><p>数据传输：MQTT网关可以采集各类工业物联设备的数据，并将其传输到云平台或其它应用系统。数据传输可以采用发布/订阅模式，设备或传感器发布数据，MQTT网关订阅数据并传输到目标位置。同时，MQTT网关也可以从云平台或其它应用系统发送数据到设备或传感器。</p>
<p>数据处理与分析：MQTT网关可以对采集到的数据进行处理和分析，包括数据清洗、数据转换、数据挖掘等操作，以提高数据质量和可用性。同时，也可以自定义生成报表和可视化数据，为决策提供支持。</p>
<p>控制：MQTT网关可以接收来自云平台或其它应用系统的控制指令，并将其发送到设备或传感器，实现对设备的远程控制。例如，可以控制设备的开关、调整设备的参数等。</p>
<p>应用案例分析</p>
<p>以一个智能制造车间为例，说明如何实现MQTT网关连接各类工业物联设备，实现数据传输与控制。在该车间中，传感器负责监测车间的温度、湿度、气压等环境参数；摄像头负责监控车间的生产线上各设备的运行状态；机器人负责执行生产任务。通过MQTT网关将这些设备连接起来，可以实现以下功能：</p>
<p>数据采集：通过传感器采集车间的环境参数，如温度、湿度、气压等，并将数据发送到云平台进行存储和分析。同时，通过摄像头监控生产线上各设备的运行状态，将视频数据传输到云平台进行实时监控。</p>
<p>数据传输：将采集到的数据通过MQTT协议发送到云平台上的数据处理系统进行分析和处理。同时，根据需要将数据传输到其他应用系统进行进一步的数据利用和价值挖掘。</p>
<p>远程控制：通过MQTT协议，可以向设备发送控制指令，实现远程控制。例如，当监测到车间的温度过高时，可以向空调发送控制指令，调整温度至正常范围。同时，也可以根据生产计划自动发送控制指令给机器人，执行相应的生产任务。</p>
<p>故障预警与诊断：通过分析采集到的数据，可以检测设备的故障或异常状态。当出现故障时，可以向维护人员发送预警信息，及时进行维修和保养。同时，通过对历史数据的分析，可以找出故障的原因和解决方案，提高生产效率。</p>
<p>优化生产流程：通过对环境参数和设备运行数据的分析，可以优化生产流程。例如，根据车间的温度和湿度数据，可以调整生产线的运行速度和工艺参数，以提高产品质量和生产效率。</p>
<p>人员管理：通过与人员定位系统结合，可以实时监测车间内员工的位置和活动情况。当出现紧急情况时，可以通过MQTT网关向员工发送紧急通知，引导他们快速疏散或采取必要的防护措施。</p>
<p>节能减排：通过监测车间的能源消耗数据，可以分析能源浪费的原因并采取相应的节能措施。例如，根据车间的温度和湿度数据，可以调整空调和通风系统的运行参数，降低能源消耗。</p>
<p>通过实现MQTT网关连接各类工业物联设备，可以实现数据采集、传输、控制等功能，提高生产效率、降低成本、保障人员安全等方面具有重要意义。这不仅有助于提高设备的智能化、远程化管理水平，还为企业的生产管理提供了实时数据支持，优化了生产流程，提高了产量和质量。同时，也有助于实现工业制造的数字化、智能化和绿色化转型。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew&amp;Linuxbrew镜像使用帮助</title>
    <url>/2023/11/15/Homebrew&amp;Linuxbrew%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Homebrew / Linuxbrew 镜像使用帮助</p>
<p>注：该镜像是 Homebrew / Linuxbrew 源程序以及 formula / cask 索引的镜像（即 brew update 时所更新内容）。本镜像站同时提供相应的二进制预编译包的镜像，请参考 Homebrew bottles 镜像使用帮助</p>
<p>本站提供了 <a href="https://github.com/Homebrew">https://github.com/Homebrew</a> 组织下的以下 repo：brew, homebrew-core, homebrew-cask, homebrew-cask-fonts, homebrew-cask-versions, homebrew-command-not-found, homebrew-services, install。</p>
<p>注：自brew 3.3.0 (2021 年 10 月 25日) 起，Linuxbrew 核心仓库 linuxbrew-core 已被弃用。Linuxbrew 用户应迁移至 homebrew-core，并请依本镜像使用帮助重新设置镜像。具体请参阅本帮助 Linuxbrew 镜像迁移说明 章节。</p>
<p>注：自brew 4.0.0 (2023 年 2 月 16日) 起，HOMEBREW_INSTALL_FROM_API 会成为默认行为，无需设置。大部分用户无需再克隆 homebrew-core 仓库，故无需设置 HOMEBREW_CORE_GIT_REMOTE 环境变量；但若需要运行 brew 的开发命令或者 brew 安装在非官方支持的默认 prefix 位置，则仍需设置 HOMEBREW_CORE_GIT_REMOTE 环境变量。如果不想通过 API 安装，可以设置 HOMEBREW_NO_INSTALL_FROM_API=1。</p>
<p>注：自brew 4.0.22 (2023 年 6 月 12 日) 起，homebrew-cask-drivers 已被弃用，所有 cask 合并至 homebrew-cask 仓库。本帮助内已移除克隆 homebrew-cask-drivers 仓库的命令。已克隆用户可选择运行 brew untap homebrew/cask-drivers 命令移除此仓库。</p>
<h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><p>可设置如下环境变量使用本站提供的 Homebrew 镜像：</p>
<pre><code>export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;
export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&quot;
export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;
export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;
export HOMEBREW_PIP_INDEX_URL=&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;
</code></pre>
<h1 id="首次安装-Homebrew-Linuxbrew"><a href="#首次安装-Homebrew-Linuxbrew" class="headerlink" title="首次安装 Homebrew / Linuxbrew"></a>首次安装 Homebrew / Linuxbrew</h1><p>首先，需要确保系统中安装了 bash、git 和 curl，对于 macOS 用户需额外要求安装 Command Line Tools (CLT) for Xcode。</p>
<p>对于 macOS 用户，系统自带 bash、git 和 curl，在命令行输入 xcode-select –install 安装 CLT for Xcode 即可。<br>对于 Linux 用户，系统自带 bash，仅需额外安装 git 和 curl。</p>
<p>接着，在终端输入以下几行命令设置环境变量：</p>
<pre><code>export HOMEBREW_INSTALL_FROM_API=1
export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;
export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&quot;
export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;
export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;
</code></pre>
<p>注：自 brew 4.0 起，HOMEBREW_INSTALL_FROM_API 会成为默认行为，无需设置；大部分用户无需再克隆 homebrew/core 仓库，故无需设置 HOMEBREW_CORE_GIT_REMOTE 环境变量。但若需要运行 brew 的开发命令或者 brew 安装在非官方支持的默认 prefix 位置，则仍需设置 HOMEBREW_CORE_GIT_REMOTE 环境变量；如果不想通过 API 安装，可以设置 HOMEBREW_NO_INSTALL_FROM_API=1。</p>
<p>最后，在终端运行以下命令以安装 Homebrew / Linuxbrew：</p>
<pre><code># 从本镜像下载安装脚本并安装 Homebrew / Linuxbrew
git clone --depth=1 https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/install.git brew-install
/bin/bash brew-install/install.sh
rm -rf brew-install

# 也可从 GitHub 获取官方安装脚本安装 Homebrew / Linuxbrew
/bin/bash -c &quot;$(curl -fsSL https://github.com/Homebrew/install/raw/master/install.sh)&quot;
</code></pre>
<p>这样在首次安装的时候也可以使用镜像。更多信息请参考 Homebrew 官方安装文档。</p>
<ul>
<li>安装成功后需将 brew 程序的相关路径加入到环境变量中：</li>
</ul>
<p>以下针对基于 Apple Silicon CPU 设备上的 macOS 系统（命令行运行 uname -m 应输出 arm64）上的 Homebrew：</p>
<pre><code>test -r ~/.bash_profile &amp;&amp; echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &gt;&gt; ~/.bash_profile
test -r ~/.zprofile &amp;&amp; echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &gt;&gt; ~/.zprofile
</code></pre>
<p>对基于 Intel CPU 设备上的 macOS 系统（命令行运行 uname -m 应输出 x86_64）的用户可跳过本步。</p>
<p>以下针对 Linux 系统上的 Linuxbrew：</p>
<pre><code>test -d ~/.linuxbrew &amp;&amp; eval &quot;$(~/.linuxbrew/bin/brew shellenv)&quot;
test -d /home/linuxbrew/.linuxbrew &amp;&amp; eval &quot;$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)&quot;
test -r ~/.bash_profile &amp;&amp; echo &quot;eval \&quot;\$($(brew --prefix)/bin/brew shellenv)\&quot;&quot; &gt;&gt; ~/.bash_profile
test -r ~/.profile &amp;&amp; echo &quot;eval \&quot;\$($(brew --prefix)/bin/brew shellenv)\&quot;&quot; &gt;&gt; ~/.profile
test -r ~/.zprofile &amp;&amp; echo &quot;eval \&quot;\$($(brew --prefix)/bin/brew shellenv)\&quot;&quot; &gt;&gt; ~/.zprofile
</code></pre>
<p>参考了 <a href="https://docs.brew.sh/Homebrew-on-Linux%E3%80%82">https://docs.brew.sh/Homebrew-on-Linux。</a></p>
<h1 id="替换现有仓库上游"><a href="#替换现有仓库上游" class="headerlink" title="替换现有仓库上游"></a>替换现有仓库上游</h1><p>替换 brew 程序本身的源，Homebrew / Linuxbrew 相同：</p>
<pre><code>export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;
export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;
brew update
</code></pre>
<p>以下针对 macOS 系统上的 Homebrew：</p>
<pre><code># 手动设置
export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;

# 注：自 brew 4.0 起，大部分 Homebrew 用户无需设置 homebrew/core 和 homebrew/cask 镜像，只需设置 HOMEBREW_API_DOMAIN 即可。
# 如果需要使用 Homebrew 的开发命令 (如 `brew cat &lt;formula&gt;`)，则仍然需要设置 homebrew/core 和 homebrew/cask 镜像。
# 请按需执行如下两行命令：
brew tap --custom-remote --force-auto-update homebrew/core https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git
brew tap --custom-remote --force-auto-update homebrew/cask https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git

# 除 homebrew/core 和 homebrew/cask 仓库外的 tap 仓库仍然需要设置镜像
brew tap --custom-remote --force-auto-update homebrew/cask-fonts https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git
brew tap --custom-remote --force-auto-update homebrew/cask-versions https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-versions.git
brew tap --custom-remote --force-auto-update homebrew/command-not-found https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-command-not-found.git
brew tap --custom-remote --force-auto-update homebrew/services https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-services.git
brew update

# 或使用下面的几行命令自动设置
export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;
for tap in core cask&#123;,-fonts,-versions&#125; command-not-found services; do
    brew tap --custom-remote --force-auto-update &quot;homebrew/$&#123;tap&#125;&quot; &quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-$&#123;tap&#125;.git&quot;
done
brew update
</code></pre>
<p>以下针对 Linux 系统上的 Linuxbrew：</p>
<pre><code>export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;

# 注：自 brew 4.0 起，使用默认 prefix (即 &quot;/home/linuxbrew/.linuxbrew&quot;) 的大部分 Homebrew 用户无需设置 homebrew/core 镜像，只需设置 HOMEBREW_API_DOMAIN 即可。
# 如果不是默认 prefix 或者需要使用 Homebrew 的开发命令 (如 `brew cat &lt;formula&gt;`)，则仍然需要设置 homebrew/core 镜像。
# 请按需执行如下命令：
brew tap --custom-remote --force-auto-update homebrew/core https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git

# 除 homebrew/core 仓库外的 tap 仓库仍然需要设置镜像
brew tap --custom-remote --force-auto-update homebrew/command-not-found https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-command-not-found.git
brew tap --custom-remote --force-auto-update homebrew/services https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-services.git
brew update
</code></pre>
<p>注：如果用户设置了环境变量 HOMEBREW_BREW_GIT_REMOTE 和 HOMEBREW_CORE_GIT_REMOTE，则每次执行 brew update 时，brew 程序本身和 Core Tap (homebrew-core) 的远程将被自动设置。推荐用户将这两个环境变量设置加入 shell 的 profile 设置中。</p>
<pre><code>test -r ~/.bash_profile &amp;&amp; echo &#39;export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;&#39; &gt;&gt; ~/.bash_profile  # bash
test -r ~/.bash_profile &amp;&amp; echo &#39;export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;&#39; &gt;&gt; ~/.bash_profile  # bash
test -r ~/.bash_profile &amp;&amp; echo &#39;export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;&#39; &gt;&gt; ~/.bash_profile
test -r ~/.profile &amp;&amp; echo &#39;export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;&#39; &gt;&gt; ~/.profile
test -r ~/.profile &amp;&amp; echo &#39;export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;&#39; &gt;&gt; ~/.profile
test -r ~/.profile &amp;&amp; echo &#39;export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;&#39; &gt;&gt; ~/.profile

test -r ~/.zprofile &amp;&amp; echo &#39;export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;&#39; &gt;&gt; ~/.zprofile  # zsh
test -r ~/.zprofile &amp;&amp; echo &#39;export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;&#39; &gt;&gt; ~/.zprofile  # zsh
test -r ~/.zprofile &amp;&amp; echo &#39;export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;&#39; &gt;&gt; ~/.zprofile
</code></pre>
<h1 id="Linuxbrew-镜像迁移说明"><a href="#Linuxbrew-镜像迁移说明" class="headerlink" title="Linuxbrew 镜像迁移说明"></a>Linuxbrew 镜像迁移说明</h1><p>Linuxbrew 核心仓库（linuxbrew-core）自 2021 年 10 月 25 日（brew 版本 3.3.0 起）被弃用，Linuxbrew 用户应迁移至 homebrew-core。Linuxbrew 用户请依新版镜像说明重新设置镜像。注意迁移前请先运行 brew update 将 brew 更新至 3.3.0 或以上版本。迁移过程中若出现任何问题，可使用如下命令重新安装 homebrew-core：</p>
<pre><code>export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;
rm -rf &quot;$(brew --repo homebrew/core)&quot;
brew tap --custom-remote --force-auto-update homebrew/core https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git
</code></pre>
<h1 id="复原仓库上游"><a href="#复原仓库上游" class="headerlink" title="复原仓库上游"></a>复原仓库上游</h1><p>(感谢 Snowonion Lee 提供说明)</p>
<ul>
<li><p>以下针对 macOS 系统上的 Homebrew</p>
<h1 id="brew-程序本身，Homebrew-Linuxbrew-相同"><a href="#brew-程序本身，Homebrew-Linuxbrew-相同" class="headerlink" title="brew 程序本身，Homebrew / Linuxbrew 相同"></a>brew 程序本身，Homebrew / Linuxbrew 相同</h1><p>  unset HOMEBREW_BREW_GIT_REMOTE<br>  git -C “$(brew –repo)” remote set-url origin <a href="https://github.com/Homebrew/brew">https://github.com/Homebrew/brew</a></p>
<h1 id="以下针对-macOS-系统上的-Homebrew"><a href="#以下针对-macOS-系统上的-Homebrew" class="headerlink" title="以下针对 macOS 系统上的 Homebrew"></a>以下针对 macOS 系统上的 Homebrew</h1><p>  unset HOMEBREW_API_DOMAIN<br>  unset HOMEBREW_CORE_GIT_REMOTE<br>  BREW_TAPS=”$(BREW_TAPS=”$(brew tap 2&gt;/dev/null)”; echo -n “${BREW_TAPS//$’\n’/:}”)”<br>  for tap in core cask{,-fonts,-versions} command-not-found services; do</p>
<pre><code>  if [[ &quot;:$&#123;BREW_TAPS&#125;:&quot; == *&quot;:homebrew/$&#123;tap&#125;:&quot;* ]]; then  # 只复原已安装的 Tap
      brew tap --custom-remote &quot;homebrew/$&#123;tap&#125;&quot; &quot;https://github.com/Homebrew/homebrew-$&#123;tap&#125;&quot;
  fi
</code></pre>
<p>  done</p>
<h1 id="重新拉取远程"><a href="#重新拉取远程" class="headerlink" title="重新拉取远程"></a>重新拉取远程</h1><p>  brew update</p>
</li>
<li><p>以下针对 Linux 系统上的 Linuxbrew</p>
<h1 id="brew-程序本身，Homebrew-Linuxbrew-相同-1"><a href="#brew-程序本身，Homebrew-Linuxbrew-相同-1" class="headerlink" title="brew 程序本身，Homebrew / Linuxbrew 相同"></a>brew 程序本身，Homebrew / Linuxbrew 相同</h1><p>  unset HOMEBREW_BREW_GIT_REMOTE<br>  git -C “$(brew –repo)” remote set-url origin <a href="https://github.com/Homebrew/brew">https://github.com/Homebrew/brew</a></p>
<h1 id="以下针对-Linux-系统上的-Linuxbrew"><a href="#以下针对-Linux-系统上的-Linuxbrew" class="headerlink" title="以下针对 Linux 系统上的 Linuxbrew"></a>以下针对 Linux 系统上的 Linuxbrew</h1><p>  unset HOMEBREW_API_DOMAIN<br>  unset HOMEBREW_CORE_GIT_REMOTE<br>  brew tap –custom-remote homebrew/core <a href="https://github.com/Homebrew/homebrew-core">https://github.com/Homebrew/homebrew-core</a><br>  brew tap –custom-remote homebrew/command-not-found <a href="https://github.com/Homebrew/homebrew-command-not-found">https://github.com/Homebrew/homebrew-command-not-found</a><br>  brew tap –custom-remote homebrew/services <a href="https://github.com/Homebrew/homebrew-services">https://github.com/Homebrew/homebrew-services</a></p>
<h1 id="重新拉取远程-1"><a href="#重新拉取远程-1" class="headerlink" title="重新拉取远程"></a>重新拉取远程</h1><p>  brew update</p>
</li>
</ul>
<p>注：重置回默认远程后，用户应该删除 shell 的 profile 设置中的环境变量 HOMEBREW_BREW_GIT_REMOTE 和 HOMEBREW_CORE_GIT_REMOTE 以免运行 brew update 时远程再次被更换。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>conda 基本操作</title>
    <url>/2023/11/14/conda%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="conda-基本操作"><a href="#conda-基本操作" class="headerlink" title="conda 基本操作"></a>conda 基本操作</h1><p>查看 conda 版本</p>
<pre><code>conda --version
</code></pre>
<p>更新 conda</p>
<pre><code>conda update conda
</code></pre>
<p>查看 conda 环境配置</p>
<pre><code>conda config --show
</code></pre>
<p>设置镜像源</p>
<pre><code># 设置清华镜像
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/

# 设置 bioconda
conda config --add channels bioconda
conda config --add channels conda-forge

# 设置搜索时显示通道地址
conda config --set show_channel_urls yes
</code></pre>
<p>查询指定命令的功能</p>
<p>conda command_name –help</p>
<h1 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h1><p>显示所有虚拟环境</p>
<pre><code>conda env list
</code></pre>
<p>创建虚拟环境</p>
<pre><code>conda create -n env_name package_name
</code></pre>
<p>如果需要指定 package 版本，可直接在 package_name 之后加上 = 号以及 package 版本号，例如：</p>
<pre><code>conda create -n env_name python=3.x
</code></pre>
<p>如果需要安装多个 package ，在 env_name 之后用空格分隔多个 package_name 即可，例如：</p>
<pre><code>conda create -n python310 python=3.10 numpy pandas
</code></pre>
<p>激活环境</p>
<pre><code>activate env_name
</code></pre>
<p>退出环境</p>
<pre><code>deactivate env_name
</code></pre>
<p>删除虚拟环境</p>
<pre><code>conda env remove -n env_name
</code></pre>
<p>导出虚拟环境</p>
<pre><code>conda env export --name env_name &gt; environment.yml
</code></pre>
<p>导入虚拟环境</p>
<pre><code>conda env create -n env_name -f environment.yml
</code></pre>
<h1 id="管理-package"><a href="#管理-package" class="headerlink" title="管理 package"></a>管理 package</h1><p>查看当前环境包含的所有 package</p>
<pre><code>conda list
</code></pre>
<p>更新当前环境包含的所有 package</p>
<pre><code>conda update --all
</code></pre>
<p>更新指定 package</p>
<pre><code>conda update package_name
</code></pre>
<p>安装指定 package</p>
<pre><code>conda install package_name
</code></pre>
<p>安装装多个 package ：</p>
<pre><code>conda installl package_name_1 package_name_2 package_name_3
</code></pre>
<p>安装固定版本的 package ：</p>
<pre><code>conda install package_name=package_version_number
</code></pre>
<p>移除指定 package</p>
<pre><code>conda remove package_name 
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda 镜像使用帮助</title>
    <url>/2023/11/13/Anaconda%20%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Anaconda-镜像使用帮助"><a href="#Anaconda-镜像使用帮助" class="headerlink" title="Anaconda 镜像使用帮助"></a>Anaconda 镜像使用帮助</h1><p>Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。</p>
<p>Anaconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> 下载。</p>
<p>TUNA 还提供了 Anaconda 仓库与第三方源（conda-forge、msys2、pytorch等，查看完整列表，更多第三方源可以前往校园网联合镜像站查看）的镜像，各系统都可以通过修改用户目录下的 .condarc 文件来使用 TUNA 镜像源。</p>
<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><p>Windows 用户无法直接创建名为 .condarc 的文件，可先执行 conda config –set show_channel_urls yes 生成该文件之后再修改。</p>
<p>注：由于更新过快难以同步，我们不同步pytorch-nightly, pytorch-nightly-cpu, ignite-nightly这三个包。</p>
<pre><code>channels:
  - defaults
show_channel_urls: true
default_channels:
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2
custom_channels:
  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/
</code></pre>
<p>即可添加 Anaconda Python 免费仓库。</p>
<p>运行 conda clean -i 清除索引缓存，保证用的是镜像站提供的索引。</p>
<p>运行 conda create -n myenv numpy 测试一下吧。</p>
<h1 id="Miniconda-镜像使用帮助"><a href="#Miniconda-镜像使用帮助" class="headerlink" title="Miniconda 镜像使用帮助"></a>Miniconda 镜像使用帮助</h1><p>Miniconda 是一个 Anaconda 的轻量级替代，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。</p>
<p>Miniconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a> 下载。</p>
<h1 id="其他三方源"><a href="#其他三方源" class="headerlink" title="其他三方源"></a>其他三方源</h1><p>对于conda的其他三方源，如有需要请修改 anaconda.py 文件，并提交pull request，我们会综合考虑多方因素来酌情增减。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载普通包，以numpy为例</p>
<pre><code>conda install numpy
</code></pre>
<p>下载pytorch</p>
<pre><code>conda install pytorch torchvision torchaudio cpuonly -c pytorch
</code></pre>
<p>关键点：</p>
<p>换源后需要加 -c pytorch 。</p>
<p>因为我们在.condarc中添加了</p>
<pre><code>custom_channels:pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
</code></pre>
<p>只有使用 -c(hannels) 才会实现使用清华源下载pytorch</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python更换国内镜像源三种实用方法</title>
    <url>/2023/11/12/python%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法1：（永久更改）"><a href="#方法1：（永久更改）" class="headerlink" title="方法1：（永久更改）"></a>方法1：（永久更改）</h1><p>在python的命令提示符中运行以下语句，该条语句将pip的下载源永久更改为某个镜像站，这里以清华大学开源镜像站为例：</p>
<pre><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/
</code></pre>
<h1 id="方法2：（永久更改）"><a href="#方法2：（永久更改）" class="headerlink" title="方法2：（永久更改）"></a>方法2：（永久更改）</h1><p>windows环境下，在用户目录中创建一个文件夹，该文件夹的命名为pip；在该pip文件夹中新建一个文件pip.ini，pip.ini的内容如下：（完整路径：C:\Users\用户名\pip\pip.ini）</p>
<pre><code>[global]
index-url=https://pypi.tuna.tsinghua.edu.cn/simple 
[install]  
trusted-host=pypi.tuna.tsinghua.edu.cn
disable-pip-version-check = true  
timeout = 6000
</code></pre>
<h1 id="方法3：（临时性使用）"><a href="#方法3：（临时性使用）" class="headerlink" title="方法3：（临时性使用）"></a>方法3：（临时性使用）</h1><p>在安装库的时候，临时需要用到某个镜像，这里以清华大学镜像为例下载pandas库：</p>
<pre><code>pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple/
</code></pre>
<p>备注：pip下载源常用的国内镜像如下：</p>
<pre><code>豆瓣：http://pypi.douban.com/simple/
阿里云：http://mirrors.aliyun.com/pypi/simple/
华为云：https://repo.huaweicloud.com/repository/pypi/simple
清华大学：https://pypi.tuna.tsinghua.edu.cn/simple
中科大：https://pypi.mirrors.ustc.edu.cn/simple/
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu用户列表：如何查看系统用户列表及其详细信息</title>
    <url>/2023/11/11/Ubuntu%E7%94%A8%E6%88%B7%E5%88%97%E8%A1%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E5%88%97%E8%A1%A8%E5%8F%8A%E5%85%B6%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.python100.com/html/91575.html">https://www.python100.com/html/91575.html</a></p>
<p>更新：2023-05-19 10:46</p>
<p>在Linux系统中，管理用户和组是一个很重要的任务之一。在Ubuntu系统中，用户和组信息存储在/etc/passwd和/etc/group文件中。在本文中，我们将探讨如何在Ubuntu系统中查看用户列表及其详细信息。</p>
<p>一、查看系统用户列表</p>
<p>Ubuntu系统中默认有许多已创建的系统用户，例如root用户、guest用户等。我们需要查看系统中所有的用户列表，以确定是否有非法用户或潜在安全隐患。</p>
<p>要查看系统中所有的用户列表，打开终端并输入以下命令：</p>
<pre><code>cat /etc/passwd | cut -d&quot;:&quot; -f1
</code></pre>
<p>该命令将显示系统上所有用户的用户名。输出结果可能会很长，如果需要分页显示，可以使用以下命令：</p>
<pre><code>cat /etc/passwd | cut -d&quot;:&quot; -f1 | less
</code></pre>
<p>现在你可以使用箭头键和Page Up/Page Down键在列表中导航。</p>
<p>二、查看单个用户详细信息</p>
<p>有时我们需要获悉一个特定用户的详细信息，例如UID、GID、主目录路径和Shell类型等等。可以使用以下命令来查看单个用户的详细信息：</p>
<pre><code>id &lt;用户名&gt;
</code></pre>
<p>例如，我们想查看用户“ubuntu”的详细信息，可以输入以下命令：</p>
<pre><code>id ubuntu
</code></pre>
<p>该命令将显示有关用户“ubuntu”的所有详细信息，包括UID、GID、组成员身份以及主目录和Shell类型。</p>
<p>三、查看所有用户详细信息</p>
<p>有时我们需要查看系统中所有用户的详细信息。可以使用以下命令获得系统中所有用户的完整信息列表：</p>
<pre><code>cat /etc/passwd
</code></pre>
<p>该命令会在终端中显示所有系统用户的详细信息列表，包括每个用户的用户名、密码、UID、GID、用户全名、主目录路径和Shell类型等信息。</p>
<p>如果需要对列表进行分页显示，可以使用以下命令：</p>
<pre><code>cat /etc/passwd | less
</code></pre>
<p>现在你可以使用箭头键和Page Up/Page Down键在列表中浏览。如果要退出列表，请按“q”键。</p>
<p>四、总结</p>
<p>通过本文，我们学习了如何在Ubuntu系统中查看系统用户列表及其详细信息。我们可以使用不同的命令来查看用户列表、单个用户的详细信息以及系统中所有用户的详细信息列表。这些技巧对于用户管理和安全意识非常有用。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS程序破解提示文件提示损坏解决办法</title>
    <url>/2023/11/10/macOS%E7%A8%8B%E5%BA%8F%E7%A0%B4%E8%A7%A3%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文件提示损坏解决办法</p>
<h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>解除隔离，绕过签名</p>
<p>启动终端实用程序，使用命令：</p>
<pre><code>sudo xattr -r -d com.apple.quarantine 
</code></pre>
<p>输入一个空格，然后将损坏的程序拖到终端窗口中。团队将添加它。</p>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>禁用 Gatekeeper：</p>
<p>启动终端实用程序并运行命令</p>
<p>对于 macOS 10.12 – 10.15.7，执行如下命令：</p>
<pre><code>sudo spctl --master-disable
</code></pre>
<p>对于 macOS 11 及更高版本，执行如下命令：</p>
<pre><code>sudo spctl --global-disable
</code></pre>
<p>无需将任何内容拖到终端中。要启用 Gatekeeper，请将“disable”替换为“enable”。</p>
<h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>应用签名方法</p>
<p>先安装Command Line Tools 工具，打开终端工具输入如下命令：</p>
<pre><code>xcode-select --install
</code></pre>
<p>弹出安装窗口后选择继续安装，安装过程需要几分钟，请耐心等待。</p>
<p>打开终端工具输入并执行如下命令对应用签名：</p>
<pre><code>sudo codesign --force --deep --sign - (应用路径)
</code></pre>
<p>注意：应用路径是「访达（Finder）-&gt;应用程序」找到应用将其拖进终端命令 – 的后面，然后按下回车键，输入macOS的密码然后按回车(输入过程中密码是不显示的，输入完密码直接按回车键即可！)<br>出现 「replacing existing signature」 提示即成功！</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS命令添加用户、删除用户</title>
    <url>/2023/11/09/macOS%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E3%80%81%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用dscl命令，以postgres用户为例</p>
<h1 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h1><pre><code># 创建用户并指定Shell
sudo dscl . -create /Users/postgres UserShell /bin/bash

# 设置用户ID（需要唯一）、显示名称
sudo dscl . -create /Users/postgres UniqueID &quot;5001&quot;
sudo dscl . -create /Users/postgres RealName &quot;postgres&quot;

# 将用户设置为管理员
sudo dscl . -create /Users/postgres PrimaryGroupID 80

# 修改密码
sudo dscl . -passwd /Users/postgres 1024
</code></pre>
<h1 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h1><pre><code># 删除用户
sudo dscl . -delete /Users/postgres

# 删除用户主目录
sudo rm -r /Users/postgres
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCPN + Ubuntu 18.04 源码编译 + Codeblocks 调试 + wxFormBuilder 安装</title>
    <url>/2023/11/08/OpenCPN%20+%20Ubuntu%2018.04%20%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%20+%20Codeblocks%20%E8%B0%83%E8%AF%95%20+%20wxFormBuilder%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、参考资料"><a href="#一、参考资料" class="headerlink" title="一、参考资料"></a>一、参考资料</h1><p>OpenCPN - linux 编译参考链接。<br>wxFormBuilder-github 链接</p>
<h1 id="二、源码编译流程"><a href="#二、源码编译流程" class="headerlink" title="二、源码编译流程"></a>二、源码编译流程</h1><p>安装依赖，没有报错。</p>
<pre><code>sudo apt-get install build-essential cmake gettext git-core gpsd gpsd-clients libgps-dev wx-common libwxgtk3.0-dev libglu1-mesa-dev libgtk2.0-dev wx3.0-headers libbz2-dev libtinyxml-dev libportaudio2 portaudio19-dev libcurl4-openssl-dev libexpat1-dev libcairo2-dev libarchive-dev liblzma-dev libexif-dev libelf-dev libsqlite3-dev
</code></pre>
<p>下载源码，使用码云加速。</p>
<pre><code>cd xxx #进入你想存放 opencpn 的文件夹
git clone https://gitee.com/xxx/OpenCPN.git  #注意更换自己的码云仓库名 xxx
</code></pre>
<p>下载速度极慢，使用码云克隆加速github。</p>
<p>注册码云，右上角新建仓库加号，选择从 Github/Gitlab 导入仓库菜单。<br>Git 仓库 URL填入想 clone的 Github仓库，这里就是<a href="https://github.com/OpenCPN/OpenCPN%EF%BC%8C%E7%82%B9%E5%87%BB%E5%AF%BC%E5%85%A5%EF%BC%8C%E5%90%8E%E5%8F%B0%E5%A4%84%E7%90%86%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%90%8E%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%80%E6%A8%A1%E4%B8%80%E6%A0%B7%E7%9A%84%E4%BB%93%E5%BA%93%E3%80%82">https://github.com/OpenCPN/OpenCPN，点击导入，后台处理一段时间后页面自动刷新会出现一模一样的仓库。</a><br>利用码云进行 git clone，因为这里我建立的是私有仓库，需要输入我的账户名和密码，输入后下载速度很快，直接达到带宽上限。<br>编译源码，cmake ../无问题，显示 Configuring done和 Generating done，继续 make。</p>
<pre><code>cd OpenCPN  
mkdir build &amp;&amp; cd build
cmake ..  
make
</code></pre>
<p>没有问题，编译成功，测试以下能否直接运行编译好的可执行文件，运行成功，没有问题。</p>
<pre><code>./opencpn
</code></pre>
<h1 id="三、利用-IDE-编译"><a href="#三、利用-IDE-编译" class="headerlink" title="三、利用 IDE 编译"></a>三、利用 IDE 编译</h1><p>官方推荐了四个 IDE ( Code::Blocks / KDevelop / Eclipse / CDT )，我们按照官方命令，生成项目文件，使用 codeblocks 首先测试：</p>
<pre><code>cmake -G &quot;CodeBlocks - Unix Makefiles&quot; ../
</code></pre>
<p>此时查看 build 文件夹下已经有了 OpenCPN.cbp 文件，这是 codeblocks 的工程文件。</p>
<p>打开 codeblocks ，选择 File - open 找到刚才的 build 文件夹，选择 OpenCPN.cbp。</p>
<p>如果系统未安装该 IDE，可以直接从源安装：</p>
<pre><code>sudo apt-get install codeblocks
</code></pre>
<p>此时右侧项目是 all 的状态，点击菜单栏上的 build 黄色小齿轮进行编译，这里提示没有错误，准备运行 opencpn。</p>
<p>Process terminated with status 0 (0 minute(s), 1 second(s))<br>0 error(s), 0 warning(s) (0 minute(s), 1 second(s))</p>
<p>在右侧的下拉菜单中将 all 改选为 opencpn ，继续点击绿色三角 run 运行，可能弹出是否用 safe mode 运行，我选择了 yes 。</p>
<p>出现 opencpn 界面，编译运行无问题。</p>
<h1 id="四、利用-IDE-调试"><a href="#四、利用-IDE-调试" class="headerlink" title="四、利用 IDE 调试"></a>四、利用 IDE 调试</h1><p>利用 IDE 进行 debug ，我们选择航线相关的源文件 Route.cpp ，随便将断点加在某行，我这里加在了 92 行构造函数的末尾，想看一看新建航线时断点能否进入。此时，加好断点，点击菜单栏中的红色三角 Debug 进行调试运行。</p>
<p>出现 opencpn 海图界面后，随便找个地方，右键选择 New Route… 新建航线， 成功进入断点。</p>
<p>实际上，官方在这里补充了一段说明。大致的意思是如果要在不安装的情况下直接在 IDE 中运行 opencpn ，需要进行一些拷贝操作，我将其简单分段如下，前三个操作只是复制，非常好理解，最后一个暂时没找到正确的位置设置，但是好像不影响调试。</p>
<p>In order to be able to run OpenCPN from inside the IDE without having it installed, you must:</p>
<p>copy the following folders from the data subfolder of the source tree to your build folder: gshhs, s57data, tcdata.<br>You also must create a subfolder uidata in the build folder and copy the following files from src/bitmaps into it: styles.xml, toolicons_journeyman_flat.png, toolicons_journeyman.png, toolicons_traditional.png, plus.svg.<br>You should also copy authors.html and license.html from /data to your ‘build’ folder.<br>Then to ensure that your ‘build’ folder is used as the ‘source’ for the run/debug session you need to ensure that OpenCPN is started with ‘-p’ as a parameter. This sets OpenCPN into ‘portable’ mode and therefore looks in the location the ‘opencpn’ executable is run from, i.e. your ‘build’ directory.</p>
<p>我把上面几句话写成了三句命令，首先 cd 进入你的 opencpn 源码路径下，执行如下命令即可。这些操作不做也可以进行编译调试，为了避免后面出现问题，最好还是按照官方指导来进行。</p>
<pre><code>cp -r ./data/s57data ./data/gshhs ./data/tcdata  ./build/
mkdir ./build/uidata &amp;&amp; cp ./src/bitmaps/styles.xml ./src/bitmaps/toolicons_journeyman_flat.png ./src/bitmaps/toolicons_journeyman.png ./src/bitmaps/toolicons_traditional.png ./src/bitmaps/plus.svg ./build/uidata 
cp ./data/authors.html ./data/license.html ./build/
</code></pre>
<p>四、测试界面开发工具<br>官方推荐使用 wxFormBuilder-github 来开发 GUI 。</p>
<p>编译这个东西，按照它作者提供的编译指南，先安装依赖，然后克隆源码，最后编译运行。</p>
<pre><code>sudo apt install libwxgtk3.0-gtk3-dev libwxgtk-media3.0-gtk3-dev meson
git clone --recursive --depth=1 https://github.com/wxFormBuilder/wxFormBuilder
cd wxFormBuilder
meson _build --prefix $PWD/_install --buildtype=release
ninja -C _build install
./_install/bin/wxformbuilder
</code></pre>
<p>运行到 ninja 编译，未通过，报错如下：</p>
<pre><code>/usr/bin/ld: cannot find -lwx_gtk2u_media-3.0
/usr/bin/ld: cannot find -lwx_gtk2u_media-3.0
collect2: error: ld returned 1 exit status
[61/67] Compiling C++ object &#39;additional@sha/plugins_additional_additional.cpp.o&#39;.
ninja: build stopped: subcommand failed.
</code></pre>
<p>缺少库，安装对应的库：</p>
<p>sudo apt-get install libwxgtk-media3.0-dev</p>
<p>最后执行编译好的可执行文件</p>
<pre><code>./_install/bin/wxformbuilder
</code></pre>
<p>报错，提示，经过查找 issues 发现有人提到了这个问题 #524，解决方案如下，注意替换路径，我是安装在我自建的Software文件夹：</p>
<pre><code>cd ~/Software/wxFormBuilder/_install/lib/x86_64-linux-gnu
cp -r wxformbuilder ../ 
cd ~/Software/wxFormBuilder/_install/bin
./wxformbuilder
</code></pre>
<p>成功解决，完事了，wxFormBuilder 的具体使用方法请自行探索。<br>————————————————<br>版权声明：本文为CSDN博主「银时大魔王」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sinat_25923849/article/details/110232728">https://blog.csdn.net/sinat_25923849/article/details/110232728</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>OpenCPN</tag>
      </tags>
  </entry>
  <entry>
    <title>【小沐学GIS】电子海图OpenCPN源代码编译和运行（VS2017 + Win10）</title>
    <url>/2023/11/07/%E3%80%90%E5%B0%8F%E6%B2%90%E5%AD%A6GIS%E3%80%91%E7%94%B5%E5%AD%90%E6%B5%B7%E5%9B%BEOpenCPN%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%EF%BC%88VS2017%20+%20Win10%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、简介<br>免费的开源海图仪和船用GPS导航软件</p>
<p><a href="https://opencpn.org/">https://opencpn.org/</a></p>
<p>1.1 OpenCPN概述<br>OpenCPN是一款自由软件（GPLv2），用于创建简洁的海图绘图仪和导航软件，可以在航行过程中使用或者作为计划工具。<br>OpenCPN提供大量免费海图下载，支持航线设计、航行监控，能接入GPS、AIS数据，能叠加雷达图像，还满足气象导航方面的要求，还有众多插件可供选择，且一直持续改进更新中。<br>OpenCPN由C++编写，遵从GPLv2协议，其源代码可以轻易的从github获取。</p>
<p>1.2 OpenCPN功能</p>
<p>2、下载和编译<br>OpenCPN由C++编写，遵从GPLv2协议，其源代码可以轻易的从github获取。在windows下编译方法windows下编译方法如下：<br><a href="https://opencpn.org/wiki/dokuwiki/doku.php?id=opencpn:developer_manual:developer_guide:compiling_windows">https://opencpn.org/wiki/dokuwiki/doku.php?id=opencpn:developer_manual:developer_guide:compiling_windows</a></p>
<p>2.1 Visual Studio 2017<br>安装Visual Studio 2017，添加C++及Windows XP C++功能。</p>
<p>下载<br><a href="https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/">https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/</a></p>
<p>2.2 Git<br>安装Git:<br><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>2.3 CMake<br>安装CMake:<br><a href="https://cmake.org/download/">https://cmake.org/download/</a></p>
<p>2.4 POedit<br>安装POedit，<br><a href="https://poedit.net/">https://poedit.net/</a></p>
<p>配置系统环境变量，在PATH中添加:</p>
<pre><code>C:\Program Files (x86)\Poedit\GettextTools\bin
</code></pre>
<p>2.5 wxWidgets<br>（1）方法一：源代码编译<br>获取wxWidgets 3.1.2源码并生成，使用VS2017 x86 Native Tools下的命令行，运行如下命令：</p>
<pre><code>cd C:\Users\tomcat\Desktop\test         //修改成自己的目录
git clone -b v3.1.2 https://github.com/wxWidgets/wxWidgets
cd wxWidgets
git submodule init
git submodule update

cd build\msw
nmake /f makefile.vc BUILD=release SHARED=1 CXXFLAGS=/D_USING_V141_SDK71_ CFLAGS=/D_USING_V141_SDK71_ LDFLAGS=/SUBSYSTEM:WINDOWS,5.01
nmake /f makefile.vc BUILD=debug SHARED=1 CXXFLAGS=/D_USING_V141_SDK71_ CFLAGS=/D_USING_V141_SDK71_ LDFLAGS=/SUBSYSTEM:WINDOWS,5.01

cd wxWidgets
git submodule init
git submodule update
</code></pre>
<p>设置环境变量wxWIDGETS_ROOT_DIR为wxWidgets 3.1.2源代码目录<br>将wxWidgets源代码目录下的路径lib\vc_dll\添加进系统变量。</p>
<p>（2）方法二：使用二进制文件<br><a href="https://github.com/wxWidgets/wxWidgets/releases?page=1">https://github.com/wxWidgets/wxWidgets/releases?page=1</a></p>
<p>下载头文件</p>
<p>下载库文件</p>
<p>设置环境变量</p>
<p>wxWIDGETS_ROOT_DIR：</p>
<pre><code>wxWIDGETS_ROOT_DIR=C:/Users/tomcat/Desktop/test/wxWidgets-3.1.2
</code></pre>
<p>wxWidgets_LIBRARIES：</p>
<pre><code>wxWidgets_LIBRARIES=C:\Users\tomcat\Desktop\test\wxMSW-3.1.2_vc141_Dev\lib\vc141_dll
</code></pre>
<p>2.6 OpenCPN<br>下载 OpenCPN源码：<br><a href="https://github.com/OpenCPN/OpenCPN/releases?q=5.0.0&amp;expanded=true">https://github.com/OpenCPN/OpenCPN/releases?q=5.0.0&amp;expanded=true</a></p>
<p>解压之后：</p>
<p>下载 预编译Windows依赖 - OpenCPN_buildwin-4.99a.7z，<br><a href="https://download.opencpn.org/s/oibxM3kzfzKcSc3/download">https://download.opencpn.org/s/oibxM3kzfzKcSc3/download</a><br>然后解压到C:\Users\tomcat\Desktop\test\OpenCPN-5.0.0\buildwin目录下。</p>
<pre><code>cd C:\Users\tomcat\Desktop\test\OpenCPN-5.0.0
mkdir build
cd build
cmake -G &quot;Visual Studio 15 2017&quot; -T v141_xp ..
cmake --build .
cmake --build . --config release
cmake --build . --config release --target package
</code></pre>
<p>编译过程中，会出现一些错误。例如“正体字”改成“zhengti”即可等。<br>下载 Copyfiles.bat.doc，并删去后缀名 .doc移动到\xx\OpenCPN\下面后执行copyfiles.bat（这步不做可能还是会缺几个dll）。<br><a href="https://opencpn.org/wiki/dokuwiki/lib/exe/fetch.php?media=opencpn:dev:copyfiles.bat.doc">https://opencpn.org/wiki/dokuwiki/lib/exe/fetch.php?media=opencpn:dev:copyfiles.bat.doc</a></p>
<pre><code>C:\Users\tomcat\Desktop\test\OpenCPN-5.0.0\Copyfiles.bat
</code></pre>
<p>鼠标双击它，直接运行如下：</p>
<p>打开文件夹“C:\Users\tomcat\Desktop\test\OpenCPN-5.0.0\build\Debug”，发现OpenCPN编译成功。</p>
<p>3、运行<br>3.1 主界面<br>直接运行opencpn.exe。</p>
<p>3.2 绘制路线（Route）<br>鼠标右键选择菜单“New Route…”，开始创建路线操作；</p>
<p>创建多段路线如下：</p>
<p>3.3 切换地图底色</p>
<p>3.4 距离测量<br>鼠标右键选择菜单“Measure”，开始距离测量操作；</p>
<p>鼠标右键选择菜单“Measure Off”，结束距离测量操作；</p>
<p>3.5 添加图表<br>将下载好的图表数据放在文件夹里“D:\Program Files (x86)\OpenCPN\data”：</p>
<p>然后通过界面更新按钮“Prepare all ENC Charts”。</p>
<p>更新过程中如下：</p>
<p>更新完成如下：</p>
<p>————————————————<br>版权声明：本文为CSDN博主「爱看书的小沐」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hhy321/article/details/134486900">https://blog.csdn.net/hhy321/article/details/134486900</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>OpenCPN</tag>
      </tags>
  </entry>
  <entry>
    <title>省市区数据分享</title>
    <url>/2023/11/06/%E7%9C%81%E5%B8%82%E5%8C%BA%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>省市区数据采集并标注拼音、坐标和边界范围<br>【在线测试和预览】省市区乡镇四级行政区划数据：支持在线生成JSON、多级联动js；<br>【在线测试和预览】ECharts Map四级下钻在线测试和预览+代码生成：坐标边界范围在线测试和预览；<br>【转换工具】AreaCity-Geo格式转换工具软件：csv文件导入数据库，坐标、边界范围转换（支持转成sql、shp、geojson）；<br>【查询工具】AreaCity-Query-Geometry（Gitee镜像库）：高性能的坐标数据、边界数据查询工具，Java开源程序、带http查询接口，内存占用低（1秒可查1万个以上坐标对应的城市信息）。</p>
<p><a href="https://www.cnblogs.com/xiangyuecn/p/17101051.html">https://www.cnblogs.com/xiangyuecn/p/17101051.html</a><br><a href="https://gitee.com/xiangyuecn/AreaCity-JsSpider-StatsGov">https://gitee.com/xiangyuecn/AreaCity-JsSpider-StatsGov</a></p>
<h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><p>当前最新版本：2023.230831.231211版，更新于2023-12-11，整合了 统计局2023-09-11、民政部2023-04-23、腾讯地图行政区划2023-08-31、高德地图行政区划采集当天 数据。</p>
<p>【区划三级】省市区 三级行政区划 数据<br>【区划四级】省市区乡镇 四级行政区划 数据</p>
<ul>
<li>支持在线预览，在线生成JSON、多级联动js代码</li>
<li>可用转换工具导入数据库、转成sql    线路一 / 线路二<br>【边界三级】省市区 坐标和边界 数据，解压后130M+</li>
<li>支持在线预览，可用转换工具转成shp、geojson、sql格式、转换坐标系</li>
<li>使用本库开源的高性能查询工具，1秒可查1万个以上坐标对应的城市信息    线路一 / 线路二<br>边界四级】乡镇级 坐标和边界 数据，导出后300M+</li>
<li>付费数据、广告、闭源，支持在线预览，提供了部分免费数据供测试    点此下载<br>如果上面线路一和线路二都无法下载：可以到 Gitee Releases 下载，或到 GitHub Releases 下载最新发布数据文件。</li>
</ul>
<p>csv纯文本文件可以非常方便解析成其他格式；如果在使用csv文件过程中出现乱码、错乱等情况，需自行调对utf-8（带BOM）编码，文本限定符为”。</p>
<p>通过本库提供的 AreaCity-Geo格式转换工具 可快速方便的将行政区划、坐标、边界范围csv文件导入数据库，并且提供格式转换功能（shp、geojson、sql），欢迎下载使用。边界导出成geojson后可通过 AreaCity-Query-Geometry Java开源程序进行高性能的坐标数据、边界数据查询。</p>
<h1 id="Git仓库和存档"><a href="#Git仓库和存档" class="headerlink" title="Git仓库和存档"></a>Git仓库和存档</h1><p>由于仓库内的历史记录数据可能会很大，可以加上–depth 1提取最新版的数据即可。</p>
<pre><code>//Gitee镜像仓库: 速度快
git clone --depth 1 https://gitee.com/xiangyuecn/AreaCity-JsSpider-StatsGov.git

//源GitHub仓库: 可能比较慢或无法访问
git clone --depth 1 https://github.com/xiangyuecn/AreaCity-JsSpider-StatsGov.git
</code></pre>
<p>每当仓库增长到一定大小后，本仓库将会进行存档处理，同时将历史记录中的大文件进行清理，这将导致一些文件之前的历史丢失，请到存档仓库查阅更早的历史记录</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS最小安装</title>
    <url>/2023/11/05/CentOS%E6%9C%80%E5%B0%8F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、将安装光盘插入服务器，开机时会读取系统安装程序，选择Install CentOS 7</p>
<p>2、安装过程是图形界面,可以选择熟悉的语言执行安装程序</p>
<p>3、选择SECURITY POLICY(安全策略)将其关闭</p>
<p>4、把KDUMP(内核崩溃转储机制)也进行关闭</p>
<p>5、接着配置网络,服务器的网线是已经连接好的</p>
<p>打开以太网连接</p>
<p>将IPv6设置 忽略</p>
<p>配置好地址,搜索域是这台主机的网络地址.</p>
<p>主机名也是网络标识,修改一下.</p>
<p>可以打开新的TTY终端,进行网络的连通性测试.</p>
<p>6、硬盘分区</p>
<p>boot引导到分区根据系统进行配置,swap分区根据内存大小而定.</p>
<p>7、时间配置</p>
<p>选择时区,可以将网络时间打开.</p>
<p>8、选择所安装的系统类型</p>
<p>选择最小安装,将一些开发工具勾选.</p>
<p>9、开始安装</p>
<p>安装前配置好了,选择开始安装.</p>
<p>10、给ROOT配置密码</p>
<p>11、安装完成</p>
<p>安装成功,重启进入系统.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7使用rpm离线安装PostgreSQL</title>
    <url>/2023/11/04/Centos7%E4%BD%BF%E7%94%A8rpm%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85PostgreSQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>使用一台能够联网的centos电脑</p>
<p>安装postgresql源</p>
<pre><code>yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm
</code></pre>
<p>安装 yumdownloader工具</p>
<pre><code>yum install yum-utils -y
</code></pre>
<p>Yumdownloader是一款简单，但是却十分有用的命令行工具，<em>它可以一次性下载任何 RPM 软件包及其所有依赖包</em>。</p>
<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><h2 id="下载离线包"><a href="#下载离线包" class="headerlink" title="下载离线包"></a>下载离线包</h2><p>postgresql14-server</p>
<pre><code>yumdownloader --resolve postgresql14-server
</code></pre>
<p>postgresql14</p>
<pre><code>yumdownloader --resolve postgresql14
</code></pre>
<p>这里我们需要的是 postgresql14-server的相关依赖，可看到postgresql14-server的依赖包含了postgresql14客户端的依赖</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><pre><code>rpm -ivh libicu-50.2-4.el7_7.x86_64.rpm postgresql14-libs-14.10-1PGDG.rhel7.x86_64.rpm postgresql14-14.10-1PGDG.rhel7.x86_64.rpm postgresql14-server-14.10-1PGDG.rhel7.x86_64.rpm 
</code></pre>
<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>默认初始化</p>
<pre><code># 默认初始化数据库
sudo /usr/pgsql-14/bin/postgresql-14-setup initdb
</code></pre>
<p>开机启动postgresql数据库</p>
<pre><code>sudo systemctl enable postgresql-14
</code></pre>
<p>启动postgresql数据库服务</p>
<pre><code>sudo systemctl start postgresql-14
</code></pre>
<p>启动成功后，使用lsof -i:5432 可以看见相关进程</p>
<p>修改初始化数据路径</p>
<pre><code>mkdir -p /home/pg14/data
chown -R postgres:postgres /home/pg14/data
</code></pre>
<p>这里使用systemctl ：</p>
<pre><code>systemctl edit postgresql-14.service
</code></pre>
<p>在新空白页覆盖原服务配置</p>
<pre><code>[Service]
Environment=PGDATA=/home/pg14/data
</code></pre>
<p>这个文件默认放在 /etc/systemd/system/postgresql-14.service.d 目录下。<br>里面会有 override.conf 文件。</p>
<p>停止之前的数据库</p>
<pre><code>systemctl stop postgresql-14
</code></pre>
<p>启动数据库</p>
<pre><code>sudo /usr/pgsql-14/bin/postgresql-14-setup initdb
</code></pre>
<p>查看日志</p>
<pre><code>more /var/lib/pgsql/14/initdb.log
</code></pre>
<p>修改数据位置后，原先默认的配置文件就失效了，配置文件在新的数据文件夹下，这里是/home/pg14/data</p>
<p>修改默认用户密码</p>
<pre><code>#登陆postgresql
sudo -u postgres psql

#修改i登陆postgresql密码
alter user postgres with password &#39;postgres&#39;;

#查看数据库存储地址
show data_directory;
</code></pre>
<p>开启远程访问</p>
<p>修改数据文件目录的postgresql.conf配置文件，监听全部IP命令</p>
<pre><code>vi /home/pg14/data/postgresql.conf
listen_addresses = &#39;*&#39; 
</code></pre>
<p>允许远程访问，修改pg_hba.conf</p>
<pre><code>vi /home/pg14/data/pg_hba.conf

# TYPE  DATABASE        USER            ADDRESS                 METHOD

# &quot;local&quot; is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
host    all             all             0.0.0.0/0                 md5
# IPv6 local connections:
host    all             all             ::1/128                 trust
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                                     trust
host    replication     all             127.0.0.1/32            trust
host    replication     all             ::1/128                 trust
</code></pre>
<p>重启启动postgresql数据库服务</p>
<pre><code>sudo systemctl restart postgresql-14
</code></pre>
<h1 id="安裝PostGIS"><a href="#安裝PostGIS" class="headerlink" title="安裝PostGIS"></a>安裝PostGIS</h1><h2 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h2><p>EPEL存储库中有许多依赖项</p>
<pre><code>yumdownloader --resolve epel-release
</code></pre>
<p>下载指定版本的postgis，这里我选用pg14的3.3版本</p>
<pre><code>yumdownloader --resolve postgis33_14
</code></pre>
<p>下载的依赖很多</p>
<h2 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h2><pre><code># 安装epel
rpm -ivh epel-release-7-11.noarch.rpm

# 安装当前目录下的所有rpm包（推荐）
rpm -Uvh  *.rpm

# 强制安装当前文件夹中所有的rpm包，忽略依赖去安装（这是上一步的备选方案，不推荐）
rpm -Uvh  *.rpm  --nodeps  --force 
</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>-- 创建数据库
CREATE DATABASE db_test;
-- 切换数据库
\c db_test;
-- 创建postgis依赖
CREATE EXTENSION postgis;
</code></pre>
<p>创建PostGIS扩展成功后、查看数据库插件</p>
<pre><code>\dx
</code></pre>
<p>本文来自互联网用户投稿，该文观点仅代表作者本人，不代表本站立场。本站仅提供信息存储空间服务，不拥有所有权，不承担相关法律责任。如若转载，请注明出处：<a href="http://www.bryh.cn/a/16064.html">http://www.bryh.cn/a/16064.html</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>PostGIS</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7下安装Mysql8</title>
    <url>/2023/11/03/Centos7%E4%B8%8B%E5%AE%89%E8%A3%85Mysql8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MySQL是一个流行的开源关系型数据库管理系统，本教程将向您展示如何在Linux系统上安装MySQL 8.1.0版本。请按照以下步骤进行操作：</p>
<p>1、下载MySQL安装包</p>
<p>官方下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p>
<p>首先，从MySQL官方网站或镜像站点下载MySQL 8.1.0的压缩包mysql-8.1.0-linux-glibc2.28-x86_64.tar.xz。确保下载的文件与您的Linux系统架构相匹配。</p>
<p>2、安装依赖</p>
<pre><code>sudo yum install libaio
</code></pre>
<p>3、上传、解压缩安装包</p>
<p>使用以下命令解压缩下载的安装包：</p>
<pre><code>tar -xf mysql-8.1.0-linux-glibc2.28-x86_64.tar.xz
</code></pre>
<p>4、移动MySQL目录</p>
<p>解压缩后，将MySQL目录移动到适当的位置。通常，您可以将其移动到/usr/local目录下：</p>
<pre><code>sudo mv mysql-8.1.0-linux-glibc2.28-x86_64 /usr/local/mysql
</code></pre>
<p>5、编辑my.cnf文件</p>
<pre><code>vim /etc/my.cnf

[mysqld]
basedir = /usr/local/mysql
datadir = /usr/local/mysql/data
socket = /usr/local/mysql/mysql.sock
character-set-server=utf8
port = 3306
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
lower_case_table_names=1

[client]
socket = /usr/local/mysql/mysql.sock
default-character-set=utf8
</code></pre>
<p>6、初始化MySQL数据目录<br>在安装MySQL之前，需要初始化MySQL数据目录。首先，创建一个用于存储数据的目录，例如：</p>
<pre><code>sudo mkdir -p /usr/local/mysql/data
</code></pre>
<p>7、创建 mysql 用户组和 mysql 用户</p>
<pre><code>groupadd mysql
useradd -g mysql mysql
chown -R mysql.mysql /usr/local/mysql/
</code></pre>
<p>接下来，使用mysqld命令初始化MySQL数据目录：</p>
<pre><code>sudo /usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
</code></pre>
<p>记录好自己的临时密码</p>
<p>8、建立MySQL服务</p>
<pre><code>cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
chmod +x /etc/init.d/mysql
</code></pre>
<p>9、添加到系统服务</p>
<pre><code>cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
chmod +x /etc/rc.d/init.d/mysqld    
chkconfig --add mysqld
</code></pre>
<p>添加到开启启动项</p>
<pre><code>sudo systemctl enable mysqld
</code></pre>
<p>检查服务是否生效</p>
<pre><code>chkconfig  --list mysqld
</code></pre>
<p>10、添加到PATH环境变量</p>
<p>配置全局环境变量 编辑 / etc/profile 文件</p>
<pre><code>vi /etc/profile
</code></pre>
<p>在 profile 文件底部添加如下两行配置，保存后退出</p>
<pre><code>export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH
</code></pre>
<p>设置环境变量立即生效</p>
<pre><code>source /etc/profile
</code></pre>
<p>然后，重新加载配置文件或重新启动终端，使更改生效。</p>
<p>11、启动MySQL服务</p>
<p>启动MySQL服务：</p>
<pre><code>systemctl start mysql
</code></pre>
<p>停止MySQL服务：</p>
<pre><code>systemctl stop mysql
</code></pre>
<p>查看MySQL服务状态：</p>
<pre><code>systemctl status mysql
</code></pre>
<p>这将以后台进程的形式启动MySQL服务器。</p>
<p>12、设置MySQL root密码</p>
<p>首次启动MySQL后，您需要设置root用户的密码。使用以下命令进入MySQL命令行：</p>
<pre><code>mysql -uroot -p
</code></pre>
<p>在MySQL提示符下，运行以下命令设置root密码（将”your_new_password”替换为您想要的实际密码）：</p>
<pre><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_new_password&#39;;
</code></pre>
<p>13、设置可以远程登录</p>
<p>先登录mysql，在mysql里操作</p>
<pre><code>use mysql
update user set host=&#39;%&#39; where user=&#39;root&#39; limit 1;
</code></pre>
<p>刷新权限</p>
<pre><code>flush privileges;
</code></pre>
<p>恭喜！您已经在Linux系统上成功安装并初始化了MySQL 8.1.0版本。现在可以开始使用MySQL进行数据库操作。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「Terence全栈开发」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_39997939/article/details/131993593">https://blog.csdn.net/qq_39997939/article/details/131993593</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Linux</tag>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7开放端口-iptables</title>
    <url>/2023/11/02/Centos7%E5%BC%80%E6%94%BE3306%E7%AB%AF%E5%8F%A3-iptables/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CentOS防火墙也可以还原传统的管理方式使用 iptables</p>
<pre><code>systemctl stop firewalld  
systemctl mask firewalld  
</code></pre>
<p>安装 iptables-services</p>
<pre><code>yum install iptables-services  
</code></pre>
<p>设置开机启动</p>
<pre><code>systemctl enable iptables
</code></pre>
<p>操作命令</p>
<pre><code>systemctl stop iptables  
systemctl start iptables  
systemctl restart iptables  
systemctl reload iptables 
</code></pre>
<p>保存设置</p>
<pre><code>service iptables save
</code></pre>
<p>开放某个端口<br>在 /etc/sysconfig/iptables 里添加</p>
<pre><code>-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「十&amp;年」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xubenxismile/article/details/107835931">https://blog.csdn.net/xubenxismile/article/details/107835931</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>NGINX</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio 编译器警告：该文件包含不能在当前代码页（936）中表示的字符。</title>
    <url>/2023/11/01/Visual%20Studio%20%E7%BC%96%E8%AF%91%E5%99%A8%E8%AD%A6%E5%91%8A%EF%BC%9A%E8%AF%A5%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%BD%93%E5%89%8D%E4%BB%A3%E7%A0%81%E9%A1%B5%EF%BC%88936%EF%BC%89%E4%B8%AD%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Visual Studio 编译器警告：该文件包含不能在当前代码页（936）中表示的字符。 以 Unicode 格式保存该文件防止数据丢失。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在利用Visual Studio编译FreeType时，编译器报警告C4819：该文件包含不能在当前代码页（936）中表示的字符。 以 Unicode 格式保存该文件防止数据丢失。一般来说这种警告应该无伤大雅，忽视即可，但按FreeType的开发者们的说法，他们写的代码在编译时应该是一个警告都不会有：</p>
<p>FreeType is written in industry-standard ANSI C and should compile easily with any compliant C or C++ compiler. We have even taken great care to eliminate all warnings when compiling with popular compilers like gcc, Visual C++, and Borland C++.<br>这勾起了我的好奇心，我想弄清楚如何以一种较为合理（优雅）的方式去消除这个警告。</p>
<h1 id="分析与解决"><a href="#分析与解决" class="headerlink" title="分析与解决"></a>分析与解决</h1><p>按微软官方文档的说法：</p>
<p>在不能表示文件中所有字符的代码页的系统上编译 ANSI 源文件时，出现 C4819。<br>C4819 occurs when you compile an ANSI source file on a system using a codepage that can’t represent all characters in the file.<br>代码页（code page）是一类字符的编码方案，编号为936的代码页对应的字符编码为GB2312（参见 Code Page Identifiers - Win32 apps | Microsoft Learn），所以我遇到的问题是：我的编程环境所用的编码是GB2312, 但我编译的源文件中却含有不能用GB2312表示的字符。按官方文档的说法，有如下三种解决方案：</p>
<h2 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h2><p>将源文件里不能用GB2312表示的字符给删了，因为这种字符往往仅出现在注释中，删掉对编译没有什么影响。这种做法有些许简单粗暴，且仅适合用在不能表示的字符数量较少的情境中，不够优雅。</p>
<h2 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h2><p>将源文件以Unicode格式保存，具体操作如下：</p>
<p>在 Visual Studio 中，选择“文件”&gt;“另存为”。 在“将文件另存为”对话框中，选择“保存”按钮旁的下拉菜单，然后选择“保存时使用编码”。 如果保存到同一文件名，可能需要确认要替换该文件。 在“高级保存选项”对话框中，选择可表示该文件中所有字符的编码（例如，Unicode（带签名的 UTF-8）- Codepage 65001，然后选择“确定”。<br>不过我下载的FreeType源码应该本身就是以Unicode格式进行编码的，所以貌似不应该是这种解决方案。事实上这种方案也并没有解决该编译器警告问题。</p>
<h2 id="方案3："><a href="#方案3：" class="headerlink" title="方案3："></a>方案3：</h2><p>将系统代码页设置为支持源代码使用的字符集，简单来说，就是让我们的Windows系统支持使用Unicode编码的字符。我认为这应该是最优雅的解决方式，毕竟作为程序员，Unicode与UTF-8应该是必须要熟悉与运用的，于情于理要让我们使用的系统支持使用Unicode。</p>
<p>这里提一嘴Unicode与UTF-8的关系：Unicode标准定义的是一个字符到一个整数的映射关系，也就是将一个字符用一个数字进行唯一的编号；而UTF-8则可以看作Unicode在计算机中的实现，如何将这个整数用一个合适的01序列进行编码并储存在计算机中，就是UTF-8干的事；UTF-16也是Unicode的一种实现，但感觉还是UTF-8的应用更广泛一些。</p>
<p>设置方法：Windows 设置&gt;时间&amp;语言&gt;区域&gt;管理语言设置&gt;更改系统区域设置，勾选Beta 版：使用 Unicode UTF-8 获取全球语言支持，然后要重启一下电脑，使更改生效。(图示版见封面)</p>
<p>方案3成功解决了我的问题，不过根据评论区的建议，谨慎采用.</p>
<h2 id="方案4："><a href="#方案4：" class="headerlink" title="方案4："></a>方案4：</h2><p>编译时，设置VC项目中的C/C++命令行 -&gt;其他选项，增加 /utf-8</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>终端通讯规约类型</title>
    <url>/2023/10/31/%E7%BB%88%E7%AB%AF%E9%80%9A%E8%AE%AF%E8%A7%84%E7%BA%A6%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.techphant.cn/blog/2305.html">https://www.techphant.cn/blog/2305.html</a><br>终端通讯规约类型<br>作者： 技象物联网 / 行业百科 / 通信系统, 通讯规约 / 2023年9月16日 09:45:01</p>
<p>终端通讯规约类型是一种用来控制和管理计算机网络上的数据传输的标准。它定义了发送和接收方如何在网络上传输数据，以及传输的数据格式、编码和传输时间。终端通讯规约类型可以帮助网络管理员更容易地管理网络，并且可以帮助网络用户更容易地使用网络。</p>
<p>终端通讯规约类型关键词</p>
<p>1.信息格式<br>信息格式是指网络上传输的数据的格式，它可以是文本、图像、声音或视频等。网络上的数据传输必须遵循一定的格式，以便发送方和接收方能够正确地识别和处理数据。</p>
<p>2.编码方式<br>编码方式是指将信息转换成数字或字符码的方式。编码是为了使信息能够被网络传输，使发送方和接收方能够正确地识别和处理信息。</p>
<p>3.传输时间<br>传输时间是指网络上传输数据的时间。它可以是实时传输，也可以是延迟传输。网络上传输数据的传输时间取决于网络带宽、网络负载和网络延迟等因素。</p>
<p>总结<br>终端通讯规约类型是一种用来控制和管理计算机网络上的数据传输的标准。它定义了发送和接收方如何在网络上传输数据，以及传输的数据格式、编码和传输时间。终端通讯规约类型包括信息格式、编码方式和传输时间等关键词，它们可以帮助网络管理员更容易地管理网络，并且可以帮助网络用户更容易地使用网络。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>通信规约类型</title>
    <url>/2023/10/30/%E9%80%9A%E4%BF%A1%E8%A7%84%E7%BA%A6%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.techphant.cn/blog/29755.html">https://www.techphant.cn/blog/29755.html</a><br>通信规约有哪几种？<br>作者： 技象物联网 / 行业百科 / 通信系统, 通讯规约 / 2023年9月16日 16:06:28</p>
<p>随着科技的发展，人们对通信技术的需求越来越高，而为了保证通信的顺利进行，必须要有一套完善的通信规约。通信规约是指在通信过程中，双方必须遵守的规则，以确保通信的顺利进行。本文将为您介绍通信规约有哪几种，以及它们之间的区别。</p>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>OSI(Open System Interconnection)参考模型是由国际标准化组织(ISO)提出的一种通用的通信模型。它将通信过程分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层都有自己的功能，它们之间的协调可以保证数据在不同的网络系统之间传输的顺利进行。</p>
<p>物理层<br>物理层是OSI参考模型中的第一层，它主要负责定义通信系统的物理连接，包括电缆、接口设备和电缆连接等。它还负责确定每个节点之间的数据传输方式，以及控制信号的传输速率。</p>
<p>数据链路层<br>数据链路层是OSI参考模型中的第二层，它主要负责检测和纠正传输中出现的错误，以及确定数据传输的最佳路径。它还负责定义数据帧的格式，以及控制帧的传输顺序。</p>
<p>网络层<br>网络层是OSI参考模型中的第三层，它主要负责确定数据在网络中的传输路径，以及确定数据包的传输顺序。它还负责确定网络中的数据传输协议，以及管理网络中的路由器和网关等。</p>
<p>传输层<br>传输层是OSI参考模型中的第四层，它主要负责确保数据在网络中的可靠传输，以及确定数据传输的最佳路径。它还负责确定发送端和接收端之间的连接，以及确定数据传输的协议。</p>
<p>会话层<br>会话层是OSI参考模型中的第五层，它主要负责管理发送端和接收端之间的会话，以及确定会话的开始和结束。它还负责确定会话的控制信息，以及确定会话中的数据传输方式。</p>
<p>表示层<br>表示层是OSI参考模型中的第六层，它主要负责将数据转换成可以在网络中传输的格式，以及将传输的数据转换成可读的格式。它还负责确定数据的编码方式，以及将数据进行压缩等。</p>
<p>应用层<br>应用层是OSI参考模型中的第七层，它主要负责实现用户和网络之间的交互，以及提供网络应用程序所需的服务。它还负责确定应用程序的协议，以及确定应用程序之间的数据传输方式。</p>
<h1 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h1><p>TCP/IP参考模型是由美国国防部提出的一种通用的通信模型。它将通信过程分为4层，分别是应用层、传输层、网络层和数据链路层。每一层都有自己的功能，它们之间的协调可以保证数据在不同的网络系统之间传输的顺利进行。</p>
<p>应用层<br>应用层是TCP/IP参考模型中的第一层，它主要负责实现用户和网络之间的交互，以及提供网络应用程序所需的服务。它还负责确定应用程序的协议，以及确定应用程序之间的数据传输方式。</p>
<p>传输层<br>传输层是TCP/IP参考模型中的第二层，它主要负责确保数据在网络中的可靠传输，以及确定数据传输的最佳路径。它还负责确定发送端和接收端之间的连接，以及确定数据传输的协议。</p>
<p>网络层<br>网络层是TCP/IP参考模型中的第三层，它主要负责确定数据在网络中的传输路径，以及确定数据包的传输顺序。它还负责确定网络中的数据传输协议，以及管理网络中的路由器和网关等。</p>
<p>数据链路层<br>数据链路层是TCP/IP参考模型中的第四层，它主要负责检测和纠正传输中出现的错误，以及确定数据传输的最佳路径。它还负责定义数据帧的格式，以及控制帧的传输顺序。</p>
<p>总结<br>通信规约是指在通信过程中，双方必须遵守的规则，以确保通信的顺利进行。OSI参考模型是由国际标准化组织(ISO)提出的一种通用的通信模型，它将通信过程分为7层，TCP/IP参考模型是由美国国防部提出的一种通用的通信模型，它将通信过程分为4层。以上就是有关通信规约有哪几种的介绍，希望</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>通信规约的内容和要求</title>
    <url>/2023/10/29/%E9%80%9A%E4%BF%A1%E8%A7%84%E7%BA%A6%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.techphant.cn/blog/2307.html">https://www.techphant.cn/blog/2307.html</a><br>通信规约有哪些内容和要求？<br>作者： 技象物联网 / 行业百科 / 通信系统, 通讯规约 / 2023年5月28日 23:39:29<br>通信规约是指在计算机网络中用于数据交换的一种协议规范。它定义了数据传输的格式、数据包的分组方式、错误检测和纠正等方面的细节。本文将介绍通信规约的内容和要求，以及它在计算机网络中的重要性。</p>
<p>一、通信规约的内容</p>
<p>通信规约包括以下几个方面：<br>1、数据传输格式：定义了数据在网络中传输时所采用的格式，比如二进制、十进制等。这个格式需要被所有设备所识别和支持。<br>2、数据分组方式：为了更高效地利用网络资源，通信规约将数据分成一个个小包进行传输，并通过头部信息进行标识。这样可以避免因为网络拥塞而导致整个数据包丢失或无法传输。<br>3、错误检测与纠正：由于网络传输过程中会出现各种各样的错误，比如噪声干扰、丢失等问题，因此需要通过差错检测和纠正机制来保证数据的可靠性。常见的差错检测方法有CRC校验和、异或校验等。<br>4、网络协议：指计算机之间进行交流时所遵循的一套规则。这些规则定义了计算机之间通信的方式，包括数据传输、数据分组和错误检测等方面。<br>无线通信</p>
<p>二、通信规约的要求</p>
<p>通信规约需要满足以下几个要求：<br>1、可靠性：通信规约需要保证数据传输的可靠性，即在传输过程中不会出现数据丢失或错误。<br>2、高效性：通信规约需要尽可能地提高网络的利用率，减少网络拥塞和延迟。<br>3、灵活性：通信规约需要能够适应不同的网络环境和需求，并具有一定的可扩展性和兼容性。<br>4、安全性：通信规约需要保证数据传输过程中的安全性，防止信息泄露、篡改等问题。</p>
<p>三、通信规约在计算机网络中的重要性</p>
<p>通信规约是计算机网络中最基本、最重要的组成部分之一。它不仅关乎到数据传输的可靠性和效率，还涉及到计算机系统安全等方面。以下是它在计算机网络中的重要作用：<br>1、保证数据传输的可靠性：通过差错检测和纠正机制来保证数据在传输过程中不会出现错误或丢失。<br>2、提高网络效率：通过数据分组和头部信息标识等方式来提高网络的利用率，减少网络拥塞和延迟。<br>3、保障计算机系统安全：通过加密、身份验证等手段来保证数据传输过程中的安全性，防止信息泄露、篡改等问题。<br>4、支持不同的应用程序和服务：通信规约可以适应不同的应用程序和服务需求，如电子邮件、文件传输、视频会议等。</p>
<p>本文介绍了通信规约的内容、要求及其在计算机网络中的重要性。通信规约是计算机网络中最基本、最重要的组成部分之一，它关乎到数据传输的可靠性和效率，还涉及到计算机系统安全等方面。因此，在设计和实现计算机网络时，需要充分考虑通信规约的作用，并根据具体需求选择合适的协议。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>通信规约与协议的区别和联系</title>
    <url>/2023/10/28/%E9%80%9A%E4%BF%A1%E8%A7%84%E7%BA%A6%E4%B8%8E%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.techphant.cn/blog/2305.html">https://www.techphant.cn/blog/2305.html</a><br>通信规约与协议的区别和联系？<br>作者： 技象物联网 / 行业百科 / 通信系统, 通讯规约 / 2023年5月28日 23:34:29</p>
<p>在计算机网络中，通信规约和协议是两个非常重要的概念。它们都是用于确保计算机之间的正常通信和数据传输的工具，但它们之间有着一些区别和联系。本文将会对这些问题做出详细解释。</p>
<p>一、通信规约</p>
<p>通信规约是指在计算机网络中，数据传输所遵循的具体规范和标准。它包括了数据格式、传输速率、传输距离、错误检测等方面的要求。通信规约不仅适用于计算机网络，还适用于其他各种类型的通信系统。</p>
<p>通信规约的主要作用是确保不同设备之间可以正常地进行数据交换和信息共享。由于不同设备之间可能存在着硬件或软件上的差异，因此需要制定统一的规范来保证它们之间能够相互兼容和交互。</p>
<p>二、协议</p>
<p>协议是指在计算机网络中，不同设备之间进行通信所必须遵循的一套规则和标准。协议包括了数据格式、传输方式、错误处理等方面的内容。与通信规约不同，协议更加注重不同设备之间进行交互时所必须遵循的行为准则。</p>
<p>协议的主要作用是确保不同设备之间可以进行有效的通信和数据传输。在计算机网络中，协议可以分为两种类型：传输层协议和应用层协议。传输层协议用于确保数据在网络中的可靠性和完整性，而应用层协议则负责处理特定类型的数据。</p>
<p>三、区别与联系</p>
<p>通信规约和协议都是在计算机网络中使用的一套规范和标准，但它们之间存在着一些区别和联系。</p>
<p>首先，通信规约更加注重数据传输的技术细节，包括了数据格式、传输速率、传输距离、错误检测等方面。而协议更加注重不同设备之间进行交互时所必须遵循的行为准则。</p>
<p>其次，通信规约是为了确保不同设备之间能够相互兼容和交互而制定的一套标准。而协议则是为了确保不同设备之间可以进行有效的通信和数据传输而制定的一套规则。</p>
<p>最后，通信规约往往具有较高的普适性，在各种不同类型的通信系统中都可以使用。而协议则更加具有针对性，在特定领域或特定应用中使用。</p>
<p>总的来说，通信规约和协议都是计算机网络中非常重要的工具。它们在不同的层次上确保了计算机之间的正常通信和数据传输，同时也为计算机网络的发展提供了支持和保障。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Python图像处理程序知识笔记</title>
    <url>/2023/10/27/Python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-1-读取文件函数"><a href="#3-1-读取文件函数" class="headerlink" title="3.1 读取文件函数"></a>3.1 读取文件函数</h1><p>PyQt中QFileDialog常用来打开保存文件或打开文件对话框，允许用户选择本地文件或者文件夹，</p>
<p>常用方法有：</p>
<p>QFileDialog.getOpenFileName()    #获取一个打开文件的文件名<br>QFileDialog.getOpenFileNames()   #获取多个打开文件的文件名<br>QFileDialog.getExistingDirectory()  #获取打开文件夹的文件名<br>QFileDialog.getOpenFileUrl()     #获取一个打开文件的统一资源定位符<br>QFileDialog.getOpenFileUrls()    #获取多个打开文件的统一资源定位符<br>QFileDialog.getSaveFileName()    #获取保存的文件名<br>QFileDialog.getSaveFileUrl()     #获取保存的url</p>
<h2 id="3-1-1-打开本地图片"><a href="#3-1-1-打开本地图片" class="headerlink" title="3.1.1 打开本地图片"></a>3.1.1 打开本地图片</h2><p>QFileDialog.getOpenFileName()返回值有两个，第一个是选择文件的文件名（文件路径），我们可以通过这个文件名打开本地文件，第二个是选择文件的类型。</p>
<p>输入有4个参数，第一个参数一般是self，第2个参数是弹出框的标题，第3个参数是打开对话框的默认地址，第4个参数是过滤字符串，一般用来限制文件类型，定义打开文件下拉框中的可选列表，并且不同的文件类型用两个分号;;隔开。</p>
<pre><code># 选择本地图片上传
def openImage(self):
global imgNamepath  # 这里为了方便别的地方引用图片路径，将其设置为全局变量

# 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型
# QFileDialog就是系统对话框的那个类第一个参数是上下文，第二个参数是弹框的名字，第三个参数是默认打开的路径，第四个参数是需要的格式

imgNamepath, imgType = QFileDialog.getOpenFileName(self.centralwidget, &quot;选择图片&quot;,
                                                   &quot;D:\\&quot;,&quot;*.jpg;;*.png;;All Files(*)&quot;)
# 通过文件路径获取图片文件，并设置图片长宽为label控件的长、宽
img = QtGui.QPixmap(imgNamepath).scaled(self.label_3.width(), self.label_3.height())

# 在label控件上显示选择的图片
self.label_3.setPixmap(img)

# 显示所选图片的路径
self.lineEdit_3.setText(imgNamepath)
</code></pre>
<h2 id="3-1-2-保存图片到本地"><a href="#3-1-2-保存图片到本地" class="headerlink" title="3.1.2 保存图片到本地"></a>3.1.2 保存图片到本地</h2><p>（1）保存图片到本地的第一种方式:首先把图片所在label控件截图，然后打开一个保存文件的弹出框，最后保存截图到选中的路径。</p>
<pre><code>def saveImage(self):
    screen = QApplication.primaryScreen()
    pix = screen.grabWindow(self.label_4.winId())
    fpath, ftype = QFileDialog.getSaveFileName(self.centralwidget, &quot;保存图片&quot;, &quot;d:\\&quot;, &quot;*.jpg;;*.png;;All Files(*)&quot;)
    pix.save(fpath)
</code></pre>
<p>（2）保存图片到本地的第二种方式:首先提取相对应Qlabel中的图片，然后打开一个保存文件的弹出框，最后保存图片到选中的路径。</p>
<pre><code>def saveImage(self):
    # 提取Qlabel中的图片
    img = self.label_4.pixmap().toImage()
    fpath, ftype = QFileDialog.getSaveFileName(self.centralwidget, &quot;保存图片&quot;, &quot;d:\\&quot;, &quot;*.jpg;;*.png;;All Files(*)&quot;)
    img.save(fpath)
</code></pre>
<p>以下函数读取文件函数在此实验没用到，只是用来记录</p>
<h2 id="3-1-3-打开文件夹"><a href="#3-1-3-打开文件夹" class="headerlink" title="3.1.3 打开文件夹"></a>3.1.3 打开文件夹</h2><pre><code># 打开文件夹（目录）
def openDirectory(self):
fd = QFileDialog.getExistingDirectory(self.centralwidget, &quot;选择文件夹&quot;, &quot;&quot;)

# 这里的label_directoryPath要根据项目替换成自己的组件
self.label_directoryPath.setText(fd)   
</code></pre>
<h2 id="3-1-4-打开本地文本文件并显示"><a href="#3-1-4-打开本地文本文件并显示" class="headerlink" title="3.1.4 打开本地文本文件并显示"></a>3.1.4 打开本地文本文件并显示</h2><pre><code># 选择文本文件上传
    def openTextFile(self):  # 选择文本文件上传
    fd, fp = QFileDialog.getOpenFileName(self.centralwidget, &quot;选择文件&quot;, &quot;d:\\&quot;, &quot;*.txt;;All Files(*)&quot;)
    f = open(fd, &#39;r&#39;)
    self.label_txt.setText(f.read())
    self.label_filePath.setText(fd)
    f.close()
</code></pre>
<h2 id="3-1-5-保存文本到本地"><a href="#3-1-5-保存文本到本地" class="headerlink" title="3.1.5 保存文本到本地"></a>3.1.5 保存文本到本地</h2><pre><code># 保存文本文件
def saveTextFile(self):
fd, fp = QFileDialog.getSaveFileName(self.centralwidget, &quot;保存文件&quot;, &quot;d:\\&quot;, &quot;*.txt;;All Files(*)&quot;)
f = open(fd, &#39;w&#39;)
f.write(self.label_txt.text())
f.close()
</code></pre>
<h2 id="3-1-6-Qimage转换为mat类型"><a href="#3-1-6-Qimage转换为mat类型" class="headerlink" title="3.1.6 Qimage转换为mat类型"></a>3.1.6 Qimage转换为mat类型</h2><pre><code># 将Qimage转换为mat类型
def qimage_to_mat(self,qimg):
ptr = qimg.consBits()
ptr.setsize(qimg.byteCount())
mat = np.array(ptr).reshape(qimg.height(),qimg.width(),4)   # 注意通道数要填4，否则报错
return mat
</code></pre>
<h1 id="3-2-关联函数"><a href="#3-2-关联函数" class="headerlink" title="3.2 关联函数"></a>3.2 关联函数</h1><pre><code># 按钮关联函数
self.pushButton_2.clicked.connect(self.openImage)
self.pushButton_3.clicked.connect(self.startAction)
self.pushButton_4.clicked.connect(self.saveImage)
</code></pre>
<p>注意函数名后面没有括号，和方法调用有点不一样self.openImage和self.openImage().</p>
<p>素描图像生成函数：</p>
<pre><code># 生成素描图
def startAction(self):
    img = cv2.imread(imgNamepath)
    img = cv2.resize(img, dsize=(768, 1080))
    # 图像转灰度图像
    gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # 灰度图像到反转灰度图像
    inverted_gray_image = 255 - gray_image
    # 模糊倒置灰度图像
    blurred_inverted_gray_image = cv2.GaussianBlur(inverted_gray_image, (19, 19), 0)
    # 反转模糊图像
    inverted_blurred_image = 255 - blurred_inverted_gray_image
    # 准备照片素描
    sketck = cv2.divide(gray_image, inverted_blurred_image, scale=256.0)
 
    path = &quot;D:\\python\\RRJ\\pycharmProject2\\zhanCunDiZhi\\&quot;
    # 因为不知道怎么将&lt;class &#39;numpy.ndarray&#39;&gt;转换为&lt;class &#39;PyQt5.QtGui.QPixmap&#39;&gt;类型，因此采用暂存再读出的方式
    cv2.imwrite(path + &#39;ZC.jpg&#39;, sketck)
    # pyqt5从路径读取图片
    imgShow = QPixmap(path + &#39;ZC.jpg&#39;)
    self.label_4.setScaledContents(True)
    self.label_4.setPixmap(imgShow)
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「༄༄小半生༅࿐」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_47682721/article/details/123928585">https://blog.csdn.net/m0_47682721/article/details/123928585</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PYQT5实现图片显示</title>
    <url>/2023/10/26/PYQT5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h1><p><a href="https://www.cnblogs.com/TM0831/p/12733571.html">https://www.cnblogs.com/TM0831/p/12733571.html</a></p>
<pre><code>import sys

from PyQt5.QtGui import QImageReader
from PyQt5.QtWidgets import QWidget, QApplication, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QFileDialog
from PyQt5.Qt import QPixmap, QPoint, Qt, QPainter, QIcon
from PyQt5.QtCore import QSize

class ImageBox(QWidget):
    def __init__(self):
        super(ImageBox, self).__init__()
        self.img = None
        self.scaled_img = None
        self.point = QPoint(0, 0)
        self.start_pos = None
        self.end_pos = None
        self.left_click = False
        self.scale = 1

    def init_ui(self):
        self.setWindowTitle(&quot;ImageBox&quot;)

    def set_image(self, img_path):
        &quot;&quot;&quot;
        open image file
        :param img_path: image file path
        :return:
        &quot;&quot;&quot;
        # img = QImageReader(img_path)
        # img.setScaledSize(QSize(self.size().width(), self.size().height()))
        # img = img.read()
        self.img = QPixmap(img_path)
        self.scaled_img = self.img

    def paintEvent(self, e):
        &quot;&quot;&quot;
        receive paint events
        :param e: QPaintEvent
        :return:
        &quot;&quot;&quot;
        if self.scaled_img:
            painter = QPainter()
            painter.begin(self)
            painter.scale(self.scale, self.scale)
            painter.drawPixmap(self.point, self.scaled_img)
            painter.end()

    def mouseMoveEvent(self, e):
        &quot;&quot;&quot;
        mouse move events for the widget
        :param e: QMouseEvent
        :return:
        &quot;&quot;&quot;
        if self.left_click:
            size = self.size().width()
            self.end_pos = e.pos() - self.start_pos
            self.point = self.point + self.end_pos
            self.start_pos = e.pos()
            self.repaint()

    def mousePressEvent(self, e):
        &quot;&quot;&quot;
        mouse press events for the widget
        :param e: QMouseEvent
        :return:
        &quot;&quot;&quot;
        if e.button() == Qt.LeftButton:
            self.left_click = True
            self.start_pos = e.pos()

    def mouseReleaseEvent(self, e):
        &quot;&quot;&quot;
        mouse release events for the widget
        :param e: QMouseEvent
        :return:
        &quot;&quot;&quot;
        if e.button() == Qt.LeftButton:
            self.left_click = False

class MainDemo(QWidget):
    def __init__(self):
        super(MainDemo, self).__init__()

        self.setWindowTitle(&quot;Image Viewer&quot;)
        self.setFixedSize(1000, 600)

        self.open_file = QPushButton(&quot;Open Image&quot;)
        self.open_file.setToolTip(&quot;Open the image to view.&quot;)
        self.open_file.clicked.connect(self.open_image)
        self.open_file.setFixedSize(150, 30)

        self.zoom_in = QPushButton(&quot;&quot;)
        self.zoom_in.clicked.connect(self.large_click)
        self.zoom_in.setFixedSize(30, 30)
        in_icon = QIcon(&quot;icons/zoomIn.png&quot;)
        self.zoom_in.setIcon(in_icon)
        self.zoom_in.setIconSize(QSize(30, 30))

        self.zoom_out = QPushButton(&quot;&quot;)
        self.zoom_out.clicked.connect(self.small_click)
        self.zoom_out.setFixedSize(30, 30)
        out_icon = QIcon(&quot;icons/zoomOut.png&quot;)
        self.zoom_out.setIcon(out_icon)
        self.zoom_out.setIconSize(QSize(30, 30))

        w = QWidget(self)
        layout = QHBoxLayout()
        layout.addWidget(self.open_file)
        layout.addWidget(self.zoom_in)
        layout.addWidget(self.zoom_out)
        layout.setAlignment(Qt.AlignLeft)
        w.setLayout(layout)
        w.setFixedSize(300, 50)

        self.box = ImageBox()
        self.box.setFixedSize(500,500)

        layout = QVBoxLayout()
        layout.addWidget(w)
        layout.addWidget(self.box)
        self.setLayout(layout)

    def open_image(self):
        &quot;&quot;&quot;
        select image file and open it
        :return:
        &quot;&quot;&quot;
        # img_name, _ = QFileDialog.getOpenFileName(self, &quot;打开图片&quot;, &quot;&quot;, &quot;All Files(*);;*.jpg;;*.png&quot;)
        img_name, _ = QFileDialog.getOpenFileName(self, &quot;Open Image File&quot;,&quot;&quot;,&quot;All Files(*);;*.jpg;;*.png;;*.jpeg&quot;)
        self.box.set_image(img_name)

    def large_click(self):
        &quot;&quot;&quot;
        used to enlarge image
        :return:
        &quot;&quot;&quot;
        if self.box.scale &lt; 2:
            self.box.scale += 0.1
            self.box.adjustSize()
            self.update()

    def small_click(self):
        &quot;&quot;&quot;
        used to reduce image
        :return:
        &quot;&quot;&quot;
        if self.box.scale &gt; 0.3:
            self.box.scale -= 0.2
            self.box.adjustSize()
            self.update()

if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    box = MainDemo()
    box.show()
    app.exec_()
</code></pre>
<h1 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h1><p><a href="https://blog.csdn.net/qq_42743778/article/details/118567409">https://blog.csdn.net/qq_42743778/article/details/118567409</a></p>
<pre><code># -*- coding: utf-8 -*-

# Form implementation generated from reading ui file &#39;top-half.ui&#39;
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QImageReader
from PyQt5.QtWidgets import QWidget, QApplication, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QFileDialog
from PyQt5.Qt import QPixmap, QPoint, Qt, QPainter, QIcon
from PyQt5.QtCore import QSize


class ImageBox(QWidget):
    def __init__(self):
        super(ImageBox, self).__init__()
        self.img = None
        self.scaled_img = None
        self.point = QPoint(0, 0)
        self.start_pos = None
        self.end_pos = None
        self.left_click = False
        self.scale = 1

    def init_ui(self):
        self.setWindowTitle(&quot;ImageBox&quot;)

    def set_image(self, img_path):
        &quot;&quot;&quot;
        open image file
        :param img_path: image file path
        :return:
        &quot;&quot;&quot;
        # img = QImageReader(img_path)
        # img.setScaledSize(QSize(self.size().width(), self.size().height()))
        # img = img.read()
        self.img = QPixmap(img_path)
        self.scaled_img = self.img

    def paintEvent(self, e):
        &quot;&quot;&quot;
        receive paint events
        :param e: QPaintEvent
        :return:
        &quot;&quot;&quot;
        if self.scaled_img:
            painter = QPainter()
            painter.begin(self)
            painter.scale(self.scale, self.scale)
            painter.drawPixmap(self.point, self.scaled_img)
            painter.end()

    def wheelEvent(self, event):
        angle = event.angleDelta() / 8  # 返回QPoint对象，为滚轮转过的数值，单位为1/8度
        angleY = angle.y()
        # 获取当前鼠标相对于view的位置
        if angleY &gt; 0:
            self.scale *= 1.1
        else:  # 滚轮下滚
            self.scale *= 0.9
        self.adjustSize()
        self.update()


    def mouseMoveEvent(self, e):
        &quot;&quot;&quot;
        mouse move events for the widget
        :param e: QMouseEvent
        :return:
        &quot;&quot;&quot;
        if self.left_click:
            self.end_pos = e.pos() - self.start_pos
            self.point = self.point + self.end_pos
            self.start_pos = e.pos()
            self.repaint()

    def mousePressEvent(self, e):
        &quot;&quot;&quot;
        mouse press events for the widget
        :param e: QMouseEvent
        :return:
        &quot;&quot;&quot;
        if e.button() == Qt.LeftButton:
            self.left_click = True
            self.start_pos = e.pos()

    def mouseReleaseEvent(self, e):
        &quot;&quot;&quot;
        mouse release events for the widget
        :param e: QMouseEvent
        :return:
        &quot;&quot;&quot;
        if e.button() == Qt.LeftButton:
            self.left_click = False

class Ui_Form(QWidget):
    def setupUi(self, Form):
        Form.setObjectName(&quot;Form&quot;)
        Form.resize(1020, 726)
        self.scrollArea = QtWidgets.QScrollArea(Form)
        self.scrollArea.setGeometry(QtCore.QRect(240, 50, 719, 309))
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName(&quot;scrollArea&quot;)
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.box = ImageBox()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, self.box.width(), self.box.height()))
        self.scrollAreaWidgetContents.setMinimumSize(QtCore.QSize(719, 309))
        self.scrollAreaWidgetContents.setObjectName(&quot;scrollAreaWidgetContents&quot;)
        self.gridLayout = QtWidgets.QGridLayout(self.scrollAreaWidgetContents)
        self.gridLayout.setObjectName(&quot;gridLayout&quot;)

        self.gridLayout.addWidget(self.box, 0, 0, 1, 1)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.open_file = QtWidgets.QPushButton(Form)
        self.open_file.setGeometry(QtCore.QRect(30, 100, 81, 41))
        font = QtGui.QFont()
        font.setFamily(&quot;Aharoni&quot;)
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.open_file.setFont(font)
        self.open_file.setObjectName(&quot;open_file&quot;)
        self.open_file.clicked.connect(self.open_image)
        self.progressBar = QtWidgets.QProgressBar(Form)
        self.progressBar.setGeometry(QtCore.QRect(240, 370, 751, 23))
        self.progressBar.setProperty(&quot;value&quot;, 24)
        self.progressBar.setObjectName(&quot;progressBar&quot;)
        self.line = QtWidgets.QFrame(Form)
        self.line.setGeometry(QtCore.QRect(50, 410, 911, 16))
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName(&quot;line&quot;)
        self.start_check = QtWidgets.QPushButton(Form)
        self.start_check.setGeometry(QtCore.QRect(130, 100, 81, 41))
        font = QtGui.QFont()
        font.setFamily(&quot;Aharoni&quot;)
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.start_check.setFont(font)
        self.start_check.setObjectName(&quot;start_check&quot;)
        self.label = QtWidgets.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(40, 170, 61, 31))
        font = QtGui.QFont()
        font.setFamily(&quot;Aharoni&quot;)
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName(&quot;label&quot;)
        self.label_2 = QtWidgets.QLabel(Form)
        self.label_2.setGeometry(QtCore.QRect(40, 300, 61, 31))
        font = QtGui.QFont()
        font.setFamily(&quot;Aharoni&quot;)
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName(&quot;label_2&quot;)


        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate(&quot;Form&quot;, &quot;Form&quot;))
        self.open_file.setText(_translate(&quot;Form&quot;, &quot;选择文件&quot;))
        self.start_check.setText(_translate(&quot;Form&quot;, &quot;开始检测&quot;))
        self.label.setText(_translate(&quot;Form&quot;, &quot;文件名称：&quot;))
        self.label_2.setText(_translate(&quot;Form&quot;, &quot;检测状态:&quot;))

    def open_image(self):
        &quot;&quot;&quot;
        select image file and open it
        :return:
        &quot;&quot;&quot;
        # img_name, _ = QFileDialog.getOpenFileName(self, &quot;打开图片&quot;, &quot;&quot;, &quot;All Files(*);;*.jpg;;*.png&quot;)
        img_name, _ = QFileDialog.getOpenFileName(None, &quot;Open Image File&quot;,&quot;&quot;,&quot;All Files(*);;*.jpg;;*.png;;*.jpeg&quot;)
        img = QPixmap(img_name)
        print(img.width(),&quot;+&quot;,img.height())
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, img.width(), img.height()))
        self.box.set_image(img_name)

if __name__ == &quot;__main__&quot;:
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_Form()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
</code></pre>
<h1 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h1><p><a href="https://huaweicloud.csdn.net/63808365dacf622b8df894dc.html">https://huaweicloud.csdn.net/63808365dacf622b8df894dc.html</a></p>
<pre><code># -*- coding: utf-8 -*-
import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QImageReader
from PyQt5.QtWidgets import QWidget, QApplication, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QFileDialog
from PyQt5.Qt import QPixmap, QPoint, Qt, QPainter, QIcon
from PyQt5.QtCore import QSize


class ImageBox(QWidget):
    def __init__(self):
        super(ImageBox, self).__init__()
        self.img = None
        self.scaled_img = None
        self.start_pos = None
        self.end_pos = None
        self.left_click = False
        self.wheel_flag = False

        self.scale = 1
        self.old_scale = 1
        self.point = QPoint(0, 0)
        self.x = -1
        self.y = -1
        self.new_height = -1
        self.new_width = -1

    def init_ui(self):
        self.setWindowTitle(&quot;ImageBox&quot;)

    def set_image(self, img_path):
        self.img = QPixmap(img_path)
        width, height = self.img.width(), self.img.height()
        if height / width &gt; 990 / 660:
            new_height = 990
            new_width = width * 990 / height
        else:
            new_height = height * 660 / width
            new_width = 660
        self.point = QPoint(int((660 - new_width) * 0.5), int((990 - new_height) * 0.5))
        self.img = self.img.scaled(new_width, new_height, Qt.KeepAspectRatio)
        self.scaled_img = self.img

        self.new_height = new_height
        self.new_width = new_width
        self.scale = 1

    def paintEvent(self, e):
        if self.scaled_img:
            painter = QPainter()
            painter.begin(self)
            painter.scale(self.scale, self.scale)
            if self.wheel_flag:        # 定点缩放
                self.wheel_flag = False
                # 判断当前鼠标pos在不在图上
                this_left_x = self.point.x() * self.old_scale
                this_left_y = self.point.y() * self.old_scale
                this_scale_width = self.new_width * self.old_scale
                this_scale_height = self.new_height * self.old_scale

                # 鼠标点在图上，以鼠标点为中心动作
                gap_x = self.x - this_left_x
                gap_y = self.y - this_left_y
                if 0 &lt; gap_x &lt; this_scale_width and 0 &lt; gap_y &lt; this_scale_height:
                    new_left_x = int(self.x / self.scale - gap_x / self.old_scale)
                    new_left_y = int(self.y / self.scale - gap_y / self.old_scale)
                    self.point = QPoint(new_left_x, new_left_y)
                # 鼠标点不在图上，固定左上角进行缩放
                else:
                    true_left_x = int(self.point.x() * self.old_scale / self.scale)
                    true_left_y = int(self.point.y() * self.old_scale / self.scale)
                    self.point = QPoint(true_left_x, true_left_y)
            painter.drawPixmap(self.point, self.scaled_img)  # 此函数中还会用scale对point进行处理
            painter.end()

    def wheelEvent(self, event):
        angle = event.angleDelta() / 8  # 返回QPoint对象，为滚轮转过的数值，单位为1/8度
        angleY = angle.y()
        self.old_scale = self.scale
        self.x, self.y = event.x(), event.y()
        self.wheel_flag = True
        # 获取当前鼠标相对于view的位置
        if angleY &gt; 0:
            self.scale *= 1.08
        else:  # 滚轮下滚
            self.scale *= 0.92
        if self.scale &lt; 0.3:
            self.scale = 0.3
        self.adjustSize()
        self.update()

    def mouseMoveEvent(self, e):
        if self.left_click:
            self.end_pos = e.pos() - self.start_pos                    # 当前位置-起始位置=差值
            self.point = self.point + self.end_pos / self.scale        # 左上角的距离变化
            self.start_pos = e.pos()
            self.repaint()

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton:
            self.left_click = True
            self.start_pos = e.pos()

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.LeftButton:
            self.left_click = False


class Ui_Form(QWidget):
    def setupUi(self, Form):
        Form.setObjectName(&quot;Form&quot;)
        Form.resize(900, 1080)
        self.scrollArea = QtWidgets.QScrollArea(Form)
        self.scrollArea.setGeometry(QtCore.QRect(150, 10, 680, 990))
        self.scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        # self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName(&quot;scrollArea&quot;)

        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.box = ImageBox()

        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 680, 990))
        self.scrollAreaWidgetContents.setMinimumSize(QtCore.QSize(100, 100))
        self.scrollAreaWidgetContents.setObjectName(&quot;scrollAreaWidgetContents&quot;)
        self.gridLayout = QtWidgets.QGridLayout(self.scrollAreaWidgetContents)
        self.gridLayout.setObjectName(&quot;gridLayout&quot;)

        self.gridLayout.addWidget(self.box, 0, 0, 1, 1)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)

        self.open_file = QtWidgets.QPushButton(Form)
        self.open_file.setGeometry(QtCore.QRect(30, 100, 81, 41))
        font = QtGui.QFont()
        font.setFamily(&quot;Aharoni&quot;)
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.open_file.setFont(font)
        self.open_file.setObjectName(&quot;open_file&quot;)
        self.open_file.clicked.connect(self.open_image)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate(&quot;Form&quot;, &quot;Form&quot;))
        self.open_file.setText(_translate(&quot;Form&quot;, &quot;选择文件&quot;))

    def open_image(self):
        img_name, _ = QFileDialog.getOpenFileName(None, &quot;Open Image File&quot;,&quot;&quot;,&quot;All Files(*);;*.jpg;;*.png;;*.jpeg&quot;)
        self.box.set_image(img_name)


if __name__ == &quot;__main__&quot;:
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_Form()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>QSS美化控件教程</title>
    <url>/2023/10/25/QSS%E7%BE%8E%E5%8C%96%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用Qt开发界面程序时，常用控件的美化是一件繁琐的事情，收藏一些基本控件的美化样式，可以在项目开发时节省大量时间，本篇文章由此而出，收集常用的控件美化样式。<br>以下qss代码是直接在Qt Designer设计界面中样式表中添加或者使用QFile读取qss代码进行修改控件样式。</p>
<h1 id="1、QPushButton美化"><a href="#1、QPushButton美化" class="headerlink" title="1、QPushButton美化"></a>1、QPushButton美化</h1><pre><code>QWidget#Widget&#123;
background-color:#fff;
&#125;

QPushButton&#123;
border:5px solid #fff;
border-radius:8px;
padding:1px 5px;
min-width:120px;
min-height:35px;
&#125;

QPushButton#first_btn&#123;
color:#fff;
background-color:#0d6efd;
&#125;
#first_btn:hover&#123;
background-color:#0055ff;
&#125;
#first_btn:pressed&#123;
border: 4px solid #98c1fe;
&#125;

QPushButton#second_btn&#123;
color:#fff;
background-color:#6c757d;
&#125;

#second_btn:hover&#123;
background-color:#5c636a;
&#125;
#second_btn:pressed&#123;
border:4px solid #c0c4c8;
&#125;

QPushButton#third_btn&#123;
color:#fff;
background-color:#198754;
&#125;
#third_btn:hover&#123;
background-color:#157347;
&#125;
#third_btn:pressed&#123;
border:4px solid #9dccb6;
&#125;

QPushButton#four_btn&#123;
color:#fff;
background-color:#dc3545;
&#125;
#four_btn:hover&#123;
background-color:#bb2d3b;
&#125;
#four_btn:pressed&#123;
border:4px solid #f0a9b0;
&#125;
QPushButton#five_btn&#123;
color:#000;
background-color:#ffc107;
&#125;
#five_btn:hover&#123;
background-color:#ffca2c;
&#125;
#five_btn:pressed&#123;
border:5px solid #ecd182;
&#125;
QPushButton#six_btn&#123;
color:#000;
background-color:#0dcaf0;
&#125;
#six_btn:hover&#123;
background-color:#31d2f2;
&#125;
#six_btn:pressed&#123;
border:54x solid #85d5e5;
&#125;
QPushButton#seven_btn&#123;
color:#000;
background-color:#f8f9fa;
&#125;
#seven_btn:hover&#123;
background-color:#f9fafb;
&#125;
#seven_btn:pressed&#123;
border:4px solid #e9e9ea;
&#125;
QPushButton#eight_btn&#123;
color:#fff;
background-color:#212529;
&#125;
#eight_btn:hover&#123;
background-color:#1c1f23;
&#125;
#eight_btn:pressed&#123;
border:4px solid #a0a2a4;
&#125;
QPushButton#nine_btn&#123;
color:#fff;
background-color:#d235d2;
&#125;
#nine_btn:hover&#123;
background-color:#a600a6;
&#125;
#nine_btn:pressed&#123;
border:4px solid #d25fd2;
&#125;
</code></pre>
<h1 id="2、QComboBox美化"><a href="#2、QComboBox美化" class="headerlink" title="2、QComboBox美化"></a>2、QComboBox美化</h1><pre><code>#cbx&#123;
border:1px #ced4da;
border-radius:4px;
padding-left:10px;
&#125;
#cbx::drop-down&#123;
border:0px;
&#125;

#cbx::down-arrow&#123;
    border-image: url(:/icons/down.png);
    width:20px;
    height:20px;
    margin-right:20px;
&#125;
#cbx:on&#123;
border:4px solid #c2dbfe;
&#125;
#cbx QListView&#123;
font-size:16px;
border:1px solid rgba(0,0,0,10%);
padding:5px;
background-color:#fff;
outline:0px;
&#125;
#cbx QListView::item&#123;
padding-left:10px;
background-color:#fff;
&#125;
#cbx QListView::item:hover&#123;
background-color:#1e90ff;
&#125;
#cbx QListView::item:selected&#123;
background-color:#1e90ff;
&#125;
</code></pre>
<h1 id="3、QLineEdit美化"><a href="#3、QLineEdit美化" class="headerlink" title="3、QLineEdit美化"></a>3、QLineEdit美化</h1><pre><code>QLineEdit&#123;
color:#fff;
border:2px solid rgb(37,39,48);
border-radius:20px;
padding-left:20px;
padding-right:20px;
background-color:rgb(34,36,44);
&#125;
QLineEdit:hover&#123;
border:4px solid rgb(48,50,62);
&#125;
QLineEdit:focus&#123;
border:4px solid rgb(85,170,255);
background-color:rgb(43,45,56);
&#125;
#Widget&#123;
background-color:rgb(37,39,48);
&#125;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「神威难藏泪~」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Thinking777/article/details/130374425">https://blog.csdn.net/Thinking777/article/details/130374425</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python强制替换文件</title>
    <url>/2023/10/24/Python%E5%BC%BA%E5%88%B6%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、检查文件是否存在</p>
<p>首先，我们需要检查待替换的文件是否存在。如果文件存在，我们将执行替换操作；如果文件不存在，我们需要进行相应的处理逻辑，比如抛出异常或创建新文件。</p>
<pre><code>import os

file_path = &#39;/path/to/source/file.txt&#39;

if os.path.exists(file_path):
    # 文件存在的处理逻辑
    pass
else:
    # 文件不存在的处理逻辑
    pass
</code></pre>
<p>2、备份现有文件<br>接下来，我们需要备份原文件，以便在替换之后可以恢复。</p>
<pre><code>import shutil

source_file_path = &#39;/path/to/source/file.txt&#39;
backup_file_path = &#39;/path/to/backup/file.txt&#39;

shutil.copyfile(source_file_path, backup_file_path)
</code></pre>
<p>3、替换文件</p>
<p>现在，我们可以将新文件替换原文件。</p>
<pre><code>import shutil

new_file_path = &#39;/path/to/new/file.txt&#39;
source_file_path = &#39;/path/to/source/file.txt&#39;

shutil.copyfile(new_file_path, source_file_path)
</code></pre>
<p>4、恢复备份</p>
<p>如果在替换文件后遇到问题，我们可以使用备份文件恢复原文件。</p>
<pre><code>import shutil

backup_file_path = &#39;/path/to/backup/file.txt&#39;
source_file_path = &#39;/path/to/source/file.txt&#39;

shutil.copyfile(backup_file_path, source_file_path)
</code></pre>
<hr>
<p>©著作权归作者所有：来自51CTO博客作者mob64ca12eab427的原创作品，请联系作者获取转载授权，否则将追究法律责任<br>python 强制替换文件<br><a href="https://blog.51cto.com/u_16213408/7158206">https://blog.51cto.com/u_16213408/7158206</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5密码输入框</title>
    <url>/2023/10/23/PyQt5%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大栗子<br>实现了三种密码输入框的方式：<br>1.输入的密码不可见；<br>2.输入的密码可见，但是鼠标点击其他控件后，密码不可见；<br>3.输入的密码不可见，同时为了更加的安全，屏蔽了鼠标右键、禁用复制、粘贴快捷键、鼠标在密码框中不可移动，不可全选。就类似我们在输入QQ密码的时候一样。</p>
<p>PasswdDialog.py</p>
<pre><code>&#39;&#39;&#39;
其实大家从这段代码中我们可以看出，本质上就是QDialog的继承，加上自己希望的界面和实现的功能。因此QDialog所有的属性，我们自定义对话框PasswdDialog都会有，这样能够省掉我们不少的时间来。这个也就是面向对象编程的魅力所在了。
&#39;&#39;&#39;
# coding=utf-8
from PyQt5.QtWidgets import QDialog, QApplication, QLineEdit, QLabel, QPushButton, QHBoxLayout, QVBoxLayout, QMessageBox
from PyQt5.QtCore import Qt, QEvent, QRegExp, QObject
from PyQt5.QtGui import QKeyEvent, QKeySequence, QRegExpValidator


class PasswdDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.resize(350, 100)
        self.setWindowTitle(&quot;密码输入框&quot;)

        self.lb = QLabel(&quot;请输入密码：&quot;, self)

        self.edit = QLineEdit(self)
        self.edit.installEventFilter(self)

        self.bt1 = QPushButton(&quot;确定&quot;, self)
        self.bt2 = QPushButton(&quot;取消&quot;, self)

        hbox = QHBoxLayout()
        hbox.addStretch(1)
        hbox.addWidget(self.bt1)
        hbox.addStretch(1)
        hbox.addWidget(self.bt2)
        hbox.addStretch(1)

        vbox = QVBoxLayout()
        vbox.addWidget(self.lb)
        vbox.addWidget(self.edit)
        vbox.addStretch(1)
        vbox.addLayout(hbox)

        self.setLayout(vbox)

        &#39;&#39;&#39;
        这个三个语句是给密码输入框增加一些属性
        &#39;&#39;&#39;
        self.edit.setContextMenuPolicy(Qt.NoContextMenu)  # 这个语句设置QLineEdit对象的上下文菜单的策略。复制，粘贴，。。。，是否可用
        self.edit.setPlaceholderText(
            &quot;密码不超15位，只能有数字和字母，必须以字母开头&quot;)  # 只要行编辑为空，设置此属性将使行编辑显示为灰色的占位符文本。默认情况下，此属性包含一个空字符串。这是非常好的使用方法，可以在用户输入密码前看到一些小提示信息，但是又不影响使用，非常棒这个方法。
        self.edit.setEchoMode(QLineEdit.Password)  # 这条语句设置了如何限定输入框中显示其包含信息的方式，这里设置的是：密码方式，即输入的时候呈现出原点出来。

        &#39;&#39;&#39;
        这三段代码大体意思就是说，运用正则表达式限定密码输入框字符接收的条件：
        长度不能超过15位；
        字母开头；
        后面跟着的字符只能是字母或者数字。
        &#39;&#39;&#39;
        regx = QRegExp(&quot;^[a-zA-Z][0-9A-Za-z]&#123;14&#125;$&quot;)  # 为给定的模式字符串构造一个正则表达式对象。
        validator = QRegExpValidator(regx,
                                     self.edit)  # 构造一个验证器，该父对象接受与正则表达式匹配的所有字符串。这里的父对象就是QLineEdit对象了。匹配是针对整个字符串; 例如：如果正则表达式是[A-Fa-f0-9]+将被视为^[A-Fa-f0-9]+$。
        self.edit.setValidator(validator)  # 将密码输入框设置为仅接受符合验证器条件的输入。 这允许您对可能输入的文本设置任何约束条件。因此我们这里设置的就是符合上面描述的三种约束条件。

        self.bt1.clicked.connect(self.Ok)
        self.bt2.clicked.connect(self.Cancel)

        object = QObject()

        &#39;&#39;&#39;
        事件过滤器可是一个非常重要的概念。根据Qt的官方文档，如果对象被安装已监视对象的事件过滤器，则过滤事件。如果要过滤事件，需重新实现此函数时，若停止进一步处理，返回true； 否则返回false。
        如果一个对象安装多个事件过滤器，那么，最后安装的过滤器首先被激活。    
        &#39;&#39;&#39;

    def eventFilter(self, object, event):
        if object == self.edit:  # 这里是对事件的判断。其中QKeyEvent类描述了一个关键事件。当按下或释放按键时，主要事件将发送到具有键盘输入焦点的小部件。然后运用matches方法匹配具体的按键。
            if event.type() == QEvent.MouseMove or event.type() == QEvent.MouseButtonDblClick:
                return True
            elif event.type() == QEvent.KeyPress:
                key = QKeyEvent(event)
                if key.matches(QKeySequence.SelectAll) or key.matches(QKeySequence.Copy) or key.matches(
                        QKeySequence.Paste):  # 然后进行事件判断与转换：鼠标移动对应的事件类型为QEvent.MouseMove，鼠标双击对应的事件类型为QEvent.MouseButtonDblClick，全选、复制、粘贴对应的事件类型为 QEvent.KeyPress，当接收到这些事件时，需要被过滤掉，所以返回true。
                    return True
        return QDialog.eventFilter(self, object, event)  # 继续传递该事件到被观察者，由其本身调用相应的事件

    def Ok(self):
        self.text = self.edit.text()
        if len(self.text) == 0:
            QMessageBox.warning(self, &quot;警告&quot;, &quot;密码为空&quot;)
        elif len(self.text) &lt; 6:
            QMessageBox.warning(self, &quot;警告&quot;, &quot;密码长度低于6位&quot;)
        else:
            self.done(1)  # 结束对话框返回1

    def Cancel(self):
        self.done(0)  # 结束对话框返回0
</code></pre>
<p>main.py</p>
<pre><code># coding=utf-8

from PyQt5.QtWidgets import (QApplication, QWidget, QPushButton, QLabel, QInputDialog, QTextBrowser, QLineEdit)
from PasswdDialog import PasswdDialog
import sys


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.resize(380, 180)
        self.setWindowTitle(&#39;早点毕业吧--自定义密码输入对话框&#39;)

        self.lb1 = QLabel(&#39;密码在此显示...&#39;, self)
        self.lb1.move(20, 20)

        self.bt1 = QPushButton(&#39;输入密码(普通型)&#39;, self)
        self.bt1.move(20, 60)

        self.bt2 = QPushButton(&#39;输入密码(普通加强型)&#39;, self)
        self.bt2.move(20, 100)

        self.bt3 = QPushButton(&#39;输入密码(特别加强型)&#39;, self)
        self.bt3.move(20, 140)

        self.show()

        self.bt1.clicked.connect(self.showDialog)
        self.bt2.clicked.connect(self.showDialog)
        self.bt3.clicked.connect(self.showDialog)

    def showDialog(self):
        sender = self.sender()
        if sender == self.bt1:
            text, ok = QInputDialog.getText(self, &#39;密码输入框&#39;, &#39;请输入密码：&#39;, QLineEdit.Password)
            if ok:
                self.lb1.setText(text)
        elif sender == self.bt2:
            text, ok = QInputDialog.getText(self, &#39;密码输入框&#39;, &#39;请输入密码：&#39;, QLineEdit.PasswordEchoOnEdit)
            if ok:
                self.lb1.setText(text)
        else:
            pwd = PasswdDialog()
            r = pwd.exec_()
            if r:
                self.lb1.setText(pwd.text)


if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<p>具体运行结果参考：<br><a href="https://zhuanlan.zhihu.com/p/30152208">https://zhuanlan.zhihu.com/p/30152208</a><br>谢谢 “学点编程吧”<br>————————————————<br>版权声明：本文为CSDN博主「十三吖」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40006058/article/details/80076669">https://blog.csdn.net/qq_40006058/article/details/80076669</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>QT对lineEdit添加图标</title>
    <url>/2023/10/22/QT%E5%AF%B9lineEdit%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>使用QLineEdit的setClearButtonEnabled方法显示清除按钮</p>
<p>在PyQt中，QLineEdit类具有一个setClearButtonEnabled方法，该方法用于在文本框的右侧显示一个清除按钮。我们可以使用这个清除按钮来放置一个图标。</p>
<p>首先，我们需要创建一个QLineEdit对象，并将其添加到主窗口中，如下所示：</p>
<pre><code>import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit

class MyWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 300, 200)

        self.lineedit = QLineEdit(self)
        self.lineedit.setGeometry(50, 50, 200, 30)

        self.lineedit.setClearButtonEnabled(True)


if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    mywindow = MyWindow()
    mywindow.show()
    sys.exit(app.exec_())
</code></pre>
<p>在上面的代码中，我们创建了一个自定义的窗口类MyWindow，并在initUI方法中创建了一个QLineEdit对象lineedit。然后，我们调用setClearButtonEnabled方法并将其参数设置为True，以显示清除按钮。</p>
<p>保存并运行上述代码，将会看到一个带有清除按钮的文本框出现在应用程序的主窗口中。</p>
<p>在上面的代码中，我们创建了一个自定义的窗口类MyWindow，并在initUI方法中创建了一个QLineEdit对象lineedit。然后，我们调用setClearButtonEnabled方法并将其参数设置为True，以显示清除按钮。</p>
<p>保存并运行上述代码，将会看到一个带有清除按钮的文本框出现在应用程序的主窗口中。</p>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>使用QLineEdit的setStyleSheet方法设置图标样式</p>
<p>除了显示清除按钮之外，我们还可以使用QLineEdit的setStyleSheet方法来设置图标样式，并将其放置在文本框的左侧或右侧。</p>
<p>首先，我们需要创建一个QLineEdit对象，并将其添加到主窗口中，如下所示：</p>
<pre><code>import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit

class MyWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 300, 200)

        self.lineedit = QLineEdit(self)
        self.lineedit.setGeometry(50, 50, 200, 30)

        self.lineedit.setStyleSheet(&quot;background-image: url(&#39;icon.png&#39;);  background-position: right; background-repeat: no-repeat; padding-right: 20px;&quot;)


if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    mywindow = MyWindow()
    mywindow.show()
    sys.exit(app.exec_())
</code></pre>
<p>在上面的代码中，我们使用了QLineEdit的setStyleSheet方法，并为其设置了一个包含图标的背景样式。在这个样式中，我们使用了background-image属性来指定图标的URL，background-position属性来设置图标的位置（这里是右侧），background-repeat属性来设置图标是否重复显示，padding-right属性来设置图标与文本框之间的距离。</p>
<p>保存并运行上述代码，将会看到一个带有图标的文本框出现在应用程序的主窗口中。</p>
<h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><ol start="3">
<li>自定义QLineEdit来放置图标<br>除了使用QLineEdit的现有方法来放置图标之外，我们还可以自定义一个QLineEdit子类，并在其中绘制图标。</li>
</ol>
<p>首先，我们需要创建一个自定义的QLineEdit子类，如下所示：</p>
<pre><code>import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit
from PyQt5.QtGui import QIcon, QPainter
from PyQt5.QtCore import Qt

class IconLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon = QIcon(&#39;icon.png&#39;)

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        rect = self.contentsRect()
        icon_rect = QRect(rect.right() - 20, rect.top(), 20, rect.height())
        self.icon.paint(painter, icon_rect, Qt.AlignCenter)

class MyWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 300, 200)

        self.lineedit = IconLineEdit(self)
        self.lineedit.setGeometry(50, 50, 200, 30)

if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    mywindow = MyWindow()
    mywindow.show()
    sys.exit(app.exec_())
</code></pre>
<p>在上面的代码中，我们创建了一个名为IconLineEdit的自定义QLineEdit子类，并在其paintEvent方法中绘制了一个图标。我们首先调用了父类QlineEdit的paintEvent方法来绘制文本框本身，然后使用QPainter对象绘制了一个图标，并设置了图标的位置（这里是在内容矩形的右侧）和对齐方式（居中对齐）。</p>
<p>然后，我们在自定义的MyWindow类中使用这个自定义的IconLineEdit类来创建一个带有图标的文本框。</p>
<p>保存并运行上述代码，将会看到一个带有图标的文本框出现在应用程序的主窗口中。</p>
<h1 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h1><p>创建了一个QAction并设置其图标，然后通过addAction()方法将该QAction添加到QLineEdit控件的左侧。<br>第二个参数指定添加的位置，QLineEdit::LeadingPosition以在最左侧添加图像，QLineEdit::TrailingPosition以在最右侧添加图像</p>
<pre><code>//对lineEdit左侧嵌入图片
actionPassword = QAction(self)
actionPassword.setIcon(QIcon(&quot;:/icons/icons/Lock.png&quot;))
self.ui.lineEdit_Password.addAction(actionPassword, QLineEdit.LeadingPosition)

self.iconEyeOpen = QIcon(&quot;:/icons/icons/EyeOpen.png&quot;)
self.iconEyeClose = QIcon(&quot;:/icons/icons/EyeClose.png&quot;)
self.actionVisible = QAction(self)
self.actionVisible.setIcon(self.iconEyeClose)
self.ui.lineEdit_Password.addAction(self.actionVisible, QLineEdit.TrailingPosition)
self.actionVisible.setCheckable(True)
self.actionVisible.toggled.connect(self.setPasswordVisibility)
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5中未包含QtWebEngine,QtWebEngineWidgets也就是老版本的QWebView</title>
    <url>/2023/10/21/PyQt5%E4%B8%AD%E6%9C%AA%E5%8C%85%E5%90%ABQtWebEngine,QtWebEngineWidgets%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%80%81%E7%89%88%E6%9C%AC%E7%9A%84QWebView/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>新版本的PyQt5 没有web引擎(至少5.15.4版本没有),需要自己改写</p>
<h1 id="思路步骤"><a href="#思路步骤" class="headerlink" title="思路步骤"></a>思路步骤</h1><p>1、额外安装模块PyQtWebEngine</p>
<pre><code>pip install PyQtWebEngine
</code></pre>
<p>2、先选择Widget控件</p>
<p>3、将Widget升级成WebEngine</p>
<p>4、在ui转成的py文件中添加URL 修改尺寸位置等</p>
<pre><code>self.webview = QtWebEngineWidgets.QWebEngineView(self.centralwidget)
self.webview.setGeometry(QtCore.QRect(280, 470, 120, 80))
self.webview.setUrl(QtCore.QUrl(&quot;https://www.baidu.com/&quot;))
self.webview.setObjectName(&quot;webview&quot;)
</code></pre>
<h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><pre><code>from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QVBoxLayout
from PyQt5.QtCore import QUrl
from PyQt5.QtWebEngineWidgets import QWebEngineView

if __name__ == &#39;__main__&#39;:
    app = QApplication([])
    main_window = QMainWindow()
    main_window.setGeometry(300, 300, 800, 600)
    main_window.setWindowTitle(&quot;web引擎&quot;)

    main_widget = QWidget()
    main_window.setCentralWidget(main_widget)

    main_layout = QVBoxLayout()
    main_widget.setLayout(main_layout)

    web = QWebEngineView()
    main_layout.addWidget(web)

    web.setUrl(QUrl(&quot;https://www.baidu.com&quot;))

    main_window.show()
    app.exec_()
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「qq_65932616」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_65932616/article/details/128364939">https://blog.csdn.net/qq_65932616/article/details/128364939</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python替换文件</title>
    <url>/2023/10/20/Python%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.python100.com/html/W14O5WJ56I2U.html">https://www.python100.com/html/W14O5WJ56I2U.html</a></p>
<p>Python是一种多用途、高效的编程语言，它具有广泛的应用场景。文件处理是其中一个领域，Python提供了很多方便的模块和函数来处理文本、二进制数据、CSV、JSON等文件类型。本文将介绍Python如何使用常用的模块和函数来替换文件。</p>
<h1 id="一、os模块"><a href="#一、os模块" class="headerlink" title="一、os模块"></a>一、os模块</h1><p>os模块提供了与操作系统交互的接口。使用该模块可以方便地访问文件系统、环境变量等系统资源。os模块中的replace()函数可以用来替换文件名和路径。</p>
<p>示例代码：</p>
<pre><code>import os

file_path = &#39;D:/test/file.txt&#39;
new_path = &#39;D:/test/new_file.txt&#39;
os.replace(file_path, new_path)
</code></pre>
<p>以上代码将文件D:/test/file.txt替换为D:/test/new_file.txt。该函数可以自动处理文件名重复等情况。</p>
<h1 id="二、shutil模块"><a href="#二、shutil模块" class="headerlink" title="二、shutil模块"></a>二、shutil模块</h1><p>shutil模块是Python的一个标准库，提供了高级的文件操作接口。它可以实现复制、移动、重命名等文件操作。shutil模块中的move()函数也可以用来替换文件。</p>
<p>示例代码：</p>
<pre><code>import shutil

file_path = &#39;D:/test/file.txt&#39;
new_path = &#39;D:/test/new_file.txt&#39;
shutil.move(file_path, new_path)
</code></pre>
<p>以上代码将文件D:/test/file.txt替换为D:/test/new_file.txt。该函数也可以自动处理文件名重复等情况。</p>
<h1 id="三、re模块"><a href="#三、re模块" class="headerlink" title="三、re模块"></a>三、re模块</h1><p>re模块是Python的一个标准库，提供了正则表达式的功能。正则表达式可以用来匹配和替换字符串。在替换文件中，如果需要根据某些特定的规则替换文件内容，可以使用re模块。</p>
<p>示例代码：</p>
<pre><code>import re

file_path = &#39;D:/test/file.txt&#39;
new_path = &#39;D:/test/new_file.txt&#39;

with open(file_path, &#39;r&#39;) as f:
    content = f.read()
    new_content = re.sub(&#39;old_text&#39;, &#39;new_text&#39;, content)

with open(new_path, &#39;w&#39;) as f:
    f.write(new_content)
</code></pre>
<p>以上代码将文件D:/test/file.txt中的所有old_text替换为new_text，并将结果保存到D:/test/new_file.txt中。用with语句打开文件可以更加方便地处理文件的读写操作。</p>
<h1 id="四、fileinput模块"><a href="#四、fileinput模块" class="headerlink" title="四、fileinput模块"></a>四、fileinput模块</h1><p>fileinput模块也是Python的一个标准库，提供了一种通用的方法来处理文件输入和输出。它可以将多个文件作为一个整体来处理，并且可以自动备份文件。</p>
<p>示例代码：</p>
<pre><code>import fileinput

file_path = &#39;D:/test/file.txt&#39;
new_path = &#39;D:/test/new_file.txt&#39;
with fileinput.FileInput(file_path, inplace=True, backup=&#39;.bak&#39;) as f:
    for line in f:
        print(line.replace(&#39;old_text&#39;, &#39;new_text&#39;), end=&#39;&#39;)
</code></pre>
<p>以上代码将文件D:/test/file.txt中的所有old_text替换为new_text，并保存到原来的文件中。使用inplace参数可以自动备份文件，使用print函数和end参数可以方便地处理文件的输出。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>Python提供了很多方便的模块和函数来处理文件，以上介绍的os、shutil、re、fileinput模块是其中常用的几个。在实际开发中，可以根据实际需求选取相应的模块和函数来完成文件替换操作。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如果单击眼睛图标显示隐藏密码（QPushButton）</title>
    <url>/2023/10/19/%E5%A6%82%E6%9E%9C%E5%8D%95%E5%87%BB%E7%9C%BC%E7%9D%9B%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E5%AF%86%E7%A0%81%EF%BC%88QPushButton%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnpython.com/qa/1374456">https://www.cnpython.com/qa/1374456</a></p>
<h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>PyQt5的一大优点是它将自动将信号连接到方法。如果您的应用程序中有一个名为<mybutton>的按钮和一个名为on_<mybutton>_clicked的方法，loadUi将自动连接。所以模式是</mybutton></mybutton></p>
<pre><code>on_&lt;widget_name&gt;_&lt;signal&gt;
</code></pre>
<p>如果我们将此应用于您的问题，您应该将“显示/隐藏”按钮设置为切换按钮。在Qt设计器中，将checkable属性设置为True（或dobtn_show_pwd.clicked.setChecked(True)）</p>
<p>代码：</p>
<pre><code>from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtWidgets import QPushButton, QLineEdit
import sys

class MyWindow(QtWidgets.QMainWindow):
    def __init__(self, maxWidth=None):
        super(MyWindow, self).__init__()
        uic.loadUi(&#39;test1.ui&#39;, self)

        self.line_password.setEchoMode(QLineEdit.Password)

    def on_btn_show_pwd_toggled(self, checked):
        if checked:
            self.line_password.setEchoMode(QLineEdit.Password)
        else:
            self.line_password.setEchoMode(QLineEdit.Normal)

if __name__ == &#39;__main__&#39;:
    app = QtWidgets.QApplication(sys.argv)
    window = MyWindow()
    window.show()
    sys.exit(app.exec_())
    
</code></pre>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>另一种可能是将可检查的QAction添加到QLineEdit并连接到toggled（或triggered）信号</p>
<pre><code>class MyWindow(QtWidgets.QMainWindow):
    def __init__(self, maxWidth=None):
        super(MyWindow, self).__init__()
        uic.loadUi(&#39;MainWindow.ui&#39;, self)

        icon = QtGui.QIcon(&#39;eye-icon.png&#39;)
        self.showPassAction = QtWidgets.QAction(icon, &#39;Show password&#39;, self)
        self.line_password.addAction(
            self.showPassAction, QtWidgets.QLineEdit.TrailingPosition)
        self.showPassAction.setCheckable(True)
        self.showPassAction.toggled.connect(self.showPassword)

    def showPassword(self, show):
        self.line_password.setEchoMode(
            QtWidgets.QLineEdit.Normal if show else QtWidgets.QLineEdit.Password)
</code></pre>
<p>如果只想在按下鼠标时显示密码，则不要连接到toggled信号，而是找到该操作的子QToolButton并连接到pressed和released。在这种情况下，操作不需要是可检查的</p>
<pre><code>self.line_password.addAction(
    self.showPassAction, QtWidgets.QLineEdit.TrailingPosition)
showPassButton = self.line_password.findChild(QtWidgets.QAbstractButton)
showPassButton.pressed.connect(lambda: self.showPassword(True))
showPassButton.released.connect(lambda: self.showPassword(False))
</code></pre>
<h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>您可以创建单个函数并切换可见性，而不是创建两个单独的方法，如eyepass_show和eyepass_hide。另外，您正试图通过self.btn_show_pwd.clicked.connect(self.eyepass_hide)和self.btn_show_pwd.clicked.connect(self.eyepass_show)将同一信号两次连接到两种不同的方法</p>
<p>试着这样做：</p>
<pre><code>from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtWidgets import QPushButton, QLineEdit
import sys
import pymysql
pymysql.install_as_MySQLdb()

class MyWindow(QtWidgets.QMainWindow):
    def __init__(self, maxWidth=None):
        super(MyWindow, self).__init__()
        uic.loadUi(&#39;MainWindow.ui&#39;, self)

        self.eyepass_show()
        self.eyepass_hide()
        self.btn_show_pwd.clicked.connect(self.toggleVisibility)
        
    def toggleVisibility(self):
        if self.line_password.echoMode()==QLineEdit.Normal:
            self.line_password.setEchoMode(QLineEdit.Password)
        else:
            self.line_password.setEchoMode(QLineEdit.Normal)

    #     self.btn_show_pwd.clicked.connect(self.eyepass_hide)
    #     self.btn_show_pwd.clicked.connect(self.eyepass_show)
    # 
    # def eyepass_show(self):
    #     self.line_password.setEchoMode(QLineEdit.Normal)
    #     print(&#39;show pass&#39;)
    # 
    # def eyepass_hide(self):
    #     self.line_password.setEchoMode(QLineEdit.Password)
    #     print(&#39;hide pass&#39;)


if __name__ == &#39;__main__&#39;:
    app = QtWidgets.QApplication(sys.argv)
    window = MyWindow()
    window.show()
    sys.exit(app.exec_())
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>AttributeError module ‘backend_interagg‘ has no attribute ‘FigureCanvas‘的解决办法</title>
    <url>/2023/10/18/AttributeError%20module%20%E2%80%98backend_interagg%E2%80%98%20has%20no%20attribute%20%E2%80%98FigureCanvas%E2%80%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>一开始我还以为是我的matoltlib和我的python版本不匹配后面发现真正原因其实是matplotlib 的 backend的默认渲染器是agg，agg是一个没有图形显示界面的终端，如果要图像正常显示，则需要切换为图形界面显示的终端TkAgg</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>修改 backend 配置：</p>
<pre><code>matplotlib.use(‘TkAgg’)
</code></pre>
<h1 id="原代码和修改后代码对比"><a href="#原代码和修改后代码对比" class="headerlink" title="原代码和修改后代码对比"></a>原代码和修改后代码对比</h1><h2 id="原代码："><a href="#原代码：" class="headerlink" title="原代码："></a>原代码：</h2><pre><code>import numpy as np

import matplotlib.pyplot as plt

x=np.linspace(0.0001,3,100)
y=x**x
plt.plot(x,y,&#39;r-&#39;,linewidth=3)
plt.show()`
</code></pre>
<p>错误提示：</p>
<pre><code>AttributeError: module &#39;backend_interagg&#39; has no attribute &#39;FigureCanvas&#39;. Did you mean: &#39;FigureCanvasAgg&#39;?
</code></pre>
<h2 id="修改后代码："><a href="#修改后代码：" class="headerlink" title="修改后代码："></a>修改后代码：</h2><pre><code>import numpy as np
import matplotlib
matplotlib.use(&#39;TkAgg&#39;)
import matplotlib.pyplot as plt

x=np.linspace(0.0001,3,100)
y=x**x
plt.plot(x,y,&#39;r-&#39;,linewidth=3)
plt.show()
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「倚剑策马笑西风」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_51763547/article/details/126918669">https://blog.csdn.net/qq_51763547/article/details/126918669</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>“matplotlib.use(‘agg‘)“语句的作用机理</title>
    <url>/2023/10/17/%E2%80%9Cmatplotlib.use(%E2%80%98agg%E2%80%98)%E2%80%9C%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%BA%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在很多使用 matplotlib 库的代码中出现了 matplotlib.use(‘agg’) 的语句。有些博客认为1，在导入matplotlib库后，且在matplotlib.pyplot库被导入前加“matplotlib.use(‘agg’)”语句的作用是在PyCharm中不显示绘图。例如1：</p>
<pre><code>import numpy as np
import matplotlib
matplotlib.use(&#39;agg&#39;) 
import matplotlib.pyplot as plt # matplotlib.use(&#39;agg&#39;)必须在本句执行前运行
x = np.arange(0, 2*np.pi, 0.001) 
y = np.sin(2 * np.pi * x) 
plt.clf() 
plt.plot(x,y) 
l = plt.axhline(linewidth=1, color=&#39;black&#39;) 
l = plt.axvline(linewidth=1, color=&#39;black&#39;) 
plt.show()
</code></pre>
<p>在Pycharm里面运行就不会显示图。</p>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>实际上，这样的理解是表面的，这个语句确实会使得在Pycharm运行时无法显示图，但是必须注意，这是其原理导致的，而这个语句并不是设置Pycharm不显示图的语句，其实前述的代码中，删掉 plt.show() ，也不会显示图片。</p>
<p>matplotlib的use()命令其实是用来配置matplotlib的backend （后端）的命令。所谓后端，就是一个渲染器，用于将前端代码渲染成我们想要的图像2。后端详细的解释可以参考博客： matplotlib中什么是后端 。</p>
<p>对于用户接口，典型的渲染器是Agg，它是使用Anti-Grain Geometry C++库来产生光栅(像素)图。</p>
<p>那么为什么这样设置Pycharm会导致其不显示图片呢？</p>
<p>可以查看一下目前的后端设置。方法是执行下面代码。</p>
<pre><code>import matplotlib
matplotlib.get_backend()
</code></pre>
<p>在Pycharm的Terminal 里面输入该项命令，可以看到，Pycharm运行的时候，默认的后端是Qt5Agg。</p>
<p>实际上，Agg 渲染器是非交互式的后端，没有GUI界面，所以不显示图片，它是用来生成图像文件。Qt5Agg 是意思是Agg渲染器输出到Qt5绘图面板，它是交互式的后端，拥有在屏幕上展示的能力3。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的zipfile入门教程</title>
    <url>/2023/10/16/Python%E7%9A%84zipfile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源如下，<br><a href="https://muzing.top/posts/4797762a/">https://muzing.top/posts/4797762a/</a><br><a href="https://zhuanlan.zhihu.com/p/480329034">https://zhuanlan.zhihu.com/p/480329034</a></p>
<p>本文做摘选，原文见上述地址。</p>
<h1 id="Python-能处理-ZIP-文件吗？"><a href="#Python-能处理-ZIP-文件吗？" class="headerlink" title="Python 能处理 ZIP 文件吗？"></a>Python 能处理 ZIP 文件吗？</h1><p>是的！Python 有几个工具可以让您操作 ZIP 文件。其中一些工具在 Python 标准库 中可用。它们包括用于使用特定压缩算法（例如 zlib 、bz2 、lzma 和其他）压缩和解压缩数据的低级库。</p>
<p>Python 还提供了一个名为“zipfile”的高级模块，专门用于创建、读取、写入、提取和列出 ZIP 文件的内容。<br>Python 的 zipfile 提供了便于使用的类和函数，允许创建、读取、写入、提取和列出 ZIP 文件包含的内容。</p>
<p>zipfile 支持的一些附加功能：</p>
<pre><code>大于 4 GiB 的 ZIP 文件（ZIP64 files）
数据解密
多种压缩算法，例如 Deflate、 Bzip2 与 LZMA
使用 CRC32 进行信息完整性检查
</code></pre>
<p>请注意，zipfile 确实有一些局限性。例如，当前的数据解密功能可能非常慢，因为它使用纯 Python 代码。该模块无法处理加密 ZIP 文件的创建。最后，也不支持使用多磁盘（multi-disk） ZIP 文件。尽管有这些局限性，zipfile 仍然是一个很棒且实用的工具。</p>
<h1 id="使用-Python-的-zipfile-操纵已存在的-ZIP-文件"><a href="#使用-Python-的-zipfile-操纵已存在的-ZIP-文件" class="headerlink" title="使用 Python 的 zipfile 操纵已存在的 ZIP 文件"></a>使用 Python 的 zipfile 操纵已存在的 ZIP 文件</h1><h2 id="打开-ZIP-文件进行读写"><a href="#打开-ZIP-文件进行读写" class="headerlink" title="打开 ZIP 文件进行读写"></a>打开 ZIP 文件进行读写</h2><p>在 zipfile 模块中，您会找到 ZipFile 类。这个类的工作方式很像 Python 内置的 open() 函数，允许使用不同的模式打开 ZIP 文件。读取模式（”r”）为默认值。也可以使用写入（”w”）、追加（”a”）和独占（”x”）模式。稍后您将详细学习其中每一项。</p>
<p>zipfile 实现了上下文管理器协议，以便于在一个 with 语句中使用该类。此特性允许您快速打开和使用 ZIP 文件，而无需担心在完成工作后关闭文件。</p>
<p>在编写任何代码之前，请确保您拥有将要使用的文件和归档的副本：</p>
<p>要获取您将用于编写本教程中的示例的文件和存档，请查看本文 附A：材料下载 一节。</p>
<p>请将下载的资源移入您的家目录（home folder）下名为 python-zipfile/ 的目录中，以准备好工作环境。将文件放在正确的位置后，移动至新创建的目录并在那里启动 Python 交互式会话。</p>
<p>译者注：对于 Windows 10/11 用户，可以在任意路径创建该目录。在文件资源管理器中进入目录后，按住 Shift 键的同时鼠标右键单击空白处，然后选择“在此处打开 Powershell 窗口”，输入 python 命令即可。</p>
<p>首先从读取名为 sample.zip 的 ZIP 文件开始热身。为此，可以在读取模式下使用 ZipFile ：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.printdir()
...
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
realpython.md                             2021-09-07 19:50:10          428
</code></pre>
<p>ZipFile 初始化的第一个参数可以是一个字符串，表示需要打开的 ZIP 文件的路径。这个参数也可以接受文件对象和路径类对象。在此示例中，使用了基于字符串的路径。</p>
<p>ZipFile 的第二个参数是一个单字母的字符串，表示用于打开文件的模式。正如您在本节开头所了解的，根据需求，ZipFile 可以接受四种可能的模式。mode 位置参数默认为 “r”，所以如果想以只读模式打开归档，可以省略它。</p>
<p>在 with 语句中，在 archive 上调用 .printdir()。archive 变量现在包含 ZipFile 本身的实例。此函数提供了一种在屏幕上显示底层 ZIP 文件内容的快捷方法。其输出为易读的表格形式，有三列信息：</p>
<p>File Name<br>Modified<br>Size<br>如果您想在尝试打开之前确保目标为有效的 ZIP 文件，那么可以将 ZipFile 包装在 try … except 语句中，并捕获任何 BadZipFile 异常：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; try:
...     with zipfile.ZipFile(&quot;sample.zip&quot;) as archive:
...         archive.printdir()
... except zipfile.BadZipFile as error:
...     print(error)
...
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
realpython.md                             2021-09-07 19:50:10          428

&gt;&gt;&gt; try:
...     with zipfile.ZipFile(&quot;bad_sample.zip&quot;) as archive:
...         archive.printdir()
... except zipfile.BadZipFile as error:
...     print(error)
...
File is not a zip file
</code></pre>
<p>第一个示例成功打开 sample.zip 而不引发 BadZipFile 异常。那是因为 sample.zip 具有有效的 ZIP 格式。另一方面，第二个示例无法成功打开 bad_sample.zip ，因为该文件不是有效的 ZIP 文件。</p>
<p>为检查 ZIP 文件的有消息，您还可以使用 is_zipfile() 函数：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; if zipfile.is_zipfile(&quot;sample.zip&quot;):
...     with zipfile.ZipFile(&quot;sample.zip&quot;, &quot;r&quot;) as archive:
...         archive.printdir()
... else:
...     print(&quot;File is not a zip file&quot;)
...
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
realpython.md                             2021-09-07 19:50:10          428

&gt;&gt;&gt; if zipfile.is_zipfile(&quot;bad_sample.zip&quot;):
...     with zipfile.ZipFile(&quot;bad_sample.zip&quot;, &quot;r&quot;) as archive:
...         archive.printdir()
... else:
...     print(&quot;File is not a zip file&quot;)
...
File is not a zip file
</code></pre>
<p>在这些示例中，使用一个 is_zipfile() 作为条件的条件语句。该函数接受一个保存文件系统中 ZIP 文件的路径的 filename 参数。此参数可以接受字符串、类文件或类路径对象。如果 filename 是有效的 ZIP 文件，则该函数返回 True。否则返回 False。</p>
<p>现在假设您想使用 ZipFile 将 hello.txt 添加到 hello.zip 归档中。为此，可以使用写入模式（”w”）。该模式打开一个 ZIP 文件进行写入。如果目标 ZIP 文件存在，则 “w” 模式会截断它并写入您传入的任何新内容。</p>
<p>Note: 如果您使用 ZipFile 处理现有文件，那么应该小心使用 “w” 模式。您可能截断 ZIP 文件并丢失所有原有内容。</p>
<p>如果目标 ZIP 文件不存在，则 ZipFile 会在您关闭归档时为您创建它：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;hello.zip&quot;, mode=&quot;w&quot;) as archive:
...     archive.write(&quot;hello.txt&quot;)
...
</code></pre>
<p>运行此代码后，python-zipfile/ 目录中将有一个 hello.zip 文件。如果使用 .printdir() 列出文件内容，那么 hello.txt 会在那里。在此示例中，可用在 ZipFile 对象上调用 .write()。此方法允许您将成员文件写入 ZIP 归档。注意 .write() 的参数应是已存在的文件。</p>
<p>Note: 当您在写模式下使用类且目标归档不存在时， ZipFile 足够智能，可以创建一个新的归档。然而，如果这些目录尚不存在，则该类不会在目标 ZIP 文件的路径中创建新目录。</p>
<p>这就解释了为何如下代码无法工作：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;missing/hello.zip&quot;, mode=&quot;w&quot;) as archive:
...     archive.write(&quot;hello.txt&quot;)
...
Traceback (most recent call last):
    ...
FileNotFoundError: [Errno 2] No such file or directory: &#39;missing/hello.zip&#39;
</code></pre>
<p>因为目标 hello.zip 文件路径中的 missing/ 目录不存在，所以会出现 FileNotFoundError 异常。</p>
<p>追加模式（”a”）允许您将新的成员文件追加到现有 ZIP 文件。此模式不会截断归档，故其原始内容是安全的。如果目标 ZIP 文件不存在，则 “a” 模式会为您创建一个新文件，然后追加作为参数传入 .write() 的任何文件。</p>
<p>为尝试 “a” 模式，更进一步添加 new_hello.txt 文件到新创建的 hello.zip 归档中：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;hello.zip&quot;, mode=&quot;a&quot;) as archive:
...     archive.write(&quot;new_hello.txt&quot;)
...

&gt;&gt;&gt; with zipfile.ZipFile(&quot;hello.zip&quot;) as archive:
...     archive.printdir()
...
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
new_hello.txt                             2021-08-31 17:13:44           13
</code></pre>
<p>此处，使用追加模式将 new_hello.txt 添加到 hello.zip 文件中。然后运行 .printdir() 以确认新文件已存在于 ZIP 文件中。</p>
<p>ZipFile 还支持独占模式（”x”）。 此模式允许您独占地创建新的 ZIP 文件并将新的成员文件写入其中。 当想要创建一个新的 ZIP 文件而不覆盖现有文件时，使用独占模式。 如果目标文件已存在，则会得到 FileExistsError。</p>
<p>最后，如果您使用 “w”、”a” 或 “x” 模式创建一个 ZIP 文件，然后在不添加任何成员文件的情况下关闭归档，则 ZipFile 会创建一个具有适当 ZIP 格式的空归档。</p>
<h2 id="从-ZIP-文件中读取元数据"><a href="#从-ZIP-文件中读取元数据" class="headerlink" title="从 ZIP 文件中读取元数据"></a>从 ZIP 文件中读取元数据</h2><p>您已将 .printdir() 付诸实践。这是一种实用的方法，可用于快速列出 ZIP 文件包含的内容。与 .printdir() 一道，ZipFile 类提供了几种从现有 ZIP 文件中提取元数据的便捷方法。</p>
<p>以下是这些方法的摘要：</p>
<p>方法    描述<br>.getinfo(filename)    返回一个关于 filename 提供的成员文件的信息的 ZipInfo 对象。注意 filename 必须包含底层 ZIP 文件中目标文件的路径。<br>.infolist()    返回一个 ZipInfo 对象列表，每个文件占一项。<br>.namelist()    返回一个包含底层归档中所有成员文件名的列表。该列表中的名称是 .getinfo() 的有效参数。<br>使用这三个工具，您可以检索许多关于 ZIP 文件内容的实用信息。例如，下面的例子使用了 .getinfo()：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     info = archive.getinfo(&quot;hello.txt&quot;)
...

&gt;&gt;&gt; info.file_size
83
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     for info in archive.infolist():
...         print(f&quot;Filename: &#123;info.filename&#125;&quot;)
...         print(f&quot;Modified: &#123;datetime.datetime(*info.date_time)&#125;&quot;)
...         print(f&quot;Normal size: &#123;info.file_size&#125; bytes&quot;)
...         print(f&quot;Compressed size: &#123;info.compress_size&#125; bytes&quot;)
...         print(&quot;-&quot; * 20)
...
Filename: hello.txt
Modified: 2021-09-07 19:50:10
Normal size: 83 bytes
Compressed size: 83 bytes
--------------------
Filename: lorem.md
Modified: 2021-09-07 19:50:10
Normal size: 2609 bytes
Compressed size: 2609 bytes
--------------------
Filename: realpython.md
Modified: 2021-09-07 19:50:10
Normal size: 428 bytes
Compressed size: 428 bytes
--------------------

&gt;&gt;&gt; info.compress_size
83

&gt;&gt;&gt; info.filename
&#39;hello.txt&#39;

&gt;&gt;&gt; info.date_time
(2021, 9, 7, 19, 50, 10)
</code></pre>
<p>正如您在上表中所了解到的，.getinfo() 将成员文件作为参数，并返回一个包含关于其信息的 ZipInfo 对象。</p>
<p>Note: ZipInfo 并不想要被直接实例化。.getinfo() 和 .infolist() 方法在被调用时会自动返回 ZipInfo 对象。然而，ZipInfo 包含一个名为 .from_file() 的类方法，它允许您在需要时显式地实例化该类。</p>
<p>ZipInfo 对象有一些属性，可以检索有关目标成员文件的实用信息。例如，.file_size 和 .compress_size 分别保存未压缩原始文件和压缩后文件的大小（以字节为单位）。该类还有一些其他实用的属性，例如 .filename 和 .date_time ，它们返回文件名和最后修改日期。</p>
<p>Note: 默认情况下，ZipFile 不会压缩输入文件以将其添加到最终归档中。这就是上例中 size 和 compressed size 大小相同的原因。您将在下面的 压缩文件和目录 部分了解有关此话题的更多信息。</p>
<p>使用 .infolist() ，您可以从指定归档中提取所有文件信息。以下是一个使用此方法生成最小报告的示例，其中包含有关 sample.zip 归档中所有成员文件的信息：</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     for info in archive.infolist():
...         print(f&quot;Filename: &#123;info.filename&#125;&quot;)
...         print(f&quot;Modified: &#123;datetime.datetime(*info.date_time)&#125;&quot;)
...         print(f&quot;Normal size: &#123;info.file_size&#125; bytes&quot;)
...         print(f&quot;Compressed size: &#123;info.compress_size&#125; bytes&quot;)
...         print(&quot;-&quot; * 20)
...
Filename: hello.txt
Modified: 2021-09-07 19:50:10
Normal size: 83 bytes
Compressed size: 83 bytes
--------------------
Filename: lorem.md
Modified: 2021-09-07 19:50:10
Normal size: 2609 bytes
Compressed size: 2609 bytes
--------------------
Filename: realpython.md
Modified: 2021-09-07 19:50:10
Normal size: 428 bytes
Compressed size: 428 bytes
--------------------
</code></pre>
<p>for 循环迭代来自 .infolist() 的 ZipInfo 对象，检索文件名、最后修改日期、未压缩大小 ，以及每个成员文件的压缩后大小。在此示例中，使用 datetime 以人类易读的方式格式化日期。</p>
<p>Note: 上面的例子改编自zipfile — ZIP Archive Access。</p>
<p>如果只需要对 ZIP 文件执行快速检查并列出其成员文件的名称，那么可以使用 .namelist()：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     for filename in archive.namelist():
...         print(filename)
...
hello.txt
lorem.md
realpython.md
</code></pre>
<p>因为此输出中的文件名是 .getinfo() 的有效参数，所以可以结合这两种方法来仅检索关于特定成员文件的信息。</p>
<p>例如，可能有一个 ZIP 文件，其中包含不同类型的成员文件（.docx、.xlsx、.txt 等）。但并不需要使用 .infolist() 获取完整信息，只需获取有关 .docx 文件的信息。那么可以按扩展名过滤文件并仅在 .docx 文件上调用 .getinfo() 。 来试一试吧！</p>
<h2 id="读写成员文件"><a href="#读写成员文件" class="headerlink" title="读写成员文件"></a>读写成员文件</h2><p>有时需要在不解压一个 ZIP 文件的情况下读取指定成员文件。为此，可以使用 .read()。此方法接收一个成员文件的 name 并将该文件的内容作为字节返回：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     for line in archive.read(&quot;hello.txt&quot;).split(b&quot;\n&quot;):
...         print(line)
...
b&#39;Hello, Pythonista!&#39;
b&#39;&#39;
b&#39;Welcome to Real Python!&#39;
b&#39;&#39;
b&quot;Ready to try Python&#39;s zipfile module?&quot;
b&#39;&#39;
</code></pre>
<p>为使用 .read()，需要以读取或追加模式打开 ZIP 文件。注意 .read() 以字节流的形式返回目标文件的内容。在此示例中，以换行符 “\n” 作为分隔符，使用 .split() 将流拆分为行。因为 .split() 正在在一个字节对象上进行操作，所以需要在字符串前添加前导 b 作为参数</p>
<p>ZipFile.read() 还接受名为 pwd 的第二个位置参数。此参数允许您提供用以读取加密文件的密码。要尝试此功能，您可以使用随本教程材料下载的 sample_pwd.zip 文件：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample_pwd.zip&quot;, mode=&quot;r&quot;) as archive:
...     for line in archive.read(&quot;hello.txt&quot;, pwd=b&quot;secret&quot;).split(b&quot;\n&quot;):
...         print(line)
...
b&#39;Hello, Pythonista!&#39;
b&#39;&#39;
b&#39;Welcome to Real Python!&#39;
b&#39;&#39;
b&quot;Ready to try Python&#39;s zipfile module?&quot;
b&#39;&#39;

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample_pwd.zip&quot;, mode=&quot;r&quot;) as archive:
...     for line in archive.read(&quot;hello.txt&quot;).split(b&quot;\n&quot;):
...         print(line)
...
Traceback (most recent call last):
    ...
RuntimeError: File &#39;hello.txt&#39; is encrypted, password required for extraction
</code></pre>
<p>在第一个例子中，提供密码 secret 来读取加密文件。pwd 参数接受字节类型的值。如果在未提供所需密码的情况下对加密文件使用 .read() ，则会得到 RuntimeError，如第二个示例所示。</p>
<p>Note: Python 的 zipfile 支持解密。但是它不支持创建加密 ZIP 文件。这就是需要使用外部文件归档工具来加密文件的原因。</p>
<p>一些流行的文件归档工具包括 Windows 上的 7z 和 WinRAR，Linux 上的 Ark 和 GNOME Archive Manager，macOC 上的 Archiver。</p>
<p>对于大型加密 ZIP 文件，请留意解密操作可能会非常慢，因为它是在纯 Python 中实现的。在这种情况下，请考虑使用专门的程序来处理您的归档而不是使用 zipfile。</p>
<p>如果经常使用加密文件，那么可能希望避免每次调用 .read() 或其他接受 pwd 参数的方法时提供密码。如果是这种情况，可以使用 ZipFile.setpassword() 设置一个全局密码：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample_pwd.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.setpassword(b&quot;secret&quot;)
...     for file in archive.namelist():
...         print(file)
...         print(&quot;-&quot; * 20)
...         for line in archive.read(file).split(b&quot;\n&quot;):
...             print(line)
...
hello.txt
--------------------
b&#39;Hello, Pythonista!&#39;
b&#39;&#39;
b&#39;Welcome to Real Python!&#39;
b&#39;&#39;
b&quot;Ready to try Python&#39;s zipfile module?&quot;
b&#39;&#39;
lorem.md
--------------------
b&#39;# Lorem Ipsum&#39;
b&#39;&#39;
b&#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    ...
</code></pre>
<p>使用 .setpassword()，只需要提供一次密码。ZipFile 使用该唯一密码来解密所有成员文件。</p>
<p>相反，如果您的 ZIP 文件的各个成员文件具有不同的密码，那么需要使用 .read() 的 pwd 参数为每个文件提供特定的密码：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample_file_pwd.zip&quot;, mode=&quot;r&quot;) as archive:
...     for line in archive.read(&quot;hello.txt&quot;, pwd=b&quot;secret1&quot;).split(b&quot;\n&quot;):
...         print(line)
...
b&#39;Hello, Pythonista!&#39;
b&#39;&#39;
b&#39;Welcome to Real Python!&#39;
b&#39;&#39;
b&quot;Ready to try Python&#39;s zipfile module?&quot;
b&#39;&#39;

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample_file_pwd.zip&quot;, mode=&quot;r&quot;) as archive:
...     for line in archive.read(&quot;lorem.md&quot;, pwd=b&quot;secret2&quot;).split(b&quot;\n&quot;):
...         print(line)
...
b&#39;# Lorem Ipsum&#39;
b&#39;&#39;
b&#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    ...
</code></pre>
<p>在这个例子中，使用 secret1 作为读取 hello.txt 的密码，secret2 作为读取 lorem.md 的。最后一个需要考虑的细节是，当使用 pwd 参数时，会覆盖可能已经通过 .setpassword() 设置的任何归档级密码。</p>
<p>Note: 在使用不支持的压缩算法的 ZIP 文件上调用 .read() 会引发 NotImplementedError。如果所需的压缩模块在您的 Python 安装中不可用，也会收到错误信息。</p>
<p>如果您正在寻找一种更灵活的方式来读取成员文件并创建和添加新的成员文件到归档中，那么 ZipFile.open() 适合您。与内置的 open() 函数一样，该方法实现了上下文管理器协议，因此它支持 with 语句：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     with archive.open(&quot;hello.txt&quot;, mode=&quot;r&quot;) as hello:
...         for line in hello:
...             print(line)
...
b&#39;Hello, Pythonista!\n&#39;
b&#39;\n&#39;
b&#39;Welcome to Real Python!\n&#39;
b&#39;\n&#39;
b&quot;Ready to try Python&#39;s zipfile module?\n&quot;
</code></pre>
<p>在本例中，打开 hello.txt 以读取。open() 的第一个参数是 name ，表示要打开的成员文件。第二个参数是模式，像往常一样默认为 “r”。ZipFile.open() 还接受一个用于打开加密文件的 pwd 参数。此参数与 .read() 中的同名参数作用相同。</p>
<p>您还可以将 .open() 与 “w” 模式组合使用。此模式允许创建一个新的成员文件，向其中写入内容，最后将该文件附加到底层归档，应以追加模式打开：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;a&quot;) as archive:
...     with archive.open(&quot;new_hello.txt&quot;, &quot;w&quot;) as new_hello:
...         new_hello.write(b&quot;Hello, World!&quot;)
...
13

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.printdir()
...     print(&quot;------&quot;)
...     archive.read(&quot;new_hello.txt&quot;)
...
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
realpython.md                             2021-09-07 19:50:10          428
new_hello.txt                             1980-01-01 00:00:00           13
------
b&#39;Hello, World!&#39;
</code></pre>
<p>在第一个代码片段中，以追加模式（”a”）打开 sample.zip 。然后通过以 “w” 模式调用 .open() 创建 new_hello.txt。此函数返回一个支持 .write() 的类文件对象，它允许您将字节写入新创建的文件。</p>
<p>Note: 需要为 .open() 提供一个非现有的文件名。如果使用底层归档中已经存在的文件名，那么会最终得到一个重复的文件和一个 UserWarning 异常。</p>
<p>在此示例中，将 b’Hello, World!’ 写入 new_hello.txt。当执行流退出内部 with 语句时，Python 将输入字节写入成员文件。当外部 with 语句退出时，Python 会将 new_hello.txt 写入底层 ZIP 文件 sample.zip。</p>
<p>第二个代码片段证实了 new_hello.txt 现在是 sample.zip 的成员文件。在这个示例的输出中需要注意的一个细节是，.write() 将新添加的文件的 Modified 日期设置为 1980-01-01 00:00:00。这是一个奇怪的行为，使用此方法时应牢记。</p>
<h2 id="将成员文件的内容作为文本读取"><a href="#将成员文件的内容作为文本读取" class="headerlink" title="将成员文件的内容作为文本读取"></a>将成员文件的内容作为文本读取</h2><p>正如您在上一节中所了解的，可以使用 .read() 和 .write() 方法来实现不从 ZIP 归档中提取而直接读写成员文件。这两种方法都仅适用于字节。</p>
<p>然而，当您有一个包含文本文件的 ZIP 归档时，可能希望将其内容作为文本而不是字节来读取。至少有两种方法可以做到这一点。可以使用：</p>
<p>bytes.decode()<br>io.TextIOWrapper<br>因为 ZipFile.read() 以字节形式返回目标成员文件的内容，故 .decode() 可以直接对这些字节进行操作。.decode() 方法使用给定的字符编码格式将 bytes 对象解码为字符串。</p>
<p>以下为如何使用 .decode() 以从 sample.zip 归档中的 hello.txt 文件中读取文本：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt;  with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     text = archive.read(&quot;hello.txt&quot;).decode(encoding=&quot;utf-8&quot;)
...

&gt;&gt;&gt; print(text)
Hello, Pythonista!

Welcome to Real Python!

Ready to try Python&#39;s zipfile module?
</code></pre>
<p>在此示例中，将 hello.txt 的内容作为字节读取。然后调用 .decode() 来将字节解码为使用 UTF-8 作为编码的字符串。为设置 encoding 参数，使用 “utf-8” 字符串。然而，可以使用任何其他有效编码，例如 UTF-16 或 cp1252，用不区分大小写的字符串表示它们。注意 “utf-8” 是 .decode() 的 encoding 参数的默认值。</p>
<p>时刻注意，您需要事先知道要使用 .decode() 处理的任何成员文件的字符编码格式。如果使用了错误的字符编码，那么代码将无法将底层字节正确解码为文本，最终可能会得到大量无法辨认的字符。</p>
<p>译者注：对于简体中文读者，最常见的一个乱码错误是，中文文本文件使用 Windows 默认的 GB2312 编码保存，而此处被以默认的 UTF-8 解码。因此见到许多“烫烫烫的锟斤拷”时不必惊慌，指定使用 GB2312 再尝试读取一次，很可能便解决了问题。</p>
<p>从成员文件中读取文本的第二个选项是使用 io.TextIOWrapper 对象，它提供具有缓冲的文字流。这次需要使用 .open() 而不是 .read()。以下是一个使用 io.TextIOWrapper 将 hello.txt 成员文件作为文字流读取的示例：</p>
<pre><code>&gt;&gt;&gt; import io
&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     with archive.open(&quot;hello.txt&quot;, mode=&quot;r&quot;) as hello:
...         for line in io.TextIOWrapper(hello, encoding=&quot;utf-8&quot;):
...             print(line.strip())
...
Hello, Pythonista!

Welcome to Real Python!

Ready to try Python&#39;s zipfile module?
</code></pre>
<p>在本例的内层 with 语句中，从 sample.zip 归档中打开成员文件 hello.txt。然后将生成的二进制类文件对象 hello 作为参数传递给 io.TextIOWrapper。这通过使用 UTF-8 字符编码格式解码 hello 的内容来创建有缓冲的文字流。因此，可以直接从目标成员文件中获得文字流。</p>
<p>就像 .encode() 一样，io.TextIOWrapper 类接受一个 encoding 参数。您应该始终为此参数指定一个值，因为默认文本编码取决于运行代码的操作系统，并且可能并非尝试解码的文件的正确值。</p>
<h2 id="从您的-ZIP-归档中提取成员文件"><a href="#从您的-ZIP-归档中提取成员文件" class="headerlink" title="从您的 ZIP 归档中提取成员文件"></a>从您的 ZIP 归档中提取成员文件</h2><p>提取给定归档的内容是对 ZIP 文件执行的最常见操作之一。根据您的需要，可能希望一次提取一个文件，或一次提取所有文件。</p>
<p>ZipFile.extract() 可以完成第一个任务。此方法接受一个 member 成员文件的名称，并将其提取到由 path 指定的目录。目标 path 默认为当前目录：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.extract(&quot;new_hello.txt&quot;, path=&quot;output_dir/&quot;)
...
&#39;output_dir/new_hello.txt&#39;
</code></pre>
<p>现在 new_hello.txt 将会出现在 output_dir/ 目录中。如果目标文件名已存在于输出目录中，则 .extract() 将不经请求确认直接覆盖它。如果输出目录不存在，则 .extract() 会为您创建它。注意 .extract() 返回提取文件的路径。</p>
<p>成员文件的名称必须是 .namelist() 返回的文件全名。它也可以是一个包含文件信息的 ZipInfo 对象。</p>
<p>您还可以将 .extract() 用于加密文件。在这种情况下，需要提供所需的 pwd 参数或使用 .setpassword() 设置归档级密码。</p>
<p>当涉及到从归档中提取所有成员文件时，可以使用 .extractall()。顾名思义，此方法将所有成员文件提取到目标路径（默认为当前目录）：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.extractall(&quot;output_dir/&quot;)
...
</code></pre>
<p>运行此代码后，sample.zip 中的所有当前内容将出现在 out_dir/ 目录中。如果将一个不存在的目录传递给 .extractall()，那么该方法会自动创建这个目录。最后，如果目标目录中已经存在任何成员文件，那么 .extractall() 将不经请求确认直接覆盖掉它们，所以要小心。</p>
<p>如果只需要从给定归档中提取一些成员文件，则可以使用 members 参数。此参数接受成员文件列表，即手头归档中全部文件列表的子集。最后，就像 .extract() 一样，.extractall() 方法也接受 pwd 参数来提取加密文件。</p>
<h2 id="使用后关闭-ZIP-文件"><a href="#使用后关闭-ZIP-文件" class="headerlink" title="使用后关闭 ZIP 文件"></a>使用后关闭 ZIP 文件</h2><p>有时候，不使用 with 语句可以便捷地打开一个给定的 ZIP 文件。在这些情况下，需要在使用后手动关闭归档以完成所有写入操作并释放获取的资源。</p>
<p>为此，可以在 ZipFile 对象上调用 .close()：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; archive = zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;)

&gt;&gt;&gt; # 在代码的不同部分使用归档
&gt;&gt;&gt; archive.printdir()
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
realpython.md                             2021-09-07 19:50:10          428
new_hello.txt                             1980-01-01 00:00:00           13

&gt;&gt;&gt; # 完成后关闭归档
&gt;&gt;&gt; archive.close()
&gt;&gt;&gt; archive
&lt;zipfile.ZipFile [closed]&gt;
</code></pre>
<p>调用 .close() 会关闭 archive 。在退出程序之前，必须调用 .close()。否则可能无法执行某些写入操作。例如，如果打开一个 ZIP 文件追加（”a”）新的成员文件，则需要关闭归档以写入文件。</p>
<h1 id="创建、填充和提取您自己的-ZIP-文件"><a href="#创建、填充和提取您自己的-ZIP-文件" class="headerlink" title="创建、填充和提取您自己的 ZIP 文件"></a>创建、填充和提取您自己的 ZIP 文件</h1><p>到目前为止，您已经学会了如何操纵现有的 ZIP 文件。您已经学会了使用 ZipFile 的不同模式来读取、写入和追加成员文件。您还学习了如何读取相关元数据以及如何提取给定 ZIP 文件的内容。</p>
<p>在本节中，您将编写一些练习示例，帮助您学习如何使用 zipfile 和其他 Python 工具从多个输入文件和整个目录创建 ZIP 文件。您还将学习如何使用 zipfile 进行文件压缩等。</p>
<h2 id="从多个常规文件创建-ZIP-文件"><a href="#从多个常规文件创建-ZIP-文件" class="headerlink" title="从多个常规文件创建 ZIP 文件"></a>从多个常规文件创建 ZIP 文件</h2><p>有时您需要从多个相关的文件创建 ZIP 归档。这样将所有的文件放在一个容器中，以便通过计算机网络分发或与朋友同事分享。为此可以创建目标文件列表并使用 ZipFile 和循环将它们写入归档：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; filenames = [&quot;hello.txt&quot;, &quot;lorem.md&quot;, &quot;realpython.md&quot;]

&gt;&gt;&gt; with zipfile.ZipFile(&quot;multiple_files.zip&quot;, mode=&quot;w&quot;) as archive:
...     for filename in filenames:
...         archive.write(filename)
...
</code></pre>
<p>此处，创建了一个 ZipFile 对象，并将所需的归档名称作为其第一个参数。”w” 模式允许您将成员文件写入最终的 ZIP 文件。</p>
<p>for() 循环遍历您输入的文件列表，并使用 .write() 将它们写入底层 ZIP 文件。一旦程序流退出 with 语句，ZipFile 会自动关闭归档，保存更改。现在获得了一个包含原始文件列表中所有文件的 multiple_files.zip 归档。</p>
<h2 id="从目录创建-ZIP-文件"><a href="#从目录创建-ZIP-文件" class="headerlink" title="从目录创建 ZIP 文件"></a>从目录创建 ZIP 文件</h2><p>将一个目录中的内容打包到单个归档中是 ZIP 文件的另一个日常用法。Python 有几个工具可以与 zipfile 一起使用来完成这项任务。例如，可以使用 pathlib 读取给定目录的内容。有了这些信息，可以使用 ZipFile 创建一个容器归档。</p>
<p>在 python-zipfile/ 目录中，有一个名为 source_dir/ 的子目录，内容如下：</p>
<pre><code>source_dir/
│
├── hello.txt
├── lorem.md
└── realpython.md
</code></pre>
<p>在 source_dir/ 中，只有三个普通文件。因为目录不包含子目录，所以可以使用 pathlib.Path.iterdir() 直接迭代其内容。按照这个思路，以下是从 source_dir/ 的内容构建 ZIP 文件的方法：</p>
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; directory = pathlib.Path(&quot;source_dir/&quot;)

&gt;&gt;&gt; with zipfile.ZipFile(&quot;directory.zip&quot;, mode=&quot;w&quot;) as archive:
...    for file_path in directory.iterdir():
...        archive.write(file_path, arcname=file_path.name)
...

&gt;&gt;&gt; with zipfile.ZipFile(&quot;directory.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.printdir()
...
File Name                                        Modified             Size
realpython.md                             2021-09-07 19:50:10          428
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
</code></pre>
<p>在此示例中，从源目录创建一个 pathlib.Path 对象。第一个 with 语句创建了一个可以写入的 ZipFile 对象。然后对 .iterdir() 的调用会返回一个遍历底层目录中条目的迭代器。</p>
<p>因为在 source_dir/ 中没有任何子目录，.iterdie() 函数只生成（yield）文件。for 循环遍历文件并将它们写入归档。</p>
<p>在此示例中，将 file_path.name 传递给 .write() 的第二个参数。此参数名为 arcname，保存着生成的归档中成员文件的名称。到目前为止，以上所有示例都依赖于 arcname 的默认值，即与作为第一个参数传递给 .write() 的文件名相同。</p>
<p>如果不将 file_path.name 传递给 arcname，那么源目录将作为 ZIP 文件的根目录。根据您的需要，这也可能是有效的结果。</p>
<p>现在查看工作目录中的 root_dir/ 文件夹。在此例中，您会发现以下结构：</p>
<pre><code>root_dir/
│
├── sub_dir/
│   └── new_hello.txt
│
├── hello.txt
├── lorem.md
└── realpython.md
</code></pre>
<p>此处有普通文件和一个包含单个文件的子目录。如果想创建一个具有相同内部结构的 ZIP 文件，那么需要一个工具来递归地遍历 root_dir/ 下的目录树。</p>
<p>以下是如何使用 zipfile 和 pathlib 模块中的Path.rglob() 来 zip 一个像上面那个一样的完整的目录树的方法：</p>
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; directory = pathlib.Path(&quot;root_dir/&quot;)

&gt;&gt;&gt; with zipfile.ZipFile(&quot;directory_tree.zip&quot;, mode=&quot;w&quot;) as archive:
...     for file_path in directory.rglob(&quot;*&quot;):
...         archive.write(
...             file_path,
...             arcname=file_path.relative_to(directory)
...         )
...

&gt;&gt;&gt; with zipfile.ZipFile(&quot;directory_tree.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.printdir()
...
File Name                                        Modified             Size
sub_dir/                                  2021-09-09 20:52:14            0
realpython.md                             2021-09-07 19:50:10          428
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
sub_dir/new_hello.txt                     2021-08-31 17:13:44           13
</code></pre>
<p>在此示例中，使用 Path.rglob() 递归遍历 root_dir/ 下的目录树。然后将每个文件和子目录写入目标 ZIP 归档。</p>
<p>这一次，使用 Path.relative_to() 来获取每个文件的相对路径，然后将其结果传递给 .write() 的第二个参数。这样生成的 ZIP 文件最终具有与源目录相同的内部结构。再一次，如果您希望源目录作为 ZIP 文件的根目录，则可以去掉这个参数。</p>
<h2 id="压缩文件和目录"><a href="#压缩文件和目录" class="headerlink" title="压缩文件和目录"></a>压缩文件和目录</h2><p>如果您的文件占用了太多磁盘空间，那么可以考虑压缩它们。Python 的 zipfile 支持一些流行的压缩方法。但该模块默认情况下不会压缩文件。如果想让文件更小，那么需要显式地为 ZipFile 提供一种压缩方法。</p>
<p>通常，术语 stored 指代写入未压缩的 ZIP 文件的成员文件。这就是为什么 ZipFile 的默认压缩方法称为 ZIP_STORED，它实际上是指简单存储在归档中未压缩的成员文件。</p>
<p>compression 方法是 ZipFile 初始化方法的第三个参数。如果想在文件写入 ZIP 归档时压缩文件，则可以将此参数设置为以下常量之一：</p>
<p>常量    压缩方法    所需模块<br>zipfile.ZIP_DEFLATED    Deflate    zlib<br>zipfile.ZIP_BZIP2    Bzip2    bz2<br>zipfile.ZIP_LZMA    LZMA    lzma</p>
<p>这些是您目前可以与 ZipFile 一起使用的压缩方法。除此之外的方法会引发 NotImplementedError。从 Python 3.10 开始，zipfile 没有其他额外可用的压缩方法。</p>
<p>作为一项附加的 requirement，如果选择其中一种方法，则为其提供支持的压缩模块必须在您的 Python 安装中可用。否则，会得到一个 RuntimeError 异常，然后代码会崩溃。</p>
<p>在压缩文件时，另一个与 ZipFile 相关的参数是 compresslevel。此参数控制使用的压缩级别。</p>
<p>使用 Deflate 方法，compresslevel 可以取从 0 到 9 的整数。使用 Bzip2 方法，可以传递从 1 到 9 的整数。在这两种情况下，当压缩级别增加时，压缩率会更高，压缩速度会更慢。</p>
<p>Note: PNG、JPG、MP3 之类的二进制文件，已经使用了某种压缩方式。因此，将它们添加到 ZIP 文件可能并不会使数据变得更小，因为它已经被压缩到一定程度。</p>
<p>现在假设您要使用 Deflate 方法来归档和压缩给定目录的内容（这是 ZIP 文件中最常用的方法）。为此可以运行以下代码：</p>
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; from zipfile import ZipFile, ZIP_DEFLATED

&gt;&gt;&gt; directory = pathlib.Path(&quot;source_dir/&quot;)

&gt;&gt;&gt; with ZipFile(&quot;comp_dir.zip&quot;, &quot;w&quot;, ZIP_DEFLATED, compresslevel=9) as archive:
...     for file_path in directory.rglob(&quot;*&quot;):
...         archive.write(file_path, arcname=file_path.relative_to(directory))
...
</code></pre>
<p>在此示例中，将 9 传递给 compresslevel 以获得最大压缩。提供此参数时要使用关键字参数。这是因为 compresslevel 并非 ZipFile 初始化时的第四个位置参数。</p>
<p>Note: ZipFile 的初始化时，接受名为 allowZip64 的第四个参数。这是一个布尔参数，告诉 ZipFile 为大于 4 GB 的文件使用 .zip64 扩展。</p>
<p>运行此代码后，在当前目录中会出现一个 comp_dir.zip 文件。如果将该文件的大小与原始 sample.zip 文件的进行比较，会发现文件大小显著减小。</p>
<h2 id="依次创建-ZIP-文件"><a href="#依次创建-ZIP-文件" class="headerlink" title="依次创建 ZIP 文件"></a>依次创建 ZIP 文件</h2><p>依次创建 ZIP 文件可能是日常编程中的另一个常见需求。例如，可能需要创建一个包含或不包含内容的初始 ZIP 文件，然后在新成员文件可用时立即追加它们。在这种情况下，需要多次打开和关闭目标 ZIP 文件。</p>
<p>为解决这个问题，可以在追加模式（”a”）下使用 ZipFile，像先前那样。此模式允许您安全地将新成员文件追加到 ZIP 归档而不截断其当前内容：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; def append_member(zip_file, member):
...     with zipfile.ZipFile(zip_file, mode=&quot;a&quot;) as archive:
...         archive.write(member)
...

&gt;&gt;&gt; def get_file_from_stream():
...     &quot;&quot;&quot;Simulate a stream of files.&quot;&quot;&quot;
...     for file in [&quot;hello.txt&quot;, &quot;lorem.md&quot;, &quot;realpython.md&quot;]:
...         yield file
...

&gt;&gt;&gt; for filename in get_file_from_stream():
...     append_member(&quot;incremental.zip&quot;, filename)
...

&gt;&gt;&gt; with zipfile.ZipFile(&quot;incremental.zip&quot;, mode=&quot;r&quot;) as archive:
...     archive.printdir()
...
File Name                                        Modified             Size
hello.txt                                 2021-09-07 19:50:10           83
lorem.md                                  2021-09-07 19:50:10         2609
realpython.md                             2021-09-07 19:50:10          428
</code></pre>
<p>在此示例中，append_member() 是一个将文件（member）追加到输入 ZIP 归档（zip_file）的函数。要执行此操作，该函数会在每次被调用时打开和关闭目标归档。使用函数来执行此任务可以根据需要多次复用代码。</p>
<p>get_file_from_stream() 函数是一个生成器函数，用于模拟要处理的文件流。同时，for 循环使用 append_number() 将成员文件依次添加到 incremental.zip 中。如果在运行此代码后检查工作目录，那么您会发现一个 incremental.zip 归档，其中包含传递到循环中的三个文件。</p>
<h2 id="提取文件和目录"><a href="#提取文件和目录" class="headerlink" title="提取文件和目录"></a>提取文件和目录</h2><p>对 ZIP 文件执行的最常见操作之一是将其内容提取到文件系统中的指定目录中。您已经学习了使用 .extract() 和 .extractall() 从归档中提取一个或所有文件的基础知识。</p>
<p>再举一个例子，回到 sample.zip 文件。此时归档包含四个不同类型的文件。有两个 .txt 文件和两个 .md 文件。假设只想提取 .md 文件。为此，可以运行以下代码：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile(&quot;sample.zip&quot;, mode=&quot;r&quot;) as archive:
...     for file in archive.namelist():
...         if file.endswith(&quot;.md&quot;):
...             archive.extract(file, &quot;output_dir/&quot;)
...
&#39;output_dir/lorem.md&#39;
&#39;output_dir/realpython.md&#39;
</code></pre>
<p>with 语句打开 sample.zip 以供读取。循环使用 namelist() 遍历归档中的每个文件，而条件语句检查文件名是否以 .md 扩展名结尾。如果是，则使用 .extract() 将手头的文件解压到目标目录 output_dir/。</p>
<h1 id="探索-zipfile-的其他类"><a href="#探索-zipfile-的其他类" class="headerlink" title="探索 zipfile 的其他类"></a>探索 zipfile 的其他类</h1><p>到目前为止，您已经了解了 zipfile 中可用的两个类： ZipFile 和 ZipInfo。该模块还提供了另外两个在某些情况下能派上用场的类。它们是 zipfile.Path 和 zipfile.PyZipFile。在以下两节中，您将了解这些类的基础知识及其主要功能。</p>
<h1 id="在-ZIP-文件中查找-PATH"><a href="#在-ZIP-文件中查找-PATH" class="headerlink" title="在 ZIP 文件中查找 PATH"></a>在 ZIP 文件中查找 PATH</h1><p>当使用您最爱的归档应用程序打开 ZIP 文件时，会看到归档的内部结构。可能在归档的根目录中有文件。也可能有包含更多文件的子目录。归档看起来很像文件系统上的普通目录，每个文件都位于特定路径（PATH）。</p>
<p>zipfile.Path 类可以构建路径对象以快速创建和管理给定 ZIP 文件中的成员文件和目录的路径。该类接受两个参数：</p>
<p>root 接受一个 ZIP 文件，可以是 ZipFile 对象，也可以是字符串格式的指向物理 ZIP 文件的路径。<br>at 保存归档中特定成员文件或目录的位置。它默认为空字符串，表示归档的根路径。<br>以老朋友 sample.zip 作为目标，运行以下代码：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; hello_txt = zipfile.Path(&quot;sample.zip&quot;, &quot;hello.txt&quot;)

&gt;&gt;&gt; hello_txt
Path(&#39;sample.zip&#39;, &#39;hello.txt&#39;)

&gt;&gt;&gt; hello_txt.name
&#39;hello.txt&#39;

&gt;&gt;&gt; hello_txt.is_file()
True

&gt;&gt;&gt; hello_txt.exists()
True

&gt;&gt;&gt; print(hello_txt.read_text())
Hello, Pythonista!

Welcome to Real Python!

Ready to try Python&#39;s zipfile module?
</code></pre>
<p>这段代码展示了 zipfile.Path 实现了与 pathlib.Path 对象相同的几个功能。可以使用 .name 获取文件的名称。可以使用 .is_file() 来检查路径是否指向一个普通文件。可以检查给定文件是否存在于特定 ZIP 文件中，等等。</p>
<p>Path 还提供了 .open() 方法来使用不同的模式打开成员文件。例如，下面的代码打开 hello.txt 以供读取：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; hello_txt = zipfile.Path(&quot;sample.zip&quot;, &quot;hello.txt&quot;)

&gt;&gt;&gt; with hello_txt.open(mode=&quot;r&quot;) as hello:
...     for line in hello:
...         print(line)
...
Hello, Pythonista!

Welcome to Real Python!

Ready to try Python&#39;s zipfile module?
</code></pre>
<p>使用 Path，可以快速创建指向给定 ZIP 文件中特定成员文件的路径对象，并使用 .open() 立即访问其内容。</p>
<p>就像使用 pathlib.Path 对象一样，可以通过在 zipfile.Path 对象上调用 .iterdir() 来列出 ZIP 文件的内容：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; root = zipfile.Path(&quot;sample.zip&quot;)
&gt;&gt;&gt; root
Path(&#39;sample.zip&#39;, &#39;&#39;)

&gt;&gt;&gt; root.is_dir()
True

&gt;&gt;&gt; list(root.iterdir())
[
    Path(&#39;sample.zip&#39;, &#39;hello.txt&#39;),
    Path(&#39;sample.zip&#39;, &#39;lorem.md&#39;),
    Path(&#39;sample.zip&#39;, &#39;realpython.md&#39;)
]
</code></pre>
<p>显然，zipfile.Path 提供了许多实用的功能，您可以使用这些功能快速管理 ZIP 归档中的成员文件。</p>
<h2 id="使用-PyZipFile-构建可导入的-ZIP-文件"><a href="#使用-PyZipFile-构建可导入的-ZIP-文件" class="headerlink" title="使用 PyZipFile 构建可导入的 ZIP 文件"></a>使用 PyZipFile 构建可导入的 ZIP 文件</h2><p>zipfile 中另一个实用的类是 PyZipFile。这个类与 ZipFile 非常相似，当需要将 Python 模块和包捆绑到 ZIP 文件中时，它特别方便。与 ZipFile 的主要区别在于，PyZipFile 初始化时使用一个名为 optimize 的可选参数，它允许您通过在归档前将 Python 代码编译为字节码来优化 Python 代码。</p>
<p>PyZipFile 提供与 ZipFile 相同的接口，但增加了 .writepy()。此方法可以接受一个 Python 文件（.py）作为参数，并将其添加到底层 ZIP 文件中。如果 optimize 为 -1（默认值），则 .py 文件会自动编译为 .pyc 文件，然后添加到目标归档中。为什么会这样？</p>
<p>从 2.3 开始，Python 解释器支持从 ZIP 文件导入 Python 代码，这种功能称为 Zip imports。它可以创建可导入的 ZIP 文件以将模块和包作为单个归档分发。</p>
<p>Note: 也可以使用 ZIP 文件格式来创建和分发 Python 可执行应用程序（通常称为 Python Zip 应用程序）。要了解如何创建它们，请查看 Python’s zipapp: Build Executable Zip Applications。</p>
<p>当需要生成可导入的 ZIP 文件时，PyZipFile 很有用。打包 .pyc 文件而不是 .py 文件使得导入过程效率大幅提高，因为它跳过了编译步骤。</p>
<p>在 python-zipfile/ 目录中，有一个 hello.py 模块，其内容如下：</p>
<pre><code>&quot;&quot;&quot;Print a greeting message.&quot;&quot;&quot;
# hello.py

def greet(name=&quot;World&quot;):
    print(f&quot;Hello, &#123;name&#125;! Welcome to Real Python!&quot;)
</code></pre>
<p>这段代码定义了一个名为 greet() 的函数，它接受 name 作为参数并将问候消息打印到屏幕上。现在假设您想将此模块打包成一个 ZIP 以进行分发。为此，可以运行以下代码：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.PyZipFile(&quot;hello.zip&quot;, mode=&quot;w&quot;) as zip_module:
...     zip_module.writepy(&quot;hello.py&quot;)
...

&gt;&gt;&gt; with zipfile.PyZipFile(&quot;hello.zip&quot;, mode=&quot;r&quot;) as zip_module:
...     zip_module.printdir()
...
File Name                                        Modified             Size
hello.pyc                                 2021-09-13 13:25:56          311
</code></pre>
<p>在此示例中，对 .writepy() 的调用会自动将 hello.py 编译为 hello.pyc，并将其存储在 hello.zip 中。当使用 printdir() 列出归档的内容时就很明显了。</p>
<p>将 hello.py 捆绑到一个 ZIP 文件后，可以使用 Python 的 import 系统从其包含的归档中导入此模块：</p>
<pre><code>&gt;&gt;&gt; import sys

&gt;&gt;&gt; # Insert the archive into sys.path
&gt;&gt;&gt; sys.path.insert(0, &quot;/home/user/python-zipfile/hello.zip&quot;)
&gt;&gt;&gt; sys.path[0]
&#39;/home/user/python-zipfile/hello.zip&#39;

&gt;&gt;&gt; # Import and use the code
&gt;&gt;&gt; import hello

&gt;&gt;&gt; hello.greet(&quot;Pythonista&quot;)
Hello, Pythonista! Welcome to Real Python!
</code></pre>
<p>从 ZIP 文件导入代码的第一步是使该文件在 sys.path 中可用。此变量包含一个字符串列表，该列表为模块指定 Python 的搜索路径。要向 sys.path 添加新项，可以使用 .insert()。</p>
<p>为了让这个示例正常工作，需要更改占位符路径并将路径指向您的文件系统上的 hello.zip。一旦可导入 ZIP 文件在此列表中，就可以像使用常规模块一样导入代码。</p>
<p>最后，考虑一下工作目录中的 hello/ 子目录。它包含一个具有以下结构的小型 Python 包：</p>
<pre><code>hello/
|
├── __init__.py
└── hello.py
</code></pre>
<p><strong>init</strong>.py 模块将 hello/ 目录转换为 Python 包。hello.py 模块与在上一个示例中使用的模块相同。现在假设您想将此包捆绑到一个 ZIP 文件中。这种情况下，可以执行以下操作：</p>
<pre><code>&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.PyZipFile(&quot;hello.zip&quot;, mode=&quot;w&quot;) as zip_pkg:
...     zip_pkg.writepy(&quot;hello&quot;)
...

&gt;&gt;&gt; with zipfile.PyZipFile(&quot;hello.zip&quot;, mode=&quot;r&quot;) as zip_pkg:
...     zip_pkg.printdir()
...
File Name                                        Modified             Size
hello/__init__.pyc                        2021-09-13 13:39:30          108
hello/hello.pyc                           2021-09-13 13:39:30          317
</code></pre>
<p>对 .writepy() 的调用将 hello 包作为参数，在其中搜索 .py 文件，将它们编译成 .pyc 文件，最后将它们添加到目标 ZIP 文件 hello.zip 中。同样，可以按照之前学习的步骤从该归档中导入代码：</p>
<pre><code>&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.path.insert(0, &quot;/home/user/python-zipfile/hello.zip&quot;)

&gt;&gt;&gt; from hello import hello

&gt;&gt;&gt; hello.greet(&quot;Pythonista&quot;)
Hello, Pythonista! Welcome to Real Python!
</code></pre>
<p>因为现在代码在一个包中，需要先从 hello 包中导入 hello 模块。然后就可以正常访问 greet() 函数了。</p>
<h1 id="从命令行运行-zipfile"><a href="#从命令行运行-zipfile" class="headerlink" title="从命令行运行 zipfile"></a>从命令行运行 zipfile</h1><p>Python 的 zipfile 还提供了一个最小的命令行界面，允许您快速访问模块的主要功能。例如，可以使用 -l 或 –list 选项列出现有 ZIP 文件的内容：</p>
<pre><code>$ python -m zipfile --list sample.zip
File Name                                         Modified             Size
hello.txt                                  2021-09-07 19:50:10           83
lorem.md                                   2021-09-07 19:50:10         2609
realpython.md                              2021-09-07 19:50:10          428
new_hello.txt                              1980-01-01 00:00:00           13
</code></pre>
<p>此命令展示与对 sample.zip 归档调用 printdir() 相同的输出。</p>
<p>现在假设您要创建一个包含多个输入文件的新 ZIP 文件。在这种情况下，可以使用 -c 或者 –creat 选项：</p>
<pre><code>$ python -m zipfile --create new_sample.zip hello.txt lorem.md realpython.md

$ python -m zipfile -l new_sample.zip
File Name                                         Modified             Size
hello.txt                                  2021-09-07 19:50:10           83
lorem.md                                   2021-09-07 19:50:10         2609
realpython.md                              2021-09-07 19:50:10          428
</code></pre>
<p>此命令创建一个 new_sample.zip 文件，其中包含 hello.txt、 lorem.md、 realpython.md 文件。</p>
<p>如果需要创建一个 ZIP 文件来归档整个目录怎么办？例如，您可能拥有自己的 source_dir/，其中包含与上例相同的三个文件。 可以使用以下命令从该目录创建 ZIP 文件：</p>
<pre><code>$ python -m zipfile -c source_dir.zip source_dir/

$ python -m zipfile -l source_dir.zip
File Name                                         Modified             Size
source_dir/                                2021-08-31 08:55:58            0
source_dir/hello.txt                       2021-08-31 08:55:58           83
source_dir/lorem.md                        2021-08-31 09:01:08         2609
source_dir/realpython.md                   2021-08-31 09:31:22          428
</code></pre>
<p>使用此命令，zipfile 将 source_dir/ 作为生成的 source_dir.zip 文件根目录。像往常一样，可以通过使用 -l 选项运行 zipfile 来列出归档内容。</p>
<p>Note: 当使用 zipfile 从命令行创建归档时，库在归档文件时隐式使用 Deflate 压缩算法。</p>
<p>还可以使用命令行中的 -e 或 –extract 选项提取给定 ZIP 文件的所有内容：</p>
<pre><code>python -m zipfile --extract sample.zip sample/
</code></pre>
<p>运行此命令后，工作目录中将有一个新的 sample/ 文件夹。 新文件夹将包含 sample.zip 归档中的当前文件。</p>
<p>可以在命令行中与 zipfile 一起使用的最后一个参数时 -t 或 –test。该选项测试给定文件是否为有效的 ZIP 文件。来吧，试一试！</p>
<h1 id="使用其他库处理-ZIP-文件"><a href="#使用其他库处理-ZIP-文件" class="headerlink" title="使用其他库处理 ZIP 文件"></a>使用其他库处理 ZIP 文件</h1><p>Python 标准库中还有一些其他工具可用于在更底层进行归档、压缩和解压缩文件。Python 的 zipfile 在内部使用了其中的几个，主要用于压缩目的。 以下是部分工具的摘要：</p>
<p>模块    描述<br>zlib    允许使用 zlib 库进行压缩和解压缩<br>bz2    提供使用 Bzip2 压缩算法来压缩和解压数据的接口<br>lzma    提供使用 LZMA 压缩算法压缩和解压缩数据的类和函数<br>不同于 zipfile，其中一些模块支持从内存和数据流中压缩和解压数据，而不是普通文件和归档。</p>
<p>在 Python 标准库中，可以找到支持 TAR 归档格式的 tarfile。还有一个名为 gzip 的模块，它提供了一个压缩和解压数据的接口，类似于 GNU Gzip 程序的做法。</p>
<p>例如，可以使用 gzip 创建一个包含一些文本的压缩文件：</p>
<pre><code>&gt;&gt;&gt; import gzip

&gt;&gt;&gt; with gzip.open(&quot;hello.txt.gz&quot;, mode=&quot;wt&quot;) as gz_file:
...     gz_file.write(&quot;Hello, World!&quot;)
...
</code></pre>
<p>运行此代码后，当前工作目录中将会有一个 hello.txt.gz 归档，其中包含 hello.txt 的压缩版本。在 hello.txt 中有文本 Hello, World!。</p>
<p>在不使用 zipfile 的情况下创建 ZIP 文件的一种快速且高级的方法是使用 shutil。该模块可以对文件和文件集合执行多项高级操作。当涉及到归档操作时，有 make_archive()，它可以创建归档，例如 ZIP 或 TAR 文件：</p>
<pre><code>&gt;&gt;&gt; import shutil

&gt;&gt;&gt; shutil.make_archive(&quot;shutil_sample&quot;, format=&quot;zip&quot;, root_dir=&quot;source_dir/&quot;)
&#39;/home/user/sample.zip&#39;
</code></pre>
<p>此代码在工作目录中创建一个名为 sample.zip 的压缩文件。此 ZIP 文件将包含输入目录 source_dir/ 中的所有文件。当您需要一种快速且高级的方式在 Python 中创建 ZIP 文件时，make_archive() 函数非常方便。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当需要从 ZIP 归档中读取、写入、压缩、解压和提取文件时，Python 的 zipfile 是一个方便的工具。ZIP 文件格式已经成为行业标准，可以打包和压缩数字数据。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python删除目录下的所有文件</title>
    <url>/2023/10/15/%E5%88%A9%E7%94%A8Python%E7%9A%84zipfile%E6%A8%A1%E5%9D%97%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>废话不多说，直接上代码，<br><a href="https://blog.csdn.net/qz_CSDN/article/details/127745062">https://blog.csdn.net/qz_CSDN/article/details/127745062</a></p>
<pre><code>import zipfile
import os


def zip_folder(dir_path, zip_full_name):
    &quot;&quot;&quot;
    压缩文件夹下所有子文件夹和文件
    :param dirpath: 目标文件夹路径
    :param zip_full_name: zip文件绝对路径
    &quot;&quot;&quot;
    with zipfile.ZipFile(zip_full_name, &#39;w&#39;, zipfile.ZIP_DEFLATD) as zf:
        for dir_full_path, dir_names, file_names in os.walk(dir_path):
            # zip压缩包内的相对路径
            dir_path_inzip = dir_full_path.replace(dirpath, &#39;&#39;)
            for dir_name in dir_names:
                zf.write(os.path.join(dir_full_path, dir_name), os.path.join(dir_path_inzip, dir_name))
            for file_name in file_names:
                zf.write(os.path.join(dir_full_path, file_name), os.path.join(dir_path_inzip, file_name))
    zf.close()


if __name__ == &#39;__name__&#39;:
    in_path = u&quot;F:\\测试\\1&quot;
    out_path = u&quot;F:\\测试\\输出&quot;
    
    folder_name_list = os.listdir(in_path)
    count = 0
    # 遍历输入路径下所有子文件夹，分别压缩
    for folder_name in folder_name_list:
        count += 1
        zip_file_fullname = os.path.join(out_path, folder_name + &quot;.zip&quot;)
        print(&quot;&#123;0&#125;、&#123;1&#125;&quot;.format(count, folder_name))
        print(&quot;    &#123;0&#125;&quot;.format(zip_file_fullname))
        zip_folder(os.path.join(in_path, folder_name), zip_file_fullname)
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python删除目录下的所有文件</title>
    <url>/2023/10/14/Python%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.python100.com/html/4XI33HW03WL0.html">https://www.python100.com/html/4XI33HW03WL0.html</a></p>
<p>一、Python删除目录及目录下文件</p>
<pre><code>import shutil
import os

dir_path = &#39;/path/to/directory&#39;

# 删除目录
shutil.rmtree(dir_path)
</code></pre>
<p>当你想要删除一个目录以及里面所有的文件时，你可以使用shutil模块中的rmtree()函数。该函数可以删除整个目录，包括其所有的文件和子目录。这是最便捷的方法，但是请确保你真的需要这么做。</p>
<p>二、Python删除目录中所有内容</p>
<pre><code>import os

dir_path = &#39;/path/to/directory&#39;

# 删除目录中所有的文件
for filename in os.listdir(dir_path):
    file_path = os.path.join(dir_path, filename)
    if os.path.isfile(file_path) or os.path.islink(file_path):
        os.unlink(file_path)
    elif os.path.isdir(file_path):
        shutil.rmtree(file_path)

# 删除目录本身
os.rmdir(dir_path)
</code></pre>
<p>如果你想要删除目录中所有内容，但是保留目录本身，你可以使用os模块中listdir()和unlink()函数来遍历该目录中的所有文件并逐个删除。在删除文件夹之前，必须先删除所有文件和子目录。</p>
<p>三、Python os删除目录</p>
<pre><code>import os

dir_path = &#39;/path/to/directory&#39;

# 删除目录
os.removedirs(dir_path)
</code></pre>
<p>os.removedirs()函数可以删除指定的目录。如果该目录是一个空目录，则可以直接删除它。如果该目录不是空目录，则需要递归地删除其所有子目录和文件。</p>
<p>四、Python删除指定目录下的文件</p>
<pre><code>import os

dir_path = &#39;/path/to/directory&#39;

# 删除指定格式的文件
for filename in os.listdir(dir_path):
    if filename.endswith(&#39;.txt&#39;):
        os.unlink(os.path.join(dir_path, filename))
</code></pre>
<p>如果你只想删除指定格式的文件，你可以使用listdir()和endswith()函数来列出该目录中满足指定格式的所有文件，并逐个删除。</p>
<p>五、Python删除非空目录</p>
<pre><code>import shutil

dir_path = &#39;/path/to/directory&#39;

# 删除非空目录
shutil.rmtree(dir_path)
</code></pre>
<p>如果你只想删除非空目录，你可以使用shutil模块的rmtree()函数。请注意，该函数可以删除目录和其中的所有文件和子目录。</p>
<p>通过上述5种方法，你可以选择最适用于你的需求的方法来删除指定目录下的所有文件。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python判断文件是否存在并且删除</title>
    <url>/2023/10/13/Python%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%B9%B6%E4%B8%94%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.python100.com/html/4XI33HW03WL0.html">https://www.python100.com/html/4XI33HW03WL0.html</a></p>
<p>对于不熟悉Python文件操作的开发者来说，如何判断文件是否存在并删除是一件常见的问题。本文将会详细介绍Python如何判断文件是否存在，并通过多个方面介绍如何删除指定文件。</p>
<p>一、Python如何判断文件是否存在？</p>
<p>在Python中，使用os和os.path模块可以判断文件是否存在。下面是一个判断文件是否存在的代码：</p>
<pre><code>import os

if os.path.isfile(&#39;test.txt&#39;):
    print(&quot;File exists&quot;)
else:
    print(&quot;File not exists&quot;)
</code></pre>
<p>上面的代码通过isfile()函数判断指定文件是否存在，如果存在则输出”File exists”，否则输出”File not exists”。</p>
<pre><code>import os

if os.path.exists(&#39;/path/to/file&#39;):
    print(&#39;文件存在&#39;)
else:
    print(&#39;文件不存在&#39;)
</code></pre>
<p>以上代码中，/path/to/file是要检测的文件路径。如果文件存在，就会输出文件存在，否则输出文件不存在。</p>
<p>二、Python如何删除文件？</p>
<p>如果我们需要删除文件，可以使用Python的os模块中的remove函数。下面是一个删除文件的代码：</p>
<pre><code>import os

if os.path.isfile(&#39;test.txt&#39;):
    os.remove(&#39;test.txt&#39;)
    print(&quot;File removed&quot;)
else:
    print(&quot;File not exists&quot;)
</code></pre>
<p>上面的代码会检查文件是否存在，如果存在则删除文件，并输出”File removed”，否则输出”File not exists”。</p>
<p>三、Python如何删除目录？</p>
<p>如果我们需要删除整个目录，可以使用Python的os模块中的rmdir函数或者shutil模块中的rmtree函数。下面是一个使用rmdir函数删除目录的代码：</p>
<pre><code>import os

if os.path.isdir(&#39;test&#39;):
    os.rmdir(&#39;test&#39;)
    print(&quot;Directory removed&quot;)
else:
    print(&quot;Directory not exists&quot;)
</code></pre>
<p>上面的代码会检查目录是否存在，如果存在则删除目录，并输出”Directory removed”，否则输出”Directory not exists”。</p>
<p>使用shutil模块的rmtree函数可以删除整个目录，包括目录下的所有文件和子目录。下面是一个使用rmtree函数删除目录的代码：</p>
<pre><code>import shutil

if os.path.exists(&#39;test&#39;):
    shutil.rmtree(&#39;test&#39;)
    print(&quot;Directory removed&quot;)
else:
    print(&quot;Directory not exists&quot;)
</code></pre>
<p>上面的代码会检查目录是否存在，如果存在则删除目录，并输出”Directory removed”，否则输出”Directory not exists”。</p>
<p>四、Python如何删除特定类型的文件？</p>
<p>如果我们需要删除特定类型的文件，可以通过glob模块来获取所有指定类型的文件，然后使用os模块中的remove函数删除它们。下面是一个删除所有txt文件的代码：</p>
<pre><code>import glob, os

for file in glob.glob(&quot;*.txt&quot;):
    os.remove(file)
    print(&quot;File removed: %s&quot; % file)
</code></pre>
<p>上面的代码会列出所有txt文件，并依次删除它们。删除每个文件时，代码会输出”File removed: file.txt”，其中file.txt是被删除的文件名。</p>
<p>五、总结</p>
<p>本文详细介绍了如何在Python中判断文件是否存在并删除。从多个方面介绍了如何删除文件和目录，以及如何删除特定类型的文件。为Python开发者提供了解决类似问题的思路和代码示例，希望本文对您有所帮助。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中查找文件是否存在</title>
    <url>/2023/10/12/Python%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.python100.com/html/14E0N1LV1S5V.html">https://www.python100.com/html/14E0N1LV1S5V.html</a></p>
<p>在Python编程中，我们经常需要查找文件是否存在。这个功能在文件处理、数据分析、系统管理等各个领域都非常有用。在本文中，我们将以Python作为中心，详细介绍如何使用Python来查找文件是否存在。</p>
<p>一、使用os模块的方法</p>
<p>Python的标准库中的os模块提供了一些方法来操作文件和目录。其中，os.path模块提供了一些判断文件或目录是否存在的函数。</p>
<pre><code>import os

# 检查文件是否存在
def file_exists(path):
    return os.path.exists(path)

# 检查目录是否存在
def directory_exists(path):
    return os.path.isdir(path)
</code></pre>
<p>使用os.path.exists函数可以判断文件是否存在，返回值为True或False。如果文件存在，则返回True；如果文件不存在，则返回False。</p>
<p>使用os.path.isdir函数可以判断目录是否存在，返回值同样为True或False。如果目录存在，则返回True；如果目录不存在，则返回False。</p>
<p>二、使用glob模块的方法</p>
<p>除了os模块，Python还提供了一个强大的文件和目录操作模块glob。glob模块可以使用通配符来查找文件。</p>
<pre><code>import glob

# 查找指定目录下的所有文件
def find_files(directory, pattern):
    return glob.glob(os.path.join(directory, pattern))

# 判断文件是否存在
def file_exists(path):
    return len(find_files(os.path.dirname(path), os.path.basename(path))) &gt; 0
</code></pre>
<p>使用glob.glob函数可以根据通配符模式查找符合条件的文件。在find_files函数中，我们使用os.path.join函数将目录和文件名拼接在一起，然后使用glob.glob函数查找匹配的文件。</p>
<p>在file_exists函数中，我们调用find_files函数查找指定文件并返回匹配到的文件列表，然后用len函数来判断文件列表的长度。如果长度大于0，则表示文件存在；如果长度等于0，则表示文件不存在。</p>
<p>三、使用pathlib模块的方法</p>
<p>Python 3.4及以上版本引入的pathlib模块提供了一种更简洁的方式来查找文件。</p>
<pre><code>from pathlib import Path

# 检查文件是否存在
def file_exists(path):
    return Path(path).is_file()

# 检查目录是否存在
def directory_exists(path):
    return Path(path).is_dir()
</code></pre>
<p>在pathlib模块中，我们可以使用Path类的is_file方法来判断文件是否存在，使用is_dir方法来判断目录是否存在。这些方法返回值同样为True或False。</p>
<p>四、其他注意事项<br>在使用Python查找文件是否存在时，还有一些注意事项需要注意：</p>
<ol>
<li><p>文件路径的表示：在使用文件路径时，我们需要注意使用不同的表示方式，如绝对路径、相对路径、转义字符等。</p>
</li>
<li><p>文件权限的问题：有时候文件存在，但是由于权限问题，我们无法操作或读取该文件。</p>
</li>
<li><p>文件名和文件后缀：有时候文件名或文件后缀的大小写问题可能导致文件找不到。</p>
</li>
</ol>
<p>总结来说，使用Python查找文件是否存在需要借助os模块、glob模块或pathlib模块，根据具体的需求选择合适的方法。同时，在使用过程中还需注意文件路径、文件权限和文件名后缀等问题。</p>
<p>希望本文对你理解Python中查找文件是否存在有所帮助！</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pyqt界面美化笔记</title>
    <url>/2023/10/11/pyqt%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.bilibili.com/video/BV1VY4y1p7it/?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1VY4y1p7it/?spm_id_from=333.999.0.0</a></p>
<p>1、窗体用label贴图或配色，做背景</p>
<pre><code>background-color: rgba(16,30,41,240);
border-radius:10px;
</code></pre>
<p>2、lineedit配色及调样式</p>
<pre><code>background-color: rgba(0, 0, 0,0);
border:1px solid rgba(0,0,0,0);
border-bottom-color:rgba(255,255,255,200);
padding-bottom:7px;
</code></pre>
<p>3、pushbutton配色及调样式</p>
<pre><code>QPushButton#pushButton&#123;
background-color:rgba(2,65,118,255);
color:rgba(255,255,255,200);
border-radius:5px;
&#125;
QPushButton#pushButton:hover&#123;
background-color:rgba(2,65,118,150);
color:rgba(255,255,255,200);
border-radius:5px;
&#125;
QPushButton#pushButton:pressed&#123;
padding-left:5px;
padding-top:5px;
background-color:rgba(2,65,118,100);
&#125;
</code></pre>
<p>4、隐藏框：</p>
<pre><code>MainWindow.setWindowFlags(QtCore.Qt.FramelessWindowHint)
MainWindow.setAttribute(QtCore.Qt.WA_TranslucentBackground)
</code></pre>
<p>5、main函数</p>
<pre><code>import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
import login
if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    win = QMainWindow()
    ui = login.Ui_MainWindow()
    ui.setupUi(win)
    win.show()
    sys.exit(app.exec_())
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pyqt5的打包exe软件</title>
    <url>/2023/10/10/pyqt5%E7%9A%84%E6%89%93%E5%8C%85exe%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装命令："><a href="#安装命令：" class="headerlink" title="安装命令："></a>安装命令：</h1><pre><code>pip install pyinstaller
</code></pre>
<h1 id="更新命令："><a href="#更新命令：" class="headerlink" title="更新命令："></a>更新命令：</h1><pre><code>pip install –upgrade pyinstaller
</code></pre>
<h1 id="打包命令："><a href="#打包命令：" class="headerlink" title="打包命令："></a>打包命令：</h1><p>通过下述命令可以打包出带有指定图标的exe，注意必须是真实的ico格式图标，不能是改后名的。</p>
<pre><code>pyinstaller main.py -y -w -i &quot;D:\workspace\mytool\ui\icons\mytool.ico&quot;
</code></pre>
<h1 id="打包命令常用选项。"><a href="#打包命令常用选项。" class="headerlink" title="打包命令常用选项。"></a>打包命令常用选项。</h1><pre><code>-y 表示自动覆盖现有的 build 和 dist 文件夹
-h，–help    查看该模块的帮助信息
-F，-onefile    产生单个的可执行文件
-D，–onedir    产生一个目录（包含多个文件）作为可执行程序
-a，–ascii    不包含 Unicode 字符集支持
-d，–debug    产生 debug 版本的可执行文件
-w，–windowed，–noconsolc    指定程序运行时不显示命令行窗口（仅对 Windows 有效）
-c，–nowindowed，–console    指定使用命令行窗口运行程序（仅对 Windows 有效）
-o DIR，–out=DIR    指定 spec 文件的生成目录。如果没有指定，则默认使用当前目录来生成 spec 文件
-p DIR，–path=DIR    设置 Python 导入模块的路径（和设置 PYTHONPATH 环境变量的作用相似）。也可使用路径分隔符（Windows 使用分号，Linux 使用冒号）来分隔多个路径
-n NAME，–name=NAME    指定项目（产生的 spec）名字。如果省略该选项，那么第一个脚本的主文件名将作为 spec 的名字
--distpath：指定输出目录
--clean：在打包之前清除临时文件夹日志
--log-level：设置日志级别，供调试嵌入其他文件
--add-data：将data文件夹嵌入到生成的可执行文件中
--add-binary：将binary文件与其他文件一起嵌入到可执行文件中
--hidden-import：打包特定的Python库，例如--hidden-import=PIL
--version：显示版本信息
--help：显示帮助信息
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm安装PyQt5及工具（Qt Designer、PyUIC、PyRcc）详细教程</title>
    <url>/2023/10/09/PyCharm%E5%AE%89%E8%A3%85PyQt5%E5%8F%8A%E5%B7%A5%E5%85%B7%EF%BC%88Qt%20Designer%E3%80%81PyUIC%E3%80%81PyRcc%EF%BC%89%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>需要安装PyQt5，pyqt5-tools</p>
<pre><code>pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install pyqt5-tools -i https://pypi.tuna.tsinghua.edu.cn/simple

# 如有需要安装PyQtWebEngine
pip install PyQtWebEngine -i https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>PyCharm点击菜单栏“File”，弹出下拉框，选择“Setting”，弹出设置界面。在设置界面中选择“Tools”→“External Tools”，</p>
<h2 id="Qt-Designer"><a href="#Qt-Designer" class="headerlink" title="Qt Designer"></a>Qt Designer</h2><p>在“Name”一栏填写“Qt-Designer”；在“Program”一栏填写designer.exe文件位置</p>
<h2 id="PyUIC"><a href="#PyUIC" class="headerlink" title="PyUIC"></a>PyUIC</h2><p>1、在“Name”一栏填写“PyUIC”；</p>
<p>2、Program中填写pyuic5.exe这个程序的文件路径，一般在“Python环境目录\Scripts\pyuic5.exe”（此处需根据实际情况修改）</p>
<p>3、在Arguments中内容填写如下：</p>
<pre><code>$FileName$ -o $FileNameWithoutExtension$.py
</code></pre>
<p>4、Working directory内容填写如下：</p>
<pre><code>$FileDir$
</code></pre>
<p>5、完成填写后，点击“OK”，以上步骤参考图片中的步骤。</p>
<h2 id="PyRCC"><a href="#PyRCC" class="headerlink" title="PyRCC"></a>PyRCC</h2><p>1、在“Name”一栏填写“PyRCC”；</p>
<p>2、Program中填写pyrcc5.exe这个程序的文件路径，一般在“Python环境目录\Scripts\pyrcc5.exe”（此处需根据实际情况修改），也可以点击右侧的文件夹选择按钮浏览文件夹选中该位置；</p>
<p>3、在Arguments中内容填写如下：</p>
<pre><code>$FileName$ -o $FileNameWithoutExtension$_rc.py
</code></pre>
<p>4、Working directory内容填写如下：</p>
<pre><code>$FileDir$
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus 通用IService使用时的一些方法</title>
    <url>/2023/10/08/MyBatis-Plus%20%E9%80%9A%E7%94%A8IService%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法:"></a>普通方法:</h1><pre><code>//查询所有
userService .list();
//根据查询条件查询一个返回实体类对象
userService.getOne(lambdaQueryWrapper);
//分页查询所有
userService.page(pageInfo,lambdaQueryWrapper);
//查询数量
userService .count();
//根据ID查list集合
userService .listByIds();
//根据ID删除
userService .removeById();
userService .removeByIds();
//修改
userService .update();
userMapper.updateById(实体类);
//新增
userService .save();
userMapper.insert(实体类);
//批量新增
userService .saveBatch(集合);
</code></pre>
<h1 id="getOne"><a href="#getOne" class="headerlink" title="getOne()"></a>getOne()</h1><p>这个是方法返回结果不止一条则会抛出异常，如果想默认取第一条结果，可以给这方法传第二个参数为false。</p>
<pre><code>User one = userService.getOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getAge, 11),false);
</code></pre>
<h1 id="saveOrUpdateBatch"><a href="#saveOrUpdateBatch" class="headerlink" title="saveOrUpdateBatch()"></a>saveOrUpdateBatch()</h1><p>批量新增或者修改方法,判断ID是否存在，如果ID不存在执行新增，如果ID存在先执行查询语句，查询结果为空新增，否则修改。</p>
<pre><code>boolean b = userService.saveOrUpdateBatch(users);
</code></pre>
<h1 id="传值为null的时候不查询"><a href="#传值为null的时候不查询" class="headerlink" title="传值为null的时候不查询"></a>传值为null的时候不查询</h1><p>如果传值为null的时候不查询，有值才查询怎么做？<br>这里用到了hutool的ObjectUtil.isNotEmpty来判非空</p>
<pre><code>//查询时间范围
LambdaQueryWrapper&lt;ProductKhtm&gt; productKhtmLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
productKhtmLambdaQueryWrapper.between(
ObjectUtil.isNotEmpty(productKhtmhz.getParams().get(&quot;endDbilldate&quot;)),
ProductKhtm::getDbilldate,
productKhtmhz.getParams().get(&quot;beginDbilldate&quot;),
productKhtmhz.getParams().get(&quot;endDbilldate&quot;)
);

productKhtmService.list(productKhtmLambdaQueryWrapper);
</code></pre>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>如果sql语句后面想补充一句sql语句应该怎么办？用last</p>
<pre><code>lambdaQueryWrapper.last(&quot;OFFSET 0 ROWS FETCH NEXT 1 ROWS ONLY&quot;);
</code></pre>
<p>注意这个自定义慎用，会有sql注入的风险</p>
<p>如果sql查询条件全部都想自定义怎么办？</p>
<pre><code>lambdaQueryWrapper.apply(&quot;YEAR(tijiao_time) = &#123;0&#125;&quot;,year);
</code></pre>
<p>注意这个自定义慎用，会有sql注入的风险</p>
<p>————————————————<br>版权声明：本文为CSDN博主「z子豪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/a864034462/article/details/123980761">https://blog.csdn.net/a864034462/article/details/123980761</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>LambdaUpdateWrapper和LambdaQueryWrapper的区别</title>
    <url>/2023/10/07/LambdaUpdateWrapper%E5%92%8CLambdaQueryWrapper%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LambdaQueryWrapper是查询时候给条件,例如</p>
<pre><code>/**
 * lambda链式编程
 */
@Test
public void test88()&#123;
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    queryWrapper.lambda()
            .between(User::getAge,30,60)
            .orderByDesc(User::getId);
    List&lt;User&gt; list = userService.list(queryWrapper);
    list.forEach(System.out::println);
&#125;
</code></pre>
<p>LambdaUpdateWrapper是修改的时候给的条件,例如:</p>
<pre><code>/**
 * 测试链式编程更新操作
 */
@Test
public void test99()&#123;
    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();
    updateWrapper.lambda()
            .le(User::getAge, 30)
            .setSql(&quot;email = &#39;le30@duck.top&#39;&quot;);
    userService.update(updateWrapper);
&#125;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「z子豪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/a864034462/article/details/123980761">https://blog.csdn.net/a864034462/article/details/123980761</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>LambdaQueryWrapper如何正确使用or或者and</title>
    <url>/2023/10/06/LambdaQueryWrapper%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8or%E6%88%96%E8%80%85and/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="例子1"><a href="#例子1" class="headerlink" title="例子1:"></a>例子1:</h1><pre><code>LambdaQueryWrapper&lt;SysUser&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
lambdaQueryWrapper.or((wrapper)-&gt;&#123;
    wrapper.eq(SysUser::getUserName, idUserPayBalUserName).or();
    wrapper.eq(SysUser::getPhonenumber, idUserPayBalUserName);
    &#125;);
lambdaQueryWrapper.and((wrapper)-&gt;&#123;
    wrapper.eq(SysUser::getNickName, idUserPayBalName);
        &#125;
            );
SysUser one = userService.getOne(lambdaQueryWrapper);
</code></pre>
<p>sql语句为</p>
<pre><code>SELECT *
 FROM sys_user
 WHERE ((user_name = &#39;15666666669&#39; OR phonenumber = &#39;15666666669&#39;) AND (nick_name = &#39;15666666669&#39;));
</code></pre>
<p>也就是说,使用or()包裹的代码执行后是在sql语句的括号内,再次使用or()或者and()则另起一个括号.</p>
<h1 id="例子2"><a href="#例子2" class="headerlink" title="例子2:"></a>例子2:</h1><pre><code>LambdaQueryWrapper&lt;SysUser&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
    lambdaQueryWrapper.eq(SysUser::getUserName, idUserPayBalUserName).or();
    lambdaQueryWrapper.eq(SysUser::getPhonenumber, idUserPayBalUserName);
    lambdaQueryWrapper.eq(SysUser::getNickName, idUserPayBalName);
    SysUser one = userService.getOne(lambdaQueryWrapper);
</code></pre>
<p>sql语句为</p>
<pre><code>SELECT *
 FROM sys_user
 WHERE (user_name = &#39;15666666669&#39; OR phonenumber = &#39;15666666669&#39; AND nick_name = &#39;123&#39;);
</code></pre>
<p>可以理解为如下这个语句👇,所以这个sql和上面的例子的sql执行后的结果是完全不一样的.</p>
<pre><code>SELECT *
 FROM sys_user
 WHERE (user_name = &#39;15666666669&#39; OR (phonenumber = &#39;15666666669&#39; AND nick_name = &#39;123&#39;));
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「z子豪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/a864034462/article/details/123980761">https://blog.csdn.net/a864034462/article/details/123980761</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus高级查询LambdaQueryWrapper&amp;QueryWrapper</title>
    <url>/2023/10/05/Mybatis-Plus%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2LambdaQueryWrapper&amp;QueryWrapper/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h1><p>LambdaQueryWrapper使用lambda表达式可以直接通过实体类get()属性，而QueryWrapper必须要与数据库的中表名一致，由于表名可能会很复杂，这时候相较而言LambdaQueryWrapper会比QueryWrapper便捷不少</p>
<h1 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h1><p>查询构造器</p>
<pre><code>条件    说明
allEq    基于 map 的比较
eq    等于 =
ne    不等于 &lt;&gt; 或者 !=
gt    大于 &gt;
ge    大于等于 &gt;=
lt    小于 &lt;
le    小于等于 &lt;
between    BETWEEN 值1 AND 值2
notBetween    NOT BETWEEN 值1 AND 值2
like    LIKE ‘%值%’
notLike    NOT LIKE ‘%值%’
likeLeft    LIKE ‘%值’
likeRight    LIKE ‘值%’
isNull    字段 IS NULL
isNotNull    字段 IS NOT NULL
in    字段 IN (value1, value2, …)
notIn    字段 NOT IN (value1, value2, …)
inSql    字段 IN (sql 语句)
inSql(“age”, “1,2,3”) -&gt; age in (1,2,3)
inSql(“id”, “select id from student where id &lt; 3”) -&gt; id in (select id from student where id &lt; 3)
notInSql    字段 NOT IN (sql 语句)
groupBy    GROUP BY 字段
orderByAsc    升序 ORDER BY 字段, … ASC
orderByDesc    降序 ORDER BY 字段, … DESC
orderBy    自定义字段排序
orderBy(true, true, “id”, “name”) -&gt; order by id ASC, name ASC
having    条件分组
or    OR 语句，拼接 + OR 字段=值
and    AND 语句，拼接 + AND 字段=值
apply    拼接 sql
last    在 sql 语句后拼接自定义条件
exists    拼接 EXISTS(sql语句)
exists(“selece id from student where age = 1”) -&gt; exists(selece id from student where age = 1)
notExists    拼接 NOT EXISTS(sql语句)
nested    正常嵌套 不带 AND 或者 OR
</code></pre>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="创建一个数据库-mybatisplus"><a href="#创建一个数据库-mybatisplus" class="headerlink" title="创建一个数据库 mybatisplus"></a>创建一个数据库 mybatisplus</h2><h2 id="创建-user-表"><a href="#创建-user-表" class="headerlink" title="创建 user 表"></a>创建 user 表</h2><pre><code>CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `email` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</code></pre>
<h2 id="创建-springboot-工程"><a href="#创建-springboot-工程" class="headerlink" title="创建 springboot 工程"></a>创建 springboot 工程</h2><h2 id="导入对应-maven-坐标"><a href="#导入对应-maven-坐标" class="headerlink" title="导入对应 maven 坐标"></a>导入对应 maven 坐标</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.3&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.cmy&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis_plus&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;mybatis_plus&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
 
        &lt;!-- mybatis-plus --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.0&lt;/version&gt;
        &lt;/dependency&gt;
 
        &lt;!-- mysql --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
 
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
 
&lt;/project&gt;
</code></pre>
<h2 id="mysql数据库相关配置"><a href="#mysql数据库相关配置" class="headerlink" title="mysql数据库相关配置"></a>mysql数据库相关配置</h2><pre><code>spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1/mybatisplus?useUnicode=true&amp;characterEncoding=utf-8
    username: root
    password: root
mybatis-plus 日志信息配置
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<h2 id="创建实体类-User"><a href="#创建实体类-User" class="headerlink" title="创建实体类 User"></a>创建实体类 User</h2><pre><code>package com.cmy.mybatis_plus.entity;
 
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
 
/**
 * 实体类 user
 */
public class User &#123;
    /**
     * 指定主键id生成的方式
     * value 是主键字段的名称，如果是id，可以不用写
     * type 指定主键的类型，主键的值如何生成。idType.AUTO 自动增长
     */
    @TableId(
            value = &quot;id&quot;,
            type = IdType.AUTO
    )
    private Long id;
    private String name;
    private String email;
    private Integer age;
 
    public Long getId() &#123;
        return id;
    &#125;
 
    public void setId(Long id) &#123;
        this.id = id;
    &#125;
 
    public String getName() &#123;
        return name;
    &#125;
 
    public void setName(String name) &#123;
        this.name = name;
    &#125;
 
    public String getEmail() &#123;
        return email;
    &#125;
 
    public void setEmail(String email) &#123;
        this.email = email;
    &#125;
 
    public Integer getAge() &#123;
        return age;
    &#125;
 
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
 
    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, email=&#39;&quot; + email + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="自定义-User-的-Mapper-接口"><a href="#自定义-User-的-Mapper-接口" class="headerlink" title="自定义 User 的 Mapper 接口"></a>自定义 User 的 Mapper 接口</h2><pre><code>package com.cmy.mybatis_plus.mapper;
 
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.cmy.mybatis_plus.entity.User;
 
/**
 * 自定义 Mapper 接口，就是 dao 接口
 * 1. 实现BaseMapper
 * 2. 指定实体类（泛型）
 *
 * BaseMapper 是 MP 框架中的对象，定义了 17 个操作方法（CRUD）
 */
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<h1 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h1><h2 id="allEq"><a href="#allEq" class="headerlink" title="allEq"></a>allEq</h2><p>条件用 Map 进行封装</p>
<pre><code>“name” -&gt; “张三”
“age” -&gt; 20

public void testAllEq() &#123;
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    // 封装条件
    Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();
    hashMap.put(&quot;name&quot;, &quot;张三&quot;);
    hashMap.put(&quot;age&quot;, 20);
 
    queryWrapper.allEq(hashMap);
 
    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);
    userList.forEach(user -&gt; &#123;
        System.out.println(user);
    &#125;);
&#125;
</code></pre>
<h2 id="eq"><a href="#eq" class="headerlink" title="eq"></a>eq</h2><p>eq(“列名”, 值) -&gt; 列名 = 值</p>
<pre><code>public List&lt;Dict&gt; listByDictCode(DictCode dictCode) &#123;
    LambdaQueryWrapper&lt;Dict&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.eq(Dict::getDictCode, dictCode.getCode())
           .eq(Dict::getEnabled, DictEnableEnum.VALID.getType());
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="ne"><a href="#ne" class="headerlink" title="ne"></a>ne</h2><p>ne(“列名”, 值) -&gt; 列名 != 值</p>
<pre><code>public List&lt;Dict&gt; listByDictCode(DictCode dictCode) &#123;
    LambdaQueryWrapper&lt;Dict&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.ne(Dict::getDictCode, dictCode.getCode())
           .ne(Dict::getEnabled, DictEnableEnum.VALID.getType());
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="gt"><a href="#gt" class="headerlink" title="gt"></a>gt</h2><p>gt(“age”, 20) -&gt; age &gt; 20</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.gt(User::getAge, 20);            
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="ge"><a href="#ge" class="headerlink" title="ge"></a>ge</h2><p>ge(“age”, 20) -&gt; age &gt;= 20</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.ge(User::getAge, 20);            
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="lt"><a href="#lt" class="headerlink" title="lt"></a>lt</h2><p>lt(“age”, 20) -&gt; age &lt; 20</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.lt(User::getAge, 20);            
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="le"><a href="#le" class="headerlink" title="le"></a>le</h2><p>le(“age”, 21) -&gt; age &lt;= 21</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.le(User::getAge, 20);            
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="between-notBetween"><a href="#between-notBetween" class="headerlink" title="between,notBetween"></a>between,notBetween</h2><p>between(“age”, 18, 25) -&gt; age BETWEEN 18 AND 25 ，年龄在18到25之间</p>
<p>notBetween就是不在18到25之间</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.between(User::getAge, 18,25);                
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="like-notLike"><a href="#like-notLike" class="headerlink" title="like,notLike"></a>like,notLike</h2><p>like 匹配值 -&gt; “%值%” 模糊查询</p>
<p>notLike 模糊查询不匹配”%值%”</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
     wrapper.like(User::getName, &quot;张&quot;);           
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="likeLeft"><a href="#likeLeft" class="headerlink" title="likeLeft"></a>likeLeft</h2><p>likeLeft 匹配值 -&gt; “%值”</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
     wrapper.likeLeft(User::getName, &quot;张&quot;);           
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="likeRight"><a href="#likeRight" class="headerlink" title="likeRight"></a>likeRight</h2><p>likeRight 匹配值 -&gt; “值%”</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.likeRight(User::getName, &quot;张&quot;);           
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="isNull，isNotNull"><a href="#isNull，isNotNull" class="headerlink" title="isNull，isNotNull"></a>isNull，isNotNull</h2><p>isNull 空值查询<br>isNotNull 非空值查询</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.isNull(User::getName);
    //wrapper.isNotNull(User::getName);              
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="in，notIn"><a href="#in，notIn" class="headerlink" title="in，notIn"></a>in，notIn</h2><p>in(“name”, “张三”, “李四”) -&gt; name in (“张三”, “李四”) 姓名是张三或李四的用户</p>
<p>notIn(“name”, “张三”, “李四”) -&gt; name not in (“张三”, “李四”) 姓名不是张三或李四的用户</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();
    wrapper.in(User::getName, &quot;张三&quot;,&quot;李四&quot;);
    //wrapper.in(User::getName, &quot;张三&quot;,&quot;李四&quot;);           
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="inSql、notInSql"><a href="#inSql、notInSql" class="headerlink" title="inSql、notInSql"></a>inSql、notInSql</h2><pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper= new LambdaQueryWrapper&lt;&gt;();
    // SELECT id,name,email,age FROM user WHERE (age IN (select age from user where id = 1))
    wrapper.inSql(User::getAge, &quot;select age from user where id = 1&quot;);
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>分组</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
    wrapper.groupBy(User::getName);
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="orderBy、orderByAsc、orderByDesc"><a href="#orderBy、orderByAsc、orderByDesc" class="headerlink" title="orderBy、orderByAsc、orderByDesc"></a>orderBy、orderByAsc、orderByDesc</h2><pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
    // SELECT id,name,email,age FROM user ORDER BY name ASC,age DESC
    wrapper.orderBy(true, true, User::getName).orderBy(true, false, User::getAge);
    
    // SELECT id,name,email,age FROM user ORDER BY name ASC,age ASC
    wrapper.orderByAsc(User::getName, User::getAge);
 
    // SELECT id,name,email,age FROM user ORDER BY name DESC,age DESC
    wrapper.orderByDesc(User::getName, User::getAge);
 
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h2 id="or、and"><a href="#or、and" class="headerlink" title="or、and"></a>or、and</h2><pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();

    // SELECT id,name,email,age FROM user WHERE (name = ? AND id = ?)
    wrapper.eq(User::getName, &quot;张三&quot;).and().eq(User::getId,1);

    // SELECT id,name,email,age FROM user WHERE (name = ? OR id = ?)       
    wrapper.eq(User::getName, &quot;张三&quot;).or().eq(User::getId,1);     
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<p>这里说明一下or和and的问题</p>
<p>错误代码</p>
<pre><code>public List&lt;User&gt; userList() &#123;
 
    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
    wrapper.eq(User::getId,1);
    wrapper.like(User::getName,&quot;张&quot;)
           .or()
           .like(User::getEmail,&quot;163&quot;)
           .or()
           .like(User::getAge,1);
&#125;
</code></pre>
<p>根据上面的写法写出的sql语句如下：</p>
<pre><code>WHERE id = &#39;1&#39; 
    AND name LIKE &#39;%张%&#39;
    OR email LIKE &#39;%163%&#39;
    OR age LIKE &#39;%1%&#39;
</code></pre>
<p>这样明显是不对的，根据mysql语句执行顺序or最后执行 ，这会导致一旦[name like ‘%张%’]条件成立后面的or条件就会失效，所以第一个条件 并没有起到and的作用。</p>
<p>解决方法</p>
<pre><code>public List&lt;User&gt; userList() &#123;
 
    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
    wrapper.eq(User::getId,1);
    wrapper.and(wrapper-&gt;wrapper.like(User::getName,&quot;张&quot;)
                                .or()
                                .like(User::getEmail,&quot;163&quot;)
                                .or()
                                .like(User::getAge,1)
               );
&#125;
</code></pre>
<p>这样得到的sql语句如下</p>
<pre><code>WHERE id = &#39;1&#39; 
    AND (name LIKE &#39;%张%&#39;
    OR email LIKE &#39;%163%&#39;
    OR age LIKE &#39;%1%&#39;)
</code></pre>
<p>这样就解决了，这个问题在我的公司中新人(包括我在内)貌似都遇到这个问题，在此说明一下</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>在末尾拼接sql语句</p>
<p>注：last()有sql注入的风险，请谨慎使用！</p>
<pre><code>public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
    // SELECT id,name,email,age FROM user WHERE (name = ? OR age = ?) limit 1
    wrapper.eq(User::getName, &quot;张三&quot;).or().eq(User::getAge, 20).last(&quot;limit 1&quot;);
    return this.baseMapper.selectList(wrapper);
&#125;
exists、notExists
public List&lt;User&gt; userList() &#123;
    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
 
    // SELECT id,name,email,age FROM user WHERE (EXISTS (select name from user where age &gt; ?))
    wrapper.exists(&quot;select name from user where age &gt; 21&quot;);
 
    // SELECT id,name,email,age FROM user WHERE (NOT EXISTS (select name from user where age &gt; ?))
    wrapper.notExists(&quot;select name from user where age &gt; 21&quot;);
 
    return this.baseMapper.selectList(wrapper);
&#125;
</code></pre>
<h1 id="附加MySQL语句执行顺序"><a href="#附加MySQL语句执行顺序" class="headerlink" title="附加MySQL语句执行顺序"></a>附加MySQL语句执行顺序</h1><pre><code>1、from
2、where (or 最后执行)
3、group by
4、having
5、DISTINCT
6、order by
7、limit
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「初级bug小天才」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_52317961/article/details/128317591">https://blog.csdn.net/weixin_52317961/article/details/128317591</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>QueryWrapper和LambdaQueryWrapper和Wrappers</title>
    <url>/2023/10/04/QueryWrapper%E5%92%8CLambdaQueryWrapper%E5%92%8CWrappers/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言：当我们使用MybatisPlus进行数据库操作，条件构造器无可厚非会使用到！</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><pre><code>Wrapper：条件构造抽象类，是最顶端父类；
AbstractWrapper：用于查询条件封装，生成sql的where条件；
AbstractLambdaWrapper：Lambda语法使用Wrapper统一处理解析lambda获取column。
LambdaQueryWrapper：用于lambda语法使用的查询Wrapper；
LambdaUpdateWrapper:Lambda更新封装Wrapper;
QueryWrapper:Entity对象封装操作类，不是用lambda；
UpdateWrapper:Update条件封装，用于Entity对象更新操作。
</code></pre>
<h1 id="一、QueryWrapper"><a href="#一、QueryWrapper" class="headerlink" title="一、QueryWrapper"></a>一、QueryWrapper</h1><p>1.1 写法</p>
<pre><code>QueryWrapper&lt;Users&gt; queryWrapper = new QueryWrapper&lt;&gt;();
queryWrapper.eq(&quot;username&quot;,name);
List&lt;User&gt; user = userMapper.selectList(lambdaQueryWrapper)
</code></pre>
<p>1.2 方法解释</p>
<pre><code>queryWrapper.lt();                            // 小于
queryWrapper.le();                            // 小于等于
queryWrapper.gt();                            // 大于
queryWrapper.ge();                            // 大于等于
queryWrapper.eq();                            // 等于    
queryWrapper.ne();                            // 不等于
queryWrapper.betweeen(&quot;age”,10,20);            // age在值10到20之间
queryWrapper.notBetweeen(&quot;age”,10,20);        // age不在值10到20之间
queryWrapper.like(&quot;属性&quot;,&quot;值&quot;);            // 模糊查询匹配值
queryWrapper.notLike(&quot;属性&quot;,&quot;值&quot;);            // 模糊查询不匹配值
queryWrapper.likeLeft(&quot;属性&quot;,&quot;值&quot;);        // 模糊查询匹配最后一位值
queryWrapper.likeRight(&quot;属性&quot;,&quot;值&quot;);        // 模糊查询匹配第一位值‘值%’
queryWrapper.isNull();                        // 值为空或null
queryWrapper.isNotNull();                    // 值不为空或null
queryWrapper.in(&quot;属性&quot;，条件，条件);            // 符合多个条件的值
queryWrapper.notIn(&quot;属性&quot;，条件，条件);            // 不符合多个条件的值
queryWrapper.or();                            // 或者
queryWrapper.and();                            // 和
queryWrapper.orderByAsc(“属性”);                // 根据属性升序排序
queryWrapper.orderByDesc(“属性”);                // 根据属性降序排序
queryWrapper.inSql(“sql语句”);                // 符合sql语句的值
queryWrapper.notSql(“sql语句”);                // 不符合SQL语句的值
queryWrapper.esists(“SQL语句”);                // 查询符合SQL语句的值
queryWrapper.notEsists(“SQL语句”);            // 查询不符合SQL语句的值
queryWrapper.select(&quot;字段1&quot;，&quot;字段2&quot;，&quot;字段3&quot;);    // 设置查询字段
</code></pre>
<h1 id="二、LambdaQueryWrapper"><a href="#二、LambdaQueryWrapper" class="headerlink" title="二、LambdaQueryWrapper"></a>二、LambdaQueryWrapper</h1><p>2.1 写法</p>
<pre><code>LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
lambdaQueryWrapper.eq(User::getUsername,name);
List&lt;User&gt; user = userMapper.selectList(lambdaQueryWrapper)
</code></pre>
<p>2.2 方法解释</p>
<pre><code> wrapper.eq(&quot;实体类::查询字段&quot;, &quot;条件值&quot;);
 wrapper.between(&quot;实体类::查询字段&quot;, &quot;区间一&quot;, &quot;区间二&quot;);
 wrapper.like(&quot;实体类::查询字段&quot;, &quot;模糊查询的字符&quot;); 
 wrapper.groupBy(&quot;实体类::查询字段&quot;); 
 wrapper.in(&quot;实体类::查询字段&quot;, &quot;包括的值,分割&quot;); 
 wrapper.orderByAsc(&quot;实体类::查询字段&quot;);                 //升序
 wrapper.orderByDesc(&quot;实体类::查询字段&quot;);                //降序
 wrapper.ge(&quot;实体类::查询字段&quot;, &quot;要比较的值&quot;);             //大于等于
 wrapper.le(&quot;实体类::查询字段&quot;, &quot;要比较的值&quot;);             //小于等于
</code></pre>
<h1 id="三、Wrappers"><a href="#三、Wrappers" class="headerlink" title="三、Wrappers"></a>三、Wrappers</h1><p>3.1 写法</p>
<pre><code>Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,name);
</code></pre>
<p>3.2 方法解释</p>
<pre><code>看上面的
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中LambdaQueryWrapper对象使用(学习笔记)</title>
    <url>/2023/10/03/Java8%E4%B8%ADLambdaQueryWrapper%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8(%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="eq："><a href="#eq：" class="headerlink" title="eq："></a>eq：</h1><p>说明：等于=</p>
<p>例：</p>
<pre><code>eq(&quot;name&quot;,&quot;老王&quot;)--------&gt; name = &#39;老王&#39;
</code></pre>
<h1 id="ne："><a href="#ne：" class="headerlink" title="ne："></a>ne：</h1><p>说明：不等于&lt;&gt;</p>
<p>例：</p>
<pre><code>ne(&quot;name&quot;,&quot;老王&quot;)--------&gt; name &lt;&gt; &#39;老王&#39;
</code></pre>
<h1 id="gt："><a href="#gt：" class="headerlink" title="gt："></a>gt：</h1><p>说明：大于&gt;</p>
<p>例：</p>
<pre><code>gt(&quot;age&quot;,18)--------&gt; age &gt; 18
</code></pre>
<h1 id="ge："><a href="#ge：" class="headerlink" title="ge："></a>ge：</h1><p>说明：大于等于&gt;=</p>
<p>例：</p>
<pre><code>ge(&quot;age&quot;,18)--------&gt; age &gt;= 18
</code></pre>
<h1 id="lt："><a href="#lt：" class="headerlink" title="lt："></a>lt：</h1><p>说明：小于&lt;</p>
<p>例：</p>
<pre><code>lt(&quot;age&quot;,18)--------&gt; age &lt; 18
</code></pre>
<h1 id="le："><a href="#le：" class="headerlink" title="le："></a>le：</h1><p>说明：小于等于&lt;=</p>
<p>例：</p>
<pre><code>le(&quot;age&quot;,18)--------&gt; age &lt;= 18
</code></pre>
<h1 id="between："><a href="#between：" class="headerlink" title="between："></a>between：</h1><p>说明：BETWEEN 值1 AND 值2</p>
<p>例：</p>
<pre><code>between(&quot;age&quot;,18,30)--------&gt; age between 18 and 30
</code></pre>
<h1 id="notBetween："><a href="#notBetween：" class="headerlink" title="notBetween："></a>notBetween：</h1><p>说明：NOT BETWEEN 值1 AND 值2</p>
<p>例：</p>
<pre><code>notBetween(&quot;age&quot;,18,30)--------&gt; age not between 18 and 30
</code></pre>
<h1 id="like："><a href="#like：" class="headerlink" title="like："></a>like：</h1><p>说明：LIKE ‘%值%’</p>
<p>例：</p>
<pre><code>like(&quot;name&quot;,&quot;王&quot;)--------&gt; name like &#39;%王%&#39;
</code></pre>
<h1 id="notLike："><a href="#notLike：" class="headerlink" title="notLike："></a>notLike：</h1><p>说明：NOT LIKE ‘%值%’</p>
<p>例：</p>
<pre><code>notLike(&quot;name&quot;,&quot;王&quot;)--------&gt; name not like &#39;%王%&#39;
</code></pre>
<h1 id="likeLeft："><a href="#likeLeft：" class="headerlink" title="likeLeft："></a>likeLeft：</h1><p>说明：LIKE ‘%值’</p>
<p>例：</p>
<pre><code>likeLeft(&quot;name&quot;,&quot;王&quot;)--------&gt; name like &#39;%王&#39;
</code></pre>
<h1 id="likeRight："><a href="#likeRight：" class="headerlink" title="likeRight："></a>likeRight：</h1><p>说明：LIKE ‘值%’</p>
<p>例：</p>
<pre><code>likeRight(&quot;name&quot;,&quot;王&quot;)--------&gt; name like &#39;王%&#39;
</code></pre>
<h1 id="isNull："><a href="#isNull：" class="headerlink" title="isNull："></a>isNull：</h1><p>说明：字段 IS NULL</p>
<p>例：</p>
<pre><code>isNull(&quot;name&quot;)--------&gt; name is null
</code></pre>
<h1 id="isNotNull："><a href="#isNotNull：" class="headerlink" title="isNotNull："></a>isNotNull：</h1><p>说明：字段 IS NOT NULL</p>
<p>例：</p>
<pre><code>isNotNull(&quot;name&quot;)--------&gt; name is not null
</code></pre>
<h1 id="in："><a href="#in：" class="headerlink" title="in："></a>in：</h1><p>说明：字段 IN (v0, v1, …)</p>
<p>例：</p>
<pre><code>in(&quot;age&quot;,&#123;1,2,3&#125;)--------&gt; age in (1,2,3)
</code></pre>
<h1 id="notIn："><a href="#notIn：" class="headerlink" title="notIn："></a>notIn：</h1><p>说明：字段 NOT IN (v0, v1, …)</p>
<p>例：</p>
<pre><code>notIN(&quot;age&quot;,&#123;1,2,3&#125;)--------&gt; age not in (1,2,3)
</code></pre>
<h1 id="inSql："><a href="#inSql：" class="headerlink" title="inSql："></a>inSql：</h1><p>说明：字段 IN ( SQL语句 )</p>
<p>例：</p>
<pre><code>inSql(&quot;id&quot;,&quot;select id from table where id &lt; 3&quot;)--------&gt; id in (select id from table where id &lt; 3)
</code></pre>
<h1 id="notInSql："><a href="#notInSql：" class="headerlink" title="notInSql："></a>notInSql：</h1><p>说明：字段 NOT IN ( SQL语句 )</p>
<p>例：</p>
<pre><code>notInSql(&quot;id&quot;,&quot;select id from table where id &lt; 3&quot;)--------&gt; id not in (select id from table where id &lt; 3)
</code></pre>
<h1 id="groupBy："><a href="#groupBy：" class="headerlink" title="groupBy："></a>groupBy：</h1><p>说明：分组 GROUP BY 字段， …</p>
<p>例：</p>
<pre><code>groupBy(&quot;id&quot;,&quot;name&quot;)--------&gt; group by id,name
</code></pre>
<h1 id="orderByAsc："><a href="#orderByAsc：" class="headerlink" title="orderByAsc："></a>orderByAsc：</h1><p>说明：排序 ORDER BY 字段，… ASC</p>
<p>例：</p>
<pre><code>orderByAsc(&quot;id&quot;,&quot;name&quot;)--------&gt; order by id ASC,name ASC
</code></pre>
<h1 id="orderByDesc："><a href="#orderByDesc：" class="headerlink" title="orderByDesc："></a>orderByDesc：</h1><p>说明：排序 ORDER BY 字段，… DESC</p>
<p>例：</p>
<pre><code>orderByDesc(&quot;id&quot;,&quot;name&quot;)--------&gt; order by id DESC,name DESC
</code></pre>
<h1 id="orderBy："><a href="#orderBy：" class="headerlink" title="orderBy："></a>orderBy：</h1><p>说明：排序 ORDER BY 字段，…</p>
<p>例：</p>
<pre><code>orderBy(&quot;id&quot;,&quot;name&quot;)--------&gt; order by id ASC,name ASC
</code></pre>
<h1 id="having："><a href="#having：" class="headerlink" title="having："></a>having：</h1><p>说明：HAVING ( SQL语句 )</p>
<p>例：</p>
<pre><code>having(&quot;sum(age) &gt; &#123;0&#125;&quot;,11)--------&gt; having sum(age) &gt; 11
</code></pre>
<h1 id="or："><a href="#or：" class="headerlink" title="or："></a>or：</h1><p>说明：拼接 OR</p>
<p>注意事项：主动调用 OR 表示紧接着下一个方法不是用 AND 连接！(不调用 OR 则默认使用 AND 连接)</p>
<p>例：</p>
<pre><code>eq.(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)--------&gt; id = 1 or name = &#39;老王&#39;
</code></pre>
<h1 id="and："><a href="#and：" class="headerlink" title="and："></a>and：</h1><p>说明：AND 嵌套</p>
<p>例：</p>
<pre><code>and(i -&gt; i.eq(&quot;name&quot;,&quot;老王&quot;).ne(&quot;status&quot;,1))--------&gt; and (name = &#39;老王&#39; and status &lt;&gt; 1)
</code></pre>
<h1 id="apply："><a href="#apply：" class="headerlink" title="apply："></a>apply：</h1><p>说明：拼接 SQL</p>
<p>注意事项：该方法可用于数据库函数，动态入参的 params 对应前面 sqlHaving 内部的 {index} 部分，这样是不会有 SQL 注入风险的，反之会有！</p>
<p>例：</p>
<pre><code>apply(&quot;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#123;0&#125;&quot;,&quot;2021-08-08&quot;)--------&gt; date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2021-08-08&#39;
</code></pre>
<h1 id="last："><a href="#last：" class="headerlink" title="last："></a>last：</h1><p>说明：无视优化规则直接拼接到 SQL 的最后</p>
<p>注意事项：只能调用一次，多次调用以最后一次为准，有 SQL 注入的风险，请谨慎使用</p>
<p>例：</p>
<pre><code>last(&quot;limit 1&quot;)
</code></pre>
<h1 id="exists："><a href="#exists：" class="headerlink" title="exists："></a>exists：</h1><p>说明：拼接 EXISTS ( SQL 语句 )</p>
<p>例：</p>
<pre><code>exists(&quot;select id from table where age = 1&quot;)--------&gt; exists (select id from table where age = 1)
</code></pre>
<h1 id="notExists："><a href="#notExists：" class="headerlink" title="notExists："></a>notExists：</h1><p>说明：拼接 NOT EXISTS ( SQL 语句 )</p>
<p>例：</p>
<pre><code>notExists(&quot;select id from table where age = 1&quot;)--------&gt; not exists (select id from table where age = 1)
</code></pre>
<h1 id="nested："><a href="#nested：" class="headerlink" title="nested："></a>nested：</h1><p>说明：正常嵌套 不带 AND 或者 OR</p>
<p>例：</p>
<pre><code>nested(i -&gt; i.eq(&quot;name&quot;,&quot;老王&quot;).ne(&quot;status&quot;,1))--------&gt; (name = &#39;老王&#39; and status &lt;&gt; 1)
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「woyaniya」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/woyaniya/article/details/129416870">https://blog.csdn.net/woyaniya/article/details/129416870</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Avue-crud 常用方法、属性</title>
    <url>/2023/10/02/Avue-crud%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Avue的v2版本是一个基于element-ui低代码前端框架，Avue的v3是一个基于element-plus低代码前端框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。avue对于后台管理系统的开发极其便捷，就是配置不容易记住，熟练该框架配置来开发会好点，不然真不如直接用element来开发的好，以下以v2为例。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>npm、yarn安装</p>
<pre><code>npm i @smallwei/avue -S
yarn add @smallwei/avue -S
</code></pre>
<p>或<br>CDN在线安装</p>
<pre><code>&lt;!-- 引入样式文件 --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@smallwei/avue/lib/index.css&quot;/&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;/&gt;
&lt;!-- 引入相关JS 文件 --&gt;
&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/@smallwei/avue/lib/avue.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>通过CDN安装的，会挂载在全局属性AVUE下，通过 Vue.use(AVUE) 注册。</p>
<pre><code>import Avue from &#39;@smallwei/avue&#39;;
import &#39;@smallwei/avue/lib/index.css&#39;;
Vue.use(Avue);
</code></pre>
<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><pre><code>Vue.use(AVUE,&#123;
  size:&#39;&#39;, // 组件的尺寸，默认small。可选值 small/mini/medium
  tableSize:&#39;&#39;, // 
  formSize:&#39;&#39;, // 
  appendToBody:true, //
  modalAppendToBody:true, // 
  menuType:&#39;&#39;, // 用于改变操作栏菜单按钮类型性，属性的组件的默认尺寸均为 text。可选值 button/icon/text/menu
  qiniu:&#123; // 七牛云配置
    AK: &#39;&#39;,
    SK: &#39;&#39;,
    scope: &#39;&#39;,
    url: &#39;&#39;,
    deadline: 1
  &#125;,
  ali:&#123; // 阿里云配置
    region: &#39;&#39;,
    endpoint: &#39;&#39;,
    accessKeyId: &#39;&#39;,
    accessKeySecret: &#39;&#39;,
    bucket: &#39;&#39;,
  &#125;,
  theme:&#39;&#39;, // 主题颜色配置，属性的组件的默认白色。可选值 dark
  canvas:&#123; // 水印配置
    text: &#39;avuejs.com&#39;,
    fontFamily: &#39;microsoft yahei&#39;,
    color: &quot;#999&quot;,
    fontSize: 16,
    opacity: 100,
    bottom: 10,
    right: 10,
    ratio: 1
  &#125;,
&#125;);
</code></pre>
<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><p>Avue 采用中文作为默认语言，同时支持多语言切换</p>
<pre><code>import Vue from &#39;vue&#39;
import Avue from &#39;@smallwei/avue&#39;
import zhLocale from &#39;@smallwei/avue/lib/locale/lang/zh&#39;
import enLocale from &#39;@smallwei/avue/lib/locale/lang/en&#39;
 
Vue.use(Avue, &#123; enLocale &#125;)
</code></pre>
<h1 id="全局api"><a href="#全局api" class="headerlink" title="全局api"></a>全局api</h1><pre><code>$DialogForm弹窗表单
$Clipboard复制到剪切板
$ImagePreview图片预览
$Print 打印插件
$Export excel导出
watermark全局水印
downFile文件下载
deepClone对象深拷贝
validatenull判断空
findNode数组中寻找对象
findArray数组中寻找对象下标
</code></pre>
<h1 id="crud-配置项-option"><a href="#crud-配置项-option" class="headerlink" title="crud 配置项 option"></a>crud 配置项 option</h1><p>crud 表格回调函数事件</p>
<p>on-load：这个事件会在表格所在的组件加载时就会执行，初始化表格数据。当表格翻页、页码变化时候也会自动执行该方法，使用了这个方法可以省略表格的current-change 、size-change两个回调函数。</p>
<p>current-change：表格页码发生变化时触发，第一个参数为当前页码。</p>
<p>size-change：表格页容量变化时触发，第一个参数就是当前页容量大小。</p>
<p>search-change ：表格查询按钮回调函数，默认有两个参数 form与done， form为搜索框的值，done为关闭搜索的刷新状态回调函数。</p>
<p>row-save ：表格新增表单确定按钮的回调函数，默认有三个参数分别为：row（表单的值），done（用于关闭表单回调函数），loading（页面loading状态） 。</p>
<p>row-update ：表格行编辑确定按钮的回调，默认四个参数 row（当前行），index（索引），done（关闭弹框回调函数），loading（页面loading状态）。</p>
<p>row-del：表格操作行删除按钮回调函数，默认两个参数，row（当前行数据），index（当前索引） 。</p>
<p>refresh-change：表格的刷新按钮回调函数。</p>
<p>current-row-change：当前表格行被点击时的回调函数，第一个参数是当前行数据。</p>
<p>tree-load：表格行展开的懒加载回调，带三个参数 row（当前展开行的数据），treeNode（展开行节点数据），resolve（行懒加载的成功回调函数，在resolve里面将懒加载的数据传出去表格进行渲染）。</p>
<p>before-close：打开前的回调函数，两个参数done（用于关闭Dialog），type（当前窗口类型）。</p>
<p>before-close：关闭前的回调函数，done（用于关闭Dialog），type（当前窗口的类型）。</p>
<p>search-reset：点击清空按钮触发，清空搜索框回调函数。</p>
<p>selection-change：当表格选择项勾选发生变化时会触发该回调函数。</p>
<p>dateChange：dateBtn为true时的选择日期回调函数。</p>
<pre><code>&lt;avue-crud
  ref=&quot;crud&quot;
  data=&quot;data&quot; // 表格显示的数据
  :option=&quot;option&quot; // 表格配置项
  :page.sync=&quot;page&quot;
  :permission=&quot;permission&quot; // 表格按钮权限控制
  @on-load=&quot;onLoad&quot;
  @current-change=&quot;currentChange&quot;
  @size-change=&quot;pageSizeChange&quot;
  @search-change=&quot;searchChange&quot;
  @row-save=&quot;rowSave&quot;
  @row-update=&quot;rowUpdate&quot;
  @row-del=&quot;rowDel&quot;
  @refresh-change=&quot;refreshChange&quot;
  @current-row-change=&quot;handleCurrentRowChange&quot;
  @tree-load=&quot;treeLoad&quot;
  @before-open=&quot;beforeOpen&quot;
  @before-close=&quot;beforeClose&quot;
  @search-reset=&quot;searchReset&quot;
/&gt;
const option = &#123;
    &#39;table-loading&#39;:&#39;&#39;, // 表格等待框的控制
    size:&#39;&#39;, // 组件尺寸
    maxHeight:&#39;&#39;, // 表格的最大高度
    index:&#39;&#39;, // 是否有序号
    indexWidth:&#39;&#39;, // 序号列宽度
    indexFixed:&#39;&#39;, // 序号列是否冻结列
    menu:&#39;&#39;, // 是否有操作栏
    menuWidth:&#39;&#39;, // 操作栏宽度
    menuTitle:&#39;&#39;, // 操作栏标题
    menuFixed:&#39;&#39;, // 操作栏列冻结列
    menuType:&#39;&#39;, // 操作栏按钮样式
    menuHeaderAlign:&#39;&#39;, // 操作栏表头的对齐方式
    title:&#39;&#39;, // 表格标题
    addBtn:&#39;&#39;, // 表格新增按钮；edit（修改）、del（删除）、view（查看）、update（修改）、save（保存）、cancel（取消）、search（查询）、empty（清空）
    addBtnText:&#39;&#39;, // 表格新增按钮文案
    addBtnIcon:&#39;&#39;, // 表格新增按钮图标
    printBtn:&#39;&#39;, // 表格打印按钮
    excelBtn:&#39;&#39;, // 表格导出按钮
    filterBtn:&#39;&#39;, // 表格自定义过滤按钮
    refreshBtn:&#39;&#39;, // 表格刷新数据按钮
    columnBtn:&#39;&#39;, // 表格列操作按钮
    searchShowBtn:&#39;&#39;, // 表格搜索显隐按钮
    copyBtn:&#39;&#39;, // 表格复制数据按钮
    addTitle:&#39;&#39;, // 表格新增弹窗标题 edit（修改）、view（查看）
    dialogDrag:&#39;&#39;, // 表格弹窗是否可以拖拽
    searchIndex:&#39;&#39;, // 表格搜索半收缩个数
    searchPlaceholder:&#39;&#39;, // 搜索项辅助文字
    searchSpan:&#39;&#39;, // 搜索项框栅列
    searchGutter:&#39;&#39;, // 搜索项框间距
    searchLabelWidth:&#39;&#39;, // 搜索项标题宽度
    searchLabelPosition:&#39;&#39;, // 搜索项标题位置
    column:[ // 表格列配置
        &#123;
            label:&#39;&#39;, // 列标题
            prop:&#39;&#39;, // 列标题的内容属性名称
            type:&#39;&#39;, // 
            width:&#39;&#39;, // 对应列的宽度
            minWidth:&#39;&#39;, // 对应列的最小宽度
            fixed:&#39;&#39;, // 列固定
            sortable:&#39;&#39;, // 对应列是否可以排序，监听 sort-change 回调，true, false, &#39;custom&#39;
            formatter:&#39;&#39;, // 格式化列内容，(row, value, row, column)
            overHidden:&#39;&#39;, // 当内容过长被隐藏时显示 tooltip
            align:&#39;&#39;, // 对齐方式
            headerAlign:&#39;&#39;, // 表头对齐方式
            filters:&#39;&#39;, // 数据过滤的选项
            search:&#39;&#39;, // 是否为搜索项
            searchValue:&#39;&#39;, // 搜索项初始化值
            searchPlaceholder:&#39;&#39;, // 搜索项辅助文字
            searchSpan:&#39;&#39;, // 搜索项框栅列
            searchOrder:&#39;&#39;, // 搜索项位置排序，序号越大越靠前
            searchLabelWidth:&#39;&#39;, // 搜索项标题宽度
            searchClearable:&#39;&#39;, // 搜索项清除
            searchMultiple:&#39;&#39;, // 搜索项是否多选
            searchTags:&#39;&#39;, // 搜索项将选中值按文字的形式展示
            display:&#39;&#39;, // 弹出表单是否显示
            disabled:&#39;&#39;, // 弹出表单是否禁止
            addDisabled:&#39;&#39;, // 表单新增时项是否禁止，edit（编辑）、view（查看）
            addDisplay:&#39;&#39;, // 表单新增时项是否显示，edit（编辑）、view（查看）
            resizable:&#39;&#39;, // 对应列是否可以通过拖动改变宽度（需要在option中border属性为真）
            searchClearable:&#39;&#39;, // 搜索项清除
            searchClearable:&#39;&#39;, // 搜索项清除
            searchClearable:&#39;&#39;, // 搜索项清除
            dicData:[ // 下拉项字典枚举
                &#123;label:&#39;A&#39;,value: &#39;a&#39;&#125;,
            ],
            rules:[ // 表单字段校验规则
                &#123;equired: true,message: &quot;请输入姓名&quot;,trigger: &quot;blur&quot;&#125;,
            ],
            hide: false, // 隐藏列
        &#125;
    ],
&#125;;
</code></pre>
<h1 id="自定义内容"><a href="#自定义内容" class="headerlink" title="自定义内容"></a>自定义内容</h1><pre><code>&lt;avue-crud :data=&quot;data&quot; :option=&quot;option&quot; ref=&quot;crud&quot;&gt;
  &lt;!-- 左边插槽 --&gt;
  &lt;template slot-scope=&quot;scope&quot; slot=&quot;menuLeft&quot;&gt;
    &lt;el-button type=&quot;danger&quot; @click=&quot;$refs.crud.rowAdd()&quot;&gt;新增&lt;/el-button&gt;
  &lt;/template&gt;
  &lt;!-- 右边插槽 --&gt;
  &lt;template slot-scope=&quot;scope&quot; slot=&quot;menuRight&quot;&gt;
    &lt;el-button type=&quot;danger&quot; @click=() =&gt; &#123;&#125;&quot;&gt;刷新&lt;/el-button&gt;
  &lt;/template&gt;
  &lt;!-- 自定义行内操作栏插槽 --&gt;
  &lt;template slot-scope=&quot;&#123;row,index&#125;&quot; slot=&quot;menu&quot;&gt;
     &lt;el-button @click=&quot;$refs.crud.rowEdit(row,index)&quot;&gt;编辑&lt;/el-button&gt;
     &lt;el-button @click=&quot;$refs.crud.rowDel(row,index)&quot;&gt;删除&lt;/el-button&gt;
  &lt;/template&gt;
  &lt;!-- 自定义弹窗内按钮插槽 --&gt;
  &lt;template slot-scope=&quot;&#123;row,index,type&#125;&quot; slot=&quot;menuForm&quot;&gt;
    &lt;el-button v-if=&quot;type==&#39;add&#39;&quot; @click=&quot;$refs.crud.rowSave()&quot;&gt;自定义新增&lt;/el-button&gt;
    &lt;el-button v-if=&quot;type==&#39;edit&#39;&quot; @click=&quot;$refs.crud.rowUpdate()&gt;自定义修改&lt;/el-button&gt;
    &lt;el-button @click=&quot;$refs.crud.closeDialog()&quot;&gt;取消&lt;/el-button&gt;
  &lt;/template&gt;
  &lt;!-- 自定义表单插槽，slot=&quot;propForm&quot; --&gt;
  &lt;template slot-scope=&quot;&#123;type,disabled&#125;&quot; slot=&quot;nameForm&quot;&gt; // column: [&#123;prop:&#39;name&#39;,formslot:true&#125;]
      &lt;el-tag v-if=&quot;type==&#39;add&#39;&quot;&gt;新增&lt;/el-tag&gt;
      &lt;el-tag v-else-if=&quot;type==&#39;edit&#39;&quot;&gt;修改&lt;/el-tag&gt;
      &lt;el-tag v-else-if=&quot;type==&#39;view&#39;&quot;&gt;查看&lt;/el-tag&gt;
      &lt;el-tag&gt;&#123;&#123;user.name?user.name:'暂时没有内容'&#125;&#125;&lt;/el-tag&gt;
      &lt;el-input :disabled=&quot;disabled&quot; v-model=&quot;user.name&quot;&gt;&lt;/el-input&gt;
  &lt;/template&gt;
  &lt;!-- 自定义表单错误提示插槽，slot=&quot;propError&quot; --&gt;
  &lt;template slot-scope=&quot;&#123;error&#125;&quot; slot=&quot;nameError&quot;&gt; // column: [&#123;prop:&#39;name&#39;,labelslot:true&#125;]
      &lt;p style=&quot;color:green&quot;&gt;自定义提示&#123;&#123;error&#125;&#125;&lt;/p&gt;
  &lt;/template&gt;
  &lt;!-- 自定义表单标题，slot=&quot;propLabel&quot; --&gt;
  &lt;template slot-scope=&quot;scope&quot; slot=&quot;nameLabel&quot;&gt; // column: [&#123;prop:&#39;name&#39;,errorslot:true&#125;]
     &lt;span&gt;姓名&amp;nbsp;&amp;nbsp;&lt;/span&gt;
     &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;文字提示&quot; placement=&quot;top-start&quot;&gt;
      &lt;i class=&quot;el-icon-warning&quot;&gt;&lt;/i&gt;
    &lt;/el-tooltip&gt;
  &lt;/template&gt;
  &lt;!-- 向搜索表单插入一个额外的（column中没有的字段）输入框 --&gt;
  &lt;template slot=&quot;search&quot;&gt;
      &lt;el-form-item label=&quot;状态&quot;&gt;
          &lt;el-input placeholder=&quot;状态&quot; v-model=&quot;search.value&quot;/&gt;
      &lt;/el-form-item&gt;
  &lt;/template&gt;
  &lt;!-- 向表单中插入一个额外的输入框 --&gt;
  &lt;template slot=&quot;menuForm&quot;&gt;
      &lt;el-form-item label=&quot;维修&quot;&gt;
          &lt;el-input placeholder=&quot;维修&quot; v-model=&quot;search.value&quot;/&gt;
      &lt;/el-form-item&gt;
  &lt;/template&gt;
&lt;/avue-crud&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「my__flower」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/my__flower/article/details/129419199">https://blog.csdn.net/my__flower/article/details/129419199</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>修改conda虚拟环境安装路径</title>
    <url>/2023/10/01/%E4%BF%AE%E6%94%B9conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言<br>第一次创建conda虚拟环境时，发现默认安装路径是C盘。为了避免后期装的包越来越多，虚拟环境占用空间太大导致C盘爆满的问题，需要修改conda的安装路径。在网上仔细学习，总结出如下有效的解决方法。</p>
<p>下载Miniconda<br>因为我希望能够根据实际需要装包，所以选择了轻量化的miniconda。话不多说，下面先放上miniconda的下载地址。</p>
<p>官方地址：<a href="https://conda.io/en/latest/miniconda.html">https://conda.io/en/latest/miniconda.html</a></p>
<p>清华镜像网址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p>
<p>下载后-右键-“以管理员身份运行”</p>
<p>这一步建议选择“All Users”</p>
<p>这一步记得修改安装路径到D盘，最好自己提前新建一个文件夹然后装到里面</p>
<p>后面应该问题不大，一直“next”到最后“finish”就好。</p>
<p>安装完成后，打开Anaconda Prompt(conda)，输入conda –version如果正确显示版本号说明安装成功。</p>
<p>准备工作</p>
<p>首先在D盘新建一个文件夹，命名任意（我命名为conda_base），然后在这个文件夹里面再新建两个文件夹，命名分别为envs和pkgs。</p>
<p>打开Anaconda Prompt(conda)，输入以下代码（一行一行复制）</p>
<pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes
</code></pre>
<p>接着，打开路径“C:\Users[用户名]\，找到文件夹中的.condarc文件，使用记事本打开。打开后会看到里面的内容如下：</p>
<p>现在我们在最下面加入以下内容：（路径按照自己实际情况修改 ）</p>
<pre><code>envs_dirs:
  - D:\conda_base\envs
pkgs_dirs:
  - D:\conda_base\pkgs
</code></pre>
<p>加入后保存即可退出。</p>
<p>创建环境</p>
<p>打开Anaconda Prompt(conda)，输入以下内容：</p>
<pre><code>conda create --name kennn python=3.9 -y
</code></pre>
<p>其中“kennn”是环境名字，python版本可根据需要更改“=”后的版本号即可</p>
<p>点击回车，自动创建环境，至此教程结束。</p>
<p>conda常用指令</p>
<p>进入某个环境：conda activate [环境名]（一开始打开Anaconda Prompt默认处于base环境）</p>
<p>退出当前环境：conda deactivate</p>
<p>已创建环境目录：conda info –envs</p>
<p>————————————————<br>版权声明：本文为CSDN博主「黯岚岚岚岚岚」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_59209871/article/details/134674607">https://blog.csdn.net/weixin_59209871/article/details/134674607</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda与Miniconda之间的选择</title>
    <url>/2023/09/30/Anaconda%E4%B8%8EMiniconda%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>导言</p>
<p>Python语言因其灵活性、易用性和强大的数据处理能力在科学计算和数据分析领域受到广泛欢迎。然而，Python的一大挑战是库的管理和环境的隔离。解决这个问题的一个方案是使用分布式管理系统，如Anaconda或Miniconda。本文将深入探讨这两者的相似之处、差异和应用场景。</p>
<p>Anaconda和Miniconda的基本概念</p>
<p>Anaconda和Miniconda都是Continuum Analytics的开源项目，用于管理Python的环境和包。两者都有用于创建和管理虚拟环境的Conda包管理器，这使得在不同的项目之间切换和隔离变得简单。但是，两者之间存在一些重要的区别。</p>
<p>Anaconda是一个包含了conda、Python和超过150个科学包及其依赖项的科学Python发行版。它具有可视化图形用户界面（Anaconda Navigator）并且为了方便新手使用，预先包含了大量的库，如NumPy, Pandas, Scipy, Matplotlib等。</p>
<p>相较之下，Miniconda更加轻量级。它只包含了Python和Conda，但并没有预装其他的库。Miniconda用户需要手动安装他们需要的包，这使得Miniconda的环境更为简洁，可以根据实际需求来安装必要的包，避免不必要的存储占用。</p>
<p>对比Anaconda和Miniconda</p>
<p>首先，我们看到Anaconda和Miniconda最显著的区别在于他们所包含的包的数量。Anaconda预安装了大量科学计算和数据分析所需的库，使得用户可以立即开始工作。而Miniconda只包含了Python和conda，它的轻量级特性使得它在需要快速部署Python环境，或者在磁盘空间有限、网络环境较差、或者需要定制特定环境的情况下具有优势。</p>
<p>其次，Anaconda提供了Anaconda Navigator这样的图形用户界面，它使得库的安装、环境的创建和管理变得更为简单直观。这对于新手用户来说是非常有帮助的，尤其是对于那些不习惯使用命令行的用户。而Miniconda没有这样的用户界面，所有的操作都需要通过命令行来完成。</p>
<p>最后，由于Anaconda包含了大量的预装库，因此它的安装文件非常大，而Miniconda则相对较小。这可能会影响到安装的速度和存储空间的占用。</p>
<p>选择Anaconda还是Miniconda？</p>
<p>选择Anaconda还是Miniconda主要取决于你的具体需求。如果你是Python新手，或者你需要的所有库都在Anaconda的预装库中，那么Anaconda可能是更好的选择。它可以让你迅速开始你的项目，而无需担心库的安装和管理。</p>
<p>然而，如果你需要定制你的Python环境，或者你需要在有限的资源下工作，那么Miniconda可能是更好的选择。它允许你只安装你需要的库，避免了不必要的存储占用。此外，由于Miniconda的安装文件更小，因此它的安装速度通常更快。</p>
<p>总结</p>
<p>无论你选择Anaconda还是Miniconda，都能获得强大的Python环境管理功能。你的选择应基于你的具体需求和资源状况。不论选择哪一个，都能通过conda进行库的管理和环境的隔离，大大提升Python开发和科学计算的效率。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda 添加清华镜像源</title>
    <url>/2023/09/29/Anaconda%20%E6%B7%BB%E5%8A%A0%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、删除之前的镜像源，恢复默认状态"><a href="#1、删除之前的镜像源，恢复默认状态" class="headerlink" title="1、删除之前的镜像源，恢复默认状态"></a>1、删除之前的镜像源，恢复默认状态</h1><pre><code>conda config --remove-key channels
</code></pre>
<h1 id="2、添加清华镜像源-清华大学开源软件镜像站"><a href="#2、添加清华镜像源-清华大学开源软件镜像站" class="headerlink" title="2、添加清华镜像源 清华大学开源软件镜像站"></a>2、添加清华镜像源 清华大学开源软件镜像站</h1><pre><code>#添加镜像源

conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2

#显示检索路径

conda config --set show_channel_urls yes

#显示镜像通道

conda config --show channels
</code></pre>
<h1 id="3、国内常见的镜像源"><a href="#3、国内常见的镜像源" class="headerlink" title="3、国内常见的镜像源"></a>3、国内常见的镜像源</h1><pre><code>清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：https://mirrors.aliyun.com/pypi/simple/
中国科技大学: https://pypi.mirrors.ustc.edu.cn/simple/
华中理工大学：https://pypi.hustunique.com/
山东理工大学：https://pypi.sdutlinux.org/ 
豆瓣：https://pypi.douban.com/simple/
</code></pre>
<h1 id="4、补充：conda的常用命令"><a href="#4、补充：conda的常用命令" class="headerlink" title="4、补充：conda的常用命令"></a>4、补充：conda的常用命令</h1><pre><code>查看所有虚拟环境 conda info --env 在显示的环境中，有*的表示当前所在的环境
创建环境 conda create -n envname python=3.6(指定python版本为3.6)
启动环境 conda activate envnane
关闭环境 conda deactivate envname
删除环境 conda remove -n envname --all
克隆环境 本地已有一个环境AAA，若需要创建一个同样的BBB conda create -n BBB --clone AAA
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小金~~」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_33682559/article/details/110389091">https://blog.csdn.net/qq_33682559/article/details/110389091</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】使用 requirements.txt 和 pip 打包批量安装</title>
    <url>/2023/09/28/%E3%80%90Python%E3%80%91%E4%BD%BF%E7%94%A8%20requirements.txt%20%E5%92%8C%20pip%20%E6%89%93%E5%8C%85%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们程序越来越复杂，使用pip管理Python包（库）。我们可以方便的使用配置文件 requirements.txt 批量安装指定版本的指定包。</p>
<p>关于涉及到的pip官方的手册在这个位置： pip documentationv23.1.dev0</p>
<p>本文对以下内容进行说明：</p>
<p>pip 的批量安装选项： -r requirements.txt</p>
<p>配置文件 requirements.txt 的写法</p>
<p>生成当前环境的requirements.txt配置文件： pip freeze</p>
<ol>
<li><p>pip 的批量安装选项：-r requirements.txt<br>以下命令根据配置文件 requirements.txt 批量安装包。</p>
<p> $ pip install -r requirements.txt</p>
</li>
</ol>
<p>配置文件名是任意的，但经常使用 requirements.txt 这个名字。<br>将 requirements.txt 放在运行命令的目录中。如果它在另一个目录中，请指定当前目录的绝对路径或相对路径。</p>
<ol start="2">
<li>配置文件requirements.txt怎么写</li>
</ol>
<p>下面是一个典型的requirements.txt文件的例子</p>
<pre><code>###### 下面的是不需要版本要求的 ######`
nose
nose-cov
beautifulsoup4

###### 进行版本要求的例子 ######`
docopt == 0.6.1         # 必须严格的 0.6.1 的版本
keyring &gt;= 4.1.1        # 最小的版本 4.1.1
coverage != 3.5         # 版本排除，只要不是 3.5 都可以
Mopidy-Dirble ~= 1.1    # 兼容版本。与&gt;=1.1，==1.* 相同
</code></pre>
<p>仔细看上面的代码，我们有如下规律</p>
<p>与 Python 代码一样， # 之后的任何内容都是注释。<br>在实际使用时，可以使用 == 、 &gt; 、 &gt;= 、 &lt; 、 &lt;= 等指定版本。如果省略版本说明，将安装最新版本。<br>另外，如果需要可以用 AND 指定两个条件，方法是用逗号 , 分隔它们。在以下示例中，将安装高于 1.0 AND 低于 2.0 的版本。</p>
<pre><code>package &gt;= 1.0, &lt;=2.0
</code></pre>
<ol start="3">
<li><p>导出当前环境配置文件：pip freeze<br>pip freeze 命令将当前环境安装的包和版本以配置文件的形式输出，可以和 pip install -r 一起使用。</p>
<p> $ pip freeze<br> agate==1.6.0<br> agate-dbf==0.2.0<br> agate-excel==0.2.1<br> agate-sql==0.5.2</p>
</li>
</ol>
<p>因此，如果将 pip freeze 输出到带有重定向 &gt; 的文件，则可以使用该文件在单独的环境中安装与原始环境相同版本的包。</p>
<p>田辛老师在复制环境的时候，经常这样做：</p>
<p>第一步，生成requirements.txt文件</p>
<pre><code>$ pip freeze &gt; requirements.txt
</code></pre>
<p>第二步，在新的机器上</p>
<pre><code>$ pip install -r requirements.txt
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「田辛 | 田豆芽」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u013589130/article/details/129039961">https://blog.csdn.net/u013589130/article/details/129039961</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 用pip批量安装包 requirements.txt</title>
    <url>/2023/09/27/Python%20%E7%94%A8pip%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85%E5%8C%85%20requirements.txt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、python用pip批量安装包"><a href="#一、python用pip批量安装包" class="headerlink" title="一、python用pip批量安装包"></a>一、python用pip批量安装包</h1><p>python查看安装的第三方扩展包,就是使用命令 pip freeze。</p>
<p>在已经配置好的一台机器上，将需要的包导出到requirements.txt</p>
<pre><code>./pip freeze &gt; requirements.txt
</code></pre>
<p>此种方式会将环境中所有的包都打包进去，适合单虚拟环境（每个项目都处在不同的虚拟环境里，这个环境里是这个项目所需要的所有包）。因此，如果不是Python虚拟环境Virtualenv。我们不推荐这么使用，推荐使用 使用pipreqs 写入requirements.txt。</p>
<p>pip安装包的方式中，有如下一种安装方式：</p>
<pre><code>pip install -r requirements.txt
</code></pre>
<p>而文件requirement.txt里面内容的格式和pip freeze的格式完全一样。因此我们可以将pip freeze的内容输出至requirements.txt。</p>
<p>推荐如下使用方式</p>
<pre><code>./pip freeze | tee requirements.txt # 输出本地包环境至文件
./pip install -r requirements.txt # 根据文件进行包安装
</code></pre>
<p>pip freeze 为什么比 pip list 的包少几个呢？<br>因为pip , wheel , setuptools 等包，是自带的而无法(un)install的。考虑到pip freeze的用途，所以这些包并没有显示。</p>
<p>ps：<br>如果一定要用pip freeze来显示所有包，可以加上参数-all，即pip freeze -all</p>
<h1 id="二、-推荐-使用pipreqs-写入requirements-txt"><a href="#二、-推荐-使用pipreqs-写入requirements-txt" class="headerlink" title="二、[推荐]使用pipreqs 写入requirements.txt"></a>二、[推荐]使用pipreqs 写入requirements.txt</h1><p>使用pipreqs 写入requirements.txt，只是程序中所用到的包，并不是电脑中安装的所有的包。</p>
<pre><code>pip install pipreqs
</code></pre>
<p>cd 到程序所在的文件夹位置</p>
<p>执行下面的语句，Windows下得加encoding=utf8，不然会出现编码问题。</p>
<pre><code>pipreqs ./ --encoding=utf8 
</code></pre>
<h1 id="三、利用requirements-txt离线安装依赖包"><a href="#三、利用requirements-txt离线安装依赖包" class="headerlink" title="三、利用requirements.txt离线安装依赖包"></a>三、利用requirements.txt离线安装依赖包</h1><p>1、下载离线的包到指定目录</p>
<p>将requirements.txt中导入的包离线下载到 package_tmp_dir 文件夹</p>
<pre><code>pip wheel -w package_tmp_dir -r requirements.txt
pip download -d package_tmp_dir -r requirements.txt
</code></pre>
<p>2、安装离线的包</p>
<pre><code>pip install --no-index --find-links=package_tmp_dir  -r requirements.txt
</code></pre>
<ol>
<li>使用 pip wheel 实现 Python 依赖包的离线安装</li>
</ol>
<p>Wheel 也是一种 built 包，而且是官方推荐的打包方式。也许你曾经遇见或使用过 egg 包，但现在 wheel 是官方推荐的打包方式（<a href="https://wheel.readthedocs.io/en/stable/%EF%BC%89%E3%80%82">https://wheel.readthedocs.io/en/stable/）。</a><br>wheel 包的优点：</p>
<p> 1.更快地安装纯 Python 和本机 C 扩展包。<br> 2.避免安装时执行任意代码。 （避免 setup.py）<br> 3.在 Windows 或 macOS 上安装 C 扩展不需要编译器。<br> 4.为测试和持续集成提供更好的缓存。<br> 5.创建 .pyc 文件作为安装的一部分，以确保它们与使用的 Python 解释器匹配。<br> 6.跨平台和机器的更一致的安装。</p>
<p>没有网络连接, 借助 wheel把整个 Python 应用做成离线安装包。</p>
<p>安装 wheel:</p>
<pre><code>pip install wheel
</code></pre>
<p>下载依赖包的 wheel 文件</p>
<pre><code>pip wheel -r requirements.txt
</code></pre>
<p>默认情况下, 上述命令会下载 requirements.txt 中每个包的 wheel 包到当前目录的 wheelhouse 文件夹, 包括依赖的依赖。</p>
<p>在你的安装脚本中执行:</p>
<pre><code>pip install --use-wheel --no-index --find-links=wheelhouse -r requirements.txt
</code></pre>
<ol start="2">
<li>下载命令</li>
</ol>
<p>一、对于单个包的安装</p>
<p>1、离线</p>
<p>(1)pip离线下载</p>
<pre><code>pip download 你的包名 -d “下载的路径(windows下双引号来表示文件夹)”
pip download pymysql -d &quot;D:\pipDownloadTest&quot;
</code></pre>
<p>(2)pip 离线安装</p>
<pre><code>pip install 包路径
pip install PyMySQL-0.9.3-py2.py3-none-any.whl
</code></pre>
<p>2、在线</p>
<pre><code>pip install pymysql
</code></pre>
<p>二、对于多个包的安装与下载</p>
<p>1、离线</p>
<p>离线下载</p>
<pre><code>pip download -d packages -r requirements.txt
</code></pre>
<p>离线安装</p>
<pre><code>pip install --no-index --find-links=packages -r requirements.txt
</code></pre>
<p>2、在线</p>
<pre><code>pip install -r requirements.txt
</code></pre>
<p>总结：多个包下载就多了一个 -r requirements.txt。</p>
<ol start="3">
<li>pip download 和 pip wheel 这两个命令的区别</li>
</ol>
<ul>
<li><p>下载的文件格式不同</p>
<p>  pip download 下载的是源代码的压缩包,通常是 .tar.gz 格式<br>  pip wheel 下载的是编译好的 wheel 二进制包,以 .whl 作为文件扩展名</p>
</li>
<li><p>是否编译</p>
<p>  pip download 仅仅下载源码,不会编译<br>  pip wheel 会自动为所支持的平台编译Wheel包</p>
</li>
<li><p>下载位置不同</p>
<p>  pip download 会下载到当前目录<br>  pip wheel 默认下载到 ~/.cache/pip/wheels 目录</p>
</li>
<li><p>用途不同<br>  pip download 用于获取源码包以便查看或自定义编译<br>  pip wheel 常用于离线环境,下载好Wheel包后直接pip install使用</p>
</li>
</ul>
<p>所以,简单来说:</p>
<p>需要源码包 - 使用pip download<br>需要离线安装 - 使用pip wheel</p>
<p>两者有不同的使用场景。</p>
<h1 id="四、pip-install-工作常见报错"><a href="#四、pip-install-工作常见报错" class="headerlink" title="四、pip install 工作常见报错"></a>四、pip install 工作常见报错</h1><p>Python.h: No such file or directory报错</p>
<ul>
<li>CentOS7 pip3 安装psycopg2出错</li>
</ul>
<p>参考URL: <a href="https://www.jianshu.com/p/fbbe3bdf1905">https://www.jianshu.com/p/fbbe3bdf1905</a><br>原因是：</p>
<p>As mentioned in psycopg documentation <a href="http://initd.org/psycopg/docs/install.html">http://initd.org/psycopg/docs/install.html</a></p>
<p>C compiler<br>Python header files</p>
<ul>
<li><p>没有安装python的环境：</p>
<p>  For apt (Ubuntu, Debian…):</p>
<pre><code>  sudo apt-get install python-dev # for python2.x installs
  sudo apt-get install python3-dev # for python3.x installs
</code></pre>
<p>  For yum (CentOS, RHEL…):</p>
<pre><code>  sudo yum install python-devel # for python2.x installs
  sudo yum install python3-devel # for python3.x installs
</code></pre>
</li>
</ul>
<p>————————————————<br>版权声明：本文为CSDN博主「西京刀客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/inthat/article/details/117026589">https://blog.csdn.net/inthat/article/details/117026589</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>conda、python环境配置</title>
    <url>/2023/09/26/conda%E3%80%81python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>新建虚拟环境</p>
<pre><code>conda create -n python36 python=3.6
</code></pre>
<p>设为当前环境</p>
<pre><code>conda activate python36
</code></pre>
<p>删除虚拟环境</p>
<pre><code>conda remove -n python36 --all
</code></pre>
<p>安装必要的包</p>
<pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xgboost==1.5.2
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xlrd==1.2.0
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas==1.1.4
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple openpyxl==3.0.10
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple Flask==2.0.2
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple Flask-Cors==3.0.10
</code></pre>
<p>导出依赖配置</p>
<pre><code>pip freeze &gt; requirements.txt
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>flask部署的几种常见方式，部署流程及问题总结</title>
    <url>/2023/09/25/flask%E9%83%A8%E7%BD%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>部署 Flask 应用通常涉及多个组件，包括 Flask 框架本身、uWSGI 进程服务器、Gunicorn WSGI 服务器、Nginx 反向代理服务器以及Supervisor 进程管理工具。</p>
<p>以下是一个常见的 Flask 部署流程及可能遇到的问题总结：</p>
<h1 id="安装必要的软件和依赖："><a href="#安装必要的软件和依赖：" class="headerlink" title="安装必要的软件和依赖："></a>安装必要的软件和依赖：</h1><ol>
<li><p>首先，在服务器上安装 Python 和 pip。根据操作系统的不同，可以使用以下命令安装：</p>
<ul>
<li>Ubuntu/Debian:</li>
</ul>
<p> sudo apt update<br> sudo apt install python3 python3-pip</p>
<ul>
<li>CentOS/Fedora:</li>
</ul>
<p> sudo yum update<br> sudo yum install python3 python3-pip</p>
</li>
<li><p>安装 Flask 框架和其他需要的库。在命令行中运行以下命令：</p>
<p> sudo pip3 install flask</p>
</li>
</ol>
<h1 id="编写-Flask-应用："><a href="#编写-Flask-应用：" class="headerlink" title="编写 Flask 应用："></a>编写 Flask 应用：</h1><ol>
<li><p>创建一个 Python 文件，例如 <code>app.py</code>，并编写 Flask 应用的代码。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></li>
<li><p>保存并退出文件。</p>
</li>
<li><p>测试 Flask 应用：在终端中运行 Flask 应用，以确保应用可以在本地运行。</p>
<p> python3 app.py</p>
</li>
</ol>
<h1 id="配置uWSGI："><a href="#配置uWSGI：" class="headerlink" title="配置uWSGI："></a>配置uWSGI：</h1><ol>
<li><p>创建一个 uWSGI 配置文件，例如 <code>your_uwsgi_config.ini</code>，并指定 Flask 应用的入口、进程数、线程数等配置项。示例配置如下：</p>
<p> [uwsgi]<br> module = app<br> callable = app<br> master = true<br> processes = 4<br> threads = 2<br> socket = 127.0.0.1:5000<br> chmod-socket = 660<br> vacuum = true<br> die-on-term = true</p>
</li>
</ol>
<p>其中，<code>module</code> 指定了 Flask 应用的入口，<code>processes</code> 指定了进程数，<code>threads</code> 指定了线程数，<code>socket</code> 指定了 uWSGI 监听的地址和端口。</p>
<h1 id="启动uWSGI："><a href="#启动uWSGI：" class="headerlink" title="启动uWSGI："></a>启动uWSGI：</h1><ol>
<li><p>在命令行中运行以下命令，启动 uWSGI，并使用指定的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uwsgi --ini your_uwsgi_config.ini</span><br></pre></td></tr></table></figure></li>
</ol>
<p>确保 uWSGI 可以成功启动并监听指定的端口。</p>
<h1 id="测试uWSGI："><a href="#测试uWSGI：" class="headerlink" title="测试uWSGI："></a>测试uWSGI：</h1><ol>
<li>使用 curl 或浏览器访问 uWSGI 提供的接口，例如 <code>http://127.0.0.1:5000/</code>，确保应用可以通过 uWSGI 进程服务器正常访问。</li>
</ol>
<h1 id="配置Gunicorn："><a href="#配置Gunicorn：" class="headerlink" title="配置Gunicorn："></a>配置Gunicorn：</h1><ol>
<li><p>创建一个 Gunicorn 配置文件，例如 <code>your_gunicorn_config.py</code>，并指定 Flask 应用的入口和其他配置项。示例配置如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bind = <span class="string">&#x27;127.0.0.1:5000&#x27;</span></span><br><span class="line">workers = <span class="number">4</span></span><br><span class="line">threads = <span class="number">2</span></span><br><span class="line">module = <span class="string">&#x27;app:app&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中，<code>bind</code> 指定了 Gunicorn 监听的地址和端口，<code>workers</code> 指定了进程数，<code>threads</code> 指定了线程数，<code>module</code> 指定了 Flask 应用的入口。</p>
<h1 id="启动Gunicorn："><a href="#启动Gunicorn：" class="headerlink" title="启动Gunicorn："></a>启动Gunicorn：</h1><ol>
<li><p>在命令行中运行以下命令，启动 Gunicorn，并使用指定的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gunicorn -c your_gunicorn_config.py your_app:app</span><br></pre></td></tr></table></figure></li>
</ol>
<p>确保 Gunicorn 可以成功启动并监听指定的端口。</p>
<h1 id="测试Gunicorn："><a href="#测试Gunicorn：" class="headerlink" title="测试Gunicorn："></a>测试Gunicorn：</h1><ol>
<li>使用 curl 或浏览器访问 Gunicorn 提供的接口，例如 <code>http://127.0.0.1:5000/</code>，确保应用可以通过 Gunicorn WSGI 服务器正常访问。</li>
</ol>
<h1 id="配置Nginx："><a href="#配置Nginx：" class="headerlink" title="配置Nginx："></a>配置Nginx：</h1><ol>
<li><p>创建一个 Nginx 配置文件，例如 <code>your_nginx_config.conf</code>，并指定反向代理规则，将客户端请求转发到 uWSGI 或 Gunicorn 服务器。示例配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your_domain.com;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:5000;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中，<code>listen</code> 指定了 Nginx 监听的端口，<code>server_name</code> 指定了服务器的域名或 IP 地址，<code>location</code> 指定了转发规则，将请求转发到 uWSGI 或 Gunicorn服务器。</p>
<h1 id="启动Nginx："><a href="#启动Nginx：" class="headerlink" title="启动Nginx："></a>启动Nginx：</h1><ol>
<li><p>在命令行中运行以下命令，启动 Nginx，并使用指定的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -c your_nginx_config.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<p>确保 Nginx 可以成功启动并监听指定的端口。</p>
<h1 id="测试Nginx："><a href="#测试Nginx：" class="headerlink" title="测试Nginx："></a>测试Nginx：</h1><ol>
<li>通过浏览器访问 Nginx 服务器的 IP 或域名，例如 <code>http://your_domain.com/</code>，确保 Nginx 可以接收客户端请求并正确转发到 uWSGI 或 Gunicorn 服务器。</li>
</ol>
<h1 id="配置Supervisor："><a href="#配置Supervisor：" class="headerlink" title="配置Supervisor："></a>配置Supervisor：</h1><ol>
<li><p>创建一个 Supervisor 配置文件，例如 <code>your_supervisor_config.conf</code>，并指定要监控的 uWSGI 或 Gunicorn 进程。示例配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:your_process]</span><br><span class="line">command=/path/to/gunicorn -c /path/to/your_gunicorn_config.py your_app:app</span><br><span class="line">directory=/path/to/your/app/directory</span><br><span class="line">user=your_user</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中，<code>command</code> 指定了启动 Gunicorn 的命令，<code>directory</code> 指定了应用程序的目录，<code>user</code> 指定了运行应用程序的用户，<code>autostart</code> 和 <code>autorestart</code> 分别指定了是否自动启动和自动重启进程，<code>redirect_stderr</code> 指定了是否将标准错误输出重定向到日志文件。</p>
<h1 id="启动Supervisor："><a href="#启动Supervisor：" class="headerlink" title="启动Supervisor："></a>启动Supervisor：</h1><ol>
<li><p>在命令行中运行以下命令，启动 Supervisor，并监控指定的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supervisorctl start your_process</span><br></pre></td></tr></table></figure></li>
</ol>
<p>确保 Supervisor 可以成功启动并监控指定的进程。</p>
<h1 id="测试Supervisor："><a href="#测试Supervisor：" class="headerlink" title="测试Supervisor："></a>测试Supervisor：</h1><ol>
<li>通过 Supervisor 的状态命令，例如 <code>supervisorctl status</code>，确保进程状态正常。</li>
</ol>
<p>以上是实现基本的部署流程，可以根据实际需求和环境进行适当的调整。需要注意的是，每个步骤的命令和配置文件路径可能会因为操作系统和具体的应用程序而有所不同，请根据实际情况进行调整。</p>
<p>可能遇到的问题及解决方法：<br>当你完成了上述部署过程后，你可能还会遇到一些常见的问题。以下是一些可能出现的问题及解决方法：</p>
<ol>
<li><p>权限问题：确保相关文件和目录对于 uWSGI、Gunicorn、Nginx 和 Supervisor 进程可读可写，并且用户拥有足够的权限。如果权限不足，可以使用 <code>sudo</code> 命令或修改文件和目录的所有者和权限。</p>
</li>
<li><p>端口冲突：确保 uWSGI、Gunicorn、Nginx 监听的端口与配置文件中的端口一致，并确保这些端口未被其他进程占用。你可以使用 <code>netstat</code> 命令来查看端口的使用情况，并修改配置文件中的端口号。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tuln    # 查看当前监听的端口</span><br><span class="line">sudo lsof -i :&lt;port&gt;   # 查看指定端口的进程</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件错误：检查 uWSGI、Gunicorn、Nginx 和 Supervisor 的配置文件语法和路径是否正确。配置文件中的路径应该是正确的，并且文件内容应符合相应的配置语法规范。</p>
</li>
<li><p>日志跟踪：查看相关组件的日志文件，以便了解错误信息和异常情况。uWSGI、Gunicorn、Nginx 和 Supervisor 都会生成日志文件，你可以在配置文件中指定日志文件位置，或者查看默认生成的日志文件。</p>
</li>
<li><p>防火墙设置：确保服务器上的防火墙允许进入和离开相关的端口流量。你可以使用防火墙工具（如 UFW 或 iptables）来配置端口的访问权限。</p>
<p>sudo ufw allow <port>    # 允许指定端口的访问<br>sudo ufw enable    # 启用防火墙<br>sudo ufw status    # 查看防火墙状态</port></p>
</li>
<li><p>进程管理：使用进程管理工具（如 Supervisor）可以更好地管理 uWSGI 和 Gunicorn 进程，保证进程的稳定和可靠性。确保 Supervisor 的配置文件正确，并使用 Supervisor 执行启动、停止和重启等命令。</p>
<p>sudo supervisorctl start <process_name>    # 启动指定进程<br>sudo supervisorctl restart <process_name>    # 重启指定进程<br>sudo supervisorctl stop <process_name>    # 停止指定进程</process_name></process_name></process_name></p>
</li>
</ol>
<p>这些是常见的问题和解决方法，部署过程可能因环境和需求而有所不同。如果你遇到了其他问题，可以仔细检查日志文件、查找在线资源或在相关社区提问以获取帮助。</p>
<p>注意，此处提到的部署流程和问题总结是一种常见方式，根据实际情况可能会有所不同。在部署过程中</p>
<p>————————————————<br>版权声明：本文为CSDN博主「白熊先生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/2302_77595648/article/details/131926223">https://blog.csdn.net/2302_77595648/article/details/131926223</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.nextTick 的原理和用途</title>
    <url>/2023/09/24/Vue.nextTick%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue.nextTick 的原理和用途</p>
<p>对于 Vue.nextTick 方法，自己有些疑惑。在查询了各种资料后，总结了一下其原理和用途，如有错误，请不吝赐教。</p>
<h1 id="异步说明"><a href="#异步说明" class="headerlink" title="异步说明"></a>异步说明</h1><p>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。<br>在 Vue 的文档中，说明 Vue 是异步执行 DOM 更新的。关于异步的解析，可以查看阮一峰老师的这篇文章。截取关键部分如下：</p>
<p>具体来说，异步执行的运行机制如下。</p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p>
<h1 id="事件循环说明"><a href="#事件循环说明" class="headerlink" title="事件循环说明"></a>事件循环说明</h1><p>简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</p>
<p>知乎上的例子：</p>
<pre><code>//改变数据
vm.message = &#39;changed&#39;

//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新
console.log(vm.$el.textContent) // 并不会得到&#39;changed&#39;

//这样可以，nextTick里面的代码会在DOM更新后执行
Vue.nextTick(function()&#123;
    console.log(vm.$el.textContent) //可以得到&#39;changed&#39;
&#125;)
</code></pre>
<p>事件循环：</p>
<p>第一个 tick（图例中第一个步骤，即’本次更新循环’）：</p>
<p>首先修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时还未涉及 DOM 。<br>Vue 开启一个异步队列，并缓冲在此事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。<br>第二个 tick（图例中第二个步骤，即’下次更新循环’）：</p>
<p>同步任务执行完毕，开始执行异步 watcher 队列的任务，更新 DOM 。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel 方法，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p>
<p>第三个 tick（图例中第三个步骤）：</p>
<p>此时就是文档所说的</p>
<p>下次 DOM 更新循环结束之后<br>此时通过 Vue.nextTick 获取到改变后的 DOM 。通过 setTimeout(fn, 0) 也可以同样获取到。</p>
<p>简单总结事件循环：</p>
<p>同步代码执行 -&gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]…</p>
<p>总之，异步是单独的一个tick，不会和同步在一个 tick 里发生，也是 DOM 不会马上改变的原因。</p>
<p>对于事件循环，可以在这里查看更详细的内容： <a href="https://segmentfault.com/a/11">https://segmentfault.com/a/11</a>…<br>用途<br>应用场景：需要在视图更新之后，基于新的视图进行操作。<br>created、mounted<br>需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。</p>
<p>官方文档说明：</p>
<p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p>
<pre><code>mounted: function () &#123;
  this.$nextTick(function () &#123;
    // Code that will run only after the
    // entire view has been rendered
  &#125;)
&#125;
</code></pre>
<h1 id="其他应用场景"><a href="#其他应用场景" class="headerlink" title="其他应用场景"></a>其他应用场景</h1><p>其他应用场景如下三例：</p>
<h2 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h2><p>点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。</p>
<pre><code>showsou()&#123;
  this.showit = true //修改 v-show
  document.getElementById(&quot;keywords&quot;).focus()  //在第一个 tick 里，获取不到输入框，自然也获取不到焦点
&#125;
</code></pre>
<p>修改为：</p>
<pre><code>showsou()&#123;
  this.showit = true
  this.$nextTick(function () &#123;
    // DOM 更新了
    document.getElementById(&quot;keywords&quot;).focus()
  &#125;)
&#125;
</code></pre>
<h2 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h2><p>点击获取元素宽度。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p ref=&quot;myWidth&quot; v-if=&quot;showMe&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;getMyWidth&quot;&gt;获取p元素宽度&lt;/button&gt;
&lt;/div&gt;

getMyWidth() &#123;
    this.showMe = true;
    //this.message = this.$refs.myWidth.offsetWidth;
    //报错 TypeError: this.$refs.myWidth is undefined
    this.$nextTick(()=&gt;&#123;
        //dom元素更新后执行，此时能拿到p元素的属性
        this.message = this.$refs.myWidth.offsetWidth;
  &#125;)
&#125;
</code></pre>
<h2 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h2><p>使用 swiper 插件通过 ajax 请求图片后的滑动问题。</p>
<h1 id="实例理解-nextTick-应用"><a href="#实例理解-nextTick-应用" class="headerlink" title="实例理解 nextTick 应用"></a>实例理解 nextTick 应用</h1><p>下面的例子各位可以复制运行一遍，加深理解。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li class=&quot;example&quot; v-for=&quot;item in list1&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;ul&gt;
            &lt;li class=&quot;example&quot; v-for=&quot;item in list2&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;ol&gt;
            &lt;li class=&quot;example&quot; v-for=&quot;item in list3&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ol&gt;
        &lt;ol&gt;
            &lt;li class=&quot;example&quot; v-for=&quot;item in list4&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ol&gt;
        &lt;ol&gt;
            &lt;li class=&quot;example&quot; v-for=&quot;item in list5&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
export default &#123;
    data() &#123;
        return &#123;
            list1: [],
            list2: [],
            list3: [],
            list4: [],
            list5: []
        &#125;
    &#125;,
    created() &#123;
        this.composeList12()
        this.composeList34()
        this.composeList5()
        this.$nextTick(function() &#123;
            // DOM 更新了
            console.log(&#39;finished test &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)
        &#125;)
    &#125;,
    methods: &#123;
        composeList12() &#123;
            let me = this
            let count = 10000

            for (let i = 0; i &lt; count; i++) &#123;
                this.$set(me.list1, i, &#39;I am a 测试信息～～啦啦啦&#39; + i)
            &#125;
            console.log(&#39;finished list1 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)

            for (let i = 0; i &lt; count; i++) &#123;
                this.$set(me.list2, i, &#39;I am a 测试信息～～啦啦啦&#39; + i)
            &#125;
            console.log(&#39;finished list2 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)

            this.$nextTick(function() &#123;
                // DOM 更新了
                console.log(&#39;finished tick1&amp;2 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)
            &#125;)
        &#125;,
        composeList34() &#123;
            let me = this
            let count = 10000

            for (let i = 0; i &lt; count; i++) &#123;
                this.$set(me.list3, i, &#39;I am a 测试信息～～啦啦啦&#39; + i)
            &#125;
            console.log(&#39;finished list3 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)

            this.$nextTick(function() &#123;
                // DOM 更新了
                console.log(&#39;finished tick3 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)
            &#125;)

            setTimeout(me.setTimeout1, 0)
        &#125;,
        setTimeout1() &#123;
            let me = this
            let count = 10000

            for (let i = 0; i &lt; count; i++) &#123;
                this.$set(me.list4, i, &#39;I am a 测试信息～～啦啦啦&#39; + i)
            &#125;
            console.log(&#39;finished list4 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)

            me.$nextTick(function() &#123;
                // DOM 更新了
                console.log(&#39;finished tick4 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)
            &#125;)
        &#125;,
        composeList5() &#123;
            let me = this
            let count = 10000

            this.$nextTick(function() &#123;
                // DOM 更新了
                console.log(&#39;finished tick5-1 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)
            &#125;)

            setTimeout(me.setTimeout2, 0)
        &#125;,
        setTimeout2() &#123;
            let me = this
            let count = 10000

            for (let i = 0; i &lt; count; i++) &#123;
                this.$set(me.list5, i, &#39;I am a 测试信息～～啦啦啦&#39; + i)
            &#125;
            console.log(&#39;finished list5 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)

            me.$nextTick(function() &#123;
                // DOM 更新了
                console.log(&#39;finished tick5 &#39; + new Date().toString(),document.querySelectorAll(&#39;.example&#39;).length)
            &#125;)
        &#125;
    &#125;
&#125;
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中下载excel文件4种方法</title>
    <url>/2023/09/23/vue%E4%B8%AD%E4%B8%8B%E8%BD%BDexcel%E6%96%87%E4%BB%B64%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、通过url下载"><a href="#1、通过url下载" class="headerlink" title="1、通过url下载"></a>1、通过url下载</h1><p>即后端提供文件的地址，直接使用浏览器去下载</p>
<p>通过window.location.href = 文件路径下载</p>
<pre><code>window.location.href = `$&#123;location.origin&#125;/operation/ruleImport/template`
</code></pre>
<p>通过 window.open(url, ‘_blank’)</p>
<pre><code>window.open(`$&#123;location.origin&#125;/operation/ruleImport/template`)
</code></pre>
<p>这两种使用方法的不同：</p>
<p>window.location：当前页跳转，也就是重新定位当前页；只能在网站中打开本网站的网页。<br>window.open：在新窗口中打开链接；可以在网站上打开另外一个网站的地址。</p>
<h1 id="2、通过-a-标签-download-属性结合-blob-构造函数下载"><a href="#2、通过-a-标签-download-属性结合-blob-构造函数下载" class="headerlink" title="2、通过 a 标签 download 属性结合 blob 构造函数下载"></a>2、通过 a 标签 download 属性结合 blob 构造函数下载</h1><p>a 标签的 download 属性是 HTML5 标准新增的，作用是触发浏览器的下载操作而不是导航到下载的 url，这个属性可以设置下载时使用新的文件名称。</p>
<p>前端创建超链接，接收后端的文件流：</p>
<pre><code>axios.get(`/operation/ruleImport/template`,
    responseType:&quot;blob&quot; //服务器响应的数据英型，可以是&#39;arraybuffer&quot;,&quot;blob&#39;,&quot;document&#39;&quot;,&#39;json&#39;,&#39;text&quot;,&#39;stream&#39;
    &#125;)
    .then(res =&gt;
        if(!res) return
        const blob = new Blob([res.data],(type:&#39;application/vnd.ms-excel&#39;&#125;)/构造一blob对象来处数据，并设置文件
        
        if (window.navigator.msSaveOrOpenBlob)&#123; //兼容IE10
            navigator.msSaveBlob(blob, this.filename)
        &#125; else &#123;
            const href = URL.createObjectURL(blob) //创建所航URL装示指定bLob对象
            const a = document.createElement(&#39;a&#39;)   //创建a标签
            a.style.display = &#39;none&#39;
            a.href = href //指定下视链接
            a.download = this.fi1ename //指定下件文件名
            a.click() //发下
            URL.revokeObjectURL(a.href) //释放URL对象
        &#125;
        //这里也可以不创建a接，蓝简vindow.open(href)也能下，
    &#125;)
    .catch(err-&gt;&#123;
        console.1og(err)
    &#125;)
</code></pre>
<p>注：请求后台接口时要在请求头上加{responseType: ‘blob’}；download 设置文件名时，可以直接设置扩展名，如果没有设置浏览器将自动检测正确的文件扩展名并添加到文件。</p>
<h1 id="3、通过-js-file-download-插件"><a href="#3、通过-js-file-download-插件" class="headerlink" title="3、通过 js-file-download 插件"></a>3、通过 js-file-download 插件</h1><p>安装：</p>
<pre><code>npm install js-file-download --S
</code></pre>
<p>代码：</p>
<pre><code>import fileDownload from &#39;js-file-download&#39;

axios.get(`/operation/ruleImport/template`,&#123;
    responseType: &#39;blob&#39; //返回的数据英型
&#125;)
.then(res =&gt; &#123;
    fileDownload(res.data,this.fileName)
&#125;)
</code></pre>
<h1 id="4、使用fetch下载"><a href="#4、使用fetch下载" class="headerlink" title="4、使用fetch下载"></a>4、使用fetch下载</h1><pre><code>exportFile()&#123;
    fetch(&#39;http://127.0.0.1:8765/course/exportCourse/33&#39;,&#123;
        method:&#39;GET&#39;,
        headers:new Headers(&#123;
            &#39;Authorization&#39;:Cookie.get(&#39;Authorization&#39;)
        &#125;),
    &#125;)
    .then(res =&gt; res.blob())
    .then(data =&gt; &#123;
        const blobUrl = window.URL.createobjectURL(data);
        const a = document.createElement(&#39;a&#39;);
        a.download = this.fileName+&#39;.xlsx&#39;;
        a.href = blobUrl;
        a.click();
    &#125;);
    &#125;,
</code></pre>
<p>原文链接：<a href="https://www.clzg.cn/article/441428.html">https://www.clzg.cn/article/441428.html</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>17个vue常用的数组方法总结与实例演示</title>
    <url>/2023/09/22/17%E4%B8%AAvue%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章主要介绍了vue中常用的数组方法,包括：VUE数组转换字符串，VUE数组遍历，VUE数组过滤，VUE数组查询,VUE数组排序等功能，需要的朋友可以参考下</p>
<h1 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h1><p>join（’参数‘）把数组的元素以传入的参数为分割符，转换成字符串。</p>
<pre><code>let arr = [1,2,3,4,5];
let str = arr.join(&#39;,&#39;);
console.log(str) // -&gt; &#39;1,2,3,4,5&#39;;
</code></pre>
<h1 id="2-push-和pop"><a href="#2-push-和pop" class="headerlink" title="2.push()和pop()"></a>2.push()和pop()</h1><p>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。<br>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>
<pre><code>let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;];
let count = arr.push(&#39;马六&#39;);
console.log(arr) // -&gt; [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;]
console.log(count) // -&gt; 4
  
let item = arr.pop();
console.log(item) // -&gt; 马六;
</code></pre>
<h1 id="3-shift-和-unshift"><a href="#3-shift-和-unshift" class="headerlink" title="3.shift() 和 unshift()"></a>3.shift() 和 unshift()</h1><p>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。<br>unshift:将参数添加到原数组开头，并返回数组的长度 。</p>
<pre><code>let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;];
let item = arr.shift();
console.log(arr) // -&gt; [&#39;李四&#39;,&#39;王五&#39;]
console.log(item); // -&gt; 张三
  
let count = arr.unshift(&#39;马六&#39;);
  
console.log(arr) // -&gt; [&#39;马六&#39;,&#39;李四&#39;,&#39;王五&#39;]
console.log(count) // -&gt; 3
</code></pre>
<h1 id="4-reverse"><a href="#4-reverse" class="headerlink" title="4.reverse();"></a>4.reverse();</h1><p>将数组的数据进行反转，并且返回反转后的数组，会改变原数组</p>
<pre><code>let arr = [1,2,3,4,5];
let arr1 = arr.reverse();
console.log(arr1) // -&gt; [5,4,3,2,1]
console.log(arr) // -&gt; [5,4,3,2,1]
</code></pre>
<h1 id="5-sort"><a href="#5-sort" class="headerlink" title="5.sort();"></a>5.sort();</h1><p>对数组内的数据进行排序(默认为升序)，并且返回排过序的新数组，会改变原来的数组</p>
<pre><code>let arr = [12,2,43,5,2,5];
console.log(arr.sort()) // -&gt; [12, 2, 2, 43, 5, 5]
// 注意：通过上面的案例，你会发现 打印的数组和原数组比较还是有变化的 [12,2,43,5,2,5] -&gt; [12, 2, 2, 43, 5, 5];但是有没有达到我们想要的结果，这是为什么呢？
// 因为排序是针对字符的排序，先使用数组的toString()方法转为字符串，再逐位比较，3是大于12的，因为首位3&gt;1，不要与Number型的数据排序混淆。
</code></pre>
<p>5.1那如果需要数值排序怎么办呢？</p>
<pre><code>// 如果需要数值排序，sort(callback) 需要传入一个回调涵数，该函数应该具有两个参数，比较这两个参数，然后返回一个用于说明这两个值的相对顺序的数字（a-b）；
例如：
let arr = [12,2,43,5,2,5];
console.log(arr.sort((a,b)=&gt;a-b)) // -&gt; [2, 2, 5, 5, 12, 43]
</code></pre>
<h1 id="6-slice"><a href="#6-slice" class="headerlink" title="6.slice();"></a>6.slice();</h1><p>截取指定位置的数组，并且返回截取的数组，不会改变原数组</p>
<pre><code>// 注意：slice（startIndex, endIndex）可以有两个参数，startIndex为必选，表示从第几位开始；endIndex为可选，表示到第几位结束(不包含endIndex位)，省略表示到最后一位；startIndex和endIndex都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。
let arr =  [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
console.log(arr.slice(1,3)); // -&gt; [&#39;李四&#39;, &#39;王五&#39;]
console.log(arr) // -&gt; [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;]; 原数组是没有改变的。
</code></pre>
<h1 id="7-splice"><a href="#7-splice" class="headerlink" title="7.splice();"></a>7.splice();</h1><p>向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。</p>
<pre><code>// 注意：splice(start,num,val1,val2,...); 所有参数全部可选。和 slice 相比 splice 是会改变原数组的。
// start 是开始位置,可以为负数，-1就代表从最后一位开始，num代表要删除或者替换的长度，不能为负数。
let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
console.log(arr.splice(2,1)) // -&gt; [&#39;王五&#39;]
console.log(arr) // -&gt; [&#39;张三&#39;,&#39;李四&#39;,&#39;马六&#39;]
  
let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
console.log(arr.splice(2,1,&#39;七郎&#39;)) // -&gt; [&#39;王五&#39;] 
console.log(arr) // -&gt; [&#39;张三&#39;, &#39;李四&#39;, &#39;七郎&#39;, &#39;马六&#39;]
</code></pre>
<h1 id="8-toString"><a href="#8-toString" class="headerlink" title="8.toString();"></a>8.toString();</h1><p>将数组转换成字符串，类似于没有参数的join()。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。不会改变原数组</p>
<pre><code>let arr = [1,2,3,4,5,6];
console.log(arr.toString()) // -&gt; &#39;1,2,3,4,5,6&#39;
// 注意：没有参数。
</code></pre>
<h1 id="9-indexOf"><a href="#9-indexOf" class="headerlink" title="9.indexOf();"></a>9.indexOf();</h1><p>根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引</p>
<pre><code>// 注意：indexOf(value, start);value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1
  
let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
console.log(arr.indexOf(&#39;李四&#39;)) // -&gt; 1
console.log(arr.indexOf(&#39;李四&#39;,2)) // -&gt; -1
</code></pre>
<h1 id="10-forEach"><a href="#10-forEach" class="headerlink" title="10.forEach()"></a>10.forEach()</h1><p>ES5新增的方法，用来遍历数组，没有返回值，</p>
<pre><code>// 注意：forEach(callback);callback默认有三个参数，分别为value(遍历到的数组的数据)，index(对应的索引)，self(数组自身)。
let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;]
let a = arr.forEach((item,index,self)=&gt;&#123;
    console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self));
&#125;)
// 打印结果为：
// 张三--0--true
// 李四--1--true
// 王五--2--true
// 马六--3--true
console.log(a);  // -&gt; undefined---forEach没有返回值
//该方法为遍历方法，不会修改原数组
</code></pre>
<h1 id="11-map-；"><a href="#11-map-；" class="headerlink" title="11.map()；"></a>11.map()；</h1><p>1.同forEach功能；<br>2.map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。</p>
<pre><code>//注意：map(callback);callback默认有三个参数，分别为value，index，self。跟上面的forEach()的参数一样
let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
let arr1 = arr.map(item =&gt; &#123;
    return &#39;你好：&#39;+item
&#125;)
console.log(arr1) // -&gt; [&#39;你好：张三&#39;, &#39;你好：李四&#39;, &#39;你好：王五&#39;, &#39;你好：马六&#39;]
</code></pre>
<h1 id="12-filter"><a href="#12-filter" class="headerlink" title="12.filter();"></a>12.filter();</h1><p>1.同forEach功能；2.filter的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）。</p>
<pre><code>// 注意：filter(callback);callback默认有三个参数，分别为value，index，self。
let arr = [1,2,3,4,5,6];
let arr1 = arr.filter((value,index,self)=&gt;&#123;
    console.log(item) // -&gt; 1,2,3,4,5,6
    console.log(index) // -&gt; 0,1,2,3,4,5
    console.log(self) // -&gt; [1,2,3,4,5,6]
    return item &gt; 3
&#125;)
  
console.log(arr1) // -&gt; [4,5,6]
</code></pre>
<h1 id="13-find"><a href="#13-find" class="headerlink" title="13.find();"></a>13.find();</h1><p>数组的循环，查找到符合条件的值并且打断循环返回找到的值；</p>
<pre><code>let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
let str = arr.find(item =&gt; item == &#39;李四&#39;);
console.log(str); // -&gt; &#39;李四&#39;
</code></pre>
<h1 id="14-findIndex"><a href="#14-findIndex" class="headerlink" title="14.findIndex();"></a>14.findIndex();</h1><p>数组的循环，查找到符合条件的索引并且打断循环返回找到的索引值</p>
<pre><code>let arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,&#39;马六&#39;];
let index = arr.findIndex(item =&gt; item == &#39;李四&#39;);
console.log(index); // -&gt; 1;
</code></pre>
<h1 id="15-every"><a href="#15-every" class="headerlink" title="15.every();"></a>15.every();</h1><p>判断数组中每一项是否都满足条件，只有所有项都满足条件，才会返回true。</p>
<pre><code>// 注意： every()接收一个回调函数作为参数，这个回调函数需要有返回值，every(callback);callback默认有三个参数，分别为value，index，self。
let arr = [1,2,3,4,5,6];
let bool = arr.every(item =&gt; item &gt; 0);
console.log(bool); // -&gt; true;
  
let bool = arr.every(item =&gt; item &gt; 3);
console.log(bool); // -&gt; false;
</code></pre>
<h1 id="16-some"><a href="#16-some" class="headerlink" title="16.some();"></a>16.some();</h1><p>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。否侧就会返回false</p>
<pre><code>//注意： some()接收一个回调函数作为参数，这个回调函数需要有返回值，some(callback);callback默认有三个参数，分别为value，index，self。
let arr = [1,2,3,4,5,6];
let bool = arr.some(item =&gt; item &gt; 3);
console.log(bool) // -&gt; true;
  
let bool = arr.some(item =&gt; item &gt; 6);
console.log(bool) // -&gt; false;
</code></pre>
<h1 id="17-reduce"><a href="#17-reduce" class="headerlink" title="17.reduce();"></a>17.reduce();</h1><p>数组的第一项开始，逐个遍历到最后，迭代数组的所有项，然后构建一个最终返回的值。</p>
<pre><code>// 注意：参数：reduce()接收一个或两个参数：第一个是回调函数，表示在数组的每一项上调用的函数；第二个参数（可选的）作为归并的初始值，被回调函数第一次执行时的第一个参数接收。 reduce(callback,initial);callback默认有四个参数，分别为prev，now，index，self。 callback返回的任何值都会作为下一次执行的第一个参数。 如果initial参数被省略，那么第一次迭代发生在数组的第二项上，因此callback的第一个参数是数组的第一项，第二个参数就是数组的第二项。
  
let arr = [10,20,30,40,50];
let sum = arr.reduce((prev,now) =&gt; prev+now)
  
console.log(sum); // -&gt; 150;
  
let sum = arr.reduce((prev,now) =&gt; prev+now,110)
  
console.log(sum)
</code></pre>
<p>本文为大家讲解了17个vue常用的数组方法总结与实例演示，包括：VUE数组转换字符串，VUE数组遍历，VUE数组过滤，VUE数组查询等功能</p>
<p><a href="https://www.jb51.net/article/269686.htm">https://www.jb51.net/article/269686.htm</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中下载不同文件五种常用的方式</title>
    <url>/2023/09/21/Vue%E4%B8%AD%E4%B8%8B%E8%BD%BD%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当在Vue中需要实现文件下载功能时，我们可以有多种方式来完成。下面将介绍五种常用的方法。</p>
<h1 id="1-使用window-open方法下载文件"><a href="#1-使用window-open方法下载文件" class="headerlink" title="1. 使用window.open方法下载文件"></a>1. 使用window.open方法下载文件</h1><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;downloadFile(&#39;file1.pdf&#39;)&quot;&gt;下载文件1&lt;/button&gt;
    &lt;button @click=&quot;downloadFile(&#39;file2.jpg&#39;)&quot;&gt;下载文件2&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  methods: &#123;
    downloadFile(fileName) &#123;
      const fileUrl = &#39;/path/to/&#39; + fileName; // 文件的URL地址
      window.open(fileUrl);
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在上面的示例中，我们使用了window.open方法来打开一个新窗口，并直接访问文件的URL地址，从而触发文件下载。</p>
<h1 id="2-使用标签进行文件下载"><a href="#2-使用标签进行文件下载" class="headerlink" title="2. 使用标签进行文件下载"></a>2. 使用<a>标签进行文件下载</a></h1><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;downloadFile(&#39;file1.pdf&#39;)&quot;&gt;下载文件1&lt;/button&gt;
    &lt;button @click=&quot;downloadFile(&#39;file2.jpg&#39;)&quot;&gt;下载文件2&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  methods: &#123;
    downloadFile(fileName) &#123;
      const fileUrl = &#39;/path/to/&#39; + fileName; // 文件的URL地址
      const link = document.createElement(&#39;a&#39;);
      link.href = fileUrl;
      link.setAttribute(&#39;download&#39;, fileName);
      link.click();
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在上面的示例中，我们首先创建一个<a>标签，然后设置其href属性为文件的URL地址，download属性为要下载的文件名。最后，通过调用click()方法触发链接的点击事件，实现文件的下载。</a></p>
<h1 id="3-使用axios下载文件"><a href="#3-使用axios下载文件" class="headerlink" title="3. 使用axios下载文件"></a>3. 使用axios下载文件</h1><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;downloadFile(&#39;file1.pdf&#39;)&quot;&gt;下载文件1&lt;/button&gt;
    &lt;button @click=&quot;downloadFile(&#39;file2.jpg&#39;)&quot;&gt;下载文件2&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import axios from &#39;axios&#39;;
export default &#123;
  methods: &#123;
    downloadFile(fileName) &#123;
      const fileUrl = &#39;/path/to/&#39; + fileName; // 文件的URL地址
      axios.get(fileUrl, &#123; responseType: &#39;blob&#39; &#125;)
        .then(response =&gt; &#123;
          const url = window.URL.createObjectURL(new Blob([response.data]));
          const link = document.createElement(&#39;a&#39;);
          link.href = url;
          link.setAttribute(&#39;download&#39;, fileName);
          document.body.appendChild(link);
          link.click();
        &#125;)
        .catch(error =&gt; &#123;
          console.error(error);
        &#125;);
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在上面的示例中，我们使用了axios发送GET请求，设置responseType为blob以便获取文件的二进制数据。然后，通过创建临时URL、创建<a>标签并设置下载属性，实现文件的下载。</a></p>
<h1 id="4-使用Fetch-API下载文件"><a href="#4-使用Fetch-API下载文件" class="headerlink" title="4. 使用Fetch API下载文件"></a>4. 使用Fetch API下载文件</h1><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;downloadFile(&#39;file1.pdf&#39;)&quot;&gt;下载文件1&lt;/button&gt;
    &lt;button @click=&quot;downloadFile(&#39;file2.jpg&#39;)&quot;&gt;下载文件2&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  methods: &#123;
    downloadFile(fileName) &#123;
      const fileUrl = &#39;/path/to/&#39; + fileName; // 文件的URL地址
      fetch(fileUrl)
        .then(response =&gt; response.blob())
        .then(blob =&gt; &#123;
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement(&#39;a&#39;);
          link.href = url;
          link.setAttribute(&#39;download&#39;, fileName);
          document.body.appendChild(link);
          link.click();
        &#125;)
        .catch(error =&gt; &#123;
          console.error(error);
        &#125;);
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在上面的示例中，我们使用了Fetch API发送GET请求，并使用.blob()方法将返回的数据转换为blob对象。然后，通过创建临时URL、创建<a>标签并设置下载属性，实现文件的下载。</a></p>
<h1 id="5-使用Vue的-download方法下载文件"><a href="#5-使用Vue的-download方法下载文件" class="headerlink" title="5. 使用Vue的$download方法下载文件"></a>5. 使用Vue的$download方法下载文件</h1><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;downloadFile(&#39;file1.pdf&#39;)&quot;&gt;下载文件1&lt;/button&gt;
    &lt;button @click=&quot;downloadFile(&#39;file2.jpg&#39;)&quot;&gt;下载文件2&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  methods: &#123;
    downloadFile(fileName) &#123;
      const fileUrl = &#39;/path/to/&#39; + fileName; // 文件的URL地址
      this.$download(fileUrl, fileName);
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在这个示例中，我们直接调用Vue实例的$download方法，并传入文件的URL地址和下载的文件名，即可实现文件的下载。</p>
<h1 id="6-使用创建a标签方法下载文件"><a href="#6-使用创建a标签方法下载文件" class="headerlink" title="6. 使用创建a标签方法下载文件"></a>6. 使用创建a标签方法下载文件</h1><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;downloadFile(&#39;file1.pdf&#39;)&quot;&gt;下载文件1&lt;/button&gt;
    &lt;button @click=&quot;downloadFile(&#39;file2.jpg&#39;)&quot;&gt;下载文件2&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  methods: &#123;
    downloadFile(fileName) &#123;
      const folderPath = &#39;/path/to/folder/&#39;; // 文件所在的文件夹路径
      const fileUrl = folderPath + fileName; // 拼接文件夹路径和文件名
      const link = document.createElement(&#39;a&#39;);
      link.href = fileUrl;
      link.setAttribute(&#39;download&#39;, fileName);
      link.click();
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<p>在这个示例中，我们首先定义了文件所在的文件夹路径folderPath，然后通过拼接文件夹路径和文件名来构建完整的文件URL地址fileUrl。接着，我们创建一个<a>标签，并设置其href属性为文件URL，download属性为要下载的文件名。最后，通过调用click()方法触发链接的点击事件，实现文件的下载。</a></p>
<p>以上是六种常用的在Vue中实现文件下载的方式，请根据项目需求选择合适的方式来完成文件下载功能。</p>
<p><a href="https://www.jb51.net/javascript/2987938qn.htm">https://www.jb51.net/javascript/2987938qn.htm</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>使用elmentUI里面el-button按钮替换input type=“file“ 默认按钮</title>
    <url>/2023/09/20/%E4%BD%BF%E7%94%A8elmentUI%E9%87%8C%E9%9D%A2el-button%E6%8C%89%E9%92%AE%E6%9B%BF%E6%8D%A2input%20type=%E2%80%9Cfile%E2%80%9C%20%E9%BB%98%E8%AE%A4%E6%8C%89%E9%92%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先隐藏input的默认按钮，再把el-button的点击事件指向input的点击事件</p>
<pre><code>&lt;form name=&quot;formInput&quot;&gt;
    &lt;input type=&quot;file&quot; 
           id=&quot;fileDemo&quot;
           class=&quot;input&quot; 
           style=&quot;position:absolute; clip:rect(0 0 0 0);&quot;   //隐藏样式
           @change=&quot;changeFileDemo&quot;&gt;
&lt;/form&gt;
&lt;el-button size=&quot;small&quot; 
        type=&quot;primary&quot; 
        plain 
        onclick=&quot;document.formInput.fileDemo.click()&quot;&gt;选择文件  //点击事件指向input
&lt;/el-button&gt;
</code></pre>
<p>formInput 为<form>里面name的值</form></p>
<p>fileDemo 为<input>里面id的值<br>————————————————<br>版权声明：本文为CSDN博主「前端小蔡姬」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/x_nweBorder01k/article/details/124715048">https://blog.csdn.net/x_nweBorder01k/article/details/124715048</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 点击el-button 触发input type=“file“ 选择本地文件 并修改样式</title>
    <url>/2023/09/19/Vue3%20%E7%82%B9%E5%87%BBel-button%20%E8%A7%A6%E5%8F%91input%20type=%E2%80%9Cfile%E2%80%9C%20%E9%80%89%E6%8B%A9%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%20%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>template</p>
<pre><code>&lt;el-button class=&quot;file-box&quot; text&gt;
    &lt;input type=&quot;file&quot; multiple class=&quot;file-btn&quot; required
        @change=&quot;setImage&quot;/&gt;上传  
&lt;/el-button&gt;
</code></pre>
<p>style</p>
<pre><code>.file-box &#123;
    display: inline-block;
    position: relative;
    overflow: hidden;
    color: rgb(252, 113, 0);
    background-color: rgb(255, 255, 255);
&#125;
 
.file-btn &#123;
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    outline: none;
    filter: alpha(opacity=0);
    -moz-opacity: 0;
    -khtml-opacity: 0;
    opacity: 0;
&#125;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「wlik」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_45220510/article/details/126172494">https://blog.csdn.net/weixin_45220510/article/details/126172494</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 实现文件上传、下载</title>
    <url>/2023/09/18/vue%20%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、使用element ui 中的el-upload</p>
<pre><code>&lt;!-- :limit=&quot;1&quot; 限制上传数量  :drag=&quot;true&quot; 可实现拖拽上传 :file-list会返显在下方--&gt;
&lt;el-upload
    class=&quot;upload-demo&quot;
    action=&quot;#&quot;
    :drag=&quot;true&quot;
    :before-upload=&quot;uploadFileFun&quot;
    :file-list=&quot;uploadFile.fileList&quot;&gt;
    &lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;
    &lt;div class=&quot;el-upload__tip fontSize12 colorRed&quot; slot=&quot;tip&quot;&gt;文件包括评审指南、须知及回避要求等，上传文件格式为word或pdf，文件大小在2M以内&lt;/div&gt;
&lt;/el-upload&gt;
</code></pre>
<p>2、data中定义相关数据，methods中书写上传方法</p>
<pre><code>data () &#123;
    return &#123;
        fileIdArr: [],
        uploadFile:&#123;
            createUser:&#39;&#39;,
            createTime:&#39;&#39;,
            fileId: &#39;&#39;, // 存放选择的文件
            fileList: [],
        &#125;,
        uploadFileRules: &#123;
          fileList: [&#123; required: true, message: &quot;请上传文件&quot;, trigger: &quot;blur&quot; &#125;],
        &#125;
    &#125;
  &#125;,
methods: &#123;
    uploadFileFun(file)&#123;
        var test = /(doc|docx|pdf)$/.test(file.type);
        if (!test) &#123;
             this.$message.error(&quot;请上传正确的文档格式!&quot;);
             return false;
         &#125;
         const isLt2M = file.size / 1024 / 1024 &lt; 2;
        if (!isLt2M) &#123;
            this.$message.error(&quot;上传文件大小不能超过 2MB!&quot;);
             return false;
         &#125;
        // 创建formdata实例
        let formData = new window.FormData();
        // 将获取的文件通过append方法加入实例中
        formData.append(&quot;file&quot;, file);
        this.$api.
            uploadFile(formData)
            .then(res =&gt; &#123;
                // fileList用于反显
                this.uploadFile.fileList.push(res.data)
                this.fileIdArr.push(res.data.id)
            &#125;)
            .catch(err =&gt; &#123;&#125;);
      &#125;,
 &#125;
</code></pre>
<p>3、下载</p>
<pre><code>methods: &#123;
    // 附件下载
    downloadFile(row)&#123;
        // 判断如果没有文件就不进行文件的下载
       if (row.fileName)&#123;
             this.$api
             .downloadFile(&#123;fileId: row.fileId&#125;)
             .then(res =&gt; &#123;
                // 如果有文件且接口掉成功，后端会直接返回文件流，因此若返回res.code，表示接口没有返回文件流
                 if(res.code)&#123;
                     this.$message(&#123;
                         type: &#39;error&#39;,
                         message: res.msg
                     &#125;)
                 &#125;else&#123;
                 
                    // 这里最重要，这里最重要！！！！！
                    
                     const link = document.createElement(&quot;a&quot;);
                     let blob = new Blob([res]);  //文件流处理
                     link.style.display = &quot;none&quot;;  //去除a标签的样式
                     // 设置链接
                     link.href = window.URL.createObjectURL(blob);
                     link.download = row.fileName; // 指定下载文件名，包含文件后缀
                     document.body.appendChild(link);
                     //模拟点击事件
                     link.click();
                     //移除创建的a标签
                     window.URL.revokeObjectURL(link.href);
                     document.body.removeChild(link);
                 &#125;
                
             &#125;)
             .catch(err =&gt; &#123;&#125;)
         &#125;else&#123;
             this.$message(&#123;
                 message: &#39;该邮件模板没有可下载的附件&#39;
             &#125;)
         &#125;
     &#125;,
&#125;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「淡紫色的回忆」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/niuniu2878499107/article/details/131958497">https://blog.csdn.net/niuniu2878499107/article/details/131958497</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue获取当前日期时间(moment、new Date())</title>
    <url>/2023/09/17/vue%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4(moment%E3%80%81new%20Date())/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="vue获取当前日期时间"><a href="#vue获取当前日期时间" class="headerlink" title="vue获取当前日期时间"></a>vue获取当前日期时间</h1><p>开发中会有要获取当前日期的需求，有的是获取到当前月份，有的是精确到分秒。</p>
<p>而且日期的格式还不一样，一下有两种获取时间的方式：</p>
<h1 id="1-new-Date-拼接"><a href="#1-new-Date-拼接" class="headerlink" title="1 new Date()+拼接"></a>1 new Date()+拼接</h1><h2 id="格式一："><a href="#格式一：" class="headerlink" title="格式一："></a>格式一：</h2><pre><code>yy/MM/dd hh:mm:ss – 例如：2022/05/01 00:00:00
yy/M/d hh:mm:ss – 例如：2022/5/1 00:00:00
</code></pre>
<p>获取当前时间</p>
<pre><code>/**
* 获取当前时间
*/
currentTime() &#123;
    var date = new Date();
    var year = date.getFullYear(); //月份从0~11，所以加一
    let month = date.getMonth();
    console.log(&quot;month&quot;,month);
    var dateArr = [
        date.getMonth() + 1,
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds(),
    ];
    //如果格式是MM则需要此步骤，如果是M格式则此循环注释掉
    for (var i = 0; i &lt; dateArr.length; i++) &#123;
        if (dateArr[i] &gt;= 1 &amp;&amp; dateArr[i] &lt;= 9) &#123;
            dateArr[i] = &quot;0&quot; + dateArr[i];
        &#125;
    &#125;
    var strDate =
        year +
        &quot;/&quot; +
        dateArr[0] +
        &quot;/&quot; +
        dateArr[1] +
        &quot; &quot; +
        dateArr[2] +
        &quot;:&quot; +
        dateArr[3] +
        &quot;:&quot; +
        dateArr[4];
        //此处可以拿外部的变量接收，也可直接返回  strDate:2022-05-01 13:25:30
        //this.date = strDate;
    console.log(&quot;strDate&quot;,strDate);
&#125;,
</code></pre>
<h2 id="格式二："><a href="#格式二：" class="headerlink" title="格式二："></a>格式二：</h2><pre><code>yy-MM-dd hh:mm:ss – 例如：2022-05-01 00:00:00
yy-MM-dd hh:mm:ss – 例如：2022-05-01 00:00:00
</code></pre>
<p>获取当前时间</p>
<pre><code>/**
* 获取当前时间
*/
currentTime() &#123;
    var date = new Date();
    var year = date.getFullYear(); //月份从0~11，所以加一
    let month = date.getMonth();
    console.log(&quot;month&quot;,month);
    var dateArr = [
        date.getMonth() + 1,
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds(),
    ];
    //如果格式是MM则需要此步骤，如果是M格式则此循环注释掉
    for (var i = 0; i &lt; dateArr.length; i++) &#123;
        if (dateArr[i] &gt;= 1 &amp;&amp; dateArr[i] &lt;= 9) &#123;
            dateArr[i] = &quot;0&quot; + dateArr[i];
        &#125;
    &#125;
    var strDate =
        year +
        &quot;/&quot; +
        dateArr[0] +
        &quot;/&quot; +
        dateArr[1] +
        &quot; &quot; +
        dateArr[2] +
        &quot;:&quot; +
        dateArr[3] +
        &quot;:&quot; +
        dateArr[4];
        //此处可以拿外部的变量接收  strDate:2022-05-01 13:25:30
        //this.date = strDate;
    console.log(&quot;strDate&quot;,strDate);
&#125;,
</code></pre>
<p>获取当前月份</p>
<pre><code>/**
* 获取当前月份，可直接返回
*/
currentTime() &#123;
    var date = new Date();
    var year = date.getFullYear(); //月份从0~11，所以加一
    let month = date.getMonth() + 1;
    console.log(&quot;month&quot;, month);

    //如果格式是MM则需要此步骤，如果是M格式则此处注释掉
    if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;
        month = &quot;0&quot; + month;
    &#125;
    let strDate = year + &quot;-&quot; + month;
    return strDate;
&#125;,
</code></pre>
<h1 id="2-moment-函数获取"><a href="#2-moment-函数获取" class="headerlink" title="2 moment()函数获取"></a>2 moment()函数获取</h1><p>下载moment依赖</p>
<pre><code>npm i moment
</code></pre>
<p>在所需要的页面引入</p>
<pre><code>import moment from &quot;moment&quot;
</code></pre>
<p>为了方便也可以在全局引入<br>用法</p>
<pre><code>this.$moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)
</code></pre>
<p>此函数很方便，只需在format设置自己需要的格式即可<br>————————————————</p>
<p>版权声明：本文为CSDN博主「猪大侠0.0」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43331014/article/details/127698605">https://blog.csdn.net/qq_43331014/article/details/127698605</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中使用定时器(setInterval、setTimeout)的两种方式</title>
    <url>/2023/09/16/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8(setInterval%E3%80%81setTimeout)%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js中定时器有两种，一个是循环执行 setInterval，另一个是定时执行 setTimeout。</p>
<p>注意：定时器需要在页面销毁的时候清除掉，不然会一直存在！</p>
<h1 id="1-循环执行（-setInterval-）"><a href="#1-循环执行（-setInterval-）" class="headerlink" title="1. 循环执行（ setInterval ）"></a>1. 循环执行（ setInterval ）</h1><p>顾名思义，循环执行就是设置一个时间间隔，每过一段时间都会循环执行这个方法,直到这个定时器被销毁掉；</p>
<p>语法：</p>
<pre><code>setInterval(code, milliseconds)；
setInterval(function, milliseconds, param1, param2, ...)；
  
code/function           必需。要调用一个代码串，也可以是一个函数。
milliseconds            必须。周期性执行或调用 code/function 之间的时间间隔，以毫秒计。
param1, param2, ...     可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。
  
  
返回值:      返回一个 ID（数字），可以将这个ID传递给 clearInterval() 来取消执行。
</code></pre>
<p>eg:</p>
<p>开始的时候创建了一个定时器 setInterval ，时间间隔为2秒，每2秒都会调用一次函数 valChange，从而使 value 的值+1。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;&#123;&#123;value&#125;&#125;&lt;/h1&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;start&quot;&gt;开始&lt;/el-button&gt;
    &lt;el-button type=&quot;danger&quot; @click=&quot;over&quot;&gt;结束&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
  
&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      timer: &quot;&quot;,
      value: 0,
    &#125;;
  &#125;,
  methods: &#123;
    start()&#123;
      this.timer = setInterval(this.valChange, 2000); // 注意: 第一个参数为方法名的时候不要加括号;
    &#125;,
    valChange() &#123;
      this.value++;
      console.log(this.value);
    &#125;,
    over()&#123;
      clearInterval(this.timer);
    &#125;
  &#125;,
  mounted() &#123;&#125;,
  beforeDestroy() &#123;
    clearInterval(this.timer);
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h1 id="2-定时执行-（-setTimeout）"><a href="#2-定时执行-（-setTimeout）" class="headerlink" title="2. 定时执行 （ setTimeout）"></a>2. 定时执行 （ setTimeout）</h1><p>定时执行 setTimeout 是设置一个时间，等待时间到达的时候只执行一次，但是执行完以后定时器还在，只是不再运行；</p>
<p>语法：</p>
<pre><code>setTimeout(code, milliseconds, param1, param2, ...)
setTimeout(function, milliseconds, param1, param2, ...)
  
code/function            必需。要调用一个代码串，也可以是一个函数。
milliseconds             可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。
param1, param2, ...      可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。

返回值:    返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行。
</code></pre>
<p>eg:</p>
<p>开始时候创建一个定时器 setTimeout，只在2秒后执行一次方法。</p>
<pre><code>let timer = setTimeout(() =&gt; &#123;
      //需要定时执行的代码
      console.debug(&quot;Hello World&quot;);
      &#125;, 2000)
</code></pre>
<p>到此这篇关于Vue中 使用定时器 （setInterval、setTimeout）的文章就介绍到这了</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue父组件子组件的通信方式20种（全网最全总结）</title>
    <url>/2023/09/15/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F20%E7%A7%8D%EF%BC%88%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、常用"><a href="#一、常用" class="headerlink" title="一、常用"></a>一、常用</h1><p>最近一直在封装各种组件, 提高组员开发效率,<br>遇到了各种情况下的父子组件, 兄弟组件之间各种传值,<br>这里做下总结和一些探索, 欢迎补充~</p>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>父组件向子组件传递数据，子组件通过props属性接收数据</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component :parentData=&quot;data&quot;&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  data () &#123;
    return &#123;
      data: &#39;父组件传递的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; parentData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  props: &#123;
    parentData: String
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>Vue props默认值类型有哪些</p>
<h2 id="emit和-on"><a href="#emit和-on" class="headerlink" title="$emit和$on"></a>$emit和$on</h2><p>子组件向父组件传递数据，子组件通过$emit触发事件，父组件通过$on监听事件并接收数据。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component @childEvent=&quot;handleChild&quot;&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleChild (data) &#123;
      console.log(&#39;父组件接收到的数据：&#39; + data)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;点击触发事件&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  methods: &#123;
    handleClick () &#123;
      this.$emit(&#39;childEvent&#39;, &#39;子组件传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a>$parent和$children</h2><p>父组件向子组件传递数据，父组件通过$children获取子组件实例并调用子组件方法传递数据。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;向子组件传递数据&lt;/button&gt;
    &lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleClick () &#123;
      this.$refs.child.handleData(&#39;父组件传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  methods: &#123;
    handleData (data) &#123;
      console.log(&#39;子组件接收到的数据：&#39; + data)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="attrs和-listeners"><a href="#attrs和-listeners" class="headerlink" title="$attrs和$listeners"></a>$attrs和$listeners</h2><p>父组件向子组件传递属性和事件，子组件通过$attrs获取属性，通过$listeners获取事件并绑定在子组件上。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component attr1=&quot;属性1&quot; attr2=&quot;属性2&quot; @event1=&quot;handleEvent&quot;&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleEvent (data) &#123;
      console.log(&#39;父组件接收到的数据：&#39; + data)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  mounted () &#123;
    this.$emit(&#39;event1&#39;, &#39;子组件传递的数据&#39;)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a>provide和inject</h2><p>父组件向子组件传递数据，父组件通过provide提供数据，子组件通过inject注入数据。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  provide () &#123;
    return &#123;
      parentData: &#39;父组件提供的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; childData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  inject: [&#39;parentData&#39;],
  computed: &#123;
    childData () &#123;
      return this.parentData + &#39;，子组件加工处理后的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h1 id="二、其他探索"><a href="#二、其他探索" class="headerlink" title="二、其他探索"></a>二、其他探索</h1><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p>父组件和子组件之间通过中央事件总线(EventBus)进行通信。</p>
<p>EventBus.js：</p>
<pre><code>import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleParent&quot;&gt;向子组件传递数据&lt;/button&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
import &#123; EventBus &#125; from &#39;./EventBus&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleParent () &#123;
      EventBus.$emit(&#39;parent-event&#39;, &#39;父组件传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; childData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; EventBus &#125; from &#39;./EventBus&#39;
 
export default &#123;
  data () &#123;
    return &#123;
      childData: &#39;&#39;
    &#125;
  &#125;,
  mounted () &#123;
    EventBus.$on(&#39;parent-event&#39;, data =&gt; &#123;
      this.childData = data
    &#125;)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>父组件和子组件之间通过Vuex进行通信，共享同一状态树。</p>
<p>store.js：</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
 
Vue.use(Vuex)
 
export default new Vuex.Store(&#123;
  state: &#123;
    data: &#39;共享的数据&#39;
  &#125;,
  mutations: &#123;
    setData (state, data) &#123;
      state.data = data
    &#125;
  &#125;
&#125;)
</code></pre>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleParent&quot;&gt;向子组件传递数据&lt;/button&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
import store from &#39;./store&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleParent () &#123;
      store.commit(&#39;setData&#39;, &#39;父组件传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; childData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; mapState &#125; from &#39;vuex&#39;
 
export default &#123;
  computed: &#123;
    ...mapState([&#39;data&#39;]),
    childData () &#123;
      return this.data + &#39;，子组件加工处理后的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="refs属性"><a href="#refs属性" class="headerlink" title="$refs属性"></a>$refs属性</h2><p>父组件可以通过$refs获取子组件的实例，进而访问子组件的属性和方法。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleParent&quot;&gt;向子组件传递数据&lt;/button&gt;
    &lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleParent () &#123;
      this.$refs.child.childData = &#39;父组件修改的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; childData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  data () &#123;
    return &#123;
      childData: &#39;子组件原始数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="parent属性"><a href="#parent属性" class="headerlink" title="$parent属性"></a>$parent属性</h2><p>子组件可以通过$parent获取父组件的实例，进而访问父组件的属性和方法。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  data () &#123;
    return &#123;
      parentData: &#39;父组件数据&#39;
    &#125;
  &#125;,
  methods: &#123;
    handleParent () &#123;
      console.log(&#39;父组件的方法&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleChild&quot;&gt;调用父组件方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  methods: &#123;
    handleChild () &#123;
      console.log(this.$parent.parentData)
      this.$parent.handleParent()
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="root属性"><a href="#root属性" class="headerlink" title="$root属性"></a>$root属性</h2><p>子组件可以通过$root获取根组件的实例，进而访问根组件的属性和方法。</p>
<p>根组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  mounted () &#123;
    console.log(&#39;根组件的数据：&#39; + this.rootData)
    this.rootMethod()
  &#125;,
  data () &#123;
    return &#123;
      rootData: &#39;根组件的数据&#39;
    &#125;
  &#125;,
  methods: &#123;
    rootMethod () &#123;
      console.log(&#39;根组件的方法&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  mounted () &#123;
    console.log(&#39;根组件的数据：&#39; + this.$root.rootData)
    this.$root.rootMethod()
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="provide-inject-高级"><a href="#provide-inject-高级" class="headerlink" title="provide / inject (高级)"></a>provide / inject (高级)</h2><p>provide / inject 可以让祖先组件向所有后代组件注入一个依赖，让这些组件使用相同的依赖注入。</p>
<p>祖先组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
    &lt;grand-child&gt;&lt;/grand-child&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
import GrandChild from &#39;./GrandChild.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent,
    GrandChild
  &#125;,
  provide: &#123;
    sharedObj: &#123;
      message: &#39;这是祖先组件注入的对象&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>直接子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  inject: [&#39;sharedObj&#39;]
&#125;
&lt;/script&gt;
</code></pre>
<p>间接子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; childData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  inject: [&#39;sharedObj&#39;],
  computed: &#123;
    childData () &#123;
      return this.sharedObj.message + &#39;，子组件加工处理后的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="provide-inject-Vuex-高级"><a href="#provide-inject-Vuex-高级" class="headerlink" title="provide / inject + Vuex (高级)"></a>provide / inject + Vuex (高级)</h2><p>使用provide / inject注入Vuex的实例，使所有组件使用相同的Vuex实例。</p>
<p>store.js：</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
 
Vue.use(Vuex)
 
export default new Vuex.Store(&#123;
  state: &#123;
    data: &#39;共享的数据&#39;
  &#125;,
  mutations: &#123;
    setData (state, data) &#123;
      state.data = data
    &#125;
  &#125;
&#125;)
</code></pre>
<p>根组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
import store from &#39;./store&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  provide () &#123;
    return &#123;
      store
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件和孙组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件接收到的数据：&#123;&#123; componentData &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  inject: &#123;
    store: &#123;
      default: null
    &#125;
  &#125;,
  computed: &#123;
    componentData () &#123;
      return this.store.state.data + &#39;，组件加工处理后的数据&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>使用vm.$on(eventName, callback)事件监听，使用vm.$emit(eventName, …args)触发事件。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;child-component @custom-event=&quot;handleCustomEvent&quot;&gt;&lt;/child-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildComponent from &#39;./ChildComponent.vue&#39;
 
export default &#123;
  components: &#123;
    ChildComponent
  &#125;,
  methods: &#123;
    handleCustomEvent (data) &#123;
      console.log(&#39;父组件接收到的数据：&#39; + data)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;点击触发事件&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  methods: &#123;
    handleClick () &#123;
      this.$emit(&#39;custom-event&#39;, &#39;子组件传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h2><p>使用一个空的Vue实例作为事件总线，一边向事件总线发出事件，另一边监听事件。</p>
<p>EventBus.js：</p>
<pre><code>import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>组件A：<br>    <template><br>      <div><br>        &lt;button @click=”handleClick”&gt;向组件B传递数据<br>      </div><br>    </template></p>
<pre><code>&lt;script&gt;
import &#123; EventBus &#125; from &#39;./EventBus&#39;
 
export default &#123;
  methods: &#123;
    handleClick () &#123;
      EventBus.$emit(&#39;event&#39;, &#39;组件A传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>组件B：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件B接收到的数据：&#123;&#123; data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; EventBus &#125; from &#39;./EventBus&#39;
 
export default &#123;
  data () &#123;
    return &#123;
      data: &#39;&#39;
    &#125;
  &#125;,
  mounted () &#123;
    EventBus.$on(&#39;event&#39;, data =&gt; &#123;
      this.data = data
    &#125;)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="localStorage（浏览器缓存）"><a href="#localStorage（浏览器缓存）" class="headerlink" title="localStorage（浏览器缓存）"></a>localStorage（浏览器缓存）</h2><p>使用浏览器缓存来存储数据，在需要通信的组件中存储并监听缓存中的数据。</p>
<p>组件A：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;向组件B传递数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  methods: &#123;
    handleClick () &#123;
      localStorage.setItem(&#39;data&#39;, &#39;组件A传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>组件B：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件B接收到的数据：&#123;&#123; data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  data () &#123;
    return &#123;
      data: &#39;&#39;
    &#125;
  &#125;,
  mounted () &#123;
    window.addEventListener(&#39;storage&#39;, this.handleStorageUpdate)
    this.updateData()
  &#125;,
  beforeDestroy () &#123;
    window.removeEventListener(&#39;storage&#39;, this.handleStorageUpdate)
  &#125;,
  methods: &#123;
    handleStorageUpdate (event) &#123;
      if (event.key === &#39;data&#39;) &#123;
        this.updateData()
      &#125;
    &#125;,
    updateData () &#123;
      this.data = localStorage.getItem(&#39;data&#39;) || &#39;&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="发布订阅（Pub-Sub）模式"><a href="#发布订阅（Pub-Sub）模式" class="headerlink" title="发布订阅（Pub/Sub）模式"></a>发布订阅（Pub/Sub）模式</h2><p>使用一个消息中心，订阅者向消息中心订阅消息，发布者向消息中心发布消息，消息中心将消息通知给所有订阅者。</p>
<p>消息中心：</p>
<pre><code>// PubSub.js
export const PubSub = &#123;
  events: &#123;&#125;,
  subscribe (event, callback) &#123;
    if (!this.events[event]) &#123;
      this.events[event] = []
    &#125;
    this.events[event].push(callback)
  &#125;,
  publish (event, data) &#123;
    if (!this.events[event]) &#123;
      this.events[event] = []
    &#125;
    this.events[event].forEach(callback =&gt; callback(data))
  &#125;
&#125;
</code></pre>
<p>组件A：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;向组件B传递数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; PubSub &#125; from &#39;./PubSub&#39;
 
export default &#123;
  methods: &#123;
    handleClick () &#123;
      PubSub.publish(&#39;event&#39;, &#39;组件A传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>组件B：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件B接收到的数据：&#123;&#123; data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; PubSub &#125; from &#39;./PubSub&#39;
 
export default &#123;
  data () &#123;
    return &#123;
      data: &#39;&#39;
    &#125;
  &#125;,
  mounted () &#123;
    PubSub.subscribe(&#39;event&#39;, data =&gt; &#123;
      this.data = data
    &#125;)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="WebSocket-高级"><a href="#WebSocket-高级" class="headerlink" title="WebSocket (高级)"></a>WebSocket (高级)</h2><p>使用WebSocket协议实现实时通信，将所有组件连接到同一个WebSocket服务器，通过推送消息实现通信。</p>
<p>连接WebSocket服务器：</p>
<pre><code>const ws = new WebSocket(&#39;ws://localhost:3000&#39;)
 
ws.onopen = function () &#123;
  console.log(&#39;WebSocket已连接&#39;)
&#125;
 
ws.onclose = function () &#123;
  console.log(&#39;WebSocket已关闭&#39;)
&#125;
 
ws.onerror = function () &#123;
  console.log(&#39;WebSocket出错&#39;)
&#125;
</code></pre>
<p>组件A：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;向组件B传递数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
const ws = new WebSocket(&#39;ws://localhost:3000&#39;)
 
export default &#123;
  methods: &#123;
    handleClick () &#123;
      ws.send(&#39;组件A传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>组件B：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件B接收到的数据：&#123;&#123; data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
const ws = new WebSocket(&#39;ws://localhost:3000&#39;)
 
export default &#123;
  data () &#123;
    return &#123;
      data: &#39;&#39;
    &#125;
  &#125;,
  mounted () &#123;
    ws.onmessage = event =&gt; &#123;
      this.data = event.data
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="路由参数（高级）"><a href="#路由参数（高级）" class="headerlink" title="路由参数（高级）"></a>路由参数（高级）</h2><p>使用路由参数来传递数据，通常适用于父子组件之间或兄弟组件之间的通信。</p>
<p>父组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    点击以下链接可以传递数据：&lt;br&gt;
    &lt;router-link :to=&quot;&#123; name: &#39;child&#39;, params: &#123; data: &#39;父组件传递的数据&#39; &#125; &#125;&quot;&gt;传递数据到子组件&lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    子组件接收到的数据：&#123;&#123; $route.params.data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  mounted () &#123;
    console.log(&#39;子组件接收到的数据：&#39; + this.$route.params.data)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>兄弟组件：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    兄弟组件接收到的数据：&#123;&#123; $route.params.data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  mounted () &#123;
    console.log(&#39;兄弟组件接收到的数据：&#39; + this.$route.params.data)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="Vuex状态管理（高级）"><a href="#Vuex状态管理（高级）" class="headerlink" title="Vuex状态管理（高级）"></a>Vuex状态管理（高级）</h2><p>使用Vuex管理公共状态，组件通过Vuex进行通信。</p>
<p>store.js：</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
 
Vue.use(Vuex)
 
export default new Vuex.Store(&#123;
  state: &#123;
    data: &#39;共享的数据&#39;
  &#125;,
  mutations: &#123;
    setData (state, data) &#123;
      state.data = data
    &#125;
  &#125;
&#125;)
</code></pre>
<p>组件A：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;向组件B传递数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import store from &#39;./store&#39;
 
export default &#123;
  methods: &#123;
    handleClick () &#123;
      store.commit(&#39;setData&#39;, &#39;组件A传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>组件B：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件B接收到的数据：&#123;&#123; data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; mapState &#125; from &#39;vuex&#39;
 
export default &#123;
  computed: &#123;
    ...mapState([&#39;data&#39;])
  &#125;,
  mounted () &#123;
    console.log(&#39;组件B接收到的数据：&#39; + this.data)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="事件总线（高级）"><a href="#事件总线（高级）" class="headerlink" title="事件总线（高级）"></a>事件总线（高级）</h2><p>使用一个空的Vue实例作为事件总线，组件A通过事件总线向组件B传递数据。</p>
<p>事件总线：</p>
<pre><code>// EventBus.js
import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>组件A：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;向组件B传递数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; EventBus &#125; from &#39;./EventBus&#39;
 
export default &#123;
  methods: &#123;
    handleClick () &#123;
      EventBus.$emit(&#39;event&#39;, &#39;组件A传递的数据&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>组件B：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    组件B接收到的数据：&#123;&#123; data &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import &#123; EventBus &#125; from &#39;./EventBus&#39;
 
export default &#123;
  data () &#123;
    return &#123;
      data: &#39;&#39;
    &#125;
  &#125;,
  mounted () &#123;
    EventBus.$on(&#39;event&#39;, data =&gt; &#123;
      this.data = data
    &#125;)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「慕白Lee」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/libusi001/article/details/131668644">https://blog.csdn.net/libusi001/article/details/131668644</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件间数据同步刷新解决方案--全局事件总线</title>
    <url>/2023/09/14/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%88%B7%E6%96%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88--%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Vue工程很多时候需要我们保持数据的一致性。举个例子，我在一个组件A的事件中请求后端接口修改了某个数据，并且后端接口响应我修改成功了。这时候界面上另外一个组件B也在展示该数据，这时候就需要使得这个B组件也进行显示数据的刷新，否则A组件与B组件的数据就不同步，很容易被测试提bug。</p>
<p>如果A组件与B组件是父子关系的话，那么只需要利用父子组件之间的通讯即可完成数据的同步。但是如果这两个组件之间没有任何关系，那么如何进行跨组件之间的数据同步呢？</p>
<h1 id="方法一：Vuex状态管理，配合组件计算属性使用"><a href="#方法一：Vuex状态管理，配合组件计算属性使用" class="headerlink" title="方法一：Vuex状态管理，配合组件计算属性使用"></a>方法一：Vuex状态管理，配合组件计算属性使用</h1><p>简要介绍一下步骤思路：</p>
<p>1、将项目中很多地方都需要用到的数据提取到Vuex的state中；并用getters方法返回该值； </p>
<p>2、在组件中使用计算属性返回Vuex的getters获取数据；</p>
<p>3、组件中通过watch监听计算属性值的变化，一旦有变化，则重新赋值；</p>
<p>4、通过Vuex中的mutations方法修改state中数据值；</p>
<p>上诉步骤即可实现在任一组件中修改数据触发其他组件实时刷新的效果。但是实现过程较为繁琐。</p>
<h1 id="方法二：全局事件总线"><a href="#方法二：全局事件总线" class="headerlink" title="方法二：全局事件总线"></a>方法二：全局事件总线</h1><p>全局事件总线是解决前端数据同步问题的一种架构思维，或者说是一种重要的编程“模式”，因为他不局限于任何一种前端框架，无论是Vue，React还是Flutter，甚至游戏编程。它都经常出现并应用。只需要学会这一套路，并通过语法变通举一反三，那么你就能轻松在各种框架上使用并解决一些列问题。而我们这里就只以Vue为例说明一下具体实现。</p>
<p>全局事件总线运用编程中两大模式：单例模式，观察者模式。</p>
<p>1、首先在任一位置新建总线类，并且该类为单例，有且只能有一个实例；以下是简单实现</p>
<pre><code>class eventbus&#123;
    constructor() &#123;
        if (!eventbus.Instance) &#123;
            //内存中存储所有事件的处理函数
            this.eventMap = &#123;&#125;;
            eventbus.Instance = this;
        &#125;
        return eventbus.Instance
    &#125;
    /**
     * 注册事件      
     * key         事件名
     * page        组件(页面)名
     * callback    注册的事件
     */
    on(key,page,callback)&#123;
        //将函数通过事件名key，页面(组件)名的形式进行注册
        this.eventMap[key] = this.eventMap[key] || &#123;&#125;;
        this.eventMap[key][page] = callback;
    &#125;
    /**
     * 事件通知      
     * key         事件名
     * data        通知的数据
     * page        组件(页面)名
     */
    emit(key,data,page=null)&#123;
        if(key &amp;&amp; this.eventMap[key])&#123;
            if(page)&#123;
                //如果参数中有页面名(组件名)，则将data通知单个页面(组件)注册的函数进行处理
                this.eventMap[key][page] &amp;&amp; this.eventMap[key][page](data);
            &#125;else&#123;
                //通知该事件名下的所有页面(组件)注册的函数进行处理
                for(let sub in this.eventMap[key]) &#123; 
                    this.eventMap[key][sub](data);
                &#125;
            &#125;
        &#125;else&#123;
            //该事件名下没有注册任何函数
        &#125;
    &#125;,
    /**
     * 事件销毁，一般在页面(组件销毁时同步销毁)      
     * key         事件名
     * page        组件(页面)名
     */
    destroy(key,page)&#123;
        if(this.eventMap[key] &amp;&amp; this.eventMap[key][page])&#123;
            //删除单个页面事件
            delete this.eventMap[key][page];
        &#125;
        if(this.eventMap[key] == &#123;&#125;)&#123;
            delete this.eventMap[key];
        &#125;
    &#125;,
    /**
     * 事件销毁，销毁全部     
     * key         事件名
     * page        组件(页面)名
     */
    destroyAll(key)&#123;
        if(this.eventMap[key] == &#123;&#125;)&#123;
            //删除所有
            delete this.eventMap[key];
        &#125;
    &#125;
&#125;
export default new eventbus()
</code></pre>
<p>2、在A组件中注册监听事件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;&#123;&#123;user&#125;&#125;&lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
//引入全局总线类
import event from &quot;@/Eventbus.js&quot;;
export default &#123;
   name: &quot;ComA&quot;,
   data () &#123;
      return &#123;
        user:&quot;我是A&quot;
      &#125;;
    &#125;,
    created() &#123;
        //注册监听事件,事件名：changeUser,组件名:ComA
        event.on(&quot;changeUser&quot;,&quot;ComA&quot;,(data)=&gt;&#123;
            if(data)&#123;
                this.user = data;
            &#125;
        &#125;)
    &#125;,
    destroyed() &#123;
        //销毁事件
        event.destroyed(&quot;changeUser&quot;,&quot;ComA&quot;);
    &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>3、B组件发送监听，使A组件变量一起刷新</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;&#123;&#123;user&#125;&#125;&lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
//引入全局总线类
import event from &quot;@/Eventbus.js&quot;;
export default &#123;
   name: &quot;ComB&quot;,
   data () &#123;
      return &#123;
        user:&quot;我是B&quot;
      &#125;;
    &#125;,
    methods: &#123;
        updateUser()&#123;
            let data = &quot;改成C&quot;;
            this.user = data;
            //通知所有组件(页面)刷新
            event.emit(&quot;changeUser&quot;,data);
            //只通知组件A刷新
            event.emit(&quot;changeUser&quot;,data,&quot;ComA&quot;)
        &#125;
    &#125; 
&#125;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「Ajucy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Ajucy/article/details/130194549">https://blog.csdn.net/Ajucy/article/details/130194549</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据更新页面却没有更新的几种情况以及解决方法</title>
    <url>/2023/09/13/Vue%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%8D%B4%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="情况一：Vue无法检测实例被创建时不存在于data中的变量"><a href="#情况一：Vue无法检测实例被创建时不存在于data中的变量" class="headerlink" title="情况一：Vue无法检测实例被创建时不存在于data中的变量"></a>情况一：Vue无法检测实例被创建时不存在于data中的变量</h1><p>原因：由于 Vue 会在初始化实例时对 data中的数据执行 getter/setter 转化，所以 变量必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>例如： </p>
<pre><code>new Vue(&#123;
  data:&#123;&#125;,
  template: &#39;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&#39;
&#125;)
this.message = &#39;Hello world!&#39; // `message` 不是响应式的页面不会发生变化
</code></pre>
<p>解决方法：</p>
<pre><code>new Vue(&#123;
  data: &#123;
    message: &#39;&#39;,
  &#125;,
  template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#39;
&#125;)
this.message = &#39;Hello world!&#39;
</code></pre>
<h1 id="情况二：vue也不能检测到data中对象的动态添加和删除"><a href="#情况二：vue也不能检测到data中对象的动态添加和删除" class="headerlink" title="情况二：vue也不能检测到data中对象的动态添加和删除"></a>情况二：vue也不能检测到data中对象的动态添加和删除</h1><p>例如：</p>
<pre><code>new Vue(&#123;
  data:&#123;
    obj: &#123;
      id: 1
    &#125;
  &#125;,
  template: &#39;&lt;div&gt;&#123;&#123; obj.message &#125;&#125;&lt;/div&gt;&#39;
&#125;)
this.obj.message = &#39;hello&#39; // 不是响应式的
delete this.obj.id       // 不是响应式的
</code></pre>
<p>解决方法：</p>
<pre><code>// 动态添加 - Vue.set
Vue.set(this.obj, &#39;id&#39;, 002)
  
// 动态添加 - this.$set
this.$set(this.obj, &#39;id&#39;, 002)
  
// 动态添加多个
// 代替 Object.assign(this.obj, &#123; a: 1, b: 2 &#125;)
this.obj = Object.assign(&#123;&#125;, this.obj, &#123; a: 1, b: 2 &#125;)
  
// 动态移除 - Vue.delete
Vue.delete(this.obj, &#39;name&#39;)
  
// 动态移除 - this.$delete
this.$delete(this.obj, &#39;name&#39;)
</code></pre>
<h1 id="情况三：变量为数组时"><a href="#情况三：变量为数组时" class="headerlink" title="情况三：变量为数组时"></a>情况三：变量为数组时</h1><p>不能通过索引直接修改或者赋值，也不能修改数组的长度</p>
<p>例如：</p>
<pre><code>new Vue(&#123;
  data: &#123;
    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
  &#125;
&#125;)
this.items[1] = &#39;x&#39; // 不是响应性的
this.items[3] = &#39;d&#39; // 不是响应性的
this.items.length = 2 // 不是响应性的
</code></pre>
<p>解决方法：</p>
<pre><code>// Vue.set
Vue.set(this.items, 4, &#39;d&#39;)
  
// this.$set
this.$set(this.items, 4, &#39;d)
  
// Array.prototype.splice
this.items.splice(indexOfItem, 4, &#39;d&#39;)
//修改长度
this.items.splice(3)
</code></pre>
<h1 id="情况四：异步获取接口数据，DOM数据不发现变化"><a href="#情况四：异步获取接口数据，DOM数据不发现变化" class="headerlink" title="情况四：异步获取接口数据，DOM数据不发现变化"></a>情况四：异步获取接口数据，DOM数据不发现变化</h1><p>原因：Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(funcation, 0) 代替。</p>
<p>例如：</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;
var vm = new Vue(&#123;
  el: &#39;#example&#39;,
  data: &#123;
    message: &#39;123&#39;
  &#125;
&#125;)
vm.message = &#39;new message&#39; // 更改数据
vm.$el.textContent === &#39;new message&#39; // false
vm.$el.style.color = &#39;red&#39; // 页面没有变化
</code></pre>
<p>解决方法：</p>
<pre><code>var vm = new Vue(&#123;
  el: &#39;#example&#39;,
  data: &#123;
    message: &#39;123&#39;
  &#125;
&#125;)
vm.message = &#39;new message&#39; // 更改数据
//使用 Vue.nextTick(callback) callback 将在 DOM 更新完成后被调用
Vue.nextTick(function () &#123;
  vm.$el.textContent === &#39;new message&#39; // true
  vm.$el.style.color = &#39;red&#39; // 文字颜色变成红色
&#125;)
</code></pre>
<h1 id="情况五：循环嵌套层级太深，视图不更新"><a href="#情况五：循环嵌套层级太深，视图不更新" class="headerlink" title="情况五：循环嵌套层级太深，视图不更新"></a>情况五：循环嵌套层级太深，视图不更新</h1><p>当嵌套太深时，页面也可能不更新，此时可以让页面强制刷新</p>
<p>this.$forceUpdate()迫使vue实例重新（rander）渲染虚拟DOM，注意并不是重新加载组件。<br>结合vue的生命周期，调用$forceUpdate后只会触发beforeUpdate和updated这两个钩子函数，不会触发其他的钩子函数。<br>它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<pre><code>//官方说如果你现在的场景需要用forceUpdate方法 ,那么99%是你的操作有问题
this.$forceUpdate();
</code></pre>
<h1 id="情况六：路由参数变化时，页面不更新-数据不更新"><a href="#情况六：路由参数变化时，页面不更新-数据不更新" class="headerlink" title="情况六：路由参数变化时，页面不更新(数据不更新)"></a>情况六：路由参数变化时，页面不更新(数据不更新)</h1><p>例如：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;router-link to=&quot;/home/foo&quot;&gt;To Foo&lt;/router-link&gt;&lt;/li&gt;    
    &lt;li&gt;&lt;router-link to=&quot;/home/baz&quot;&gt;To Baz&lt;/router-link&gt;&lt;/li&gt;    
    &lt;li&gt;&lt;router-link to=&quot;/home/bar&quot;&gt;To Bar&lt;/router-link&gt;&lt;/li&gt;    
  &lt;/ul&gt;    
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;

const Home = &#123;
  template: `&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;`,
  data() &#123;
    return &#123;
      message: this.$route.params.name
    &#125;
  &#125;
&#125;
  
const router = new VueRouter(&#123;
  mode:&#39;history&#39;,
    routes: [
    &#123;path: &#39;/home&#39;, component: Home &#125;,
    &#123;path: &#39;/home/:name&#39;, component: Home &#125;
  ]
&#125;)
  
new Vue(&#123;
  el: &#39;#app&#39;,
  router
&#125;)
</code></pre>
<p>上段代码中，我们在路由构建选项 routes 中配置了一个动态路由 ‘/home/:name’，它们共用一个路由组件 Home，这代表他们复用 RouterView 。</p>
<p>当进行路由切换时，页面只会渲染第一次路由匹配到的参数，之后再进行路由切换时，message 是没有变化的。</p>
<p>解决方法：</p>
<ul>
<li><p>1.通过 watch 监听 $route 的变化。</p>
<p>  const Home = {</p>
<pre><code>template: `&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;`,
data() &#123;
  return &#123;
    message: this.$route.params.name
  &#125;
&#125;,
watch:&#123;
   &#39;$route&#39;:function()&#123;
      this.message = this.$route.params.name
   &#125;
&#125;
</code></pre>
<p>  }<br>  …<br>  new Vue({</p>
<pre><code>el: &#39;#app&#39;,
router
</code></pre>
<p>  })</p>
</li>
<li><p>2.给<router-view> 绑定key属性，这样 Vue 就会认为这是不同的 <router-view>。</router-view></router-view></p>
</li>
</ul>
<p>弊端：如果从 /home 跳转到 /user 等其他路由下，我们是不用担心组件更新问题的，所以这个时候 key 属性是多余的。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
   &lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre>
<h1 id="情况七：变量通过赋值来定义的"><a href="#情况七：变量通过赋值来定义的" class="headerlink" title="情况七：变量通过赋值来定义的"></a>情况七：变量通过赋值来定义的</h1><p>在 Vue 中有两种类型的变量：响应式变量和非响应式变量。</p>
<p>从后端获取的变量通常是响应式变量，也就是说它们会被 Vue 监测到变化并同步到页面上，如果你修改了这些响应式变量，页面会随之改变。</p>
<p>而通过赋值来定义的变量通常是非响应式变量，如果你修改了这些非响应式变量，Vue 并不会监测到它们的变化，所以页面不会改变。</p>
<p>如果你需要使一个非响应式变量变成响应式变量，可以使用 Vue.set 方法或者数组的变异方法（例如 push、splice 等）。</p>
<p>例1：Vue.set(对象,添加的key,属性值”)</p>
<pre><code>Vue.set
//这个是直接用在Vue身上的。例如: Vue.set(对象,添加的key,属性值”)
//常见于: xx.js文件中
//注意: js文件中，需要引入vue，比如: import Vue from vue
</code></pre>
<p>例2：this.$set(对象,添加的key’,属性值)</p>
<pre><code>this.$set
//这个是用在vm或者vc实例身上的，比如vue文件中，this.$set(对象,添加的key&#39;,属性值)
//常见于: xx.vue文件中
强制更新数据：this.$forceUpdate();
</code></pre>
<p><a href="https://www.jb51.net/javascript/286151v3n.htm">https://www.jb51.net/javascript/286151v3n.htm</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 组件通信、组件间传值的几种方式</title>
    <url>/2023/09/12/Vue2%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E3%80%81%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-文件间的关系"><a href="#1-文件间的关系" class="headerlink" title="1. 文件间的关系"></a>1. 文件间的关系</h1><p>App 为根组件<br>Father 与 Brother 为兄弟组件，也同为 App 的子组件<br>Child 是 Father 的子组件，也是 App 的孙组件</p>
<h1 id="2-父子之间传值"><a href="#2-父子之间传值" class="headerlink" title="2. 父子之间传值"></a>2. 父子之间传值</h1><h2 id="2-1-props，父传子"><a href="#2-1-props，父传子" class="headerlink" title="2.1 props，父传子"></a>2.1 props，父传子</h2><p>Father.vue 文件</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;Child :cMsg=&quot;msg&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Child from &quot;./Child.vue&quot;;

export default &#123;
  name: &quot;Father&quot;,
  components: &#123;
    Child,
  &#125;,
  data() &#123;
    return &#123;
      msg: &quot;我是 Father 组件中的数据&quot;,
    &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Child.vue 文件</p>
<pre><code>// Child.vue 文件
&lt;template&gt;
  &lt;div id=&quot;child&quot;&gt;
    &lt;span&gt; 我是 Child 组件，接收到的数据为：&#123;&#123; cMsg &#125;&#125; &lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Child&quot;,
  props: &#123;
    cMsg: String,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h2 id="2-2-props，子传父"><a href="#2-2-props，子传父" class="headerlink" title="2.2 props，子传父"></a>2.2 props，子传父</h2><p>Father.vue 文件</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;Child :cHander=&quot;fHander&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Child from &quot;./Child.vue&quot;;

export default &#123;
  name: &quot;Father&quot;,
  components: &#123;
    Child,
  &#125;,
  methods: &#123;
    fHander(msg) &#123;
      console.log(msg);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Child.vue 文件</p>
<pre><code>// Child.vue 文件
&lt;template&gt;
  &lt;div id=&quot;child&quot;&gt;
    &lt;button @click=&quot;btn&quot;&gt;点击我向 Father 组件传入数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Child&quot;,
  props: &#123;
    cHander: Function,
  &#125;,
  methods: &#123;
    btn() &#123;
      this.cHander(&quot;666666&quot;);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h2 id="2-3-自定义事件，子传父"><a href="#2-3-自定义事件，子传父" class="headerlink" title="2.3 自定义事件，子传父"></a>2.3 自定义事件，子传父</h2><p>Father.vue 文件</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;Child ref=&quot;child&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Child from &quot;./Child.vue&quot;;

export default &#123;
  name: &quot;Father&quot;,
  components: &#123;
    Child,
  &#125;,
  mounted() &#123;
    this.$refs.child.$on(&quot;change&quot;, (msg) =&gt; &#123;
      console.log(msg);
    &#125;);
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Child.vue 文件</p>
<pre><code>// Child.vue 文件
&lt;template&gt;
  &lt;div id=&quot;child&quot;&gt;
    &lt;button @click=&quot;btn&quot;&gt;点击我向 Father 组件传入数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Child&quot;,
  methods: &#123;
    btn() &#123;
      this.$emit(&quot;change&quot;, 666666);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h1 id="3-兄弟之间传值"><a href="#3-兄弟之间传值" class="headerlink" title="3. 兄弟之间传值"></a>3. 兄弟之间传值</h1><h2 id="3-1-事件总线"><a href="#3-1-事件总线" class="headerlink" title="3.1 事件总线"></a>3.1 事件总线</h2><p>main.js 文件</p>
<pre><code>// main.js 文件
import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;

Vue.config.productionTip = false

new Vue(&#123;
  render: h =&gt; h(App),
  beforeCreate() &#123;
    // 需要在全局添加一个属性
    Vue.prototype.$bus = this
  &#125;
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>Father.vue 文件</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;button @click=&quot;btn&quot;&gt;我要给 Brother 组件传数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Father&quot;,
  methods: &#123;
    btn() &#123;
      this.$bus.$emit(&quot;change&quot;, 66666);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Brother.vue 文件</p>
<pre><code>// Brother.vue 文件
&lt;template&gt;
  &lt;div id=&quot;brother&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Brother&quot;,
  mounted() &#123;
    this.$bus.$on(&quot;change&quot;, (msg) =&gt; &#123;
      console.log(msg);
    &#125;);
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h2 id="3-2-Vuex"><a href="#3-2-Vuex" class="headerlink" title="3.2 Vuex"></a>3.2 Vuex</h2><p>store/index.js 文件</p>
<pre><code>// store/index.js 文件
import Vue from &quot;vue&quot;
import Vuex from &quot;vuex&quot;
Vue.use(Vuex)

export default new Vuex.Store(&#123;
  state: &#123;
    count: 1
  &#125;,
  mutations: &#123;
    change(state, value) &#123;
      state.count += value
    &#125;
  &#125;
&#125;)
</code></pre>
<p>main.js 文件</p>
<pre><code>// main.js 文件
import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import store from &quot;./store/index&quot;

Vue.config.productionTip = false

new Vue(&#123;
  render: h =&gt; h(App),
  // 需要挂载 store
  store
&#125;).$mount(&#39;#app&#39;)

// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;button @click=&quot;btn&quot;&gt;我要给 VueX 中的数据加一&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Father&quot;,
  methods: &#123;
    btn() &#123;
      this.$store.commit(&quot;change&quot;, 1);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Brother.vue 文件</p>
<pre><code>// Brother.vue 文件
&lt;template&gt;
  &lt;div id=&quot;brother&quot;&gt;
    &#123;&#123; $store.state.count &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Brother&quot;,
&#125;;
&lt;/script&gt;
</code></pre>
<h2 id="3-3-发布订阅"><a href="#3-3-发布订阅" class="headerlink" title="3.3 发布订阅"></a>3.3 发布订阅</h2><p>需要安装 pubsub：npm i pubsub-js</p>
<p>Father.vue</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;button @click=&quot;btn&quot;&gt;我要向 Brother 组件传递数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import pubsub from &quot;pubsub-js&quot;;

export default &#123;
  name: &quot;Father&quot;,
  methods: &#123;
    btn() &#123;
      pubsub.publish(&quot;change&quot;, 666);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Brother.vue 文件</p>
<pre><code>// Brother.vue 文件
&lt;template&gt;
  &lt;div id=&quot;brother&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import pubsub from &quot;pubsub-js&quot;;

export default &#123;
  name: &quot;Brother&quot;,
  mounted() &#123;
    pubsub.subscribe(&quot;change&quot;, (msgName, msg) =&gt; &#123;
      console.log(msgName, msg);
    &#125;);
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h1 id="4-祖孙之间传值"><a href="#4-祖孙之间传值" class="headerlink" title="4. 祖孙之间传值"></a>4. 祖孙之间传值</h1><h2 id="4-1-provide与inject"><a href="#4-1-provide与inject" class="headerlink" title="4.1 provide与inject"></a>4.1 provide与inject</h2><p>App.vue 文件</p>
<pre><code>// App.vue 文件
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;Father /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Father from &quot;./components/Father.vue&quot;;

export default &#123;
  name: &quot;App&quot;,
  components: &#123;
    Father,
  &#125;,
  provide: &#123;
    msg: &quot;要给 Child 传数据&quot;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Father.vue 文件</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;Child /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Child from &quot;./Child.vue&quot;;

export default &#123;
  name: &quot;Father&quot;,
  components: &#123;
    Child,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Child.vue 文件</p>
<pre><code>// Child.vue 文件
&lt;template&gt;
  &lt;div id=&quot;child&quot;&gt;
    &#123;&#123; msg &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Child&quot;,
  inject: [&quot;msg&quot;],
&#125;;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「codeCat!」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_60547084/article/details/124408513">https://blog.csdn.net/weixin_60547084/article/details/124408513</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解11-promise传参</title>
    <url>/2023/09/11/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A311/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>promise 中 resolve 如何传递多个参数</p>
<pre><code>//类似与这样使用，但实际上后面两个参数无法获取
promise = new Promise((resolve,reject)=&gt;&#123;
    let a = 1
    let b = 2
    let c = 3
    resolve(a,b,c) 
&#125;)
promise.then((a,b,c)=&gt;&#123;
    console.log(a,b,c)
&#125;)
</code></pre>
<p>resolve() 只能接受并处理一个参数，多余的参数会被忽略掉。<br>如果想多个用数组，或者对象方式。。</p>
<p>数组</p>
<pre><code>promise = new Promise((resolve,reject)=&gt;&#123;
    resolve([1,2,3]) 
&#125;)
promise.then((arr)=&gt;&#123;
    console.log(arr[0],arr[1],arr[2])
&#125;)
</code></pre>
<p>对象</p>
<pre><code>promise = new Promise((resolve,reject)=&gt;&#123;
    resolve(&#123;a:1,b:2,c:3&#125;) 
&#125;)
promise.then(obj=&gt;&#123;
    console.log(obj.a,obj.b,obj.c)
&#125;)
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解10-孙传祖使用$listeners</title>
    <url>/2023/09/10/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A310/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>孙传祖使用$listeners<br>文字内容同第九个</p>
<p>祖组件</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;children-one @eventOne=&quot;eventOne&quot;&gt;&lt;/children-one&gt;
    &#123;&#123; msg &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import ChildrenOne from &#39;../src/components/children.vue&#39;
export default &#123;
  name: &#39;App&#39;,
  components: &#123;
    ChildrenOne,
  &#125;,
  data() &#123;
    return &#123;
      msg: &#39;&#39;
    &#125;
  &#125;,
  methods: &#123;
    eventOne(value) &#123;
      this.msg = value
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>父组件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;children-two v-on=&quot;$listeners&quot;&gt;&lt;/children-two&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import ChildrenTwo from &#39;./childrenTwo.vue&#39;
 
export default &#123;
  name: &#39;childrenOne&#39;,
  components: &#123;
    ChildrenTwo
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;setMsg&quot;&gt;点击传给祖父&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  name: &#39;children&#39;,
  methods: &#123;
    setMsg() &#123;
      this.$emit(&#39;eventOne&#39;, &#39;123&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解09-祖传孙 $attrs</title>
    <url>/2023/09/09/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A309/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>祖传孙 $attrs</p>
<p>正常情况下需要借助父亲的props作为中间过渡，但是这样在父亲组件就会多了一些跟父组件业务无关的属性，耦合度高，借助$attrs可以简化些，而且祖跟孙都无需做修改</p>
<p>祖组件：</p>
<pre><code>&lt;template&gt;
    &lt;section&gt;
        &lt;parent name=&quot;grandParent&quot; sex=&quot;男&quot; age=&quot;88&quot; hobby=&quot;code&quot; @sayKnow=&quot;sayKnow&quot;&gt;&lt;/parent&gt;
    &lt;/section&gt;
&lt;/template&gt;
 
&lt;script&gt;
    import Parent from &#39;./Parent&#39;
    export default &#123;
        name: &quot;GrandParent&quot;,
        components: &#123;
          Parent
        &#125;,
        data() &#123;
            return &#123;&#125;
        &#125;,
        methods: &#123;
          sayKnow(val)&#123;
            console.log(val)
          &#125;
        &#125;,
        mounted() &#123;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
<p>父组件</p>
<pre><code>&lt;template&gt;
  &lt;section&gt;
    &lt;p&gt;父组件收到&lt;/p&gt;
    &lt;p&gt;祖父的名字：&#123;&#123;name&#125;&#125;&lt;/p&gt;
    &lt;children v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/children&gt;
  &lt;/section&gt;
&lt;/template&gt;
 
&lt;script&gt;
  import Children from &#39;./Children&#39;
 
  export default &#123;
    name: &quot;Parent&quot;,
    components: &#123;
      Children
    &#125;,
    // 父组件接收了name,所以name值是不会传到子组件的
    props:[&#39;name&#39;],
    data() &#123;
      return &#123;&#125;
    &#125;,
    methods: &#123;&#125;,
    mounted() &#123;
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code>&lt;template&gt;
  &lt;section&gt;
    &lt;p&gt;子组件收到&lt;/p&gt;
    &lt;p&gt;祖父的名字：&#123;&#123;name&#125;&#125;&lt;/p&gt;
    &lt;p&gt;祖父的性别：&#123;&#123;sex&#125;&#125;&lt;/p&gt;
    &lt;p&gt;祖父的年龄：&#123;&#123;age&#125;&#125;&lt;/p&gt;
    &lt;p&gt;祖父的爱好：&#123;&#123;hobby&#125;&#125;&lt;/p&gt;
 
    &lt;button @click=&quot;sayKnow&quot;&gt;我知道啦&lt;/button&gt;
  &lt;/section&gt;
&lt;/template&gt;
 
&lt;script&gt;
  export default &#123;
    name: &quot;Children&quot;,
    components: &#123;&#125;,
    // 由于父组件已经接收了name属性，所以name不会传到子组件了
    props:[&#39;sex&#39;,&#39;age&#39;,&#39;hobby&#39;,&#39;name&#39;],
    data() &#123;
      return &#123;&#125;
    &#125;,
    methods: &#123;
      sayKnow()&#123;
        this.$emit(&#39;sayKnow&#39;,&#39;我知道啦&#39;)
      &#125;
    &#125;,
    mounted() &#123;
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解08-路由传值</title>
    <url>/2023/09/08/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A308/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>路由传值</p>
<p>*使用问号传值</p>
<p>A页面跳转B页面时使用 this.r o u t e r . p u s h ( ’ / B ? n a m e = d a n s e e k ’ ) B 页面可以使用 t h i s . router.push(’/B?name=danseek’) B页面可以使用 this.router.push(’/B?name=danseek’)B页面可以使用this.route.query.name 来获取A页面传过来的值<br>上面要注意router和route的区别</p>
<p>*使用冒号传值</p>
<p>配置如下路由：</p>
<pre><code>&#123;
    path: &#39;/b/:name&#39;,
    name: &#39;b&#39;,
    component: () =&gt; import( &#39;../views/B.vue&#39;)
&#125;,
</code></pre>
<p>在B页面可以通过 this.$route.params.name 来获取路由传入的name的值</p>
<p>*使用父子组件传值</p>
<p>由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch</p>
<pre><code>&lt;router-view :type=&quot;type&quot;&gt;&lt;/router-view&gt;
 
// 子页面
props: [&#39;type&#39;]
watch: &#123;
       type()&#123;
           // console.log(&quot;在这个方法可以时刻获取最新的数据:type=&quot;,this.type)
       &#125;,
&#125;,
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解07-sessionStorage传值</title>
    <url>/2023/09/07/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A307/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>sessionStorage 是浏览器的全局对象，存在它里面的数据会在页面关闭时清除 。运用这个特性，我们可以在所有页面共享一份数据。<br>代码示例：</p>
<pre><code>// 保存数据到 sessionStorage
sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;);
 
// 从 sessionStorage 获取数据
let data = sessionStorage.getItem(&#39;key&#39;);
 
// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem(&#39;key&#39;);
 
// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();
</code></pre>
<p>注意：里面存的是键值对，只能是字符串类型，如果要存对象的话，需要使用 let objStr = JSON.stringify(obj) 转成字符串然后再存储（使用的时候 let obj = JSON.parse(objStr) 解析为对象）。<br>推荐一个库 good-storage ，它封装了sessionStorage ，可以直接用它的API存对象</p>
<pre><code>//localStorage
 storage.set(key,val) 
 storage.get(key, def)
//sessionStorage
 storage.session.set(key, val)
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解06-$parent</title>
    <url>/2023/09/06/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A306/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过parent可以获父组件实例 ，然 后通过这个实例就可以访问父组件的属 性和方法 ，它还有一个兄弟parent可以获父组件实例，然后通过这个实例就可以访问父组件的属性和方法，它还有一个兄弟parent可以获父组件实例，然后通过这个实例就可以访问父组件的属性和方法，它还有一个兄弟root，可以获取根组件实例。</p>
<p>代码示例：</p>
<pre><code>// 获父组件的数据
this.$parent.foo
 
// 写入父组件的数据
this.$parent.foo = 2
 
// 访问父组件的计算属性
this.$parent.bar
 
// 调用父组件的方法
this.$parent.baz()
 
//在子组件传给父组件例子中，可以使用this.$parent.getNum(100)传值给父组件。
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解05-Vuex通信</title>
    <url>/2023/09/05/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A305/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>组件通过 dispatch 到 actions，actions 是异步操作，再 actions中通过 commit 到 mutations，mutations 再通过逻辑操作改变 state，从而同步到组件，更新其数据状态</p>
<p>代码示例：</p>
<p>父组件</p>
<pre><code>//父组件
template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ChildA/&gt;
    &lt;ChildB/&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import ChildA from &#39;./ChildA&#39; // 导入A组件
  import ChildB from &#39;./ChildB&#39; // 导入B组件
  export default &#123;
    components: &#123;ChildA, ChildB&#125; // 注册组件
  &#125;
&lt;/script&gt;
</code></pre>
<p>子组件A</p>
<pre><code>//子组件A
&lt;template&gt;
 &lt;div id=&quot;childA&quot;&gt;
   &lt;h1&gt;我是A组件&lt;/h1&gt;
   &lt;button @click=&quot;transform&quot;&gt;点我让B组件接收到数据&lt;/button&gt;
   &lt;p&gt;因为点了B，所以信息发生了变化：&#123;&#123;BMessage&#125;&#125;&lt;/p&gt;
 &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
 export default &#123;
   data() &#123;
     return &#123;
       AMessage: &#39;Hello，B组件，我是A组件&#39;
     &#125;
   &#125;,
   computed: &#123;
     BMessage() &#123;
       // 这里存储从store里获取的B组件的数据
       return this.$store.state.BMsg
     &#125;
   &#125;,
   methods: &#123;
     transform() &#123;
       // 触发receiveAMsg，将A组件的数据存放到store里去
       this.$store.commit(&#39;receiveAMsg&#39;, &#123;
         AMsg: this.AMessage
       &#125;)
     &#125;
   &#125;
 &#125;
&lt;/script&gt;
</code></pre>
<p>子组件B</p>
<pre><code>//子组件B
&lt;template&gt;
 &lt;div id=&quot;childB&quot;&gt;
   &lt;h1&gt;我是B组件&lt;/h1&gt;
   &lt;button @click=&quot;transform&quot;&gt;点我让A组件接收到数据&lt;/button&gt;
   &lt;p&gt;点了A，我的信息发生了变化：&#123;&#123;AMessage&#125;&#125;&lt;/p&gt;
 &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
 export default &#123;
   data() &#123;
     return &#123;
       BMessage: &#39;Hello，A组件，我是B组件&#39;
     &#125;
   &#125;,
   computed: &#123;
     AMessage() &#123;
       // 这里存储从store里获取的A组件的数据
       return this.$store.state.AMsg
     &#125;
   &#125;,
   methods: &#123;
     transform() &#123;
       // 触发receiveBMsg，将B组件的数据存放到store里去
       this.$store.commit(&#39;receiveBMsg&#39;, &#123;
         BMsg: this.BMessage
       &#125;)
     &#125;
   &#125;
 &#125;
&lt;/script&gt;
</code></pre>
<p>vuex</p>
<pre><code>//vuex
import Vue from &#39;vue&#39;
 import Vuex from &#39;vuex&#39;
 Vue.use(Vuex)
 const state = &#123;
   AMsg: &#39;&#39;,
   BMsg: &#39;&#39;
 &#125;
 
 const mutations = &#123;
   receiveAMsg(state, payload) &#123;
     // 将A组件的数据存放于state
     state.AMsg = payload.AMsg
   &#125;,
   receiveBMsg(state, payload) &#123;
     // 将B组件的数据存放于state
     state.BMsg = payload.BMsg
   &#125;
 &#125;
 
 export default new Vuex.Store(&#123;
   state,
   mutations
 &#125;)
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解04-ref/refs（父子组件通信）</title>
    <url>/2023/09/04/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A304/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（1）ref 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，<br>（2）可以通过实例直接调用组件的方法或访问数据。也算是子组件向父组件传值的一种</p>
<p>代码示例：</p>
<p>父组件</p>
<pre><code>//父组件
&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;sayHello&quot;&gt;sayHello&lt;/button&gt;
    &lt;child ref=&quot;childForRef&quot;&gt;&lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import child from &#39;./child.vue&#39;
  export default &#123;
    components: &#123; child &#125;,
    data () &#123;
      return &#123;
        childForRef: null,
      &#125;
    &#125;,
    mounted() &#123;
      this.childForRef = this.$refs.childForRef;
      console.log(this.childForRef.name);
    &#125;,
    methods: &#123;
      sayHello() &#123;
        this.childForRef.sayHello()
      &#125;
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code>//子组件
&lt;template&gt;
  &lt;div&gt;child 的内容&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  data () &#123;
    return &#123;
      name: &#39;我是 child&#39;,
    &#125;
  &#125;,
  methods: &#123;
    sayHello () &#123;
      console.log(&#39;hello&#39;);
      alert(&#39;hello&#39;);
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解03-兄弟组件通信（bus总线）</title>
    <url>/2023/09/03/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A303/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>main.js</p>
<pre><code>// main.js 文件
import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;

Vue.config.productionTip = false

new Vue(&#123;
  render: h =&gt; h(App),
  beforeCreate() &#123;
    // 需要在全局添加一个属性
    Vue.prototype.$bus = this
  &#125;
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>Father.vue</p>
<pre><code>// Father.vue 文件
&lt;template&gt;
  &lt;div id=&quot;father&quot;&gt;
    &lt;button @click=&quot;btn&quot;&gt;我要给 Brother 组件传数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Father&quot;,
  methods: &#123;
    btn() &#123;
      this.$bus.$emit(&quot;change&quot;, 66666);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>Brother.vue</p>
<pre><code>// Brother.vue 文件
&lt;template&gt;
  &lt;div id=&quot;brother&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;Brother&quot;,
  mounted() &#123;
    this.$bus.$on(&quot;change&quot;, (msg) =&gt; &#123;
      console.log(msg);
    &#125;);
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「codeCat!」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_60547084/article/details/124408513">https://blog.csdn.net/weixin_60547084/article/details/124408513</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解02-子传父传递</title>
    <url>/2023/09/02/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A302/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（1）在父组件的子组件标签上自定义一个事件，然后调用需要的方法<br>（2）在子组件的方法中通过 this.$emit(“事件”)来触发在父组件中定义的事件，数据是以参数的形式进行传递的</p>
<p>代码示例：</p>
<p>父组件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;i&gt;父组件&lt;/i&gt;
    &lt;!--页面使用--&gt;
    &lt;son @lcclick=&quot;lcclick&quot;&gt;&lt;/son&gt;//自定义一个事件
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import son from &quot;./son.vue&quot;; //导入父组件
export default &#123;
  components: &#123; son &#125;, //注册组件
  name: &quot;父组件&quot;,
  data() &#123;
    return &#123;&#125;;
  &#125;,
  methods: &#123;
    lcclick()&#123;
      alert(&#39;子传父&#39;)
    &#125;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;lcalter&quot;&gt;点我&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
components: &#123; &#125;,
  name: &#39;子组件&#39;,
  methods: &#123;
    lcalter()&#123;
      this.$emit(&#39;lcclick&#39;)//通过emit来触发事件
    &#125;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2传值方式详解01-父传子传递</title>
    <url>/2023/09/01/Vue2%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A301/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（1）在父组件的子组件标签上绑定一个属性，挂载要传输的变量<br>（2）在子组件中通过props来接受数据，props可以是数组也可以是对象，接受的数据可以直接使用 props: [“属性名”] props:{属性名:数据类型}</p>
<p>代码示例</p>
<p>父组件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;i&gt;父组件&lt;/i&gt;
    &lt;!--页面使用--&gt;
    &lt;son :data=&#39;name&#39;&gt;&lt;/son&gt; 
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
import son from &quot;./son.vue&quot;;//导入父组件
export default &#123;
  components: &#123; son &#125;,//注册组件
  name: &quot;父组件&quot;,
  data() &#123;
    return &#123;
      name: &quot;Frazier&quot;, //父组件定义变量
    &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
components: &#123; &#125;,
  name: &#39;子组件&#39;,
  props:[&quot;data&quot;],
&#125;;
&lt;/script&gt;
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「小毕学习代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_70703397/article/details/132201160">https://blog.csdn.net/qq_70703397/article/details/132201160</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas实用入门案例04</title>
    <url>/2023/08/31/Pandas%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先先介绍一下什么是Pandas ？</p>
<p>Pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。<br>Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。<br>pandas提供了大量能使我们快速便捷地处理数据的函数和方法。你很快就会发现，它是使Python成为强大而高效的数据分析环境的重要因素之一。</p>
<p>首先引入相关模块：</p>
<pre><code>import numpy as np
import pandas as pd
</code></pre>
<h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><h2 id="第一章-DataFrame"><a href="#第一章-DataFrame" class="headerlink" title="第一章 DataFrame"></a>第一章 DataFrame</h2><h3 id="1-1-创建Series"><a href="#1-1-创建Series" class="headerlink" title="1.1 创建Series"></a>1.1 创建Series</h3><p>index不指定则从0开始编号</p>
<pre><code>s = pd.Series([1, 2, 3, np.nan], index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])
print s
</code></pre>
<p>输出</p>
<pre><code>A 1.0
B 2.0
C 3.0
D NaN
dtype: float64
</code></pre>
<h3 id="1-2-创建时间序列"><a href="#1-2-创建时间序列" class="headerlink" title="1.2 创建时间序列"></a>1.2 创建时间序列</h3><p>必须指定start、end、periods中的两个参数值</p>
<pre><code>dates = pd.date_range(&#39;20180101&#39;, periods=5)
print dates
</code></pre>
<p>输出</p>
<pre><code>DatetimeIndex([‘2018-01-01’, ‘2018-01-02’, 
‘2018-01-03’, ‘2018-01-04’,‘2018-01-05’],
dtype=’datetime64[ns]’, freq=’D’)
</code></pre>
<h3 id="1-3-创建DataFrame"><a href="#1-3-创建DataFrame" class="headerlink" title="1.3 创建DataFrame"></a>1.3 创建DataFrame</h3><p>必须指定start、end、periods中的两个参数值</p>
<pre><code>df = pd.DataFrame(np.random.rand(3,4),columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print df
</code></pre>
<p>输出</p>
<pre><code>a b c d
0 0.233310 0.170256 0.036988 0.697916
1 0.159580 0.287814 0.528123 0.956051
2 0.815038 0.438103 0.143477 0.769143
</code></pre>
<p>通过字典创建（key为列名）：</p>
<pre><code>df = pd.DataFrame(&#123;&#39;A&#39;: 1,
                   &#39;B&#39;: pd.Timestamp(&#39;20171208&#39;),
                   &#39;C&#39;: pd.Series(np.arange(4)),
                   &#39;D&#39;: pd.Categorical([&#39;test&#39;, &#39;train&#39;, &#39;test&#39;, &#39;train&#39;])&#125;)
print df
</code></pre>
<p>输出</p>
<pre><code>A B C D
0 1 2017-12-08 0 test
1 1 2017-12-08 1 train
2 1 2017-12-08 2 test
3 1 2017-12-08 3 train
</code></pre>
<h3 id="1-4-DataFrame属性"><a href="#1-4-DataFrame属性" class="headerlink" title="1.4 DataFrame属性"></a>1.4 DataFrame属性</h3><pre><code>df = pd.DataFrame(&#123;&#39;A&#39;: 1,
                   &#39;B&#39;: pd.Timestamp(&#39;20171208&#39;),
                   &#39;C&#39;: pd.Series(np.arange(4)),
                   &#39;D&#39;: pd.Categorical([&#39;test&#39;, &#39;train&#39;, &#39;test&#39;, &#39;train&#39;])&#125;)
</code></pre>
<p>查看每列数据类型</p>
<pre><code>print df.dtypes
</code></pre>
<p>输出</p>
<pre><code>A int64
B datetime64[ns]
C int32
D category
dtype: object
</code></pre>
<p>查看索引</p>
<pre><code>print df.index  
</code></pre>
<p>输出</p>
<pre><code>RangeIndex(start=0, stop=4, step=1)
</code></pre>
<p>查看列名</p>
<pre><code>print df.columns
</code></pre>
<p>输出</p>
<pre><code>Index([u’A’, u’B’, u’C’, u’D’], dtype=’object’)
</code></pre>
<p>查看数据</p>
<pre><code>print df.values  
</code></pre>
<p>输出</p>
<pre><code>[[1L Timestamp(‘2017-12-08 00:00:00’) 0 ‘test’]
[1L Timestamp(‘2017-12-08 00:00:00’) 1 ‘train’]
[1L Timestamp(‘2017-12-08 00:00:00’) 2 ‘test’]
[1L Timestamp(‘2017-12-08 00:00:00’) 3 ‘train’]]
</code></pre>
<p>DataFrame统计信息</p>
<pre><code>print df.describe()
</code></pre>
<p>输出</p>
<pre><code>A C
count 4.0 4.000000
mean 1.0 1.500000
std 0.0 1.290994
min 1.0 0.000000
25% 1.0 0.750000
50% 1.0 1.500000
75% 1.0 2.250000
max 1.0 3.000000
</code></pre>
<h3 id="1-5-DataFrame常用操作"><a href="#1-5-DataFrame常用操作" class="headerlink" title="1.5 DataFrame常用操作"></a>1.5 DataFrame常用操作</h3><p>转置</p>
<pre><code>df = pd.DataFrame(np.arange(12).reshape((3,4)),columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print df.T
</code></pre>
<p>输出</p>
<pre><code>0 1 2
a 0 4 8
b 1 5 9
c 2 6 10
d 3 7 11
</code></pre>
<p>按index排序</p>
<pre><code>df = pd.DataFrame(np.arange(12).reshape((3, 4)), columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print df.sort_index(axis=1, ascending=False)
</code></pre>
<p>输出</p>
<pre><code>d c b a
0 3 2 1 0
1 7 6 5 4
2 11 10 9 8
</code></pre>
<p>按值排序</p>
<pre><code>df = pd.DataFrame(np.arange(12).reshape((3, 4)), columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print df.sort_values(by=&#39;b&#39;, ascending=False)
</code></pre>
<p>输出</p>
<pre><code>a b c d
2 8 9 10 11
1 4 5 6 7
0 0 1 2 3
</code></pre>
<p>数据选择</p>
<p>创建如下dataframe：</p>
<pre><code>dates = pd.date_range(&#39;20180101&#39;, periods=3)
df = pd.DataFrame(np.arange(12).reshape((3, 4)),
                  index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print df
</code></pre>
<p>输出</p>
<pre><code>a b c d
2018-01-01 0 1 2 3
2018-01-02 4 5 6 7
2018-01-03 8 9 10 11
</code></pre>
<h2 id="第二章-数据选择"><a href="#第二章-数据选择" class="headerlink" title="第二章 数据选择"></a>第二章 数据选择</h2><h3 id="2-1-选择列"><a href="#2-1-选择列" class="headerlink" title="2.1 选择列"></a>2.1 选择列</h3><pre><code>print df[&#39;a&#39;]  # print df.a
</code></pre>
<p>输出</p>
<pre><code>2018-01-01 0
2018-01-02 4
2018-01-03 8
</code></pre>
<h3 id="2-2-选择行"><a href="#2-2-选择行" class="headerlink" title="2.2 选择行"></a>2.2 选择行</h3><pre><code>print df[0:2]  # print df[&#39;20180101&#39;:&#39;20180102&#39;]
</code></pre>
<p>输出</p>
<pre><code>a b c d
2018-01-01 0 1 2 3
2018-01-02 4 5 6 7
</code></pre>
<h3 id="2-3-标签选择：loc"><a href="#2-3-标签选择：loc" class="headerlink" title="2.3 标签选择：loc"></a>2.3 标签选择：loc</h3><p>1</p>
<pre><code>print df.loc[:,[&#39;a&#39;, &#39;b&#39;]] 
</code></pre>
<p>输出</p>
<pre><code>a b
2018-01-01 0 1
2018-01-02 4 5
2018-01-03 8 9
</code></pre>
<p>2</p>
<pre><code>print df.loc[&#39;20180102&#39;]
</code></pre>
<p>输出</p>
<pre><code>a 4
b 5
c 6
d 7
Name: 2018-01-02 00:00:00, dtype: int32
</code></pre>
<h3 id="2-4-位置选择：iloc"><a href="#2-4-位置选择：iloc" class="headerlink" title="2.4 位置选择：iloc"></a>2.4 位置选择：iloc</h3><pre><code>print df.iloc[[0, 2], 2:4]
</code></pre>
<p>输出</p>
<pre><code>c d
2018-01-01 2 3
2018-01-03 10 11
</code></pre>
<h3 id="2-5-混合标签与位置：ix"><a href="#2-5-混合标签与位置：ix" class="headerlink" title="2.5 混合标签与位置：ix"></a>2.5 混合标签与位置：ix</h3><pre><code>print df.ix[:2, [&#39;c&#39;, &#39;d&#39;]]
</code></pre>
<p>输出</p>
<pre><code>c d
2018-01-01 2 3
2018-01-02 6 7
</code></pre>
<h3 id="2-6-Boolean选择"><a href="#2-6-Boolean选择" class="headerlink" title="2.6 Boolean选择"></a>2.6 Boolean选择</h3><pre><code>print df[df.a &lt; 5]
</code></pre>
<p>输出</p>
<pre><code>a b c d
2018-01-01 0 1 2 3
2018-01-02 4 5 6 7
</code></pre>
<p>处理NaN数据</p>
<p>首先创建包含NaN的dataframe：</p>
<pre><code>dates = pd.date_range(&#39;20180101&#39;, periods=3)
df = pd.DataFrame(np.arange(12).reshape((3, 4)),
                  index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
df.iloc[1, 1], df.iloc[2, 2] = np.nan, np.nan
print df
</code></pre>
<p>输出</p>
<pre><code>a b c d
2018-01-01 0 1.0 2.0 3
2018-01-02 4 NaN 6.0 7
2018-01-03 8 9.0 NaN 11
</code></pre>
<h2 id="第三章-处理NaN数据"><a href="#第三章-处理NaN数据" class="headerlink" title="第三章 处理NaN数据"></a>第三章 处理NaN数据</h2><h3 id="3-1-删除NaN数据"><a href="#3-1-删除NaN数据" class="headerlink" title="3.1 删除NaN数据"></a>3.1 删除NaN数据</h3><pre><code>print df.dropna(axis=1)  # how = [&#39;any&#39;, &#39;all&#39;]
</code></pre>
<p>输出</p>
<pre><code>a d
2018-01-01 0 3
2018-01-02 4 7
2018-01-03 8 11
</code></pre>
<h3 id="3-2-填充NaN数据"><a href="#3-2-填充NaN数据" class="headerlink" title="3.2 填充NaN数据"></a>3.2 填充NaN数据</h3><pre><code>print df.fillna(value=&#39;*&#39;)
</code></pre>
<p>输出</p>
<pre><code>a b c d
2018-01-01 0 1 2 3
2018-01-02 4 * 6 7
2018-01-03 8 9 * 11
</code></pre>
<h3 id="3-3-检查是否存在NaN数据"><a href="#3-3-检查是否存在NaN数据" class="headerlink" title="3.3 检查是否存在NaN数据"></a>3.3 检查是否存在NaN数据</h3><pre><code>print df.isnull()
</code></pre>
<p>输出</p>
<pre><code>a b c d
2018-01-01 False False False False
2018-01-02 False True False False
2018-01-03 False False True False
</code></pre>
<h2 id="第四章-导入与导出"><a href="#第四章-导入与导出" class="headerlink" title="第四章 导入与导出"></a>第四章 导入与导出</h2><pre><code>导入函数    导出函数功能
read_csv    to_csv
read_excel    to_excel
read_sql    to_sql
read_json    to_json
read_msgpack    to_msgpack
read_html    to_html
read_gbq    to_gbq
read_stata    to_stata
read_sas    to_sas
read_clipboard    to_clipboard
read_pickle    to_pickle
</code></pre>
<p>以下面这个test.txt为例：</p>
<pre><code>A B
Tom 21
Joe 26
Sam 55
Kerry 27
</code></pre>
<p>忽略第一行，并设置列名分别为‘name’和‘age’</p>
<pre><code>data = pd.read_csv(&#39;test.txt&#39;, sep=&#39; &#39;, skiprows=1, names=[&#39;name&#39;,&#39;age&#39;])
print data
</code></pre>
<p>输出</p>
<pre><code>name age
0 Tom 21
1 Joe 26
2 Sam 55
3 Kerry 27
</code></pre>
<h2 id="第五章-合并DataFrame"><a href="#第五章-合并DataFrame" class="headerlink" title="第五章 合并DataFrame"></a>第五章 合并DataFrame</h2><h3 id="5-1-concat函数"><a href="#5-1-concat函数" class="headerlink" title="5.1 concat函数"></a>5.1 concat函数</h3><pre><code>df1 = pd.DataFrame(np.ones((3, 4))*0, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
df2 = pd.DataFrame(np.ones((3, 4))*1, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
df3 = pd.DataFrame(np.ones((3, 4))*2, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
# ignore_index=True将重新对index排序
print pd.concat([df1, df2, df3], axis=0, ignore_index=True)
</code></pre>
<p>输出</p>
<pre><code>a b c d
0 0.0 0.0 0.0 0.0
1 0.0 0.0 0.0 0.0
2 0.0 0.0 0.0 0.0
3 1.0 1.0 1.0 1.0
4 1.0 1.0 1.0 1.0
5 1.0 1.0 1.0 1.0
6 2.0 2.0 2.0 2.0
7 2.0 2.0 2.0 2.0
8 2.0 2.0 2.0 2.0
</code></pre>
<p>join参数用法</p>
<pre><code>df1 = pd.DataFrame(np.ones((3, 4))*0, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], index=[1,2,3])
df2 = pd.DataFrame(np.ones((3, 4))*1, columns=[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], index=[2,3,4])
# join默认为&#39;outer&#39;，不共有的列用NaN填充
print pd.concat([df1, df2], join=&#39;outer&#39;) 
# join=&#39;inner&#39;只合并共有的列
print pd.concat([df1, df2], join=&#39;inner&#39;)
</code></pre>
<p>输出 1</p>
<pre><code>a b c d e
1 0.0 0.0 0.0 0.0 NaN
2 0.0 0.0 0.0 0.0 NaN
3 0.0 0.0 0.0 0.0 NaN
2 NaN 1.0 1.0 1.0 1.0
3 NaN 1.0 1.0 1.0 1.0
4 NaN 1.0 1.0 1.0 1.0
</code></pre>
<p>输出 2</p>
<pre><code>b c d
1 0.0 0.0 0.0
2 0.0 0.0 0.0
3 0.0 0.0 0.0
2 1.0 1.0 1.0
3 1.0 1.0 1.0
4 1.0 1.0 1.0
</code></pre>
<p>join_axes参数用法</p>
<pre><code>df1 = pd.DataFrame(np.ones((3, 4))*0, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], index=[1, 2, 3])
df2 = pd.DataFrame(np.ones((3, 4))*1, columns=[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], index=[2, 3, 4])
# 按照df1的index进行合并
print pd.concat([df1, df2], axis=1, join_axes=[df1.index])
</code></pre>
<p>输出</p>
<pre><code>a b c d b c d e
1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN
2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0
3 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0
</code></pre>
<h3 id="5-2-append函数"><a href="#5-2-append函数" class="headerlink" title="5.2 append函数"></a>5.2 append函数</h3><p>append多个DataFrame</p>
<pre><code>df1 = pd.DataFrame(np.ones((3, 4))*0, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
df2 = pd.DataFrame(np.ones((3, 4))*1, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])

print df1.append(df2, ignore_index=True)
</code></pre>
<p>输出</p>
<pre><code>a b c d
0 0.0 0.0 0.0 0.0
1 0.0 0.0 0.0 0.0
2 0.0 0.0 0.0 0.0
3 1.0 1.0 1.0 1.0
4 1.0 1.0 1.0 1.0
5 1.0 1.0 1.0 1.0
</code></pre>
<p>append一组数据</p>
<pre><code>df1 = pd.DataFrame(np.ones((3, 4))*0, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
s = pd.Series([4, 4, 4, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])

print df1.append(s, ignore_index=True)
</code></pre>
<p>输出</p>
<pre><code>a b c d
0 0.0 0.0 0.0 0.0
1 0.0 0.0 0.0 0.0
2 0.0 0.0 0.0 0.0
3 4.0 4.0 4.0 4.0
</code></pre>
<h3 id="5-3-merge函数"><a href="#5-3-merge函数" class="headerlink" title="5.3 merge函数"></a>5.3 merge函数</h3><p>基于某一列进行合并</p>
<pre><code>df1 = pd.DataFrame(&#123;&#39;A&#39;: [&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],
                    &#39;B&#39;: [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],
                   &#39;KEY&#39;: [&#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;]&#125;)
df2 = pd.DataFrame(&#123;&#39;C&#39;: [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],
                    &#39;D&#39;: [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;],
                   &#39;KEY&#39;: [&#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;]&#125;)

print pd.merge(df1, df2, on=&#39;KEY&#39;)
</code></pre>
<p>输出</p>
<pre><code>A B KEY C D
0 A1 B1 K1 C1 D1
1 A2 B2 K2 C2 D2
2 A3 B3 K3 C3 D3
</code></pre>
<p>基于某两列进行合并</p>
<pre><code>df1 = pd.DataFrame(&#123;&#39;A&#39;: [&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],
                    &#39;B&#39;: [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],
                    &#39;KEY1&#39;: [&#39;K1&#39;, &#39;K2&#39;, &#39;K0&#39;],
                    &#39;KEY2&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K3&#39;]&#125;)
df2 = pd.DataFrame(&#123;&#39;C&#39;: [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],
                    &#39;D&#39;: [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;],
                    &#39;KEY1&#39;: [&#39;K0&#39;, &#39;K2&#39;, &#39;K1&#39;],
                    &#39;KEY2&#39;: [&#39;K1&#39;, &#39;K1&#39;, &#39;K0&#39;]&#125;)
# how:[&#39;left&#39;,&#39;right&#39;,&#39;outer&#39;,&#39;inner&#39;]
print pd.merge(df1, df2, on=[&#39;KEY1&#39;, &#39;KEY2&#39;], how=&#39;inner&#39;)
</code></pre>
<p>输出</p>
<pre><code>A B KEY1 KEY2 C D
0 A1 B1 K1 K0 C3 D3
1 A2 B2 K2 K1 C2 D2
</code></pre>
<p>按index合并</p>
<pre><code>df1 = pd.DataFrame(&#123;&#39;A&#39;: [&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],
                    &#39;B&#39;: [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]&#125;,
                   index=[&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;])
df2 = pd.DataFrame(&#123;&#39;C&#39;: [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],
                    &#39;D&#39;: [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;,
                   index=[&#39;K0&#39;, &#39;K1&#39;, &#39;K3&#39;])

print pd.merge(df1, df2, left_index=True, right_index=True, how=&#39;outer&#39;)
</code></pre>
<p>输出</p>
<pre><code>A B C D
K0 A1 B1 C1 D1
K1 A2 B2 C2 D2
K2 A3 B3 NaN NaN
K3 NaN NaN C3 D3
</code></pre>
<p>为列加后缀</p>
<pre><code>df_boys = pd.DataFrame(&#123;&#39;id&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],
                        &#39;age&#39;: [&#39;23&#39;, &#39;25&#39;, &#39;18&#39;]&#125;)
df_girls = pd.DataFrame(&#123;&#39;id&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],
                        &#39;age&#39;: [&#39;18&#39;, &#39;18&#39;, &#39;18&#39;]&#125;)

print pd.merge(df_boys, df_girls, on=&#39;id&#39;, suffixes=[&#39;_boys&#39;, &#39;_girls&#39;])
</code></pre>
<p>输出</p>
<pre><code>age_boys id age_girls
0 23 1 18
1 25 2 18
2 18 3 18
</code></pre>
<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><p>引入相应模块</p>
<pre><code>import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
</code></pre>
<p>绘制Series</p>
<pre><code>data = pd.Series(np.random.randn(1000))
data = data.cumsum()

data.plot()
plt.show()
</code></pre>
<h2 id="–本文完–"><a href="#–本文完–" class="headerlink" title="–本文完–"></a>–本文完–</h2><p>©著作权归作者所有：来自51CTO博客作者程序员小猿的原创作品，请联系作者获取转载授权，否则将追究法律责任<br>全网最全的Pandas入门教程（精简版）<br><a href="https://blog.51cto.com/u_13294304/3386462">https://blog.51cto.com/u_13294304/3386462</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>vue循环遍历对象、数组和字符串</title>
    <url>/2023/08/30/vue%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-循环遍历对象"><a href="#1-循环遍历对象" class="headerlink" title="1.循环遍历对象"></a>1.循环遍历对象</h1><h2 id="1-1vue-在html里面循环遍历对象"><a href="#1-1vue-在html里面循环遍历对象" class="headerlink" title="1.1vue 在html里面循环遍历对象"></a>1.1vue 在html里面循环遍历对象</h2><pre><code>v-for=&quot; (val, key , i) in dimItemMap&quot; :key=&quot;key&quot;

val-每一项
key -key值
i-第几个

&lt;el-table-column prop=&quot;score&quot; label=&quot;评分&quot; :show-overflow-tooltip=&quot;true&quot; align=&quot;center&quot;&gt;
    &lt;template slot-scope=&quot;scope&quot;&gt;
    &lt;span&gt;
        &lt;span v-for=&quot; (val, key , i) in scope.row.dimItemMap&quot; :key=&quot;key&quot;&gt;
        &#123;&#123;val.score&#125;&#125;//score为键，val.score为值
        &lt;/span&gt;
    &lt;/span&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;
</code></pre>
<h2 id="1-2-在js里面forin遍历对象"><a href="#1-2-在js里面forin遍历对象" class="headerlink" title="1.2 在js里面forin遍历对象"></a>1.2 在js里面forin遍历对象</h2><p>for…in 循环主要是为了遍历对象而生，不适用于遍历数组</p>
<pre><code>let data = [&#123; wiun2dvi: 232, wiun3dvi: 55, wiu4ndvi: 33, wiun1dvi: 24432 &#125;];
    data.forEach((item,index)=&gt;&#123;
      for (const key in item) &#123;
        console.log(&quot;item[key]&quot;,item[key]);//值
        console.log(&quot;key&quot;,key);//键
      &#125;
    &#125;)
</code></pre>
<h1 id="2-循环遍历数组"><a href="#2-循环遍历数组" class="headerlink" title="2.循环遍历数组"></a>2.循环遍历数组</h1><h2 id="2-1-vue-在html里面循环遍历数组"><a href="#2-1-vue-在html里面循环遍历数组" class="headerlink" title="2.1 vue 在html里面循环遍历数组"></a>2.1 vue 在html里面循环遍历数组</h2><pre><code>&lt;el-table-column v-for=&quot;item in tableCol&quot; :key=&quot;item.id&quot; :prop=&quot;item.id&quot; :label=&quot;item.name&quot; :show-overflow-tooltip=&quot;true&quot; align=&quot;center&quot;&gt;
    &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;span&gt;&#123;&#123;scope.row.dimItemMap?scope.row.dimItemMap[item.id].name:""&#125;&#125;&lt;/span&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;

&lt;el-table-column prop=&quot;score&quot; label=&quot;评分&quot; :show-overflow-tooltip=&quot;true&quot; align=&quot;center&quot;&gt;
    &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;span&gt;
            &lt;span v-for=&quot; (item, index) in scope.row.dimItemMap&quot; :key=&quot;index&quot;&gt;
                &#123;&#123;item.score&#125;&#125;
            &lt;/span&gt;
        &lt;/span&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;
</code></pre>
<h2 id="2-2-在js里面for遍历数组"><a href="#2-2-在js里面for遍历数组" class="headerlink" title="2.2 在js里面for遍历数组"></a>2.2 在js里面for遍历数组</h2><pre><code>let id = 1524466
for (let i = 0; i &lt; list.length; i++) &#123;
    let a = list[i];
    if (a.id === id) &#123;
        return a.name;
    &#125; 
&#125;
</code></pre>
<h2 id="2-3-在js里面forof遍历数组"><a href="#2-3-在js里面forof遍历数组" class="headerlink" title="2.3 在js里面forof遍历数组"></a>2.3 在js里面forof遍历数组</h2><p>   let arr = [{<br>        name: 12,<br>        hello: “wsdfnioq”,<br>    }, {<br>        name: 12,<br>        hello: “wsdfnioq”,<br>    }, {<br>        name: 12,<br>        hello: “wsdfnioq”,<br>    }]</p>
<pre><code>for (const i of arr) &#123;
    console.log(&quot;i&quot;, i);
&#125;
        
//i &#123;name: 12, hello: &#39;wsdfnioq&#39;&#125;
//i &#123;name: 12, hello: &#39;wsdfnioq&#39;&#125;
//i &#123;name: 12, hello: &#39;wsdfnioq&#39;&#125;

let arr = [
    [&#39;name&#39;, &quot;张三&quot;],
    [&#39;地址&#39;, &#39;北京&#39;],
    [&#39;手机&#39;, &#39;123&#39;]
]
for (const [value0, value1] of arr) &#123;
    console.log(&#39;k&#39;, value0, value1);
&#125;
// k name 张三
// k 地址 北京
// k 手机 123
</code></pre>
<h2 id="2-4-for-in，不推荐对数组进行遍历"><a href="#2-4-for-in，不推荐对数组进行遍历" class="headerlink" title="2.4 for in，不推荐对数组进行遍历"></a>2.4 for in，不推荐对数组进行遍历</h2><pre><code>let arr = [&quot;lsadnkol&quot;, &quot;klsmvaod&quot;, &quot;lpsaojfoas&quot;]
for (const key in arr) &#123;
    console.log(&quot;arr&quot;, key, typeof key, arr[key]);
&#125;
// 0 string lsadnkol
// 1 string klsmvaod
// 2 string lpsaojfoas
</code></pre>
<h2 id="2-5-forEach-函数遍历数组"><a href="#2-5-forEach-函数遍历数组" class="headerlink" title="2.5 forEach() 函数遍历数组"></a>2.5 forEach() 函数遍历数组</h2><p>①无任何返回，可改变原来数组中的内容</p>
<p>②循环次数：数组的长度</p>
<p>③不支持return，不需要return语句</p>
<p>如下案例：给每个对象中添加age属性</p>
<pre><code>let forArr = [&#123;name:&#39;tom&#39;,sex:&#39;man&#39;&#125;,&#123;name:&#39;linda&#39;,sex:&#39;woman&#39;&#125;,]
 forArr.forEach((item,index) =&gt; &#123;
    console.log(&quot;forEach循环==index==&quot;,index,item);
     item.age = 27
&#125;)
console.log(&quot;forArr==遍历后===&quot;,forArr)
// forArr ----&gt;[&#123;name:&#39;tom&#39;,sex:&#39;man&#39;,age:27&#125;,&#123;name:&#39;linda&#39;,sex:&#39;woman&#39;,age:27&#125;]
</code></pre>
<h1 id="vue循环遍历-指令v-for"><a href="#vue循环遍历-指令v-for" class="headerlink" title="vue循环遍历,指令v-for"></a>vue循环遍历,指令v-for</h1><h2 id="1-循环遍历"><a href="#1-循环遍历" class="headerlink" title="1.循环遍历"></a>1.循环遍历</h2><p>vue的循环遍历用v-for，语法类似于js中的for循环</p>
<p>当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。</p>
<p>v-for使用格式：</p>
<p>格式为：v-for = item in items</p>
<p> (遍历items中的数据)</p>
<h2 id="2-v-for遍历数组"><a href="#2-v-for遍历数组" class="headerlink" title="2.v-for遍历数组"></a>2.v-for遍历数组</h2><p>用v-for指令基于一个数组来渲染一个列表。</p>
<p>v-for 指令使用item in items形式的语法，其中items是源数据数组， 而item则是被迭代的数组元素。</p>
<ul>
<li>如果v-for遍历数组中的数组值</li>
</ul>
<p>语法格式：v-for=”movie in movies”<br>依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie</p>
<pre><code>&lt;li v-for=&quot;movie in movies&quot;&gt; &#123;&#123;movie&#125;&#125; &lt;/li&gt;
 
</code></pre>
<ul>
<li>如果v-for遍历数组中的数组值、索引值</li>
</ul>
<p>语法格式：v-for=(item, index) in items<br>v-for中使用二个参数，即当前项和当前项的索引</p>
<pre><code>&lt;li v-for=&quot;(item, index) in items&quot;&gt;&#123;&#123;index&#125;&#125;. &#123;&#123;item&#125;&#125;&lt;/li&gt;
</code></pre>
<p>样例：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;name in names&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt;
  &lt;/ul&gt;
   //v-for遍历过程中，遍历数组中值,并显示
  &lt;ul&gt;
    &lt;li v-for=&quot;(name,index) in names&quot;&gt;&#123;&#123;index&#125;&#125;. &#123;&#123;name&#125;&#125;&lt;/li&gt;
  &lt;/ul&gt;
   //遍历过程中，遍历数组中值、索引值，并显示
&lt;/div&gt;

&lt;script&gt;
  const app = new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
      names:[&quot;刘富楠&quot;,&quot;科比&quot;,&quot;詹姆斯&quot;,&quot;库里&quot;]
    &#125;
  &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="3-v-for遍历对象"><a href="#3-v-for遍历对象" class="headerlink" title="3.v-for遍历对象"></a>3.v-for遍历对象</h2><p>1.遍历对象属性 用value值<br>2.遍历对象属性和属性值 用value值和key<br>3.遍历对象属性和属性值和索引 用value值、key和index</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    //展示出所有信息
    &lt;ul&gt;
        &lt;li &gt;&#123;&#123;info.name&#125;&#125;&lt;/li&gt;
        &lt;li &gt;&#123;&#123;info.age&#125;&#125;&lt;/li&gt;
        &lt;li &gt;&#123;&#123;info.height&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
    //方法1.一个个写出来
    &lt;ul&gt;
        &lt;li v-for=&quot;item in info&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
    //方法2.用v-for遍历对象的value值。(属性)
    &lt;ul&gt;
        &lt;li v-for=&quot;(value,key) in info&quot;&gt;&#123;&#123;value&#125;&#125;--&#123;&#123;key&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
    //方法3.用v-for遍历对象的value值和key，value在前面。(属性和属性值)
    &lt;ul&gt;
        &lt;li v-for=&quot;(value,key,index) in info&quot;&gt;&#123;&#123;value&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
    //方法4.用v-for遍历对象的value值、key和index。(属性和属性值和索引)
&lt;/div&gt;

&lt;script&gt;
    const app = new Vue(&#123;
        el:&quot;#app&quot;,
        data:&#123;
            info:&#123;
                name:&quot;lfn&quot;,
                age :18,
                height:180
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;    
</code></pre>
<h2 id="4-v-for使用中添加key"><a href="#4-v-for使用中添加key" class="headerlink" title="4.v-for使用中添加key"></a>4.v-for使用中添加key</h2><p>在遍历数组时可以在元素中绑定一个key，key=数组值</p>
<p>绑定key的作用 ：主要是为了高效的更新虚拟DOM。(vue内部；让性能高一点)</p>
<ul>
<li><p>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点，</p>
<p> 则Diff算法默认执行起来是比较复杂的。(一个个重新替换)</p>
</li>
<li><p>但绑定key后，可以使用key来给每个节点做一个唯一标识</p>
<p> Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p>
  <div id="app">
    <ul>
      <li v-for="item in letters" :key="item"></li>
    </ul>
  </div>

  <script>
    const app = new Vue({
      el:"#app",
      data:{
        letters:["A","B","C","D","E"]
      }
    })
  </script></li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue遍历对象的几种方式</title>
    <url>/2023/08/29/vue%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在vue项目开发中，我们需要对对象进行处理等问题，这里简单记录遍历对象的几种方法</p>
<p>一、for in 这是遍历对象的基本方法，其中key代表键，值可以通过Object[key]进行获取，</p>
<pre><code>let obj1 = &#123;
    name: &#39;张三&#39;,
    age: &#39;18&#39;,
    height: &#39;180&#39;
&#125;
for (let key in obj2) &#123;
    console.log(&#39;key&#39;, key)
    console.log(&#39;value&#39;, obj1[key])
&#125;
        
</code></pre>
<p>衍生：obj2中部分key与obj1相同，这是需要将obj1与obj2中key相同的进行赋值，代码如下</p>
<pre><code>let obj2 = &#123;
    name: &#39;&#39;,
    age: &#39;&#39;,
&#125;
let obj1 = &#123;
    name: &#39;张三&#39;,
    age: &#39;18&#39;,
    height: &#39;180&#39;
&#125;
for (let key in obj2) &#123;
    obj2[key] = obj1[key]
&#125;
console.log(obj2)
        
</code></pre>
<p>二、Object.keys(),ES5新增的对象方法，该方法会返回自身属性名组成的数组</p>
<pre><code>let obj1 = &#123;
    name: &#39;张三&#39;,
    age: &#39;18&#39;,
    height: &#39;180&#39;
&#125;
let a = Object.keys(obj1)
console.log(a) //输出[&#39;name&#39;, &#39;age&#39;, &#39;height&#39;]
        
</code></pre>
<p>衍生：obj2中部分key与obj1相同，这是需要将obj1与obj2中key相同的进行赋值，代码如下</p>
<pre><code>let obj2 = &#123;
    name: &#39;&#39;,
    age: &#39;&#39;,
&#125;
let obj1 = &#123;
    name: &#39;张三&#39;,
    age: &#39;18&#39;,
    height: &#39;180&#39;
&#125;
Object.keys(obj2).forEach(item =&gt; &#123;
    obj2[item] = obj1[item]
&#125;)
console.log(obj2) //输出&#123;name: &#39;张三&#39;, age: &#39;18&#39;&#125;
        
</code></pre>
<p>三、Object.getOwnPropertyNames()，该方法也是ES5新增的，返回一个自身属性名的数组，包括不可枚举的属性</p>
<pre><code>let obj1 = &#123;
    name: &#39;张三&#39;,
    age: &#39;18&#39;,
    height: &#39;180&#39;
&#125;
let a = Object.getOwnPropertyNames(obj1)
console.log(a) //[&#39;name&#39;, &#39;age&#39;, &#39;height&#39;]
        
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「Maidangchen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/A1123352950/article/details/132687113">https://blog.csdn.net/A1123352950/article/details/132687113</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue使用RegExp</title>
    <url>/2023/08/28/Vue%E4%BD%BF%E7%94%A8RegExp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>vue 把字符串的所有=替换成&amp;&amp;&amp;的方法</p>
<pre><code>//把字符串中所有=换成&amp;&amp;&amp;
let reg=new RegExp(&#39;=&#39;,&#39;g&#39;)//g代表全部
let newMsg=JSON.stringify(msg).replace(reg,&#39;&amp;&amp;&amp;&#39;);
console.log(newMsg)
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式的书写顺序及规范</title>
    <url>/2023/08/27/CSS%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%E5%8F%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS样式的书写顺序及规范"><a href="#CSS样式的书写顺序及规范" class="headerlink" title="CSS样式的书写顺序及规范"></a>CSS样式的书写顺序及规范</h1><p>CSS样式属性有很多，开发过程中书写顺序对于浏览器渲染其实至关重要。规范化编码有利于程序的后期维护，并且别人也容易理解其中意思。</p>
<h1 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h1><h2 id="布局定位属性"><a href="#布局定位属性" class="headerlink" title="布局定位属性"></a>布局定位属性</h2><p>display    置元素是否被视为块或者内联元素以及用于子元素的布局，例如流式布局、网格布局或弹性布局。<br>visibility    指定一个元素是否是可见的。<br>list-style    在一个声明中设置所有的列表属性。<br>list-style-type    设置列表项标记的类型。<br>list-style-position    指示如何相对于对象的内容绘制列表项标记。<br>list-style-image    使用图像来替换列表项的标记。<br>position    指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。<br>top    定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。<br>right    定义了定位元素右外边距边界与其包含块右边界之间的偏移。<br>bottom    定义了定位元素下外边距边界与其包含块下边界之间的偏移。<br>left    定义了定位元素左外边距边界与其包含块左边界之间的偏移。<br>z-index    指定一个元素的堆叠顺序。<br>clear    指定段落的左侧或右侧不允许浮动的元素。<br>float    指定一个盒子（元素）是否应该浮动。</p>
<h2 id="自身属性"><a href="#自身属性" class="headerlink" title="自身属性"></a>自身属性</h2><p>width    设置元素的宽度。<br>max-width    设置元素的最大宽度。<br>min-width    设置元素的最小宽度。<br>height    设置元素的高度。<br>max-height    设置元素的最大高度。<br>min-height    设置元素的最低高度。<br>overflow    指定如果内容溢出一个元素的框，会发生什么。<br>clip    定义及使用说明如果图像大于包含它的元素,会发生什么?<br>margin    一个声明中设置所有外边距属性。<br>margin-top    设置元素的上部边距。<br>margin-right    设置元素的右边距。<br>margin-bottom    设置元素的下边距。<br>margin-left    设置元素的左边距。<br>padding    在一个声明中设置所有填充属性。<br>padding-top    设置一个元素的顶部填充（空格）。<br>padding-right    设置一个元素的右填充（空格）。<br>padding-bottom    设置一个元素的底部填充（空格）。<br>padding-left    设置一个元素的左填充（空格）。<br>outline    在一个声明中设置所有的轮廓属性。<br>outline-color    指定轮廓颜色。<br>outline-style    指定outline的样式。<br>outline-width    指定轮廓的宽度。<br>border    用于指定元素边框的样式、宽度和颜色。<br>background    在一个声明中设置所有的背景属性。<br>background-color    指定要使用的背景颜色。<br>background-image    指定要使用的一个或多个背景图像。<br>background-repeat    指定如何重复背景图像。<br>background-attachment    设置背景图像是否固定或者随着页面的其余部分滚动。<br>background-position    指定背景图像的位置。</p>
<h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>color    指定文本的颜色。<br>font    在一个声明中设置所有字体属性。<br>font-style    规定字体样式<br>font-variant    规定字体异体。<br>font-weight    规定字体粗细。<br>font-size    规定字体尺寸。<br>line-height    规定字体行高。<br>font-family    规定字体系列。<br>caption    定义被标题控件（比如按钮、下拉列表等）使用的字体。<br>icon    定义被图标标记使用的字体。<br>menu    定义被下拉列表使用的字体。<br>message-box    定义被对话框使用的字体。<br>small-caption    caption 字体的小型版本。<br>status-bar    定义被窗口状态栏使用的字体。<br>text-overflow    指定当文本溢出包含它的元素时，应该如何显示。<br>text-align    指定元素文本的水平对齐方式。<br>text-indent    规定文本块中首行文本的缩进。<br>white-space    指定元素内的空白怎样处理。<br>vertical-align    设置一个元素的垂直对齐方式。</p>
<h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><p>cursor    设置鼠标指针(光标)在元素上面时的显示样式<br>animation    通过关键帧@keyframes来实现更为复杂的动画效果。<br>transition    设置元素当过渡效果，</p>
<h1 id="CSS3浏览器私有前缀写法"><a href="#CSS3浏览器私有前缀写法" class="headerlink" title="CSS3浏览器私有前缀写法"></a>CSS3浏览器私有前缀写法</h1><p>CSS3 浏览器私有前缀在前，标准前缀在后</p>
<pre><code>-webkit-border-radius: 10px;
-moz-border-radius: 10px;
-o-border-radius: 10px;
-ms-border-radius: 10px;
border-radius: 10px;
</code></pre>
<h1 id="浏览器的渲染流程"><a href="#浏览器的渲染流程" class="headerlink" title="浏览器的渲染流程"></a>浏览器的渲染流程</h1><p>1、解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构布局<br>2、构建render树：DOM树和CSS树合并以后造成的render树。<br>3、布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每一个节点在屏幕中的位置。<br>4、绘制render树：按照计算出来的规则，经过显卡把内容画在屏幕上。</p>
<p>css样式解析到显示至浏览器屏幕上就发生在②③④步骤，可见浏览器并非一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第②步，而后开始遍历每一个树结点的css样式进行解析，此时的css样式的遍历顺序彻底是按照以前的书写顺序。在解析过程当中，一旦浏览器发现某个元素的定位变化影响布局，则须要倒回去从新渲染.</p>
<ul>
<li><p>例如<br>按照这样的书写书序：</p>
<p> width: 100px;<br> height: 100px;<br> background-color: red;<br> position: absolute;</p>
</li>
</ul>
<p>当浏览器解析到position的时候忽然发现该元素是绝对定位元素须要脱离文档流，而以前倒是按照普通元素进行解析的，因此不得不从新渲染，解除该元素在文档中所占位置，然而因为该元素的占位发生变化，其余元素也可能会受到它回流的影响而从新排位。最终致使③步骤花费的时间过久而影响到④步骤的显示，影响了用户体验。</p>
<p>因此规范的的css书写顺序对于文档渲染来讲必定是事半功倍的！</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>回流必将引起重绘, 重绘不一定引起回流。</p>
<ul>
<li>reflow（回流）:<br>会引起元素位置变化的就会reflow(回流),窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置。</li>
</ul>
<p>*repaint（重绘）：<br>改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，可是元素的几何尺寸没有变。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>a.render树的结构不等同于DOM树的结构，一些设置display:none的节点不会被放在render树中，但会在dom树中。</p>
<p>b.有些状况，好比修改了元素的样式，浏览器并不会理科reflow或repaint，而是把这些操做积攒一批，而后作一次reflow，这也叫作异步reflow.但在有些状况下，好比改变窗口，改变页面默认的字体等，对于这些状况，浏览器会立刻进行reflow.</p>
<p>c.为了更好的用户体验，渲染引擎将会尽量早的将内容呈现到屏幕上，并不会等到全部的html都解析完成以后再去构建和布局render树。它是解析完一部份内容就显示一部份内容，同时，可能还在经过网络下载其他内容。</p>
<h1 id="布局流程"><a href="#布局流程" class="headerlink" title="布局流程"></a>布局流程</h1><p>必须确定页面的版心(可视区),我们测量可知<br>分析页面中的行模块,以及每个行模块中的列模块,其实页面布局就是一行行罗列而成<br>制作html结构,我们还是遵循,现有结构后有样式的原则,结构永远最重要<br>然后开始运用盒子模型的原理,通过div+css布局来控制网页的各个模块</p>
<h1 id="顺序书写的优点"><a href="#顺序书写的优点" class="headerlink" title="顺序书写的优点"></a>顺序书写的优点</h1><p>正确的样式顺序有利于查看维护。<br>减小浏览器reflow（回流）与repaint（重绘），提高浏览器渲染dom的性能<br>利于网页加载代码，加快代码加载顺序。<br>正确的样式顺序也是css样式优化的一种方式。</p>
<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><h2 id="css文件命名规范"><a href="#css文件命名规范" class="headerlink" title="css文件命名规范"></a>css文件命名规范</h2><p>文件名    说明<br>reset.css    重置样式，重置元素默认样式<br>global.css    全局样式，全站公用，定义页面基础样式<br>themes.css    主题样式，用于实现换肤功能<br>module.css    模块样式，用于模块的样式<br>print.css    打印样式，用于打印的样式<br>master.css    主要样式<br>themes.css    主体样式<br>font.css    文字样式<br>layout.css    布局样式<br>columns.css    专栏<br>forms.css    表单<br>mend.css    补丁样式</p>
<h2 id="id和class命名"><a href="#id和class命名" class="headerlink" title="id和class命名"></a>id和class命名</h2><p>骆驼峰命名法，例如topMain、 subLeftMenu。<br>中划线命名法，例如top-main、sub-left-menu。<br>下划线命名法，例如top_ main、sub_ Jeft_ menu。</p>
<h2 id="id和class命名规范"><a href="#id和class命名规范" class="headerlink" title="id和class命名规范"></a>id和class命名规范</h2><p>网页部分    命名<br>最外层    wrapper<br>头部    header<br>容器    container<br>内容    content<br>导航条    nav<br>主导航    mainnav<br>子导航    subnav<br>顶导航    topnav<br>边导航、侧栏    sidebar<br>左导航    leftsidebar<br>右导航    rightsidebar<br>主体    main<br>左侧    main-left<br>右侧    main-right<br>底部    footer<br>左    left<br>中    right<br>右    center<br>栏目    column<br>菜单    menu<br>子菜单    submenu<br>登录条    loginbar<br>登录    login<br>注册    register<br>标志    logo<br>功能区    shop<br>按钮    btn<br>当前的    current<br>图标    icon<br>注释    note<br>搜索    search<br>滚动    scroll<br>标签    tags<br>标籤页    tab<br>状态    status<br>提示信息    msg<br>小技巧    tips<br>栏目标题    title<br>摘要    summary<br>下载    download<br>链接    link<br>友情链接    friendlink<br>加入我们    joinus<br>版权    copyright<br>服务    service<br>新闻    news<br>文章列表    list<br>广告    banner<br>热点    hot<br>加入    joinus<br>指南    guide<br>投票    vote<br>合作伙伴    partner</p>
<h2 id="规范命名的优点"><a href="#规范命名的优点" class="headerlink" title="规范命名的优点"></a>规范命名的优点</h2><p>把样式文件划分为多个文件，按照功能模块划分CSS文件，是为了方便在开发阶段进行开发和修改。<br>好的元素id和class的命名，方便阅读、方便维护。</p>
<h2 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h2><p>*使用CSS缩写属性</p>
<p>CSS有些属性是可以缩写的，比如padding,margin,font等等，这样精简代码同时又能提高用户的阅读体验。</p>
<p>*不要随意使用id</p>
<p>id在JS是唯一的，不能多次使用，而使用class类选择器却可以重复使用，另外id的优先级优先与class，所以id应该按需使用，而不能滥用。</p>
<p>*为选择器添加状态前缀</p>
<p>有时候可以给选择器添加一个表示状态的前缀，让语义更明了。<br>为了避免class命名的重复，命名时- -般取父元素的class名作为前缀，例如:</p>
<pre><code>&lt;div class=&quot;column&quot;&gt;
  &lt;h3 class=&quot;column-title&quot;&gt;&lt;/h3&gt;
  &lt;div class=&quot;column-content&quot;&gt;&lt;/div&gt;.
&lt;/div&gt;
</code></pre>
<h2 id="id和class命名统一规范"><a href="#id和class命名统一规范" class="headerlink" title="id和class命名统一规范"></a>id和class命名统一规范</h2><p>id和class命名一律小写，尽量用英文，尽量不缩写，除非一看就明白的单词。<br>尽量不要出现一个用中划线命名，而另外一个用下划线命名的情况。虽然下划线和中划线都可以，但是建议使用中划线，可参见各大型网站。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为了长远发展考虑，建议大家应该重视这些编码习惯。当然，本文所述内容并不完全是绝对正确的指导，但学会了这些内容，你就学会了最基本的CSS编码规范。可参考本文内容，结合您自己的部分编码习惯，编写适合您的优秀、规范代码。<br>————————————————<br>版权声明：本文为CSDN博主「song-yl」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42367460/article/details/131042969">https://blog.csdn.net/weixin_42367460/article/details/131042969</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>一份 CSS 书写顺序、命名规则的指南</title>
    <url>/2023/08/26/%E4%B8%80%E4%BB%BD%20CSS%20%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E7%9A%84%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里总结了一些国外一些文章以及我的个人经验总结出来，我想对写CSS的前端用户来说是值得学习的。</p>
<h1 id="CSS-书写顺序"><a href="#CSS-书写顺序" class="headerlink" title="CSS 书写顺序"></a>CSS 书写顺序</h1><p>位置属性 position、top、right、z-index、display、float 等<br>大小 width、height、padding、margin)<br>文字系列 font、line-height、letter-spacing、color-text-align 等<br>背景 background、border 等<br>其他 animation、transition 等</p>
<p>不推荐</p>
<pre><code>.example &#123;
    color: red;
    z-index: -1;
    background-color: #9e0;
    display: inline-block;
    font-size: 1.5em;
&#125;
</code></pre>
<p>推荐</p>
<pre><code>.example &#123;
    z-index: -1;
    display: inline-block;
    font-size: 1.5em;
    color: red;
    background-color: #9e0;
&#125;
</code></pre>
<h1 id="CSS-书写规范"><a href="#CSS-书写规范" class="headerlink" title="CSS 书写规范"></a>CSS 书写规范</h1><h2 id="使用-CSS-缩写属性"><a href="#使用-CSS-缩写属性" class="headerlink" title="使用 CSS 缩写属性"></a>使用 CSS 缩写属性</h2><p>CSS 有些属性是可以缩写的，比如 padding、margin、font 等等，这样精简代码同时又能提高用户的阅读体验。</p>
<p>不推荐</p>
<pre><code>.list-box &#123;
    border-top-style: none;
    font-family: serif;
    font-size: 100%;
    line-height: 1.6;
    padding-bottom: 2em;
    padding-left: lem;
    padding-right: lem;
    padding-top: 0;
&#125;
</code></pre>
<p>推荐</p>
<pre><code>.list-box &#123;
    border-top: 0;
    font: 100%/1.6 serif;
    padding: 0 lem 2em;
&#125;
</code></pre>
<h2 id="去掉小数点前的-0"><a href="#去掉小数点前的-0" class="headerlink" title="去掉小数点前的 0"></a>去掉小数点前的 0</h2><p>不推荐</p>
<pre><code>font-size: 0.8em;
</code></pre>
<p>推荐</p>
<pre><code>font-size: .8em;
</code></pre>
<h2 id="简写命名"><a href="#简写命名" class="headerlink" title="简写命名"></a>简写命名</h2><p>很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！</p>
<p>不推荐</p>
<pre><code>#navigation &#123;
    margin: 0 0 lem 2em;
&#125;
.atr &#123;
    color: #93c;
&#125;
</code></pre>
<p>推荐</p>
<pre><code>#nav &#123;
    margin: 0 0 lem 2em;
&#125;
.author &#123;
    color: #93c;
&#125;
</code></pre>
<h2 id="16-进制颜色代码缩写"><a href="#16-进制颜色代码缩写" class="headerlink" title="16 进制颜色代码缩写"></a>16 进制颜色代码缩写</h2><p>有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。</p>
<p>不推荐</p>
<pre><code>color: #eebbcc;
</code></pre>
<p>推荐</p>
<pre><code>color: #ebc;
</code></pre>
<h2 id="连字符-CSS-选择器命名规范"><a href="#连字符-CSS-选择器命名规范" class="headerlink" title="连字符 CSS 选择器命名规范"></a>连字符 CSS 选择器命名规范</h2><p>长名称或词组可以使用中横线来为选择器命名。<br>不建议使用 _ 下划线来命名 CSS 选择器，为什么呢？<br>*输入的时候少按一个 shift 键；<br>*浏览器兼容问题 （比如使用 _tips 的选择器命名，在 IE6 是无效的）<br>*能良好区分 JavaScript 变量命名（JS 变量命名是用 _）</p>
<p>这里有一篇破折号与下划线的详细讨论，<br>英文：点击查看<br>中文：点击查看</p>
<h2 id="不要随意使用-Id"><a href="#不要随意使用-Id" class="headerlink" title="不要随意使用 Id"></a>不要随意使用 Id</h2><p>id 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。</p>
<p>不推荐</p>
<pre><code>#info-title &#123;
    font-size: 8em;
&#125;
</code></pre>
<p>推荐</p>
<pre><code>.info-title &#123;
    font-size: 8em;
&#125;
</code></pre>
<h2 id="为选择器添加状态前缀"><a href="#为选择器添加状态前缀" class="headerlink" title="为选择器添加状态前缀"></a>为选择器添加状态前缀</h2><p>有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了 .is- 前缀。</p>
<p>不推荐</p>
<pre><code>#withdrawal &#123;
    background-color: #ccc;
&#125;
</code></pre>
<p>推荐</p>
<pre><code>.is-withdrawal &#123;
    background-color: #ccc;
&#125;
</code></pre>
<h1 id="CSS-命名规范（规则）"><a href="#CSS-命名规范（规则）" class="headerlink" title="CSS 命名规范（规则）"></a>CSS 命名规范（规则）</h1><h2 id="常用的-CSS-命名规则"><a href="#常用的-CSS-命名规则" class="headerlink" title="常用的 CSS 命名规则"></a>常用的 CSS 命名规则</h2><pre><code>头：header
内容：content/container
尾：footer
导航：nav
侧栏：sidebar
栏目：column
页面外围控制整体佈局宽度：wrapper
左右中：left right center
登录条：loginbar
标志：logo
广告：banner
页面主体：main
热点：hot
新闻：news
下载：download
子导航：subnav
菜单：menu
子菜单：submenu
搜索：search
友情链接：friendlink
页脚：footer
版权：copyright
滚动：scroll
内容：content
标签：tags
文章列表：list
提示信息：msg
小技巧：tips
栏目标题：title
加入：joinus
指南：guide
服务：service
注册：regsiter
状态：status
投票：vote
合作伙伴：partner
</code></pre>
<h2 id="注释的写法"><a href="#注释的写法" class="headerlink" title="注释的写法"></a>注释的写法</h2><pre><code>/* Header */
内容区
/* End Header */
</code></pre>
<h2 id="Id-的命名"><a href="#Id-的命名" class="headerlink" title="Id 的命名"></a>Id 的命名</h2><h3 id="1-页面结构"><a href="#1-页面结构" class="headerlink" title="(1)页面结构"></a>(1)页面结构</h3><pre><code>容器: container
页头：header
内容：content/container
页面主体：main
页尾：footer
导航：nav
侧栏：sidebar
栏目：column
页面外围控制整体佈局宽度：wrapper
左右中：left right center
</code></pre>
<h3 id="2-导航"><a href="#2-导航" class="headerlink" title="(2)导航"></a>(2)导航</h3><pre><code>导航：nav
主导航：mainnav
子导航：subnav
顶导航：topnav
边导航：sidebar
左导航：leftsidebar
右导航：rightsidebar
菜单：menu
子菜单：submenu
标题: title
摘要: summary
</code></pre>
<h3 id="3-功能"><a href="#3-功能" class="headerlink" title="(3)功能"></a>(3)功能</h3><pre><code>标志：logo
广告：banner
登陆：login
登录条：loginbar
注册：register
搜索：search
功能区：shop
标题：title
加入：joinus
状态：status
按钮：btn
滚动：scroll
标籤页：tab
文章列表：list
提示信息：msg
当前的: current
小技巧：tips
图标: icon
注释：note
指南：guild
服务：service
热点：hot
新闻：news
下载：download
投票：vote
合作伙伴：partner
友情链接：link
版权：copyright
</code></pre>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><pre><code>1.一律小写
2.尽量用英文
3.不加中槓和下划线
4.尽量不缩写，除非一看就明白的单词
</code></pre>
<h3 id="CSS-样式表文件命名"><a href="#CSS-样式表文件命名" class="headerlink" title="CSS 样式表文件命名"></a>CSS 样式表文件命名</h3><pre><code>主要的 master.css
模块 module.css
基本共用 base.css
布局、版面 layout.css
主题 themes.css
专栏 columns.css
文字 font.css
表单 forms.css
补丁 mend.css
打印 print.css
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例08--json.dumps()和jsonify()</title>
    <url>/2023/08/25/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>json.dumps()和jsonify()的区别</p>
<h1 id="一、来源不同"><a href="#一、来源不同" class="headerlink" title="一、来源不同"></a>一、来源不同</h1><p>dumps和loads方法，来自json模块，而json模块是python中的，可以直接导入：</p>
<pre><code>import json
</code></pre>
<p>而jsonify是flask封装的扩展包</p>
<p>from flask import jsonify</p>
<h1 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h1><p>1、dumps()和loads()</p>
<p>json.dumps()：把字典转成json字符串，</p>
<p>json.loads()：把json字符串转成字典</p>
<p>他们操作的都是变量（变量是存储在内存中的）。</p>
<p>2、jsonify</p>
<p>字典转成json字符串</p>
<h1 id="三、效果不同"><a href="#三、效果不同" class="headerlink" title="三、效果不同"></a>三、效果不同</h1><p>1、json.dumps()</p>
<p>@app.route(‘/‘)<br>def index():<br>    data = {<br>        ‘name’:’lili’,<br>        ‘age’:’18’<br>    }<br>    # return data # 不能返回字典<br>    return json.dumps(data)</p>
<p>查看响应信息（Content-Type：响应内容的类型）：</p>
<p>json.dumps() 返回的是： Content-Type:text/html </p>
<p>2、jsonify</p>
<pre><code>@app.route(&#39;/&#39;)
def index():
    data = &#123;
        &#39;name&#39;:&#39;lili&#39;,
        &#39;age&#39;:&#39;18&#39;
    &#125;
    # jsonify的作用，就是把字典转成json字符串。
    return jsonify(data)
</code></pre>
<p>查看响应信息：</p>
<p>jsonify() 返回的是：Content-Type: application/json</p>
<p>都是返回的json字符串（内容本质没有发生变化，只是外层包装不同），而json.dumps()就显得有些言不符实了。</p>
<h1 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h1><p>json：基于键值对的字符串，本质是字符串，但不是数据类型。</p>
<p>另外，python的json模块还有dump()和load()两个方法，他们作用相同，但又与dumps和loads有些区别：</p>
<p>json.dump()和json.load()，操作的是文件对象(具有read和write方法的对象，存在硬盘中)</p>
<h1 id="附：完整代码供测试"><a href="#附：完整代码供测试" class="headerlink" title="附：完整代码供测试"></a>附：完整代码供测试</h1><pre><code>from flask import Flask,jsonify
import json
 
 
app = Flask(__name__)
 
@app.route(&#39;/&#39;)
def index():
    data = &#123;
        &#39;name&#39;:&#39;lili&#39;,
        &#39;age&#39;:&#39;18&#39;
    &#125;
    # return data # 不能返回字典
    
    # return json.dumps(data)
    return jsonify(data)
 
 
if __name__ == &#39;__main__&#39;:
    app.run(debug=True)
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「高岩_deal」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mydistance/article/details/83960333">https://blog.csdn.net/mydistance/article/details/83960333</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例07--jsonify</title>
    <url>/2023/08/24/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jsonify：Python中处理JSON数据的工具</p>
<h1 id="一、jsonify函数"><a href="#一、jsonify函数" class="headerlink" title="一、jsonify函数"></a>一、jsonify函数</h1><p>jsonify函数是Flask框架中的一个函数，用于返回一个包含JSON数据的响应体(Response Body)，其主要作用是将Python任意的数据类型转换为JSON格式的数据并返回给前端。jsonify函数将数据序列化为JSON格式的字符串，并设置响应的Content-Type为application/json。</p>
<pre><code>from flask import jsonify

@app.route(&#39;/json/&#39;)
def get_json():
    data = &#123;&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125;
    return jsonify(data)
</code></pre>
<p>在实际开发中，我们会将数据从数据库中查询出来，然后通过jsonify函数将数据转换为JSON格式的字符串，并返回给前端使用。</p>
<h1 id="二、jsonify-flask"><a href="#二、jsonify-flask" class="headerlink" title="二、jsonify flask"></a>二、jsonify flask</h1><p>jsonify函数是Flask框架中的一个函数，用于返回一个包含JSON数据的响应体(Response Body)。一般情况下，我们会将数据从数据库中查询出来，然后通过jsonify函数将数据转换为JSON格式的字符串，并返回给前端使用。</p>
<p>举个例子：假设我们要查询数据库中用户信息，并返回JSON格式数据，那么代码如下：</p>
<pre><code>from flask import Flask, jsonify

app = Flask(__name__)

@app.route(&#39;/user/&#39;)
def get_user():
    user = &#123;&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125;
    return jsonify(user)

if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre>
<h1 id="三、jsonify怎么读"><a href="#三、jsonify怎么读" class="headerlink" title="三、jsonify怎么读"></a>三、jsonify怎么读</h1><p>jsonify函数的读音为[juh-son-if-ahy]，其中juh-son代表JSON，if代表format，ahy代表-y。</p>
<h1 id="四、jsonify怎么用"><a href="#四、jsonify怎么用" class="headerlink" title="四、jsonify怎么用"></a>四、jsonify怎么用</h1><p>jsonify函数非常容易使用，只需要将数据作为参数传递给该函数，函数会自动将数据转换为JSON格式的字符串，并返回给前端。</p>
<p>使用示例：</p>
<pre><code>from flask import jsonify

data = &#123;&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125;
json_str = jsonify(data)

print(json_str)
</code></pre>
<h1 id="五、jsonify是什么"><a href="#五、jsonify是什么" class="headerlink" title="五、jsonify是什么"></a>五、jsonify是什么</h1><p>jsonify是Flask框架中的一个函数，用于返回一个包含JSON数据的响应体(Response Body)，其主要作用是将Python任意的数据类型转换为JSON格式的数据并返回给前端。jsonify函数将数据序列化为JSON格式的字符串，并设置响应的Content-Type为application/json。</p>
<h1 id="六、jsonify多转义"><a href="#六、jsonify多转义" class="headerlink" title="六、jsonify多转义"></a>六、jsonify多转义</h1><p>由于JSON中有些特殊字符需要进行转义处理，如双引号、反斜杠等。当我们使用json.dumps()将Python数据类型转换成JSON格式字符串时，JSON字符串中的特殊字符已经被转义，但使用jsonify()函数时，需要手动进行转义。</p>
<p>举个例子：</p>
<pre><code>from flask import jsonify

data = &#123;&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;, &#39;info&#39;: &#39;I\&#39;m a good student.&quot;&#39;&#125;
json_str = jsonify(data)
print(json_str)
</code></pre>
<h1 id="七、json格式"><a href="#七、json格式" class="headerlink" title="七、json格式"></a>七、json格式</h1><p>JSON（JavaScript Object Notation，JavaScript 对象表示法）是一种轻量级的数据交换格式。JSON格式的数据由两部分组成：键和值，键值之间使用冒号：分隔。</p>
<p>举个例子：</p>
<pre><code>&#123;
    &quot;name&quot;: &quot;小明&quot;,
    &quot;age&quot;: 18,
    &quot;sex&quot;: &quot;male&quot;
&#125;
</code></pre>
<h1 id="八、json解析"><a href="#八、json解析" class="headerlink" title="八、json解析"></a>八、json解析</h1><p>JSON解析是将JSON格式的字符串转换为Python数据类型的过程。</p>
<p>举个例子：</p>
<pre><code>import json

json_str = &#39;&#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18, &quot;sex&quot;: &quot;male&quot;&#125;&#39;
data = json.loads(json_str)
print(data)
</code></pre>
<p>上面的代码将JSON格式的字符串解析为Python数据类型，输出结果为：</p>
<pre><code>&#123;&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125;
</code></pre>
<h1 id="九、json数据格式"><a href="#九、json数据格式" class="headerlink" title="九、json数据格式"></a>九、json数据格式</h1><p>JSON数据格式是一种轻量级的数据交换格式，由键和值以及逗号分隔组成。JSON数据格式支持包括数字、字符串、布尔值、数组、对象等多种数据类型。</p>
<p>举个例子：</p>
<pre><code>&#123;
    &quot;name&quot;: &quot;小明&quot;,
    &quot;age&quot;: 18,
    &quot;sex&quot;: &quot;male&quot;,
    &quot;hobbies&quot;: [&quot;basketball&quot;, &quot;football&quot;],
    &quot;family&quot;: &#123;
        &quot;father&quot;: &quot;张三&quot;,
        &quot;mother&quot;: &quot;李四&quot;
    &#125;
&#125;
</code></pre>
<h1 id="十、json文件是干什么的"><a href="#十、json文件是干什么的" class="headerlink" title="十、json文件是干什么的"></a>十、json文件是干什么的</h1><p>JSON文件用于存储和交换数据，它是一种轻量级的数据交换格式。与其他数据存储格式相比，JSON文件更加简洁、易读、易解析，并且具有跨语言、跨平台的特性，因此被广泛应用于Web开发、移动端开发等领域。</p>
<p>举个例子：假设我们要存储用户信息，可以将用户信息以JSON格式保存到文件中，代码如下：</p>
<pre><code>import json

data = &#123;&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125;
with open(&#39;user.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
    json.dump(data, f)
</code></pre>
<p>上面的代码将用户信息以JSON格式保存到文件中。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>el-form表单重置resetForm()不生效问题</title>
    <url>/2023/08/23/el-form%E8%A1%A8%E5%8D%95%E9%87%8D%E7%BD%AEresetForm()%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字段不清空 或者完全没效果<br>检查：</p>
<p>1、el-form 是否绑定model,带有ref,并且绑定的是同一数组。</p>
<pre><code>&lt;el-form :rules=&quot;rules&quot; ref=&quot;form&quot; :model=&quot;form&quot;&gt;
</code></pre>
<p>2、el-form-item绑定prop,且名称要与v-model绑定的参数一致。</p>
<el-form-item label="商品状态" prop="enabled">
    <el-radio-group v-model="form.enabled">
        <el-radio label="true">上架</el-radio>
        <el-radio label="false">下架</el-radio>
    </el-radio-group>
</el-form-item>

<pre><code>&lt;el-form-item label=&quot;商品名称&quot; prop=&quot;name&quot;&gt;
    &lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;请输入商品名称&quot;&gt;&lt;/el-input&gt;
&lt;/el-form-item&gt;
</code></pre>
<p>然后使用校验</p>
<pre><code>this.$refs[form].resetFields();
</code></pre>
<p>3、如果是在el-dialog里，检查el-dialog的关闭弹窗事件与取消事件是否相同</p>
<p>4、还不生效可以使用$nextTick</p>
<pre><code>this.$nextTick(() =&gt; &#123;
    this.$refs[form].resetFields();
&#125;);
 
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「qfCSDN」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qfCSDN/article/details/120505846">https://blog.csdn.net/qfCSDN/article/details/120505846</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中Vue.prototype使用详解</title>
    <url>/2023/08/22/Vue%E4%B8%ADVue.prototype%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们可能会在很多组件里用到数据/实用工具，但是不想污染全局作用域。这种情况下，可以通过在原型上定义它们使其在每个 Vue 的实例中可用。</p>
<h1 id="1-基本示例"><a href="#1-基本示例" class="headerlink" title="1. 基本示例"></a>1. 基本示例</h1><p>在main.js中添加一个变量到 Vue.prototype</p>
<pre><code>Vue.prototype.$appName = &#39;My App&#39;
</code></pre>
<p>这样 $appName 就在所有的 Vue 实例中可用了，甚至在实例被创建之前就可以</p>
<pre><code>new Vue(&#123;
  beforeCreate: function () &#123;
    console.log(this.$appName)
  &#125;
&#125;)
</code></pre>
<p>控制台会打印出 My App，就这么简单！</p>
<h1 id="2-为实例prototype设置作用域"><a href="#2-为实例prototype设置作用域" class="headerlink" title="2. 为实例prototype设置作用域"></a>2. 为实例prototype设置作用域</h1><p>为什么 appName 要以$开头？这很重要吗？这里没有什么魔法。<br>$是在 Vue 所有实例中都可用的 property 的一个简单约定。这样做会避免和已被定义的数据、方法、计算属性产生冲突。<br>如果我们设置：</p>
<pre><code>Vue.prototype.appName = &#39;My App&#39;
</code></pre>
<p>那么如下的代码输出什么：</p>
<pre><code>new Vue(&#123;
  data: &#123;
    // 啊哦，`appName` 也是一个我们定义的实例 property 名！
    appName: &#39;The name of some other app&#39;
  &#125;,
  beforeCreate: function () &#123;
    console.log(this.appName)
  &#125;,
  created: function () &#123;
    console.log(this.appName)
  &#125;
&#125;)
</code></pre>
<p>日志中会先出现 “My App”，然后出现 “The name of some other app”，因为 this.appName 在实例被创建之后被 data 覆写了。我们通过 为实例property设置作用域来避免这种事情发生。你还可以根据你的喜好使用自己的约定，诸如为实例 property 设置作用域来避免这种事情发生。 </p>
<p>你还可以根据你的喜好使用自己的约定，诸如为实例property设置作用域来避免这种事情发生。你还可以根据你的喜好使用自己的约定，诸如_appName 或 ΩappName，来避免和插件或未来的插件相冲突。</p>
<h1 id="3-注册和使用全局变量"><a href="#3-注册和使用全局变量" class="headerlink" title="3. 注册和使用全局变量"></a>3. 注册和使用全局变量</h1><p>每个组件都是一个vue实例，Vue.prototype加一个变量，只是给每个组件加了一个属性，这个属性的值并不具有全局性。<br>比如以下例子：</p>
<pre><code>// main.js
import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import router from &#39;./router&#39;
import store from &#39;./store&#39;
 
Vue.config.productionTip = false
Vue.prototype.$appName = &#39;main&#39;
 
new Vue(&#123;
    el: &#39;#app&#39;,
    store,
    router,
    components: &#123; App &#125;,
    template: &#39;&lt;App/&gt;&#39;,
&#125;)
 
// 给所有组件注册了一个属性 $appName，赋予初始值 &#39;main&#39; ，所有组件都可以用 this.$appName 访问此变量;
// 如果组件中没有赋值，初始值都是&#39;main&#39;

// home.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;div @click=&quot;changeName&quot;&gt;change name&lt;/div&gt;
    &lt;div @click=&quot;gotoTest2&quot;&gt;goto test2&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default &#123;
  methods:&#123;
    changeName()&#123;
      this.$appName = &quot;test1&quot;
    &#125;,
    gotoTest2()&#123;
      this.$router.push(&#39;/about&#39;)
    &#125; 
  &#125;
&#125;
&lt;/script&gt;

// about.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;&#123;&#123;this.$appName&#125;&#125; in test2&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>点击 home 中的 change name 再跳转about，about里面还是显示 main in test2<br>如果要实现全局变量的功能，需要把属性变为引用类型</p>
<pre><code>Vue.prototype.$appName = &#123; name: &#39;main&#39; &#125;
</code></pre>
<p>后面使用 this.$appName.name 改变和引用相应的值<br>这进入 about 后显示 test1 in test2</p>
<h1 id="4-原型方法的上下文"><a href="#4-原型方法的上下文" class="headerlink" title="4. 原型方法的上下文"></a>4. 原型方法的上下文</h1><p>在 JavaScript 中一个原型的方法会获得该实例的上下文,也就是说可以使用 this 访问：数据、计算属性、方法或其它任何定义在实例上的东西。<br>让我们将其用在一个名为 $reverseText 的方法上：</p>
<pre><code>// main.js
Vue.prototype.$reverseText = function (propertyName) &#123;
  this[propertyName] = this[propertyName]
    .split(&#39;&#39;)
    .reverse()
    .join(&#39;&#39;)
&#125;

// 相应组件
&lt;script&gt;
export default &#123;
  data() &#123;
    return&#123;
      message: &#39;Hello&#39;
    &#125;
  &#125;,
  created() &#123;
    console.log(this.message) // =&gt; &quot;Hello&quot;
    this.$reverseText(&#39;message&#39;)
    console.log(this.message) // =&gt; &quot;olleH&quot;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h1 id="5-应用示例"><a href="#5-应用示例" class="headerlink" title="5. 应用示例"></a>5. 应用示例</h1><h2 id="5-1-引入-axios"><a href="#5-1-引入-axios" class="headerlink" title="5.1 引入 axios"></a>5.1 引入 axios</h2><p>安装</p>
<pre><code>npm install vue-axios --save
npm install qs.js --save//它的作用是能把json格式的直接转成data所需的格式
</code></pre>
<p>代码</p>
<pre><code>// mian.js
import Vue from &#39;vue&#39;
import axios from &#39;axios&#39;
import qs from &#39;qs&#39;
 
Vue.prototype.$axios = axios    //全局注册，使用方法为:this.$axios
Vue.prototype.qs = qs           //全局注册，使用方法为:this.qs
 
// 相应组件
&lt;script&gt;
  export default&#123;
    data()&#123;
      return&#123;
        userId:666,
        token:&#39;&#39;,
      &#125;
    &#125;,
    created()&#123;
      this.$axios(&#123;
        method:&#39;post&#39;,
        url:&#39;api&#39;,
        data:this.qs.stringify(&#123;    //这里是发送给后台的数据
          userId:this.userId,
          token:this.token,
        &#125;)
      &#125;).then((response) =&gt;&#123;          //这里使用了ES6的语法
        console.log(response)       //请求成功返回的数据
      &#125;).catch((error) =&gt;&#123;
        console.log(error)       //请求失败返回的数据
      &#125;)
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<h1 id="6、Vue-prototype、Vue-component和Vue-use区别"><a href="#6、Vue-prototype、Vue-component和Vue-use区别" class="headerlink" title="6、Vue.prototype、Vue.component和Vue.use区别"></a>6、Vue.prototype、Vue.component和Vue.use区别</h1><h2 id="1、Vue-prototype"><a href="#1、Vue-prototype" class="headerlink" title="1、Vue.prototype"></a>1、Vue.prototype</h2><p>在多个地方都需要使用但不想污染全局作用域的情况下，这样定义，在每个 Vue 实例中都可用。<br>参考：<a href="https://cn.vuejs.org/v2/cookbook/adding-instance-properties.html">https://cn.vuejs.org/v2/cookbook/adding-instance-properties.html</a><br>$ 表示这是一个在 Vue 所有实例中都可用的属性<br>常用于方法、变量等</p>
<pre><code>import echarts from &#39;echarts&#39;
Vue.prototype.$echarts = echarts 
</code></pre>
<h2 id="2、vue-component"><a href="#2、vue-component" class="headerlink" title="2、vue.component"></a>2、vue.component</h2><p>全局注册组件，<br>第一个参数是调用组件时写的组件名<br>第二个参数是引入组件时写的名称<br>可用于注册自定义组件</p>
<pre><code>import myLoading from &#39;base/loading&#39;
Vue.component(&#39;myLoading&#39;,myLoading);
</code></pre>
<h2 id="3、Vue-use"><a href="#3、Vue-use" class="headerlink" title="3、Vue.use"></a>3、Vue.use</h2><p>同样是全局注册，和component的区别是接收的参数必须有install方法<br>常用于注册第三方插件</p>
<pre><code>import ElementUI from &#39;element-ui&#39;;
Vue.use(ElementUI);
</code></pre>
<p>到此这篇关于Vue中 Vue.prototype使用详解的文章就介绍到这了</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex 布局教程</title>
    <url>/2023/08/21/Flex%20%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是弹性布局？"><a href="#什么是弹性布局？" class="headerlink" title="什么是弹性布局？"></a>什么是弹性布局？</h1><p>弹性布局（Flex布局）是一种现代的CSS布局方式，通过使用display: flex属性来创建一个弹性容器，并在其中使用灵活的盒子模型来进行元素的排列和定位。</p>
<h1 id="弹性布局的特点？"><a href="#弹性布局的特点？" class="headerlink" title="弹性布局的特点？"></a>弹性布局的特点？</h1><p>弹性布局具有以下特点：</p>
<p>*主轴与交叉轴：<br>弹性容器具有主轴（main axis）和交叉轴（cross axis）。默认情况下，主轴是水平方向，交叉轴是垂直方向。</p>
<p>*弹性容器：<br>通过将父元素的display属性设置为flex或inline-flex来创建弹性容器。</p>
<p>*子元素的弹性项目：<br>弹性容器中的每个子元素都成为弹性项目。子元素可以指定各自在主轴和交叉轴上的大小、顺序以及对齐方式等。</p>
<p>*主轴对齐：<br>弹性项目可以在主轴上按照一定比例分配空间，也可以使用justify-content属性定义主轴的对齐方式。</p>
<p>*交叉轴对齐：<br>弹性项目可以在交叉轴上进行对齐，包括顶部对齐、底部对齐、居中对齐等，使用align-items属性定义交叉轴对齐方式。</p>
<p>*换行与自动调整：<br>可控制弹性项目是否换行，并且具备自动调整元素大小的能力。<br>弹性布局简化了网页布局的开发过程，提供了更灵活、响应式的布局方式。它适用于各种屏幕尺寸和设备类型，并能够快速适应不同的布局需求。</p>
<h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<pre><code>.box &#123;
  justify-content: flex-start | flex-end | center | space-between | space-around;
&#125;
</code></pre>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<pre><code>flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
</code></pre>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<pre><code>.box &#123;
  align-items: flex-start | flex-end | center | baseline | stretch;
&#125;
</code></pre>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<pre><code>flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
</code></pre>
<h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p>决定主轴的方向，水平或者垂直</p>
<pre><code>.box &#123;
  flex-direction: row | row-reverse | column | column-reverse;
&#125;

row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。
</code></pre>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>换行不换行以及换行的方向</p>
<pre><code>.box&#123;
  flex-wrap: nowrap | wrap | wrap-reverse;
&#125;

nowrap（默认）：不换行
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。
</code></pre>
<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>以上两种的简写方式</p>
<pre><code>.box &#123;
  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
&#125;
</code></pre>
<h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<pre><code>.box &#123;
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
&#125;

flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
</code></pre>
<h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<pre><code>.item &#123;
  order: &lt;integer&gt;;
&#125;
</code></pre>
<h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<pre><code>.item &#123;
  flex-grow: &lt;number&gt;; /* default 0 */
&#125;
</code></pre>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<pre><code>.item &#123;
  flex-shrink: &lt;number&gt;; /* default 1 */
&#125;
</code></pre>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<pre><code>.item &#123;
  flex-basis: &lt;length&gt; | auto; /* default auto */
&#125;
</code></pre>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<pre><code>.item &#123;
  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]
&#125;
</code></pre>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<pre><code>.item &#123;
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
&#125;
</code></pre>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「奶糖 肥晨」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_48998573/article/details/131240067">https://blog.csdn.net/weixin_48998573/article/details/131240067</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue按钮居中居左居右</title>
    <url>/2023/08/20/Vue%E6%8C%89%E9%92%AE%E5%B1%85%E4%B8%AD%E5%B1%85%E5%B7%A6%E5%B1%85%E5%8F%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Vue 中,如果需要将按钮居中显示,可以使用 CSS 中的 <code>text-align: center</code> 属性来实现。</p>
<h1 id="一、按钮居中"><a href="#一、按钮居中" class="headerlink" title="一、按钮居中"></a>一、按钮居中</h1><p>在 Vue 中，如果需要将按钮居中显示，可以使用 CSS 中的 <code>text-align: center</code> 属性来实现。</p>
<p>例如，可以在按钮所在的容器元素上添加 <code>text-align: center</code> 样式：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;button-container&quot;&gt;
    &lt;el-button type=&quot;primary&quot;&gt;提交&lt;/el-button&gt;
    &lt;el-button&gt;取消&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
  
&lt;style&gt;
.button-container &#123;
  text-align: center;
&#125;
&lt;/style&gt;
</code></pre>
<p>上面的代码中，我们在按钮所在的容器元素上添加了 <code>text-align: center</code> 样式，来实现按钮居中显示。</p>
<p>另外，还可以使用 Flex 布局来实现。例如，将按钮所在的容器元素设置为 Flex 容器，并使用 <code>justify-content: center</code> 属性来实现水平居中显示。示例如下：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;button-container&quot;&gt;
    &lt;el-button type=&quot;primary&quot;&gt;提交&lt;/el-button&gt;
    &lt;el-button&gt;取消&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
  
&lt;style&gt;
.button-container &#123;
  display: flex;
  justify-content: center;
&#125;
&lt;/style&gt;
</code></pre>
<p>上面的代码中，我们将按钮所在的容器元素设置为 Flex 容器，并使用 <code>justify-content: center</code> 属性来实现水平居中显示。</p>
<h1 id="二、按钮居右"><a href="#二、按钮居右" class="headerlink" title="二、按钮居右"></a>二、按钮居右</h1><p>在 Vue 中，可以使用 flex 布局来实现按钮居右的效果。具体步骤如下：</p>
<p>在按钮父元素上添加 display: flex; justify-content: flex-end; 样式，将子元素沿着横轴方向向右对齐。</p>
<pre><code>&lt;div class=&quot;button-wrapper&quot;&gt;
  &lt;button&gt;按钮&lt;/button&gt;
&lt;/div&gt;

.button-wrapper &#123;
  display: flex;
  justify-content: flex-end;
&#125;
</code></pre>
<p>在按钮上添加 margin-left 样式，控制按钮与其左边兄弟元素之间的距离。</p>
<pre><code>&lt;div class=&quot;button-wrapper&quot;&gt;
  &lt;span&gt;左边的元素&lt;/span&gt;
  &lt;button class=&quot;right-btn&quot;&gt;按钮&lt;/button&gt;
&lt;/div&gt;

.button-wrapper &#123;
  display: flex;
  justify-content: flex-end;
&#125;
.right-btn &#123;
  margin-left: 10px; /* 调整按钮与左边元素之间的距离 */
&#125;
</code></pre>
<p>这样就可以将按钮居右了。如果有多个元素需要靠右对齐，只需要将它们包裹在一个父元素中，并且在父元素上应用 display: flex; justify-content: flex-end; 样式即可。</p>
<h1 id="三、按钮居左"><a href="#三、按钮居左" class="headerlink" title="三、按钮居左"></a>三、按钮居左</h1><p>1、方法1<br>在 Vue 中，可以使用 flex 布局来实现按钮居左的效果。具体步骤如下：</p>
<p>在按钮父元素上添加 display: flex; 样式，启用 flex 布局。</p>
<pre><code>&lt;div class=&quot;button-wrapper&quot;&gt;
  &lt;button class=&quot;left-btn&quot;&gt;按钮&lt;/button&gt;
&lt;/div&gt;

.button-wrapper &#123;
  display: flex;
&#125;
</code></pre>
<p>在按钮上添加 margin-right 样式，控制按钮与其右边兄弟元素之间的距离。</p>
<pre><code>&lt;div class=&quot;button-wrapper&quot;&gt;
  &lt;button class=&quot;left-btn&quot;&gt;按钮&lt;/button&gt;
  &lt;span&gt;右边的元素&lt;/span&gt;
&lt;/div&gt;

.button-wrapper &#123;
  display: flex;
&#125;
.left-btn &#123;
  margin-right: 10px; /* 调整按钮与右边的元素之间的距离 */
&#125;
</code></pre>
<p>这样就可以将按钮居左了。如果有多个元素需要靠左对齐，只需要将它们包裹在一个父元素中，并且在父元素上应用 display: flex; 样式即可。使用 flex 布局时，元素的位置由 order 属性控制，而子元素的位置是由它们在父元素中出现的顺序决定的，因此靠前的元素会出现在靠左的位置。如果需要调整元素的位置，只需要在它的样式中添加 order 属性即可。</p>
<p>2、方法2<br>在 Vue 中，可以通过给按钮元素添加 float: left; 样式来实现按钮居左的效果。具体步骤如下：</p>
<pre><code>&lt;div class=&quot;button-container&quot;&gt;
  &lt;button class=&quot;left-btn&quot;&gt;按钮&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>这样就可以将按钮居左了。如果按钮元素的父元素中还有其它元素，为避免按钮影响其他元素的布局，可以在父元素上添加 overflow: auto; 样式，使其包含浮动元素的布局上下文，从而避免对其它元素造成影响。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas实用入门案例03</title>
    <url>/2023/08/19/Pandas%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Python之Pandas的常用技能【索引的增、删、改、查】</p>
<p>1、索引简介<br>索引（index）是数据处理中非常重要的工具。索引主要用来：</p>
<p>1）标记数据；2）快速检索数据；</p>
<p>Pandas中的索引，有两种：1）index（行索引）；2）columns（列索引）；</p>
<p>数据准备</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
print(df)
</code></pre>
<p>2、设置索引的常用方法<br>2.1 读取数据时设置索引</p>
<pre><code>import pandas as pd
#读取数据，同时，使用index_col选取第一列作为索引列。
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3,index_col=0)
print(df)
</code></pre>
<p>2.2 查看索引相关信息<br>2.2.1 df.index</p>
<pre><code>import pandas as pd
#读取数据时，设置了index
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3,index_col=1)
print(df)
print(&#39;\n&#39;)
print(df.index)
</code></pre>
<p>2.3 设置索引列的名称<br>2.3.1 df.rename_axis()</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
print(df)
print(&#39;\n&#39;)
df = df.rename_axis(&#39;index_col&#39;)
print(df)
</code></pre>
<p>2.3.2 df.index.name</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
print(df)
print(&#39;\n&#39;)
df.index.name = &#39;index_col&#39;
print(df)
</code></pre>
<p>2.3.3 df.index.names = []</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
#set_index()是设置索引列，reset_index()可以将索引列变成数据列。
df = df.set_index(keys=[&#39;id&#39;,&#39;name&#39;],drop=True,append=True)
df_new = df.reset_index(level=1,drop=False)
print(df_new)
print(&#39;\n&#39;)
df_new.index.names = [&#39;x&#39;,&#39;y&#39;]
print(df_new)
</code></pre>
<p>2.3.4 df.columns=values</p>
<pre><code>import pandas as pd
#先设置多级别index
index = pd.MultiIndex.from_tuples([(&#39;girl&#39;,&#39;Lucy&#39;),
                                    (&#39;girl&#39;,&#39;Rose&#39;),
                                    (&#39;boy&#39;,&#39;Tom&#39;),
                                   (&#39;boy&#39;,&#39;Jack&#39;),

                                   ],
                                  names=[&#39;gender&#39;,&#39;name&#39;])
#设置columns，一列一个元组，如果是多级别，在一个元组内。
columns = pd.MultiIndex.from_tuples([(&#39;math&#39;,),
                                     (&#39;english&#39;,)])
#构造数据。
df = pd.DataFrame([
    (99,78),
    (87,32),
    (23,89),
    (28,81)
],
index=index,
columns=columns)
print(df)
df.columns=[&#39;数学&#39;,&#39;英语&#39;]
print(&#39;\n&#39;)
print(df)
</code></pre>
<p>2.4 重置索引：df.index=values<br>使用赋值的方法。</p>
<p>【注：重置索引后，不会将原来的索引列作为新的一列保留。】</p>
<pre><code>import pandas as pd
#读取数据,同时，使用index_col选取第一列作为索引列。
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3,index_col=0)
df.index = range(len(df))
print(df)
</code></pre>
<p>2.5 重置索引：df.reset_index()<br>2.5.1 df.reset_index()参数详情</p>
<pre><code>df.reset_index(
level=None, #如果索引有多个层级，仅从索引中删除level指定的列。默认为删除所有的列。
drop=False, #重置索引后，是否将原来的索引列作为新的一列保留。默认为False，即保留。
col_level=0, #如果列有多个级别，确定将这一索引列插入到哪一个级别。默认情况为0，即插入到第一级别。
col_fill=&#39;&#39; ,#确定如何命名其他级别。
inplace=False#是否要用新的DataFrame替换原来的DataFrame，一般默认为False。
)
</code></pre>
<p>2.5.2 修改索引，并保留原来的索引列为新的一列</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3,index_col=0)
#重置索引,会将原来的索引列，变成新的一列。
df_new = df.reset_index()
print(df,df_new,sep=&#39;\n&#39;)
</code></pre>
<p>2.5.3 删除索引：将索引的列的第二列，变成数据列的第二列</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
#先用set_index()增加几个索引
df = df.set_index(keys=[&#39;id&#39;,&#39;name&#39;],drop=True,append=True)
print(df)
</code></pre>
<p>使用df.reset_index（）将id列变成数据列</p>
<pre><code>import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
#set_index()是设置索引列，reset_index()可以将索引列变成数据列。
df = df.set_index(keys=[&#39;id&#39;,&#39;name&#39;],drop=True,append=True)
df_new = df.reset_index(level=1,drop=False)
print(df,df_new,sep=&#39;\n&#39;)
</code></pre>
<p>2.5.4 多级别索引的处理</p>
<p>1）使用MultiIndex构造多级别索引</p>
<pre><code>import pandas as pd
#先设置多级别index
index = pd.MultiIndex.from_tuples([(&#39;girl&#39;,&#39;Lucy&#39;),
                                    (&#39;girl&#39;,&#39;Rose&#39;),
                                    (&#39;boy&#39;,&#39;Tom&#39;),
                                   (&#39;boy&#39;,&#39;Jack&#39;),

                                   ],
                                  names=[&#39;gender&#39;,&#39;name&#39;])
#设置columns，一列一个元组，如果是多级别，在一个元组内。
columns = pd.MultiIndex.from_tuples([(&#39;math&#39;,),
                                     (&#39;english&#39;,)])
#构造数据。
df = pd.DataFrame([
    (99,78),
    (87,32),
    (23,89),
    (28,81)
],
index=index,
columns=columns)
print(df)
</code></pre>
<p>将索引”gender”当成数据列。</p>
<pre><code>df = df.reset_index(level=&#39;gender&#39;)
print(df)
</code></pre>
<p>2.6 重置索引：df.set_index()<br>2.6.1 df.set_index()参数详解</p>
<pre><code>df.set_index(
keys, #要设置索引的列名。
drop=True, #将设置索引的列删除，默认为True，即不保留。
append=False, #是否保留原索引。默认为False。
inplace=False, #是否在替换原来的DataFrame。默认为False。
verify_integrity=False#是否检查索引有无重复，默认为False。
)


import pandas as pd
#读取数据
df = pd.read_excel(r&#39;C:\Users\XXXXXX\Desktop\pandas练习文档.xlsx&#39;,sheet_name=3)
#先用set_index()增加几个索引
df = df.set_index(keys=[&#39;id&#39;,&#39;name&#39;],drop=False,append=True)
print(df)
</code></pre>
<p>2.7 重置索引：df.reindex()<br>2.7.1 df.reindex()参数详解</p>
<p>【注：这个参数对其中某些值如method，即使按照官网上的操作，还是报错。我也没弄特别清楚】</p>
<pre><code>pandas.DataFrame.reindex &amp;#8212; pandas 1.5.2 documentation

df.reindex(
keywords for axes, #列标签，行标签。即index=,columns等。
method=None, #默认为None。针对填入的数据是向前，向后，向左，还是向右。&#123;None， &#39;backfill&#39;/&#39;bfill&#39;， &#39;pad&#39;/&#39;ffill&#39;， &#39;nearest&#39;&#125;
copy=True, 
level=None, #多级别索引时使用。
fill_value=nan, #一般默认填入NaN。可以设置。
limit=None, #向前或向后填入的最大连续数。
tolerance=None
</code></pre>
<p>2.7.2 基本用法</p>
<pre><code>import pandas as pd
df = pd.DataFrame([
    (99,78),
    (87,32),
    (23,89),
    (28,81)
])
print(df)

print(&#39;\n&#39;)
#使用df.reindex()重新赋值索引。
df = df.reindex([0,&#39;B&#39;,3,&#39;D&#39;])
print(df)

fill_value的使用

import pandas as pd
df = pd.DataFrame([
    (99,78),
    (87,32),
    (23,89),
    (28,81)
])
print(df)

print(&#39;\n&#39;)
#使用df.reindex()重新赋值索引。
df = df.reindex([0,&#39;B&#39;,3,&#39;D&#39;],fill_value=&#39;--&#39;)
print(df)
</code></pre>
<p>修改columns</p>
<pre><code>import pandas as pd
df = pd.DataFrame([
    (99,78),
    (87,32),
    (23,89),
    (28,81)
],columns=[&#39;math&#39;,&#39;english&#39;])
print(df)

print(&#39;\n&#39;)
#使用df.reindex()重新赋值索引。
df = df.reindex(columns=[&#39;math&#39;,&#39;english&#39;,&#39;music&#39;],fill_value=&#39;100&#39;)
#或者使用
print(df)
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas实用入门案例02</title>
    <url>/2023/08/18/Pandas%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Pandas中，DataFrame是一个非常重要的数据结构，在对DataFrame进行遍历的同时修改其单元格内容是常见的需求。本文介绍几种在Pandas中遍历DataFrame并修改单元格的方法。</p>
<p>.loc按标签选择<br>可以使用<code>.loc</code>按行标签和列标签选择单元格，然后赋值:</p>
<pre><code>for row in df.index:
    for col in df.columns:
        df.loc[row， col] = new_value
</code></pre>
<p>.iloc按位置选择<br>使用<code>.iloc</code>按整数位置选择单元格，然后赋值: </p>
<pre><code>for row in range(df.shape[0]):
    for col in range(df.shape[1]):
        df.iloc[row， col] = new_value
</code></pre>
<p>.itertuples()遍历行<br>通过<code>.itertuples()</code>遍历行，然后修改指定列:</p>
<pre><code>for row in df.itertuples():
    df.at[row.Index， &#39;col1&#39;] = new_value
</code></pre>
<p>.apply()批量修改<br>通过<code>.apply()</code>在轴上应用函数进行批量修改:   </p>
<pre><code>df[[&#39;col1&#39;，&#39;col2&#39;]] = df[[&#39;col1&#39;，&#39;col2&#39;]].apply(lambda x: new_value， axis=1)
</code></pre>
<p>.iterrows()遍历行<br>通过<code>.iterrows()</code>同时遍历行标签和行值，然后修改:</p>
<pre><code>for label， row in df.iterrows():
    df.at[label， &#39;col1&#39;] = new_value
</code></pre>
<p>举个例子，有这样一个DataFrame:</p>
<pre><code>   |   col1 |  col2 | 
:--|:--|:-- 
0 |   1    |   4
1 |   2    |   5 
2 |   3    |   6
</code></pre>
<p>可以这样同时遍历和修改:</p>
<pre><code>for row in df.index:
    for col in df.columns:
        if col == &#39;col1&#39; and row == 2:
            df.loc[row， col] = 10  
</code></pre>
<p>结果为:</p>
<pre><code>   |  col1 |  col2 | 
:--|:--|:--
0 |   1   |   4
1 |   2   |   5
2 |  10   |   6
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「devid008」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/devid008/article/details/131060034">https://blog.csdn.net/devid008/article/details/131060034</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas实用入门案例01</title>
    <url>/2023/08/17/Pandas%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="遍历DataFrame的三种方法"><a href="#遍历DataFrame的三种方法" class="headerlink" title="遍历DataFrame的三种方法"></a>遍历DataFrame的三种方法</h1><p>iteritem()方法返回一个&lt;class ‘method’&gt;数据,可利用for循环获得输出<br>iterrow()方法返回一个&lt;class ‘generator’&gt;数据,可利用for循环获得输出<br>itertuple()方法返回一个&lt;class ‘pandas.core.frame.Pandas’&gt;数据,可利用getattr(row,‘列索引’)方法获得对应数据</p>
<h1 id="演示数据准备"><a href="#演示数据准备" class="headerlink" title="演示数据准备"></a>演示数据准备</h1><pre><code>data = &#123;&#39;state&#39;:[&#39;Ohio&#39;,&#39;Ohio&#39;,&#39;Ohio&#39;,&#39;Nevada&#39;,&#39;Nevada&#39;,&#39;Nevada&#39;],
&#39;year&#39;:[2000,2001,2002,2003,2004,2005],
&#39;pop&#39;:[1.5,1.7,3.6,2.4,2.9,3.2]&#125;
frame = pd.DataFrame(data)
</code></pre>
<h1 id="1、遍历方法"><a href="#1、遍历方法" class="headerlink" title="1、遍历方法"></a>1、遍历方法</h1><h2 id="按列遍历"><a href="#按列遍历" class="headerlink" title="按列遍历"></a>按列遍历</h2><pre><code>column_indexs = []
for column_index, row_data in frame.iteritems():
    column_indexs.append(column_index)
    print(row_data)
print(column_indexs)
</code></pre>
<h2 id="按行遍历"><a href="#按行遍历" class="headerlink" title="按行遍历"></a>按行遍历</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><pre><code>row_indexs = []
for index, row in frame.iterrows():
    row_indexs.append(index)
    print(row)
print(row_indexs)
</code></pre>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><pre><code>for row in frame.itertuples():
    print(getattr(row, &#39;state&#39;), getattr(row, &#39;year&#39;), getattr(row, &#39;pop&#39;))
    print(type(row))
    
</code></pre>
<h1 id="2、遍历DataFrame某一列-行-数据"><a href="#2、遍历DataFrame某一列-行-数据" class="headerlink" title="2、遍历DataFrame某一列(行)数据"></a>2、遍历DataFrame某一列(行)数据</h1><h2 id="获取frame的index属性-然后使用frame-列索引-get-行索引-获得对应的值"><a href="#获取frame的index属性-然后使用frame-列索引-get-行索引-获得对应的值" class="headerlink" title="获取frame的index属性,然后使用frame[列索引].get(行索引)获得对应的值"></a>获取frame的index属性,然后使用frame[列索引].get(行索引)获得对应的值</h2><pre><code>print(frame.columns)
for index in frame.index:
    print(frame[&#39;state&#39;].get(index))
for index in frame.index:
    print(frame[&#39;state&#39;][index])
for index in frame.index:
    print(frame.get(&#39;state&#39;).get(index))
</code></pre>
<h2 id="获取frame的column属性-然后使用frame-列索引-get-行索引-获得对应的值"><a href="#获取frame的column属性-然后使用frame-列索引-get-行索引-获得对应的值" class="headerlink" title="获取frame的column属性,然后使用frame[列索引].get(行索引)获得对应的值"></a>获取frame的column属性,然后使用frame[列索引].get(行索引)获得对应的值</h2><pre><code>print(frame.index)
for column in frame.columns:
    print(frame[column].get(0))
    
</code></pre>
<h1 id="3、获取某一个值"><a href="#3、获取某一个值" class="headerlink" title="3、获取某一个值"></a>3、获取某一个值</h1><h2 id="DataFrame-at-行索引-列索引-获取某一个值"><a href="#DataFrame-at-行索引-列索引-获取某一个值" class="headerlink" title="DataFrame.at[行索引,列索引]获取某一个值"></a>DataFrame.at[行索引,列索引]获取某一个值</h2><pre><code>print(frame.at[1,&#39;pop&#39;])
</code></pre>
<h2 id="DataFrame-iat-默认行索引-默认列索引-获取某一个值"><a href="#DataFrame-iat-默认行索引-默认列索引-获取某一个值" class="headerlink" title="DataFrame.iat[默认行索引,默认列索引]获取某一个值"></a>DataFrame.iat[默认行索引,默认列索引]获取某一个值</h2><pre><code>print(frame.iat[1,1])
</code></pre>
<h2 id="DataFrame-loc-行索引-列索引-获取某个值-与at不同的是-只输入某一参数-获得某一行或某一列"><a href="#DataFrame-loc-行索引-列索引-获取某个值-与at不同的是-只输入某一参数-获得某一行或某一列" class="headerlink" title="DataFrame.loc[行索引,列索引]获取某个值,与at不同的是,只输入某一参数,获得某一行或某一列"></a>DataFrame.loc[行索引,列索引]获取某个值,与at不同的是,只输入某一参数,获得某一行或某一列</h2><pre><code>print(frame.loc[1,&#39;pop&#39;])
print(frame.loc[:,&#39;pop&#39;])
print(frame.loc[[1,2]])
print(frame.loc[:,[&#39;state&#39;,&#39;pop&#39;]])
</code></pre>
<h2 id="DataFrame-iloc-默认行索引-默认列索引-获取某个值-与iat不同的是-只输入某一参数-获得某一行或某一列"><a href="#DataFrame-iloc-默认行索引-默认列索引-获取某个值-与iat不同的是-只输入某一参数-获得某一行或某一列" class="headerlink" title="DataFrame.iloc[默认行索引,默认列索引]获取某个值,与iat不同的是,只输入某一参数,获得某一行或某一列:"></a>DataFrame.iloc[默认行索引,默认列索引]获取某个值,与iat不同的是,只输入某一参数,获得某一行或某一列:</h2><pre><code>print(frame.loc[0:2,:])
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例06--跨域</title>
    <url>/2023/08/16/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#场景：<br>问题：跨域问题<br>原因分析：由于前后端分离，服务的端口号不同导致的</p>
<p>#解决方案<br>引入flask_cors，并配置<br>CORS(app, resources=r’/*’)<br>即可解决跨域问题</p>
<pre><code>from flask import Flask
from flask_cors import CORS

app = Flask(__name__)
CORS(app, resources=r&#39;/*&#39;)


@app.route(&#39;/&#39;)
def hello_world():  # put application&#39;s code here
    return &#39;Hello World!&#39;


if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例05--参数解析</title>
    <url>/2023/08/15/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官方文档：<br>（1）尽管 Flask 能够简单地访问请求数据(比如查询字符串或者 POST 表单编码的数据)，验证表单数据仍然很痛苦。Flask-RESTful 内置了支持验证请求数据，它使用了一个类似 argparse 的库。<br>（2）需要注意地是与 argparse 模块不同，reqparse.RequestParser.parse_args() 返回一个 Python 字典而不是一个自定义的数据结构。</p>
<pre><code>from flask import Flask
from flask_restful import reqparse, abort, Api, Resource
 
app = Flask(__name__)
api = Api(app)
 
parser = reqparse.RequestParser()
parser.add_argument(&#39;task&#39;, type=str)
parser.add_argument(&#39;name&#39;, type=str)
 
 
# 获取 &amp; 更新
class Get_Modify(Resource):
 def post(self):
  args = parser.parse_args()
  print(args)
  return args, 201
 
 
api.add_resource(Get_Modify, &#39;/get_modify&#39;)
 
if __name__ == &#39;__main__&#39;:
 app.run(debug=True)
 
</code></pre>
<p>上例中，即使传递其他参数，最终也只会读取定义的2个参数的值<br>通过如上代码说明：reqparse.RequestParser.parse_args()，即如上的args可以获取到request的form表单的参数，最终是一个字典。</p>
<pre><code>from flask import Flask
from flask_restful import reqparse, abort, Api, Resource

app = Flask(__name__)
api = Api(app)

Tasks = &#123;
 &#39;t1&#39;: &#123;&#39;task&#39;: &#39;eat an app&#39;&#125;,
 &#39;t2&#39;: &#123;&#39;task&#39;: &#39;play football&#39;&#125;,
 &#39;t3&#39;: &#123;&#39;task&#39;: &#39;watching TV&#39;&#125;,
&#125;

def abort_if_todo_doesnt_exist(t_id):
 if t_id not in Tasks:
  abort(404, message=&quot;Todo &#123;&#125; doesn&#39;t exist&quot;.format(t_id))


parser = reqparse.RequestParser()
parser.add_argument(&#39;task&#39;, type=str)


# 获取 &amp; 更新
class Get_Modify(Resource):
 def get(self):
  return Tasks

 def post(self):
  args = parser.parse_args()
  t_id = int(max(Tasks.keys()).lstrip(&#39;t&#39;)) + 1
  t_id = &#39;t%i&#39; % t_id
  Tasks[t_id] = &#123;&#39;task&#39;: args[&#39;task&#39;]&#125;
  return Tasks[t_id], 201


# 设置每个视图函数的访问格式
api.add_resource(Get_Modify, &#39;/get_modify&#39;)

if __name__ == &#39;__main__&#39;:
 app.run(debug=True)
</code></pre>
<p>解释：<br>（1）如上的函数，get是获取总的列表Tasks<br>（2）post是添加最新的一个key的值，且key的值是以“t”开头，数字自增的一种形式<br>（3）max(Tasks.keys())这个可以获取到Tasks列表里面，索引最大的key值，在没添加的时候，索引最大为t3<br>（4）x_string.lstrip（‘t’）,这个可以截取x_string字符串里面以’t’开始的剩余字符串。例如t3最终得到3，最终int(max(Tasks.keys()).lstrip(‘t’)) + 1这一行的意思是，得到列表最大的一个key的索引，然后自增到下一个。<br>（5）在希望在form表单里面传递参数，需要在函数里面，使用args = parser.parse_args()接收传递的参数，具体key值通过add_argument函数设置 </p>
<pre><code>from flask import Flask
from flask_restful import reqparse, abort, Api, Resource

app = Flask(__name__)
api = Api(app)

Tasks = &#123;
 &#39;t1&#39;: &#123;&#39;task&#39;: &#39;eat an app&#39;&#125;,
 &#39;t2&#39;: &#123;&#39;task&#39;: &#39;play football&#39;&#125;,
 &#39;t3&#39;: &#123;&#39;task&#39;: &#39;watching TV&#39;&#125;,
&#125;


def abort_if_todo_doesnt_exist(t_id):
 if t_id not in Tasks:
  abort(404, message=&quot;Todo &#123;&#125; doesn&#39;t exist&quot;.format(t_id))


parser = reqparse.RequestParser()
parser.add_argument(&#39;task&#39;, type=str)


# 更新 &amp; 删除 任务
class Updata_Delete(Resource):
 def get(self, t_id):    # 根据t_id获取对应的value
  abort_if_todo_doesnt_exist(t_id)
  return Tasks[t_id]

 def delete(self, t_id):   # 根据t_id删除对应的value
  abort_if_todo_doesnt_exist(t_id)
  del Tasks[t_id]
  return &#39;delete success&#39;, 204

 def post(self, t_id):   # 判断t_id是否存在，并返回Tasks整个列表
  abort_if_todo_doesnt_exist(t_id)
  return Tasks,201

 def put(self, t_id):   # 根据t_id添加对应的value，并返回所有值
  args = parser.parse_args()
  task = &#123;&#39;task&#39;: args[&#39;task&#39;]&#125;
  Tasks[t_id] = task
  return Tasks, 201


api.add_resource(Updata_Delete, &#39;/update_delete/&lt;t_id&gt;&#39;)

if __name__ == &#39;__main__&#39;:
 app.run(debug=True)
 
</code></pre>
<p>解释：<br>（1）通过url传递参数，给视图函数，这种方式一般用在get请求，post请求通过form表单形式比较实用<br>（2）通过url传递参数，需要定义函数时候，使用形参t_id,且在使用add_resource（）函数的使用，url参数形式最后添加<t_id>变量，例如’/update_delete/<t_id>‘这个形式。<br>（3）delete这个函数，最终执行删除是成功的，但是最终并没有返回return的字符串”delete success”，具体原因不详，可能是用法不对，后续再更新中说明.<br>(return ‘delete success’, 204 将 204去掉即可)</t_id></t_id></p>
<p><a href="https://www.jb51.net/article/176172.htm">https://www.jb51.net/article/176172.htm</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例04--endpoint</title>
    <url>/2023/08/14/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在flask框架中，我们经常会遇到endpoint这个东西，最开始也没法理解这个到底是做什么的。最近正好在研究Flask的源码，也就顺带了解了一下这个endpoint<br>首先，我们看一个例子：</p>
<pre><code>@app.route(&#39;/user/&lt;name&gt;&#39;)
def user(name):
  return &#39;Hello, %s&#39; % name
</code></pre>
<p>这个是我们在用flask框架写网站中最常用的。<br>通过看源码，我们可以发现：<br>函数等效于</p>
<pre><code>def user(name)
  return &#39;Hello, %s&#39; % name
</code></pre>
<p>app.add_url_rule(‘/user/<name>‘, ‘user’, user)</name></p>
<p>这个add_url_rule函数在文档中是这样解释的：</p>
<pre><code>add_url_rule(*args, **kwargs)
 Connects a URL rule. Works exactly like the route() decorator. If a view_func is provided it will be registered with the endpoint.
</code></pre>
<p>add_url_rule有如下参数：</p>
<pre><code>rule – the URL rule as string

endpoint – the endpoint for the registered URL rule. Flask itself assumes the name of the view function as endpoint

view_func – the function to call when serving a request to the provided endpoint
options – the options to be forwarded to the underlying Rule object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (GET, POST etc.). By default a rule just listens for GET (and implicitly HEAD). Starting with Flask 0.6, OPTIONS is implicitly added and handled by the standard request handling.
</code></pre>
<p>抛开options这个参数不谈，我们看看前三个参数。</p>
<p>rule：这个参数很简单，就是匹配的路由地址<br>view_func：这个参数就是我们写的视图函数<br>endpoint：这个参数就是我今天重点要讲的，endpoint</p>
<p>很多人认为：假设用户访问<a href="http://www.example.com/user/eric">http://www.example.com/user/eric</a><br>flask会找到该函数，并传递name=’eric’，执行这个函数并返回值。<br>但是实际中，Flask真的是直接根据路由查询视图函数么？<br>在源码中我们可以发现：</p>
<p>每个应用程序app都有一个view_functions，这是一个字典，存储endpoint-view_func键值对。add_url_rule的第一个作用就是向view_functions中添加键值对(这件事在应用程序run之前就做好了)<br>每个应用程序app都有一个url_map，它是一个Map类(具体实现在werkzeug/routing.py中)，里面包含了一个列表，列表元素是Role的实例(werkzeug/routing.py中)。add_url_rule的第二个作用就是向url_map中添加Role的实例(它也是在应用程序run之前就做好了)</p>
<p>我们可以通过一个例子来看：</p>
<pre><code>app = Flask(__name__)
 
@app.route(&#39;/test&#39;, endpoint=&#39;Test&#39;)
def test():
  pass
 
 
@app.route(&#39;/&#39;, endpoint=&#39;index&#39;)
def hello_world():
  return &#39;Hello World!&#39;
 
if __name__ == &#39;__main__&#39;:
  print(app.view_functions)
  print(app.url_map)
  app.run()
</code></pre>
<p>运行这个程序，结果是：</p>
<pre><code>&#123;&#39;static&#39;: &lt;bound method Flask.send_static_file of &lt;Flask &#39;flask-code&#39;&gt;&gt;, &#39;Test&#39;: &lt;function test at 0x10065e488&gt;, &#39;index&#39;: &lt;function hello_world at 0x10323d488&gt;&#125;
Map([&lt;Rule &#39;/test&#39; (HEAD, OPTIONS, GET) -&gt; Test&gt;,
 &lt;Rule &#39;/&#39; (HEAD, OPTIONS, GET) -&gt; index&gt;,
 &lt;Rule &#39;/static/&lt;filename&gt;&#39; (HEAD, OPTIONS, GET) -&gt; static&gt;])
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
</code></pre>
<p>所以我们可以看出：这个url_map存储的是url与endpoint的映射!<br>回到flask接受用户请求地址并查询函数的问题。实际上，当请求传来一个url的时候，会先通过rule找到endpoint(url_map)，然后再根据endpoint再找到对应的view_func(view_functions)。通常，endpoint的名字都和视图函数名一样。</p>
<p>这时候，这个endpoint也就好理解了：<br>实际上这个endpoint就是一个Identifier，每个视图函数都有一个endpoint，<br>当有请求来到的时候，用它来知道到底使用哪一个视图函数</p>
<p>在实际应用中，当我们需要在一个视图中跳转到另一个视图中的时候，我们经常会使用url_for(endpoint)去查询视图，而不是把地址硬编码到函数中。<br>这个时候，我们就不能使用视图函数名当endpoint去查询了<br>我们举个例子来说明。比如：</p>
<pre><code>app = Flask(__name__)
app.register_blueprint(user, url_prefix=&#39;user&#39;)
app.register_blueprint(file, url_prefix=&#39;file&#39;)
</code></pre>
<p>我们注册了2个蓝图。<br>在user中(省略初始化过程)：</p>
<pre><code>@user.route(&#39;/article&#39;)
def article():
  pass
</code></pre>
<p>在file中(省略初始化过程)：</p>
<pre><code>@file.route(&#39;/article&#39;)
def article():
  pass
</code></pre>
<p>这时候，我们发现，/article这个路由对应了两个函数名一样的函数，分别在两个蓝图中。当我们使用url_for(article)调用的时候(注意，url_for是通过endpoint查询url地址，然后找视图函数)，flask无法知道到底使用哪个蓝图下的endpoint，所以我们需要这样:</p>
<pre><code>url_for(&#39;user.article&#39;)
</code></pre>
<p>以上就是本文的全部内容，希望对大家的学习有所帮助。</p>
<p>来源：<a href="https://www.jb51.net/article/176173.htm">https://www.jb51.net/article/176173.htm</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例03--Flask-RESTful</title>
    <url>/2023/08/13/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用flask可以快速开发restful风格的后台服务，下面展示几种常用实用接口案例。</p>
<p>Flask-RESTful 提供的最主要的基础就是资源(resources)。资源(Resources)是构建在 Flask 可拔插视图 之上，只要在你的资源(resource)上定义方法就能够容易地访问多个 HTTP 方法.</p>
<p>其实就是想表达，在资源路由上（resources）定义多个方法（get，post，put等），就可以实现多种效果</p>
<pre><code>from flask import Flask, request
from flask_restful import Api, Resource
 
app = Flask(__name__)
api = Api(app)
 
todos = &#123;&#125;
 
class TodoSimple(Resource):
 def get(self, todo_id):
  return &#123;todo_id: todos[todo_id]&#125;
 
 def put(self, todo_id):
  todos[todo_id] = request.form[&#39;data&#39;]
  return &#123;todo_id: todos[todo_id]&#125;
 
api.add_resource(TodoSimple, &#39;/&lt;string:todo_id&gt;&#39;)
 
if __name__ == &#39;__main__&#39;:
 app.run(debug=True)
 
</code></pre>
<p>解释：<br>（1）TodoSimple类定义了2种方法，最终地址/string:todo_id’下面，就可以实现2种请求方法<br>（2）add_resource方法中第一个参数：视图函数名；第二个参数：路由的具体地址，以及string:todo_id代表传递的是一个字符串，且是必要参数。<br>（3）request.form[‘data’]获取request里面，form表单的key为data的参数，如果request里面，没有data参数，那报错。如果有包含data的多个参数，那也只会取data这一个参数</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例02</title>
    <url>/2023/08/12/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用flask可以快速开发restful风格的后台服务，下面展示几种常用实用接口案例。</p>
<pre><code>from flask import Flask, request, jsonify, send_from_directory
from werkzeug.utils import secure_filename
import os
import uuid

app = Flask(__name__)

# 设置文件上传保存路径
app.config[&#39;UPLOAD_FOLDER&#39;] = &#39;static/upload/&#39;
# MAX_CONTENT_LENGTH设置上传文件的大小，单位字节
app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 1 * 1024 * 1024


@app.route(&#39;/upload&#39;, methods=[&#39;POST&#39;])
def upload():
    f = request.files[&#39;file&#39;]
    fname = secure_filename(f.filename)
    ext = fname.rsplit(&#39;.&#39;)[-1]
    # 生成一个uuid作为文件名
    fileName = str(uuid.uuid4()) + &quot;.&quot; + ext
    # os.path.join拼接地址，上传地址，f.filename获取文件名
    f.save(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], fileName))
    return jsonify(&#123;&#39;result&#39;: &#39;success&#39;&#125;)


# 图片下载
@app.route(&#39;/download/&lt;filename&gt;&#39;, methods=[&#39;GET&#39;])
def download(filename):
    if request.method == &quot;GET&quot;:
        # 通过文件名下载文件
        path = os.path.isfile(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename))
        if path:
            return send_from_directory(app.config[&#39;UPLOAD_FOLDER&#39;], filename, as_attachment=True)

@app.route(&#39;/&#39;)
def hello_world():  # put application&#39;s code here
    return &#39;Hello World!&#39;


if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask实用入门案例01</title>
    <url>/2023/08/11/flask%E5%AE%9E%E7%94%A8%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用flask可以快速开发restful风格的后台服务，下面展示几种常用实用接口案例。</p>
<pre><code>from flask import Flask, abort, request, jsonify

# import requests

app = Flask(__name__)
tasks = []


@app.route(&#39;/add_user&#39;, methods=[&#39;POST&#39;])
def add_user():
    if not request.json or &#39;id&#39; not in request.json or &#39;name&#39; not in request.json:
        abort(400)
    task = &#123;
        &#39;id&#39;: request.json[&#39;id&#39;],
        &#39;name&#39;: request.json[&#39;name&#39;]
    &#125;
    tasks.append(task)
    return jsonify(&#123;&#39;result&#39;: &#39;success&#39;&#125;)


@app.route(&#39;/get_user&#39;, methods=[&#39;GET&#39;])
def get_user():
    if not request.args or &#39;id&#39; not in request.args:
        return jsonify(tasks)
    else:
        task_id = request.args[&#39;id&#39;]
        task = filter(lambda t: t[&#39;id&#39;] == int(task_id), tasks)
        return jsonify(task) if task else jsonify(&#123;&#39;result&#39;: &#39;not found&#39;&#125;)


@app.route(&#39;/getUser/&lt;userName&gt;&#39;)
def getUser(userName):
    return &quot;Hello:&#123;&#125;!&quot;.format(userName)


@app.route(&#39;/hello_world&#39;)
def hello_world():  # put application&#39;s code here
    return &#39;Hello World!&#39;


if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.7之后版本datetime默认值不能设置为0000-00-00的问题</title>
    <url>/2023/08/10/mysql5.7%E4%B9%8B%E5%90%8E%E7%89%88%E6%9C%ACdatetime%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%8D%E8%83%BD%E8%AE%BE%E7%BD%AE%E4%B8%BA0000-00-00%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>根据报错猜测可能是因为MySQL版本的问题，导出的SQL文件是从MySQL 5.6导出的， 目前Mac上面的MySQL版本是5.7</p>
<p>查询官网发现：</p>
<p>参考地址<a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html">https://dev.mysql.com/doc/refman/5.7/en/datetime.html</a></p>
<p>The DATE type is used for values with a date part but no time part. MySQL retrieves and displays DATE values in ‘YYYY-MM-DD’<br>format. The supported range is ‘1000-01-01’ to ‘9999-12-31’.</p>
<p>The DATETIME type is used for values that contain both date and time parts. MySQL retrieves and displays DATETIME values<br>in ‘YYYY-MM-DD HH:MM:SS’ format. The supported range is ‘1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’.</p>
<p>The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of<br>‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC.<br>故相关的默认值需要设置成’1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ 之间即可</p>
<p>作者：全栈运维<br>链接：<a href="https://www.jianshu.com/p/90bb8c825f2f">https://www.jianshu.com/p/90bb8c825f2f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SF6气体</title>
    <url>/2023/08/09/SF6%E6%B0%94%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果您是从事高压电力工作的小伙伴，您可能会接触到气体绝缘开关装置。这三个字母是气体绝缘全封闭复合装置的英文缩写。它也可以称为“SF6全封闭开关设备”。为什么会这样？</p>
<p>最初，当充满SF6气体时，气体绝缘开关设备可以实现导体对护套、相间和断口之间的可靠绝缘。</p>
<p>那么，什么是SF6气体？为什么它具有良好的绝缘和灭弧性能？本文作者将带你一起去揭开他的秘密。</p>
<h2 id="SF6气体的基本特性"><a href="#SF6气体的基本特性" class="headerlink" title="SF6气体的基本特性"></a>SF6气体的基本特性</h2><p>六氟化硫，化学式为SF6，是一种无色、无臭、无毒、不燃的稳定气体，分子量为146.06，在20℃和0.1MPa时密度为6.1kg/m3，约为空气密度的5倍，六氟化硫在常温常压下为气态。</p>
<p>SF6气体是目前最好的绝缘介质和灭弧剂，其绝缘和灭弧性能远优于绝缘油。</p>
<p>其分子结构为完全对称的八面体结构，尖端有六个氟原子，中心有硫原子共价键合。</p>
<p>物理性质：无色、无味、无味、无毒、不易燃，临界温度45.6℃；它不溶于水，在某些有机溶剂中具有很高的溶解度。</p>
<p>化学性质：非常稳定。通常，在室温下，甚至在电气设备最高允许温度的150℃范围内，不会发生化学反应。超过150℃时，与塑料发生弱化学反应。超过200℃时，它与铜和铝反应缓慢，在500℃时开始分解。</p>
<p>导热性：导热性差，导热系数仅为空气的2/3，但表面传热系数为15，为空气的2.5倍。总的来说，其散热性能优于空气。</p>
<p>电负性：分子容易吸收自由电子形成负离子。由于F的最外层是7个电子，因此很容易吸收一个电子，使其成为稳定的8个电子。</p>
<p>灭弧原理：SF6的负电荷形成负离子，与电弧中的正离子结合，使电弧中的击穿迅速减少，电弧的击穿电压升高，电弧迅速恢复。</p>
<p>制造工艺：s+3f2→sf6+q（放热），合成原料经水洗、碱洗、热解、吸附剂吸附等一系列清洗处理后，放入钢瓶中进行液体输送。</p>
<p>气体绝缘开关设备安装后，应清除各种杂质和水分。其标准由国际电工委员会（IEC）和各国制定。</p>
<p>由于SF6气体的分子量较大，用公式p=rt计算温度、压力和密度三个状态参数的偏差很大。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>PNMP安装使用</title>
    <url>/2023/08/08/PNMP%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介</p>
<p>pnpm是一种新起的包管理器，从npm的下载量看，目前还没有超过yarn，但它的实现方式值得主流包管理器学习，某些开发者极力推荐使用pnpm。</p>
<p>从结果上来看，它具有以下优势：</p>
<ol>
<li>目前，安装效率高于npm和yarn的最新版</li>
<li>极其简洁的node_modules目录</li>
<li>避免了开发时使用间接依赖的问题</li>
<li>能极大的降低磁盘空间的占用</li>
</ol>
<p>// 全局安装<br>npm install pnpm -g</p>
<p>//查看源<br>pnpm config get registry<br>//切换淘宝源<br>pnpm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com/</a></p>
<p>// 使用<br>pnpm install 包 // 安装依赖<br>pnpm i  包      // 安装依赖<br>pnpm add 包     // -S  默认写入dependencies<br>pnpm add -D     // -D devDependencies<br>pnpm add -g     // 全局安装</p>
<p>// 移除<br>pnpm remove 包               // 移除包<br>pnpm remove 包 –global      // 移除全局包</p>
<p>// 更新<br>pnpm up                      // 更新所有依赖项<br>pnpm upgrade 包              // 更新包<br>pnpm upgrade 包 –global     // 更新全局包</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>PNMP</tag>
      </tags>
  </entry>
  <entry>
    <title>finereport入门系列（四）</title>
    <url>/2023/08/07/finereport%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="决策报表自动查询"><a href="#决策报表自动查询" class="headerlink" title="决策报表自动查询"></a>决策报表自动查询</h1><ol>
<li>概述</li>
<li>1 应用场景<br>在决策报表中，控件可以添加到参数界面使用「查询」按钮查询数据，也可以直接在 body 中使用，但是在 body 中使用时，控件是无法直接使用查询按钮来查询数据的，那我们要如何实现控件联动查询数据呢？</li>
</ol>
<p>例如：在 body 中的下拉框控件选择「地区」，其他使用了地区参数的组件能根据选择的地区展示对应数据。预期效果 </p>
<p>1.2 实现思路<br>在数据集中定义地区参数为 $area ，将下拉框控件的名称修改为与地区参数相同的名称 area，即可使用参数联动控件实现自动查询。</p>
<p>若想要实现在参数界面实现自动查询请参考：JS实现决策报表参数界面自动查询。</p>
<ol start="2">
<li>示例</li>
<li>1 数据准备<br>1）点击设计器左上角「文件&gt;新建决策报表」，新建空白模板。</li>
</ol>
<p>2）新建一个数据库查询 ds1，SQL 查询语句为：</p>
<pre><code>SELECT * FROM 销量 where 1=1 $&#123;if(len(area)=0,&quot;&quot;,&quot; and 地区=&#39;&quot;+area+&quot;&#39;&quot;)&#125;
</code></pre>
<p>即定义 area 参数，值为「地区」字段，且当 参数为空时展示全部数据 。</p>
<p>2.2 决策报表设计<br>1）将 body 的布局方式修改为「绝对布局」，再向 body 中拖入「报表块」、「饼图」、「标签控件」和「下拉框控件」。 </p>
<p>2）设置「标签控件」的控件值为「地区：」；「下拉框控件」的控件名称为「area」，即将下拉框控件与参数 $area 绑定。</p>
<p>注：必须保证「下拉框控件」的控件名称与参数名称 area 保持一致。</p>
<p>3）设置「下拉框控件」的数据字典为「数据库表」销量表，实际值和显示值均为「地区」。 </p>
<p>2.3 设计报表块<br>双击报表块，进入报表块编辑界面，拖入「地区、销售员、销量」字段，设置 C2 单元格的数据设置为「汇总&gt;求和」。单元格样式可在「单元格属性&gt;样式」中自行设置。</p>
<p>2.4 绑定图表数据<br>双击饼图，设置饼图的数据来源：数据集为 ds1，系列名为「销售员」，值为「销量」，汇总方式为「求和」。 </p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>finereport</tag>
      </tags>
  </entry>
  <entry>
    <title>finereport入门系列（三）</title>
    <url>/2023/08/06/finereport%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="钻取地图示例"><a href="#钻取地图示例" class="headerlink" title="钻取地图示例"></a>钻取地图示例</h1><p>3.1 准备数据<br>新建决策报表，新建内置数据集， </p>
<p>注：这边因跨数据取数问题，也就直接分了两个数据集，供参考。</p>
<p>3.2 插入地图<br>1）决策报表中插入报表块和钻取地图， </p>
<p>2）报表块中有 2 个数据集的数据，所以要进行数据集关联，设置下过滤条件， </p>
<p>3.3 绑定数据<br>钻取地图添加需要的钻取层级，将报表块中处理好的单元格数据添加至地图单元格数据集中， </p>
<p>注：第 1 层和第 2 层都要设置，图中只给了第 1 层的，别漏掉了。</p>
<p>3.4 添加事件<br>1）决策报表 body 添加初始化事件， </p>
<p>JavaScript 代码如下：</p>
<pre><code>setTimeout(function()&#123;
var vanchart =FR.Chart.WebUtils.getChart(&quot;chart0&quot;).getChartWithIndex(0); //获取图表对象
vanchart.openAutoTooltip(); //开启数据点提示轮播
&#125;,500)
</code></pre>
<p>2）在钻取地图「特效&gt;交互属性」下添加 JavaScript 类型的超级链接， </p>
<p>JavaScript 代码如下：</p>
<pre><code>FR.Chart.WebUtils.getChart(&quot;chart0&quot;).getChartWithIndex(0).openAutoTooltip();
//钻取时触发超链，实现轮播
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>finereport</tag>
      </tags>
  </entry>
  <entry>
    <title>finereport入门系列（二）</title>
    <url>/2023/08/05/finereport%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="地图开启数据点提示轮播"><a href="#地图开启数据点提示轮播" class="headerlink" title="地图开启数据点提示轮播"></a>地图开启数据点提示轮播</h1><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1 实现思路"></a>1 实现思路</h2><p>获取 图表对象 后，调用方法chart.openAutoTooltip([delay, initPoints]);即可开启数据点提示自动轮播。</p>
<p>方法中的delay为轮播间隔时间，initPoints为数据点集合。</p>
<p>如果不设置参数，直接调用chart.openAutoTooltip()，表示采用默认设置，轮播间隔为 3 秒，数据点集合为当前图表下的所有数据点。</p>
<p>注：该接口不支持扩展图表。</p>
<p>注：FVS 可视化看板详情可见：FVS基础图表实现数据点提示轮播 。</p>
<h2 id="2-普通地图示例"><a href="#2-普通地图示例" class="headerlink" title="2. 普通地图示例"></a>2. 普通地图示例</h2><h3 id="2-1-准备数据"><a href="#2-1-准备数据" class="headerlink" title="2.1 准备数据"></a>2.1 准备数据</h3><p>新建决策报表，新建内置数据集 Embedded1</p>
<h3 id="2-2-插入地图"><a href="#2-2-插入地图" class="headerlink" title="2.2 插入地图"></a>2.2 插入地图</h3><p>将「地图」拖到决策报表中，「编辑」地图，地图类型选择区域地图，地图边界选择「安徽省」，GIS图层选择「无」</p>
<h3 id="2-3-绑定数据"><a href="#2-3-绑定数据" class="headerlink" title="2.3 绑定数据"></a>2.3 绑定数据</h3><p>属性面板点击「数据」，绑定地图数据</p>
<h3 id="4-设置图例"><a href="#4-设置图例" class="headerlink" title="4 设置图例"></a>4 设置图例</h3><p>此处是对地图区域的预览颜色进行设置。</p>
<p>属性面板点击「样式&gt;图例」，勾选「图例可见」，形态选择「渐变色」，区间配置自定义最小值为「0」，最大值为「200」，自定义「主题颜色」，划分阶段修改为1</p>
<h3 id="5-设置提示"><a href="#5-设置提示" class="headerlink" title="5 设置提示"></a>5 设置提示</h3><p>此处修改提示信息的背景样式，提升提示清晰度。</p>
<p>属性面板点击「样式&gt;提示」，勾选「使用数据点提示」，背景填充颜色选择「黑色」，不透明度设置为「50」</p>
<h3 id="6-修改悬浮颜色"><a href="#6-修改悬浮颜色" class="headerlink" title="6 修改悬浮颜色"></a>6 修改悬浮颜色</h3><p>鼠标悬浮在地图区域上会有高亮效果，地图数据点提示轮播时也会显示这个高亮效果，但是默认的高亮效果不明显，需要进行修改。</p>
<p>属性面板选择「特效&gt;条件显示」，给地图添加一个「悬浮颜色」类型的条件属性，自定义颜色后，将「区域名」和内置数据集字段「区域」绑定，点击「增加」按钮即可</p>
<h3 id="7-添加事件"><a href="#7-添加事件" class="headerlink" title="7 添加事件"></a>7 添加事件</h3><p>选中「body」，添加一个「初始化后事件」</p>
<p>JavaScript 代码如下：</p>
<pre><code>setTimeout(function () &#123;
    //获取图表对象
    var vanchart = FR.Chart.WebUtils.getChart(&quot;chart0&quot;).getChartWithIndex(0);
    //开启数据点提示轮播，轮播间隔为1秒，作用于该系列下的所有数据点
    vanchart.openAutoTooltip(1000, vanchart.series[0].points);
&#125;, 3000);
</code></pre>
<h3 id="8-设置报表背景"><a href="#8-设置报表背景" class="headerlink" title="8 设置报表背景"></a>8 设置报表背景</h3><p>选中「body」，属性下点击样式「编辑」按钮，修改决策报表的背景填充颜色为「深蓝色」</p>
<h3 id="9-效果预览"><a href="#9-效果预览" class="headerlink" title="9 效果预览"></a>9 效果预览</h3><p>保存报表，点击「PC端预览」，效果如「1.1预期效果」所示。</p>
<p>注：不支持移动端。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>finereport</tag>
      </tags>
  </entry>
  <entry>
    <title>finereport入门系列（一）</title>
    <url>/2023/08/04/finereport%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JS实现切换Tab块时进行数据联动"><a href="#JS实现切换Tab块时进行数据联动" class="headerlink" title="JS实现切换Tab块时进行数据联动"></a>JS实现切换Tab块时进行数据联动</h1><h2 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1 准备数据"></a>1 准备数据</h2><p>点击设计器左上角「文件&gt;新建决策报表」，新建数据库查询 ds1，输出 SQL 查询语句：</p>
<pre><code>SELECT * FROM 地图
</code></pre>
<h2 id="2-设计模板"><a href="#2-设计模板" class="headerlink" title="2 设计模板"></a>2 设计模板</h2><h3 id="1-设计-Tab-块"><a href="#1-设计-Tab-块" class="headerlink" title="1 设计 Tab 块"></a>1 设计 Tab 块</h3><p>1）向决策报表 body 中拖入一个 Tab 块，并调整其大小和位置。<br>2）双击 Tab 块，点击 Tab 块右上角添加按钮，再添加两个 Tab 页。接着向每个 Tab 页中拖入一个地图图表。<br>3）分别设置地图：单击选中地图图表，在属性面板中取消勾选「标题可见」。<br>再双击图表进入编辑状态，将三个地图的边界分别设置为「江苏省、山东省、浙江省」，GIS图层均设置为「标准&gt;幻影黑」。<br>本文主要演示 Tab 切换时的联动，所以这里地图无需绑定数据。<br>4）选中 Tab 块整体，开启 Tab 块轮播，轮播间隔时间为 2 秒。再选中 Tab 块标题，将标题组件大小修改为 0 ，即可实现隐藏 Tab 块标题。</p>
<h3 id="2-添加模板参数"><a href="#2-添加模板参数" class="headerlink" title="2 添加模板参数"></a>2 添加模板参数</h3><p>为了实现联动，需添加一个模板参数。<br>点击「模板&gt;模板参数」，新增一个参数并重命名为 area ，设置默认值为「江苏省」，对应第一个 Tab 页中的地图边界。</p>
<h3 id="3-设计报表块"><a href="#3-设计报表块" class="headerlink" title="3 设计报表块"></a>3 设计报表块</h3><p>1）向 body 中拖入一个 报表块，并调整其大小和位置。<br>2）双击报表块进入编辑界面，将 pid 、销售额字段分别拖入 A1、A2 单元格，并设置其字体、大小、颜色等。<br>再选中 A2 单元格，设置销售额的「数据设置」为「汇总&gt;求和」，左父格设置为「自定义&gt; A1 」。<br>3）双击 A1 单元格，设置过滤条件为 pid 等于参数 $area ，则会根据参数过滤显示数据。<br>4）点击表格左下角「表单」返回 body 界面，将报表块背景设置为与地图背景同样的颜色。 </p>
<h3 id="4-添加控件"><a href="#4-添加控件" class="headerlink" title="4 添加控件"></a>4 添加控件</h3><p>为了配合 JS 和数据集传参实现联动，需添加一个控件。<br>1）向 body 中拖入一个 下拉框控件 ，将控件名称设置为 area ，即可与参数 $area 绑定 。取消勾选「可见」，则预览时不会显示该控件。<br>2）选中控件，设置其数据字典为 ds1 数据集的 pid 字段。 </p>
<h3 id="5-添加事件"><a href="#5-添加事件" class="headerlink" title="5 添加事件"></a>5 添加事件</h3><p>选中 Tab 块的标题面板 tabpane0 ，添加一个「Tab块切换」事件。输入 JavaScript 代码如下：</p>
<pre><code>setTimeout(function() &#123; 
//TAB切换后,获取到当前TAB块的标题索引
FR.IndexNum = _g().getWidgetByName(&quot;tabpane0&quot;).getShowIndex();
var a = 0;
a = FR.IndexNum;
if(a==0)&#123;
    x=&#39;江苏省&#39;;
    &#125;
else if(a==1)&#123;
        x=&#39;山东省&#39;;
    &#125;
else if(a==2)&#123;
        x=&#39;浙江省&#39;;
    &#125;      
var cc = _g().getWidgetByName(&quot;area&quot;) //获取控件
cc.setValue(x);    //给控件赋值
&#125;, 50);
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>finereport</tag>
      </tags>
  </entry>
  <entry>
    <title>xampp-mysql-FEEDBACK-is-disabled修复</title>
    <url>/2023/08/03/xampp-mysql-FEEDBACK-is-disabled%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>前一天还能正常使用的 xampp，再一次使用时，无端端地无法启用 mysql 服务，启用 mysql 服务时提示 MySQL 意外关闭（Error: MySQL shutdown unexpectedly.）</p>
<p>查看 mysql 错误日志文件 mysql_error.log 发现有一行提示 “Plugin ‘FEEDBACK’ is disabled.”</p>
<p>看字面意思是 “FEEDBACK” 这个插件被禁用，查找到的解决方法如下：</p>
<h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><p>1、先备份/xampp/mysql/data/中的所有文件。</p>
<p>2、将/xampp/mysql/backup/中所有文件复制并覆盖/xampp/mysql/data/中的所有文件，重启 xampp 后 mysql 启动成功。</p>
<p>或者复制xampp/mysql/backup里的所有文件除了ibdata1文件，覆盖掉xampp/mysql/data里的所有文件。</p>
<p>3、文件覆盖后，phpmyadmin的登录密码变回初始密码（即没有密码），需要进入 phpmyadmin 管理中重新修改 root 帐号密码，原来的网站才能正常连接数据库。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>xampp</tag>
      </tags>
  </entry>
  <entry>
    <title>VeraCrypt好用的硬盘加密工具</title>
    <url>/2023/08/02/VeraCrypt%E5%A5%BD%E7%94%A8%E7%9A%84%E7%A1%AC%E7%9B%98%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>VeraCrypt is a free open source disk encryption software for Windows, Mac OSX and Linux. Brought to you by IDRIX (<a href="https://www.idrix.fr/">https://www.idrix.fr</a>) and based on TrueCrypt 7.1a.</p>
<h1 id="VeraCrypt-main-features"><a href="#VeraCrypt-main-features" class="headerlink" title="VeraCrypt main features:"></a>VeraCrypt main features:</h1><ul>
<li>Creates a virtual encrypted disk within a file and mounts it as a real disk.</li>
<li>Encrypts an entire partition or storage device such as USB flash drive or hard drive.</li>
<li>Encrypts a partition or drive where Windows is installed (pre-boot authentication).</li>
<li>Encryption is automatic, real-time(on-the-fly) and transparent.</li>
<li>Parallelization and pipelining allow data to be read and written as fast as if the drive was not encrypted.</li>
<li>Encryption can be hardware-accelerated on modern processors.</li>
<li>Provides plausible deniability, in case an adversary forces you to reveal the password: Hidden volume (steganography) and hidden operating system.</li>
<li>More information about the features of VeraCrypt may be found in the documentation</li>
</ul>
<h1 id="What-does-VeraCrypt-bring-to-you"><a href="#What-does-VeraCrypt-bring-to-you" class="headerlink" title="What does VeraCrypt bring to you?"></a>What does VeraCrypt bring to you?</h1><p>VeraCrypt adds enhanced security to the algorithms used for system and partitions encryption making it immune to new developments in brute-force attacks.<br>VeraCrypt also solves many vulnerabilities and security issues found in TrueCrypt.</p>
<p>As an example, when the system partition is encrypted, TrueCrypt uses PBKDF2-RIPEMD160 with 1000 iterations whereas in VeraCrypt we use 200000 iterations by default (can be increased using a custom PIM). And for standard containers and other partitions, TrueCrypt uses at most 2000 iterations but VeraCrypt uses 500000 iterations by default (can also be increased using a custom PIM).</p>
<p>This enhanced security adds some delay only to the opening of encrypted partitions without any performance impact to the application use phase. This is acceptable to the legitimate owner but it makes it much harder for an attacker to gain access to the encrypted data.</p>
<p>Starting from version 1.12, it is possible to use custom iterations through the PIM feature, which can be used to increase the encryption security.</p>
<p>Starting from version 1.0f, VeraCrypt can load TrueCrypt volume. It also offers the possibility to convert TrueCrypt containers and non-system partitions to VeraCrypt format.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>隔离装置</tag>
      </tags>
  </entry>
  <entry>
    <title>C++工具库集合Harlinn.Windows</title>
    <url>/2023/08/01/C++%E5%B7%A5%E5%85%B7%E5%BA%93%E9%9B%86%E5%90%88Harlinn.Windows/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A collection of, mostly, C and C++ libraries</p>
<p><a href="https://github.com/Harlinn/Harlinn.Windows">https://github.com/Harlinn/Harlinn.Windows</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Harlinn.Windows</tag>
        <tag>libraries</tag>
      </tags>
  </entry>
  <entry>
    <title>正反向隔离装置</title>
    <url>/2023/07/31/%E6%AD%A3%E5%8F%8D%E5%90%91%E9%9A%94%E7%A6%BB%E8%A3%85%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、安全区定义"><a href="#一、安全区定义" class="headerlink" title="一、安全区定义"></a>一、安全区定义</h1><p>根据电力二次系统的特点，划分为生产控制大区和管理信息大区。生产控制大区分为控制区（安全区Ⅰ）和非控制区（安全区Ⅱ）。信息管理大区分为生产管理区（安全区Ⅲ）和管理信息区（安全区Ⅳ）。不同安全区确定不同安全防护要求，其中安全区Ⅰ安全等级最高，安全区Ⅱ次之，其余依次类推。</p>
<p>安全区Ⅰ典型系统:调度自动化系统、变电站自动化系统、继电保护、安全自动控制系统等。<br>安全区Ⅱ典型系统:水库调度自动化系统、电能量计量系统、继保及故障录波信息管理系统等。<br>安全区Ⅲ典型系统:调度生产管理系统（DMIS）、雷电监测系统、统计报表系统等。<br>安全区Ⅳ典型系统:管理信息系统（MIS）、办公自动化系统（OA）、客户服务系统等。</p>
<h1 id="二、物理隔离"><a href="#二、物理隔离" class="headerlink" title="二、物理隔离"></a>二、物理隔离</h1><p>物理隔离指内部网不直接或间接地连接公共网。物理隔离的目的是保护网络设备及计算机等硬件实体和通信链路免受自然灾害、人为破坏和搭线窃听攻击。只有使内部网和公共网物理隔离，才能真正保证内部信息网络不受来自互联网的黑客攻击。同时，物理隔离也为内部网划定了明确的安全边界，使得网络的可控性增强，便于内部管理。</p>
<p>在物理隔离技术出现之前，对网络的信息安全采取了许多措施，如在网络中增加防火墙、防病毒系统，对网络进行入侵检测、漏洞扫描等。由于这些技术的极端复杂性，安全控制十分有限性，这些在线分析技术无法提供涉密机构提出的高度数据安全要求。而且，此类软件的保护是一种逻辑机制，对于逻辑实体而言极易被操纵。因此，必须有一道绝对安全的大门，保证涉密网的信息不被泄露和破坏，这就是物理隔离所起的作用。</p>
<h1 id="三、正反向隔离"><a href="#三、正反向隔离" class="headerlink" title="三、正反向隔离"></a>三、正反向隔离</h1><p>电力系统按照安全等级的要求把计算机系统分为了I、II、III等。I和II之间要有防火墙，I/II区与III区之间则要在物理上做隔离。即I/II发到III区的数据要经过正向隔离装置，III区发到I/II区的数据要经过反向隔离装置。</p>
<p>正向隔离装置不接受III区的数据(最多只能过一个字节的数据)，反向隔离装置只能容许III区的文件穿透到I区。</p>
<ul>
<li>A.正向安全隔离装置</li>
</ul>
<p>1.两个安全区之间的非网络方式的安全的数据交换，并且保证安全隔离装置内外两个处理系统不同时连通;<br>2.表示层与应用层数据完全单向传输，即从安全区III到安全区I/II的TCP应答禁止携带应用数据;<br>3.透明工作方式:虚拟主机IP地址、隐藏MAC地址<br>4.基于MAC、IP、传输协议、传输端口以及通信方向的综合报文过滤与访问控制;<br>5.支持NAT;<br>6.防止穿透性TCP联接:禁止两个应用网关之间直接建立TCP联接，将内外两个应用网关之间的TCP联接分解成内外两个应用网关分别到隔离装置内外两个网卡的两个TCP虚拟联接。隔离装置内外两个网卡在装置内部是非网络连接，且只允许数据单向传输;<br>7.具有可定制的应用层解析功能，支持应用层特殊标记识别;<br>8.安全、方便的维护管理方式:基于证书的管理人员认证，使用图形化的管理界面。</p>
<ul>
<li>B.反向隔离装置</li>
</ul>
<p>反向隔离装置用于从安全区III到安全区I/II传递数据，是安全区III到安全区I/II的唯一一个数据传递途径。反向隔离装置集中接收安全区III发向安全区I/II的数据，进行签名验证、内容过滤、有效性检查等处理后，转发给安全区I/II内部的接收程序具体过程如下：<br>1.全区III内的数据发送端首先对需要发送的数据签名，然后发给反向隔离装置；<br>2.反向隔离装置接收数据后，进行签名验证，并对数据进行内容过滤、有效性检查等处理。</p>
<ul>
<li>C.安全区I/II内部接收程序  </li>
</ul>
<p>将处理过的数据转发给安全区I/II内部的接收程序，其功能如下:<br>1.有应用网关功能，实现应用数据的接收与转发;<br>2.具有应用数据内容有效性检查功能;<br>3.具有基于数字证书的数据签名/解签名功能;<br>4.实现两个安全区之间的非网络方式的安全的数据传递;<br>5.支持透明工作方式：虚拟主机IP地址、隐藏MAC地址;<br>6.支持NAT;<br>7.基于MAC、IP、传输协议、传输端口以及通信方向的综合报文过滤与访问控制;<br>8.防止穿透性TCP联接。</p>
<ul>
<li>D.装置安全保障要点</li>
</ul>
<p>隔离装置本身应该具有较高的安全防护能力，其安全性要求主要包括：<br>1.用非INTEL指令系统的(及兼容)微处理器；<br>2.安全、固化的操作系统；<br>3.不存在设计与实现上的安全漏洞，抵御除Dos以外的已知的网络攻击。</p>
<h1 id="四-网络隔离装置要点"><a href="#四-网络隔离装置要点" class="headerlink" title="四.网络隔离装置要点"></a>四.网络隔离装置要点</h1><p>1.一个网络隔离装置(作为阻塞点、控制点)能极大地提高一个监控系统的安全性，并通过过滤不安全的服务而降低风险。由于只有经过精心选择的应用协议才能通过网络隔离装置，所以网络环境变得更安全。如网络隔离装置可以禁止不安全的NFS协议进出保护网络，这样外部的攻击者就不可能利用这些脆弱的协议来攻击监控系统。网络隔离装置同时可以保护网络免受基于路由的攻击，如IP选项中的源路由攻击和ICMP重定向中的重定向路径。网络隔离装置应该可以拒绝所有以上类型攻击的报文并通知网络隔离装置管理员。</p>
<p>2.通过以网络隔离装置为中心的安全方案配置，能将所有安全策略配置在网络隔离装置上。与将网络安全问题分散到各个主机上相比，网络隔离装置的集中安全管理更方便可靠。例如在网络访问时，监控系统通过加密口令/身份认证方式与其它信息系统通信，在电力监控系统基本上不可行，它意味监控系统要重新测试，因此用网络隔离装置集中控制，无需修改双端应用程序是最佳的选择。</p>
<p>3.如果所有的访问都经过网络隔离装置，那么，网络隔离装置就能记录下这些访问并作出日志记录，同时也能提供网络使用情况的统计数据。当发生可疑动作时，网络隔离装置能进行适当的报警，并提供网络是否受到监测和攻击的详细信息。</p>
<p>4.通过网络隔离装置对监控系统及其它信息系统的划分，实现监控系统重点网段的隔离，一个监控系统中不引人注意的细节可能包含了有关安全的线索而引起外部攻击者的兴趣，甚至因此而暴露了监控系统的某些安全漏洞。使用网络隔离装置就可以隐蔽那些透漏内部细节，例如网络隔离装置可以进行网络地址转换(NAT)，这样一台主机IP地址就不会被外界所了解, 不会为外部攻击创造条件</p>
<hr>
<p>作者：三氯甲烷<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/stillfantasy1988/article/details/78805859">https://blog.csdn.net/stillfantasy1988/article/details/78805859</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！<br>————————————————<br>版权声明：本文为CSDN博主「金士顿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wojiuguowei/article/details/86542299">https://blog.csdn.net/wojiuguowei/article/details/86542299</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>隔离装置</tag>
      </tags>
  </entry>
  <entry>
    <title>最新docker部署禅道指南</title>
    <url>/2023/07/30/%E6%9C%80%E6%96%B0docker%E9%83%A8%E7%BD%B2%E7%A6%85%E9%81%93%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.zentao.net/book/zentaopms/38.html">Docker方式部署禅道</a></p>
<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><pre><code>docker pull hub.zentao.net/app/zentao:latest
</code></pre>
<h1 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h1><pre><code>sudo docker run -d \
    --name zentao \
    --restart always \
    -p 9880:80 \
    -p 9806:3306 \
    -v /home/zentao/zentaopms:/www/zentaopms \
    -v /home/zentao/mysqldata:/var/lib/mysql \
    hub.zentao.net/app/zentao:latest
</code></pre>
<p>访问ip:9880，安装禅道，mysql默认密码：123456</p>
<p>如果需要修改镜像安装参数，先停止禅道容器，再删除容器，然后重新安装镜像</p>
<h1 id="停止禅道容器"><a href="#停止禅道容器" class="headerlink" title="停止禅道容器"></a>停止禅道容器</h1><pre><code>sudo docker stop zentao
</code></pre>
<h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><pre><code>sudo docker rm zentao 
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>禅道</tag>
      </tags>
  </entry>
  <entry>
    <title>最新docker部署ownCloud指南</title>
    <url>/2023/07/29/%E6%9C%80%E6%96%B0docker%E9%83%A8%E7%BD%B2ownCloud%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://doc.owncloud.com/server/10.12/admin_manual/installation/docker/">Installing with Docker</a></p>
<h1 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h1><pre><code>docker pull owncloud
docker pull mariadb

docker run --name mariadb -e MYSQL_ROOT_PASSWORD=owncloud -v /home/owncloud/mariadb:/var/lib/mysql --restart=always -d mariadb
docker run --name owncloud -p 10080:80 -v /home/owncloud/owncloud:/var/www/html/data --link mariadb:mysql --restart=always -d owncloud
</code></pre>
<h1 id="信任域问题"><a href="#信任域问题" class="headerlink" title="信任域问题"></a>信任域问题</h1><p> find / -name config.php<br>编辑 …/config/config.php文件</p>
<pre><code>A typical configuration may look like this:

&#39;trusted_domains&#39; =&gt; [
   0 =&gt; &#39;localhost&#39;,
   1 =&gt; &#39;server1.example.com&#39;,
   2 =&gt; &#39;192.168.1.50&#39;,
],
</code></pre>
<p>仿照格式添加信任域，然后重新访问 http://公网IP:端口，问题解决了</p>
<h1 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h1><p>登录<a href="http://ip:9780，第一次登录需要配置，配置信息如下：">http://ip:9780，第一次登录需要配置，配置信息如下：</a><br>管理员账号密码<br>数据目录（默认值，不改）<br>数据库：选择mysql/mariadb。数据库用户root，数据库密码ownCloud，数据库名owncloud，localhost设为mariadb</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>ownCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>最新docker部署gitlab指南</title>
    <url>/2023/07/28/%E6%9C%80%E6%96%B0docker%E9%83%A8%E7%BD%B2gitlab%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://docs.gitlab.cn/jh/install/docker.html">极狐GitLab Docker 镜像</a></p>
<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><pre><code>sudo docker pull gitlab/gitlab-ce:latest
</code></pre>
<h1 id="安装容器"><a href="#安装容器" class="headerlink" title="安装容器"></a>安装容器</h1><pre><code>sudo docker run --detach \
  --hostname 192.168.10.33 \
  --publish 9443:443 --publish 9980:80 --publish 9822:22 \
  --name gitlab \
  --restart always \
  --volume /home/gitlab/config:/etc/gitlab \
  --volume /home/gitlab/logs:/var/log/gitlab \
  --volume /home/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce:latest
</code></pre>
<h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><pre><code>，可以用容器名，也可以用容器id

sudo docker logs -f gitlab
</code></pre>
<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><pre><code>sudo docker exec -it gitlab /bin/bash
</code></pre>
<h1 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h1><ol>
<li>切换到相应路径下: cd /opt/gitlab/bin/</li>
<li>打开控制台: gitlab-rails console -e production</li>
<li>查询用户账号信息并赋值给u: u=User.where(id:1).first</li>
<li>设置该用户名的密码: u.password=’Demo9999’</li>
<li>确认密码: u.password_confirmation=’Demo9999’</li>
<li>保存信息： u.save </li>
<li>退出: exit</li>
</ol>
<h1 id="修改外部访问地址"><a href="#修改外部访问地址" class="headerlink" title="修改外部访问地址"></a>修改外部访问地址</h1><pre><code>vi /etc/gitlab/gitlab.rb

external_url &#39;http://192.168.10.33:9980&#39;
gitlab_rails[&#39;gitlab_ssh_host&#39;]=&#39;192.168.10.33&#39;
gitlab_rails[&#39;gitlab_shell_ssh_port&#39;]=&#39;9822&#39;
gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39;
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>最新centos部署docker指南</title>
    <url>/2023/07/27/%E6%9C%80%E6%96%B0centos%E9%83%A8%E7%BD%B2docker%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2023年7月之后，Docker Compose V1不再更新，与后续新版Docker Destop也不再适配。<br>取而代之，当前支持的Docker Desktop均使用Docker Compose V2。</p>
<h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><p><a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS</a><br><a href="https://docs.docker.com/compose/install/">Overview of installing Docker Compose</a></p>
<h1 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h1><p>整理如下：</p>
<pre><code>sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine

sudo yum install -y yum-utils
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre>
<h1 id="查看版本："><a href="#查看版本：" class="headerlink" title="查看版本："></a>查看版本：</h1><pre><code>sudo docker -v
sudo docker compose version
</code></pre>
<h1 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h1><pre><code>sudo systemctl start docker
sudo systemctl enable docker
</code></pre>
<h1 id="测试docker"><a href="#测试docker" class="headerlink" title="测试docker"></a>测试docker</h1><pre><code>sudo docker run hello-world
</code></pre>
<h1 id="查看docker容器"><a href="#查看docker容器" class="headerlink" title="查看docker容器"></a>查看docker容器</h1><pre><code>sudo docker ps
sudo docker ps | grep zentao
</code></pre>
<h1 id="查看docker容器日志，XXXXXX可以是容器名字，也可以是容器id"><a href="#查看docker容器日志，XXXXXX可以是容器名字，也可以是容器id" class="headerlink" title="查看docker容器日志，XXXXXX可以是容器名字，也可以是容器id"></a>查看docker容器日志，XXXXXX可以是容器名字，也可以是容器id</h1><pre><code>docker logs -f XXXXXX
</code></pre>
<h1 id="进入容器操作"><a href="#进入容器操作" class="headerlink" title="进入容器操作"></a>进入容器操作</h1><pre><code>sudo docker exec -it gitlab /bin/bash
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle统计字符串包含字符个数</title>
    <url>/2023/07/26/oracle%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数：REGEXP_COUNT();</p>
<pre><code>select REGEXP_COUNT(&#39;1,2,6,8,7,9&#39;,&#39;,&#39;) from dual

结果：5
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains软件下载地址</title>
    <url>/2023/07/25/Jetbrains%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IDEA</p>
<p><a href="https://www.jetbrains.com/idea/download/other.html">https://www.jetbrains.com/idea/download/other.html</a></p>
<p>WebStorm</p>
<p><a href="https://www.jetbrains.com/webstorm/download/other.html">https://www.jetbrains.com/webstorm/download/other.html</a></p>
<p>Pycharm</p>
<p><a href="https://www.jetbrains.com/pycharm/download/other.html">https://www.jetbrains.com/pycharm/download/other.html</a></p>
<p>Goland</p>
<p><a href="https://www.jetbrains.com/go/download/other.html">https://www.jetbrains.com/go/download/other.html</a></p>
<p>Clion</p>
<p><a href="https://www.jetbrains.com/clion/download/other.html">https://www.jetbrains.com/clion/download/other.html</a></p>
<p>其他软件，可访问官网【jetbrains.com】查找并下载<br>选择对应版本下载</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7修改SSH默认端口22教程</title>
    <url>/2023/07/24/CentOS7%E4%BF%AE%E6%94%B9SSH%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A322%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.先查看防火墙状态</p>
<pre><code>systemctl status firewalld    #查看防火墙状态
</code></pre>
<p>不建议关闭防火墙，测试服务器可以关闭省事</p>
<pre><code>systemctl stop firewalld     #关闭防火墙
systemctl disable firewalld #禁止开机启动
</code></pre>
<p>关闭封火墙存在很大的风险，生产环境强烈建议不要关闭。</p>
<p>2、想好你要修改的端口，这里我以修改默认端口22为2222为例。</p>
<p>可以通过以下命令授权开放端口：开放2222端口</p>
<pre><code>firewall-cmd --permanent --add-port=2222/tcp
</code></pre>
<p>3、修改ssh端口</p>
<pre><code>vi /etc/ssh/sshd_config
Port 2222    //去掉前面的#号，然后把22改成你要的端口，最大别超过65535
</code></pre>
<p>wq保存退出。</p>
<p>4、SELinux设置</p>
<p>如果SELinux未开启可跳过直接重启防火墙和sshd服务即可。默认SELinux都是开启的。</p>
<p>设置SELinux允许SSH监听新的自定义SSH端口</p>
<pre><code>semanage port -a -t ssh_port_t -p tcp 2222
</code></pre>
<p>如果提示semanage没安装，可以执行下面的命令安装。</p>
<pre><code>yum -y install policycoreutils-python             //安装后就可以使用semanage命令了。
</code></pre>
<p>接下来执行以下命令查看SELinux下SSH相关端口是不是成功修改为自定义SSH端口</p>
<pre><code>semanage port -l|grep ssh
ssh_port_t tcp 2222, 22              //这么显示说明端口已经修改了。
</code></pre>
<p>第⑤步：重启SSH服务和防火墙</p>
<pre><code>systemctl restart sshd       //重启SSH
systemctl restart firewalld.service     //重启防火墙
</code></pre>
<p>步骤全部完成，可以打开新的putty客户端通过新端口测试下。</p>
<p>如果不行，可联系售后 进去检查配置。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>WebGIS开源时空架构方案</title>
    <url>/2023/07/23/WebGIS%E5%BC%80%E6%BA%90%E6%97%B6%E7%A9%BA%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>一套WebGIS架构方案包含以下几个基本要素：</p>
<h2 id="1-前端框架"><a href="#1-前端框架" class="headerlink" title="1. 前端框架"></a>1. 前端框架</h2><p>前端框架选择主要考虑到易用性、维护性和功能性。目前比较流行的前端框架有Vue、React和Angular等，其中Vue最为轻量级、易上手和扩展性好，因此可以选择Vue作为前端框架。</p>
<h2 id="2-后端框架"><a href="#2-后端框架" class="headerlink" title="2. 后端框架"></a>2. 后端框架</h2><p>后端框架主要负责处理数据接口请求和数据存储。根据项目规模和需求，可以选择Flask、Django、Express、Spring等框架。其中，Flask是一款轻量级、灵活的框架，易于搭建，因此可以选择Flask作为后端框架。</p>
<h2 id="3-数据库选择"><a href="#3-数据库选择" class="headerlink" title="3. 数据库选择"></a>3. 数据库选择</h2><p>数据库主要用于存储和管理各种数据，包括地理空间数据、非地理空间数据等。目前较为常见的数据库有MySQL、PostgreSQL、MongoDB等，其中PostgreSQL是一款可扩展性和稳定性较好的数据库，支持地理空间数据的存储和查询，因此可以选择PostgreSQL作为数据库。</p>
<h2 id="4-数据库管理工具"><a href="#4-数据库管理工具" class="headerlink" title="4. 数据库管理工具"></a>4. 数据库管理工具</h2><p>数据库管理工具可以方便地对数据库进行管理、维护和优化。目前比较优质的数据库管理工具有PgAdmin、Navicat等，其中PgAdmin是一款免费且开源的数据库管理工具，支持PostgreSQL的管理和维护。</p>
<h2 id="5-地图渲染引擎"><a href="#5-地图渲染引擎" class="headerlink" title="5. 地图渲染引擎"></a>5. 地图渲染引擎</h2><p>地图渲染引擎负责将地理空间数据转换为可视化的地图，并提供丰富的地图交互功能。目前较为流行的地图渲染引擎有Mapbox、Leaflet、OpenLayers等，其中Leaflet是一款轻量级、易扩展的地图渲染引擎，提供丰富的地图渲染和交互功能，因此可以选择Leaflet作为地图渲染引擎。</p>
<h2 id="6-地理编码服务"><a href="#6-地理编码服务" class="headerlink" title="6. 地理编码服务"></a>6. 地理编码服务</h2><p>地理编码服务主要用于将地址转换为经纬度坐标或者将经纬度坐标转换为地址。目前市面上比较好的地理编码服务有Google Maps API、ArcGIS Online等，其中Google Maps API是一款大众使用的地理编码服务，免费版可以提供较准确的地址解析和逆地址解析功能，因此可以选择Google Maps API作为地理编码服务。</p>
<h2 id="7-部署环境"><a href="#7-部署环境" class="headerlink" title="7. 部署环境"></a>7. 部署环境</h2><p>部署环境在开源WebGIS方案中也是十分关键的，可以选择Linux操作系统、Nginx服务器和Docker容器。其中，Linux操作系统是开源、快速、安全和稳定的操作系统，适用于部署Web应用、网络服务器等；Nginx服务器是一款高性能的Web服务器和反向代理服务器，可以提高Web应用程序的性能和规模化适应能力；Docker容器是一款轻量级、移植性强的容器技术平台，可以确保应用程序在任何环境下都能够正常运行。</p>
<p>以此为基本架构，可以根据实际情况进行灵活的定制和优化，以满足项目需求。</p>
<p>目前国际上著名的地理空间信息生产商大都拥有了成熟的产品线， 基本涵盖了从数据采集、数据编辑、数据管理、空间数据互操作、空间分析到网络地理信息服务注册、发布、聚合等所有地理信息工程相关的功能模块 。有时候，在商业软件价格比较昂贵的情况下，使用开源WebGIS也是一个不错的选择。</p>
<h1 id="二、开源WebGIS架构"><a href="#二、开源WebGIS架构" class="headerlink" title="二、开源WebGIS架构"></a>二、开源WebGIS架构</h1><p>一套开源WebGIS架构方案包含以下三个部分：</p>
<h2 id="2-1-地理信息数据库和业务数据库"><a href="#2-1-地理信息数据库和业务数据库" class="headerlink" title="2.1 地理信息数据库和业务数据库"></a>2.1 地理信息数据库和业务数据库</h2><p>地理信息数据库用于存储地理信息数据（包含矢量、地名地址、专题及瓦片数据）；<br>业务数据库用于存储前端网站或者行业应用的关系型数据；</p>
<h2 id="2-2-GIS服务器"><a href="#2-2-GIS服务器" class="headerlink" title="2.2 GIS服务器"></a>2.2 GIS服务器</h2><p>GIS服务器则用于提供WMS、WTMS、WFS和WCS等GIS服务；</p>
<h2 id="2-3-Web应用服务器"><a href="#2-3-Web应用服务器" class="headerlink" title="2.3 Web应用服务器"></a>2.3 Web应用服务器</h2><p>Web应用服务器主要针对行业应用，用于调取GIS服务和后台的业务数据，并在前端展示。</p>
<p>提供Web信息浏览服务，通常你看到的是一个网站。</p>
<h2 id="2-4-开源WebGIS解决方案"><a href="#2-4-开源WebGIS解决方案" class="headerlink" title="2.4 开源WebGIS解决方案"></a>2.4 开源WebGIS解决方案</h2><p>针对WebGIS以上组成部分，一套开源WebGIS有着相应的解决方案，其架构方式如下 ：</p>
<p>数据生产（桌面软件–uDig、QGIS等）<br>数据存储（关系型或非关系型数据库：postgreSQL、mySQL、mongodb）<br>GIS服务（GIS服务器：mapserver、Geoserver）<br>Web服务（Web服务器：tomcat、apache、nginx）<br>前端渲染（OpenLayers 、cesium、mapbox、leaflet）<br>当然还需要提供这一整套架构方式的外围软件环境：</p>
<p>虚拟化或者云环境(VirtualBox、OpenStack、docker)<br>操作系统（linux：centos、ubuntu）<br>堡垒机( teleport )<br>运维系统( spug )<br>Nas服务器(TrueNas)</p>
<ul>
<li>2.4.1 地图数据生产</li>
</ul>
<p>使用uDig、QGIS、Grass等开源桌面GIS软件采集、加工地理信息数据<br>uDig：<a href="http://udig.refractions.net/">http://udig.refractions.net/</a><br>QGIS：<a href="https://www.qgis.org/">https://www.qgis.org/</a><br>Grass：<a href="https://grass.osgeo.org/">https://grass.osgeo.org/</a><br>OpenEV：<a href="http://openev.sourceforge.net/">http://openev.sourceforge.net/</a><br>gvSIG ：<a href="http://www.gvsig.com/">http://www.gvsig.com/</a><br>OpenJUMP：<a href="http://www.openjump.org/">http://www.openjump.org/</a><br>OSSIM：<a href="http://trac.osgeo.org/ossim/">http://trac.osgeo.org/ossim/</a><br>InterImage：<a href="http://www.lvc.ele.puc-rio.br/projects/interimage/%EF%BC%88%E4%B8%93%E6%B3%A8%E5%BD%B1%E5%83%8F%E8%A7%A3%E8%AF%91%EF%BC%89">http://www.lvc.ele.puc-rio.br/projects/interimage/（专注影像解译）</a><br>PolSARPro：<a href="https://earth.esa.int/web/polsarpro%EF%BC%88%E6%9E%81%E5%8C%96%E9%9B%B7%E8%BE%BE%E5%A4%84%E7%90%86%EF%BC%89">https://earth.esa.int/web/polsarpro（极化雷达处理）</a><br>E-foto：<a href="http://www.efoto.eng.uerj.br/en">http://www.efoto.eng.uerj.br/en</a> 航空摄影测量</p>
<ul>
<li>2.4.2 地理信息数据存储</li>
</ul>
<p>关系型数据使用PostGIS或者MySQL Spatial数据库存储地理信息数据和关系型业务数据，</p>
<p>非关系型数据使用mongodb数据库（瓦片、图像）<br>PostGIS：<a href="http://postgis.net/">http://postgis.net/</a><br>PostgreSQL：<a href="https://www.postgresql.org/">https://www.postgresql.org/</a><br>MySQL：<a href="https://www.mysql.com/">https://www.mysql.com</a><br>mongodb ：<a href="https://www.mongodb.com/">https://www.mongodb.com/</a><br>rasdaman：<a href="http://www.rasdaman.org/">http://www.rasdaman.org/</a> （栅格数据库）<br>SpatiaLite:<a href="http://www.gaia-gis.it/gaia-sins/">http://www.gaia-gis.it/gaia-sins/</a> (轻量级数据库SQLite空间扩展)</p>
<ul>
<li>2.4.3 GIS服务器</li>
</ul>
<p>使用GeoServer、MapServer生产地图瓦片，注册、发布地理信息服务。</p>
<p>GeoServer：<a href="http://geoserver.org/">http://geoserver.org/</a><br>MapServer：<a href="http://mapserver.org/">http://mapserver.org/</a><br>Mapnik：<a href="http://mapnik.org/">http://mapnik.org/</a><br>TileCache：<a href="http://tilecache.org/">http://tilecache.org/</a><br>MapTiler:<a href="https://www.maptiler.com/">https://www.maptiler.com/</a></p>
<ul>
<li>2.4.4 Web服务器应用</li>
</ul>
<p>使用Geomajas、Tomcat或apache搭建网站，在网页中嵌入地图容器加载地图；使用niginx作为反向代理或者负载均衡。</p>
<p>Tomcat：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> （网站服务器）<br>apache:<a href="https://www.apache.org/(apache%E5%8D%B3%E5%8F%AF%E5%81%9A%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%88%E5%8F%AF%E4%BD%9C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)">https://www.apache.org/(apache即可做网站服务器又可作反向代理、负载均衡)</a><br>nginx：<a href="http://nginx.org/">http://nginx.org/</a> （负载均衡、反向代理）</p>
<p>地图网站专用服务器<br>GeoMoose：<a href="https://demo.geomoose.org/">https://demo.geomoose.org/</a><br>Geomajas：<a href="http://www.geomajas.org/">http://www.geomajas.org/</a></p>
<ul>
<li>2.4.5 个人客户端或者web应用服务器的前端展示：</li>
</ul>
<p>地理信息服务使用OpenScales、支持Java的Openlayers或Leaflet地图容器前端展示。前端其他数据展示使用Java、vue等流行网页API。</p>
<p>openlayers(Java): <a href="http://openlayers.org/">http://openlayers.org/</a><br>openscales(Flex): <a href="http://openscales.org/">http://openscales.org/</a><br>LeafLet：<a href="https://leafletjs.com/">https://leafletjs.com</a><br>Cesium:<a href="https://github.com/CesiumGS/cesium">https://github.com/CesiumGS/cesium</a><br>ol-cesium:<a href="https://openlayers.org/ol-cesium/">https://openlayers.org/ol-cesium/</a><br>注：这里的web应用服务器相对于GIS服务器而言是客户端，相对于浏览者而言是服务器。</p>
<p>以上给出使用开源软件实现WebGIS各个环节可采用的软件，在实际项目中，应根据项目需要做一下筛选。</p>
<p>比如：uDig (QGIS)+ PostgreSQL/PostGIS （mongodb）+ GeoServer + Tomcat +Openlayers组合。</p>
<p>倘若有高性能、高可用的需求，还应使用集群技术，搭建数据库集群、GIS服务器集群和web应用服务器集群生态，增加服务的冗余，提高服务性能，毕竟地图服务不是简单的网页服务，其消耗的资源是非常大的，即便是一个空间查询语句，对数据库的性能消耗也是非常可观的。</p>
<h1 id="三、开源地理数据函数库"><a href="#三、开源地理数据函数库" class="headerlink" title="三、开源地理数据函数库"></a>三、开源地理数据函数库</h1><p>以下列出所有开源软地理信息软件或者商业地理信息软件都可能有到的开源地理信息函数库。其中，GDAL/ORG、PROJ.4、GEOS是地理信息软件或者系统开发的三架马车，它们搭建了地理信息软件的基础。</p>
<p>GDAL/OGR:<a href="https://gdal.org/">https://gdal.org/</a> 开源栅格/矢量空间数据转换库<br>PROJ.4:<a href="https://proj.org/">https://proj.org/</a> 地图投影库<br>GEOS:<a href="http://trac.osgeo.org/geos">http://trac.osgeo.org/geos</a> 开源地理空间数据引擎<br>pyshp:<a href="https://pypi.org/project/pyshp/">https://pypi.org/project/pyshp/</a> 用于处理shapfile的简单函数库<br>Shapely:<a href="https://pypi.org/project/Shapely/">https://pypi.org/project/Shapely/</a> 基于 GEOS，用于操作和分析平面几何对象的函数库<br>Fiona:<a href="https://pypi.org/project/Fiona/">https://pypi.org/project/Fiona/</a> 基于GDAL,用于读取空间矢量数据的函数库<br>Rasterio:<a href="https://pypi.org/project/rasterio/">https://pypi.org/project/rasterio/</a> 基于GDAL和Numpy，用于读取地理空间栅格数据的函数库<br>PIL:<a href="https://pypi.org/project/PIL/">https://pypi.org/project/PIL/</a> 用于处理影像的python库<br>NumPy：<a href="https://pypi.org/project/numpy/">https://pypi.org/project/numpy/</a> 用于矩阵科学计算的函数库<br>Scikit-image：基于scipy的一款图像处理python库<br>GeoPandas:<a href="http://geopandas.org/">http://geopandas.org/</a> 用于空间分析的函数库<br>SPy:<a href="http://www.spectralpython.net/">http://www.spectralpython.net/</a> 用于高光谱遥感影像处理的python库<br>GML4J：<a href="http://gml4j.sourceforge.net/">http://gml4j.sourceforge.net/</a> 用于读取gml数据的函数库<br>GSLIB：<a href="http://www.gslib.com/">http://www.gslib.com/</a> 用于空间统计的函数库<br>JTS：<a href="https://sourceforge.net/projects/jts-topo-suite/">https://sourceforge.net/projects/jts-topo-suite/</a> （支持JAVA的空间分析包）<br>GeoTools：<a href="https://www.geotools.org/">https://www.geotools.org/</a> （支持JAVA的地理处理工具箱）<br>GeoMesa：<a href="https://www.geomesa.org/">https://www.geomesa.org/</a> 分布式时空大数据分析工具，配合hadoop使用</p>
<h1 id="四、开放网络地图引擎"><a href="#四、开放网络地图引擎" class="headerlink" title="四、开放网络地图引擎"></a>四、开放网络地图引擎</h1><p>OSM:<a href="https://www.openstreetmap.org/">https://www.openstreetmap.org/</a> 地图<br>Navit:<a href="https://www.navit-project.org/">https://www.navit-project.org/</a> 导航</p>
<h1 id="五、开放三维引擎"><a href="#五、开放三维引擎" class="headerlink" title="五、开放三维引擎"></a>五、开放三维引擎</h1><p>Cesium：<a href="https://cesium.com/">https://cesium.com/</a><br>OSG earth:<a href="http://www.openscenegraph.org/">http://www.openscenegraph.org/</a><br>ogre:<a href="https://www.ogre3d.org/">https://www.ogre3d.org/</a><br>marble:<a href="https://marble.kde.org/">https://marble.kde.org/</a></p>
<h1 id="六、开放地理处理工具"><a href="#六、开放地理处理工具" class="headerlink" title="六、开放地理处理工具"></a>六、开放地理处理工具</h1><p>GeoTools：<a href="https://www.geotools.org/">https://www.geotools.org/</a> 地理处理工具箱<br>GeoNetwork：<a href="https://geonetwork-opensource.org/">https://geonetwork-opensource.org/</a> 网络地图查看和目录工具<br>Orfeo ToolBox：<a href="https://www.orfeo-toolbox.org/">https://www.orfeo-toolbox.org/</a> 可以处理TB级的高分辨率光学，多光谱和雷达图像。 </p>
<h1 id="七、时空大数据框架"><a href="#七、时空大数据框架" class="headerlink" title="七、时空大数据框架"></a>七、时空大数据框架</h1><p>随着全球化和信息化的发展，数据已经成为一种非常宝贵的资源。时空大数据处理技术也因其在军事、环境、气象、交通和金融等领域的广泛应用而备受关注。为了提高数据处理效率和准确度，许多企业和机构开始采用开源框架来构建他们的时空大数据应用。</p>
<p>在本文中，我们介绍几个流行的时空大数据开源框架。</p>
<ul>
<li><ol>
<li>Apache Hadoop</li>
</ol>
</li>
</ul>
<p>Apahce Hadoop是一款流行的分布式存储和分析平台，它可以处理大规模数据和时间序列数据。Hadoop是一种完全开源的框架，旨在处理大数据集并在集群中分发数据。它主要由HDFS（Hadoop 分布式文件系统）和MapReduce（一种计算框架）组成。Hadoop有着广泛的数据处理能力，因此可以在很多大型企业、政府机构和科研团队中得到应用。</p>
<ul>
<li><ol start="2">
<li>Apache Spark</li>
</ol>
</li>
</ul>
<p>Apache Spark是一款快速的大数据计算系统，其可以在内存中快速处理大数据。它能够支持复杂的数据分析任务和像机器学习这样的数据科学工作负载。Spark比Hadoop处理速度更快，并且可以在不占用太多资源的情况下进行大数据处理。它也支持Python、Java和Scala等多种编程语言。Apache Spark常被用来对时空数据进行分析和可视化。</p>
<ul>
<li><ol start="3">
<li>GeoMesa</li>
</ol>
</li>
</ul>
<p>GeoMesa是一个地理信息系统（GIS）库，可以用于管理和分析大规模时空数据集。它是一个开源库，形成了在云中处理海量时空数据的技术基础，并提供了一些用于时空数据管理和分析的工具。GeoMesa支持多种数据源，如Hadoop、Spark和Accumulo等。利用GeoMesa框架，可以实现时空数据的存储、查询、分析和可视化等操作。</p>
<ul>
<li><ol start="4">
<li>GeoSpark</li>
</ol>
</li>
</ul>
<p>GeoSpark是基于Spark的时空数据处理、分析和可视化框架。与Apache Spark相似，GeoSpark使用内存计算技术，利于大规模数据的处理。该框架支持多种时空数据源，包括点、线、面、栅格等各种空间数据类型，并提供了丰富的时空数据分析算法。GeoSpark发挥了Spark和Hadoop的优点，使它成为一种非常强大的时空数据分析框架，被广泛应用于城市规划、交通管理和环境监测等领域。</p>
<p>总之，这些时空大数据开源框架可以帮助企业和组织快速处理和分析时空数据，最大程度地实现数据价值。以上框架都是经过长期测试的，应用广泛的开源框架，因此用户可以根据项目需求和特点对其进行灵活的选择和定制。</p>
<h1 id="八、开放协会或组织"><a href="#八、开放协会或组织" class="headerlink" title="八、开放协会或组织"></a>八、开放协会或组织</h1><p><a href="https://www.osgeo.org/">https://www.osgeo.org/</a> 开源地理空间基金会<br><a href="https://www.osgeo.cn/">https://www.osgeo.cn/</a> 中国开放地理空间实验室<br><a href="https://www.opengeospatial.org/">https://www.opengeospatial.org/</a> OGC开放地理空间信息联盟</p>
<p>加利福利亚大学荧光动力学实验室python 库:<br><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<p>也可参见grss-ieee地球科学与遥感学会与遥感相关的开源函数库和软件列表：<br><a href="http://www.grss-ieee.org/open-source-software-related-to-geoscience-and-remote-sensing/">http://www.grss-ieee.org/open-source-software-related-to-geoscience-and-remote-sensing/</a></p>
<p>OSGeoLive 目录：<br><a href="http://live.osgeo.org/en/overview/overview.html">http://live.osgeo.org/en/overview/overview.html</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>WebGIS</tag>
        <tag>OpenSource</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下的GitLab安装与删除</title>
    <url>/2023/07/22/CentOS7%E4%B8%8B%E7%9A%84GItLab%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-GitLab-安装"><a href="#一-GitLab-安装" class="headerlink" title="一. GitLab 安装"></a>一. GitLab 安装</h1><h2 id="1-安装和配置必须的依赖项"><a href="#1-安装和配置必须的依赖项" class="headerlink" title="1. 安装和配置必须的依赖项"></a>1. 安装和配置必须的依赖项</h2><pre><code>sudo yum install -y curl policycoreutils-python openssh-server perl
sudo systemctl enable sshd
sudo systemctl start sshd
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo systemctl reload firewalld

sudo yum install postfix
sudo systemctl enable postfix
sudo systemctl start postfix
</code></pre>
<h2 id="2-下载-安装极狐GitLab"><a href="#2-下载-安装极狐GitLab" class="headerlink" title="2. 下载/安装极狐GitLab"></a>2. 下载/安装极狐GitLab</h2><p>配置极狐GitLab 软件源镜像。</p>
<ul>
<li><p>旗舰版、官网教程</p>
<p>  curl -fsSL <a href="https://packages.gitlab.cn/repository/raw/scripts/setup.sh">https://packages.gitlab.cn/repository/raw/scripts/setup.sh</a> | /bin/bash<br>  sudo EXTERNAL_URL=”<a href="https://192.168.10.33:9998&quot;">https://192.168.10.33:9998&quot;</a> yum install -y gitlab-jh</p>
</li>
<li><p>社区版，CSDN参考</p>
<p>  curl <a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh">https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh</a> | sudo bash<br>  sudo EXTERNAL_URL=”<a href="http://192.168.10.33:9998&quot;">http://192.168.10.33:9998&quot;</a> yum install -y gitlab-ce</p>
<p>  gitlab-ctl reconfigure</p>
<p>  gitlab-ctl start || gitlab-ctl restart</p>
</li>
</ul>
<h2 id="4-设置开机自启动"><a href="#4-设置开机自启动" class="headerlink" title="4 设置开机自启动"></a>4 设置开机自启动</h2><pre><code>sudo systemctl enable gitlab-runsvdir.service
</code></pre>
<h2 id="5-切换目录使用命令进入控制台修改用户状态"><a href="#5-切换目录使用命令进入控制台修改用户状态" class="headerlink" title="5.切换目录使用命令进入控制台修改用户状态"></a>5.切换目录使用命令进入控制台修改用户状态</h2><pre><code>1) 切换到相应路径下: cd /opt/gitlab/bin/
2) 打开控制台: sudo gitlab-rails console -e production
3) 查询用户账号信息并赋值给u: u=User.where(id:1).first
4) 设置该用户名的密码: u.password=&#39;Demo9999&#39;
5) 确认密码: u.password_confirmation=&#39;Demo9999&#39;
6) 保存信息： u.save 
7) 退出: exit
</code></pre>
<h1 id="二-GitLab-卸载"><a href="#二-GitLab-卸载" class="headerlink" title="二. GitLab 卸载"></a>二. GitLab 卸载</h1><h2 id="1、停止-gitlab服务"><a href="#1、停止-gitlab服务" class="headerlink" title="1、停止 gitlab服务"></a>1、停止 gitlab服务</h2><pre><code>gitlab-ctl stop
</code></pre>
<h2 id="2、卸载-gitlab（社区版）"><a href="#2、卸载-gitlab（社区版）" class="headerlink" title="2、卸载 gitlab（社区版）"></a>2、卸载 gitlab（社区版）</h2><pre><code>rpm -e gitlab-ce 或者  yum remove gitlab-ce
</code></pre>
<h2 id="3、查看-gitlab-进程"><a href="#3、查看-gitlab-进程" class="headerlink" title="3、查看 gitlab 进程"></a>3、查看 gitlab 进程</h2><pre><code>ps aux | grep gitlab 
</code></pre>
<h2 id="4、杀掉gitlab-service进程，该进程与runsvdir相关（带有好多…………-的进程）"><a href="#4、杀掉gitlab-service进程，该进程与runsvdir相关（带有好多…………-的进程）" class="headerlink" title="4、杀掉gitlab service进程，该进程与runsvdir相关（带有好多…………. 的进程）"></a>4、杀掉gitlab service进程，该进程与runsvdir相关（带有好多…………. 的进程）</h2><pre><code>kill -9 xxxxxx
</code></pre>
<p>其实就是强杀/opt/gitlab/service进程</p>
<p>如果还不知道怎么杀，就重启服务器也行。</p>
<h2 id="5、查找并删除所有包含-gitlab-的遗留文件"><a href="#5、查找并删除所有包含-gitlab-的遗留文件" class="headerlink" title="5、查找并删除所有包含 gitlab 的遗留文件"></a>5、查找并删除所有包含 gitlab 的遗留文件</h2><pre><code>find / -name *gitlab*|xargs rm -rf  
find / -name gitlab |xargs rm -rf 

find / -name postgres |xargs rm -rf 

删除gitlab-ctl uninstall时自动在root下备份的配置文件（ls /root/gitlab* 看看有没有，有也删除）
</code></pre>
<h2 id="6、根据上面列出来的目录清单主要删除一下目录"><a href="#6、根据上面列出来的目录清单主要删除一下目录" class="headerlink" title="6、根据上面列出来的目录清单主要删除一下目录"></a>6、根据上面列出来的目录清单主要删除一下目录</h2><pre><code>rm -rf /etc/gitlab
rm -rf /opt/gitlab
rm -rf /log/gitlab
rm -rf /var/opt/gitlab
rm -rf /var/log/gitlab
rm -rf /run/gitlab
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>WinRar删除文件有妙用</title>
    <url>/2023/07/21/WinRar%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%9C%89%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经常出现文件删掉了，文件夹无法删除，出现“该项目不在请确认该项目位置,然后重试”的场景</p>
<p>使用WinRar的压缩功能，把文件夹选中，点右键选中压缩功能，在弹窗中勾选压缩后自动删除源文件，压缩。神奇的事情发生了，可以把源文件删掉。win11亲测有效。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>删除文件</tag>
        <tag>WinRar</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM软件包名中的el5、el6、el7是什么</title>
    <url>/2023/07/20/RPM%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%90%8D%E4%B8%AD%E7%9A%84el5%E3%80%81el6%E3%80%81el7%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>EL 是 Red Hat Enterprise Linux 的简写。同理，OL 大概是 Oracle Linux的意思吧。</p>
<p>EL6 表示软件包可以在 Red Hat 6.x，CentOS 6.x，CloudLinux 6.x 进行安装<br>EL5 表示软件包可以在 Red Hat 5.x，CentOS 5.x，CloudLinux 5.x 进行安装<br>EL7 表示软件包可以在 Red Hat 7.x，CentOS 7.x，CloudLinux 7.x 进行安装</p>
<p>————————————————<br>版权声明：本文为CSDN博主「liaowenxiong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/liaowenxiong/article/details/117136545">https://blog.csdn.net/liaowenxiong/article/details/117136545</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Github国内镜像网址，亲测好用</title>
    <url>/2023/07/19/Github%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E7%BD%91%E5%9D%80%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%A5%BD%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不定期测试更新可用网址。建议先收藏</p>
<p><a href="https://kgithub.com/">https://kgithub.com/</a></p>
<p>使用方式：<br>将github源网址前面加k即可。</p>
<p>比如：<a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a></p>
<p>改为：<a href="https://kgithub.com/spring-projects/spring-boot">https://kgithub.com/spring-projects/spring-boot</a></p>
<p>然后可以查看代码，查看issue和评论，默认自动带上k，方便。</p>
<p>限制：<br>1.不能注册</p>
<p>2.不能上传文件，可以登录，可以在线编辑</p>
<p>3.来自raw.githubusercontent.com的下载可使用raw.kgithub.com替代</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>电价机制迎来新变化 拉大峰谷价差，建立“尖峰”电价</title>
    <url>/2023/07/18/%E7%94%B5%E4%BB%B7%E6%9C%BA%E5%88%B6%E8%BF%8E%E6%9D%A5%E6%96%B0%E5%8F%98%E5%8C%96%EF%BC%8C%E6%8B%89%E5%A4%A7%E5%B3%B0%E8%B0%B7%E4%BB%B7%E5%B7%AE%EF%BC%8C%E5%BB%BA%E7%AB%8B%E2%80%9C%E5%B0%96%E5%B3%B0%E2%80%9D%E7%94%B5%E4%BB%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源：人民日报海外版</p>
<p>拉大峰谷价差，建立“尖峰”电价——电价机制迎来新变化</p>
<p>“最大用电负荷创历史新高”——今夏，全国各地高温天气频繁，发用电量连刷新纪录。国家能源局数据显示，7月，全社会用电量达7758亿千瓦时，同比增长12.8%。</p>
<p>为缓解电力供需矛盾，国家发改委日前印发《关于进一步完善分时电价机制的通知》（下称《通知》），部署各地进一步完善分时电价机制。完善分时电价机制有何考量？具体作了哪些调整？对工商业和普通居民用电有啥影响？</p>
<p>适应电力供需新形势</p>
<p>立秋后，暑热未消。下班回到家，王东从冰箱里拿出一罐冰可乐一饮而尽。“天气太热了，每天都离不开冷饮和空调。”家住上海市长宁区的王东抱怨，高温“炙烤”模式下，家里的空调几乎从早开到晚，7月的电费因此比上个月翻了一番。</p>
<p>受全国多地持续大范围高温天气影响，进入迎峰度夏以来，全国发用电量持续攀升。数据显示，7月14日，全国用电量达271.87亿千瓦时，比去年夏季最高值增长超10%。华东、华中、南网3个区域电网和河北南网、上海、江苏等12个省级电网最高用电负荷均创历史新高。</p>
<p>日前，发改委下发《通知》，要求各地进一步完善分时电价机制。这将对用电产生哪些影响？</p>
<p>据介绍，分时电价机制，是基于电能时间价值设计的，是引导用户削峰填谷、保障电力系统安全稳定经济运行的一项重要机制安排。通过对各时段制定不同的电价水平，引导电力用户在高峰时段少用电、低谷时段多用电。</p>
<p>自上世纪80年代起，国家开始推行分时电价：四川等地按月划分丰水期、枯水期，对电力供应紧张的枯水期执行丰枯电价；上海等地按季划分夏季、非夏季，对盛夏用电高峰期执行更高的季节性电价……截至目前，全国已有29个省份实施了分时电价机制。</p>
<p>“总体来看，这些年峰谷分时电价机制实施效果不错。”华北电力大学能源互联网研究中心主任曾鸣告诉本报记者，“尤其是用电占比大的工商业，由于其用电成本较高，对于能降低用电成本的削峰填谷机制也较重视。因此，多数工商业用户会通过积极调整用电时间等方式，达到降低成本的目的。”</p>
<p>不过，随着近年来中国电力消费结构加快变化，用电负荷对气温变化更敏感，电力系统负荷夏、冬两季尖峰化特征日益突出，电力供需呈现“平时充裕、尖峰紧张”“整体平衡、局部紧张”新特征，原有的分时电价机制已难以适应新形势。</p>
<p>国家发改委发布的数据显示，各地夏季最热、冬季最冷时段的全年累计时间普遍低于60个小时，但对应的尖峰电力需求可较平时高出1亿千瓦以上，保障电力系统安全稳定运行面临更大挑战，去年以来部分地方已不得不实施有序用电。</p>
<p>“进一步完善分时电价机制，特别是优化峰谷电价机制、出台尖峰电价机制，有利于充分发挥电价信号作用，引导用户错峰用电，保障电力系统安全稳定运行，降低经济社会运行成本。”国家发改委价格司相关负责人表示。</p>
<p>合理拉大峰谷价差</p>
<p>此次完善分时电价，做了哪些调整？</p>
<p>据介绍，调整主要包括优化峰谷电价机制、建立尖峰电价机制、建立健全季节性电价机制和丰枯电价机制、明确分时电价机制执行范围、建立动态调整机制、加强与电力市场的衔接等6个方面。其中，最大的亮点是合理拉大了峰谷电价价差，为引导电力用户削峰填谷、促进储能加快发展释放了清晰强烈的价格信号。</p>
<p>数据显示，目前，国内居民生活用电峰谷价差平均值在2∶1以下，工商业用电峰谷价差平均值在3∶1以下。面对不断攀升的用电负荷，偏低的峰谷电价价差可能削弱分时电价机制的经济性调节作用。</p>
<p>对此，新分时电价机制作出调整：电力系统峰谷差率超过40%的地方，峰谷电价价差原则上不低于4∶1，其他地方原则上不低于3∶1。各地应建立尖峰电价机制，尖峰时段根据前两年当地电力系统最高负荷95%及以上用电负荷出现的时段合理确定，尖峰电价在峰段电价基础上的上浮比例原则上不低于20%。</p>
<p>“此次调整增加了电价的浮动范围，有利于在电力供需矛盾极为突出的情况下，引导用户错峰用电，保障电力系统安全。”北京理工大学能源与环境政策研究中心副主任廖华告诉本报记者。</p>
<p>对于高峰用电的成本支出，江苏省昆山市一家笔记本电脑零部件企业负责人颇有感触。“夏季是我们的用电高峰期，不仅办公楼空调用电负担加重，还得加大生产车间换气设备投入。每到7月，电费就会比其他月份高出十几万元。”提及此次分时电价调整，他有些担忧：“拉大峰谷电价价差，会不会导致电费总体上涨？”</p>
<p>国家发改委价格司相关负责人表示，进一步完善分时电价机制，要坚持一项原则：保持电网企业的销售电价总水平基本稳定。</p>
<p>“也就是说，进一步完善分时电价机制，对社会总体用电成本影响较小，电网企业不会因此多收钱。”该负责人说。具体看，由于合理拉大了峰谷电价价差，高峰时段的电价会有所上调，低谷时段的电价会有所下调，能够错峰用电、在低谷时段多用电的用户用电成本会下降，在高峰时段用电的用户用电成本会有所上升。考虑到部分商业用户错峰用电难度大，同时明确对部分不适宜错峰用电的一般工商业电力用户，各地可研究制定平均电价，由用户自行选择。</p>
<p>对于居民用电，国家发改委的《通知》作出要求：有条件的地方，要按程序推广居民峰谷电价机制，逐步拉大峰谷电价价差，引导居民用户在高峰时段少用电、低谷时段多用电，发挥削峰填谷的作用。“总的看，此次进一步完善分时电价机制，对居民用电价格的影响较小。”发改委相关负责人表示。</p>
<p>推动构建新型电力市场</p>
<p>进一步完善分时电价机制，对能源产业发展有何现实意义？</p>
<p>“无论是鼓励高峰抑制用电，还是低谷促进用电，从经济层面看来，执行峰谷电价的积极意义都不小。”国网能源研究院财会与审计研究所所长李成仁接受本报记者采访表示，“前者可以降低电力系统投入，后者则能提高电力系统利用率。随着负荷峰谷差降低，还可能减少调峰资源的投入，节约燃料等运行成本。”</p>
<p>近年来，可再生能源装机规模和发电量不断增长，以风、光等为代表的新能源跻身发电“生力军”。由于“极热无风”“晚峰无光”“云来无光”“冬季枯水”，新能源存在一定“靠天吃饭”的特性。专家认为，推行新的分时电价机制，有助于提高可再生电力资源利用效率，加快推进能源系统转型升级。同时，也将为抽水蓄能、新型储能发展创造更大的空间。</p>
<p>“供应方面，分时电价机制有助于促进新能源发展和消纳。需求方面，能进一步推动储能和智能用电技术发展。”廖华说。通过拉大峰谷价差，鼓励高峰时段以较高价格发电，低谷时段以较低价格蓄能，将为储能技术提供发展动力。“在电价可变情形下，今后可以逐步推广更智能的用电设施，根据电价波动，智能调整用电时段。比如，未来可推广电动汽车智能充电技术和设施，根据电价水平自动决定是否充电。”</p>
<p>着眼中长期，完善分时电价机制，还将有力推动实现碳达峰、碳中和目标。“分时电价能促进可再生能源的消纳，从而助力实现‘双碳’目标。特别是中国电力市场还处于初期建设阶段、政府定价将在相当长时间内存在的情况下，分时电价机制将发挥非常重要的作用。”李成仁表示。</p>
<p>“未来，以风光为代表的可再生能源比例越来越大，发电出力曲线也会因此变化。执行分时电价机制，就是将需求侧的灵活性资源与供应侧的波动性曲线相匹配，这有利于建立新型电力系统和新型电力市场。长远来看，有助于‘双碳’目标的实现。”曾鸣说。</p>
<p>在具体执行方面，曾鸣认为，各地发电结构不一，新能源比例和出力特征不同。他建议，各地应因地制宜，划定分时电价的各种时段和具体价差。</p>
<p>廖睿灵</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>南方区域（广东）储能规模化应用的机遇和挑战</title>
    <url>/2023/07/17/%E5%8D%97%E6%96%B9%E5%8C%BA%E5%9F%9F%EF%BC%88%E5%B9%BF%E4%B8%9C%EF%BC%89%E5%82%A8%E8%83%BD%E8%A7%84%E6%A8%A1%E5%8C%96%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%BA%E9%81%87%E5%92%8C%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2018年7月2-4日，由上海逍天电子科技有限公司和华东储能领跑者联盟（EESA）联合主办的“2018中国国际光储充大会”于上海佘山召开。大会期间，共有百位演讲嘉宾分享了他们的专题报告。</p>
<p>南方区域（广东）储能规模化应用的机遇和挑战</p>
<p>南方电网储能科研团队，广东电网电科院储能技术研究所，易斌</p>
<p>01</p>
<p>储能应用需求及现状</p>
<p>广东电力系统运行特点：</p>
<p>从电网安全稳定运行的角度来看，广东电力系统运行特点明显，对灵活性快速调节资源的需求大。</p>
<p>广东电力系统运行特点：一是，电源装机容量大、煤电占比高。截至2017年底，广东统调装机容量1.07亿千瓦，其中燃煤机组占比54%。二是，省内快速调节资源紧张，调峰困难。燃气燃油机组、水电机组、蓄能机组占比仅28%，随着风电、光伏发电、核电等电源不断投产，预计未来系统调峰更为困难。三是，电网负荷水平高、峰谷差大，负荷曲线波动大及调频困难。2017年最高统调负荷10858万千瓦，负荷水平全国第一。广东电网高峰负荷日谷峰比达到0.62，高峰负荷当日的高峰与低谷负荷的差值甚至达到广西最高统调负荷的2倍。广东负荷攀升和下降速度快，部分时段变化速率较大，达80万kW/分钟。</p>
<p>▲ 2017年底广东电网地理接线图</p>
<p>▲ 广东电力系统运行特点</p>
<p>▲ 广东电网2017年高峰负荷日统调负荷曲线</p>
<p>广东可再生能源发展情况：</p>
<p>目前，广东省可再生能源以陆上风电、集中式光伏、分布式光伏和生物质发电为主，截至2018年5月，可再生能源并网总容量785.8万千瓦；光伏发电部分，分布式光伏所占比重大，且以城市区域分布式光伏发电较多，过去两年集中式光伏规模增长快。</p>
<p>▲ 截至2018年5月广东可再生能源并网容量（万千瓦）</p>
<p>▲ 集中式和分布式光伏对比（万千瓦）</p>
<p>注：广东省不含广州、深圳，不含水电</p>
<p>广东省沿海平均风速较大，风功率密度和风能利用小时数较高，湍流强度较低，风能资源丰富、品质较好，十分适宜发展海上风电。</p>
<p>《广东省海上风电发展规划(2017-2030)（修编）》，2020年海上风电建成投产200万千瓦，2030年约3000万千瓦。</p>
<p>全省规划海上风电场址23个，总装机容量6685万千瓦。近海浅水区15个，装机985万千瓦；近海深水区8个，装机5700万千瓦。</p>
<p>用户侧需求较大：</p>
<p>广东省2017年全社会用电量5958.97亿千瓦时，全国排名第一，其中工业用电量3815.29亿千瓦时，占比64%；</p>
<p>珠三角地区电价水平相对较高，也是工业用户聚集地，工业用户通过储能削峰填谷，可节约可观的用电成本。</p>
<p>注1：五市是指广州、珠海、佛山、中山、东莞。</p>
<p>注2：2017年1月1日起执行电价表。</p>
<p>注3：一般工商业用电的峰谷电价执行范围仅限于原普通工业专变用户。</p>
<p>注4：上述电价不含各项政府性基金及附加。</p>
<p>储能应用现状：</p>
<p>受储能技术成本因素制约，储能在广东应用规模较小，主要分布在少数的工业用户、工业园区、微电网示范区，发电侧储能应用刚刚起步。</p>
<p>但市场空间和发展潜力较大。</p>
<p>相关政策解读及市场机遇</p>
<p>02</p>
<p>广东电力市场建设概况：</p>
<p>当前广东中长期市场主要包括年度双边协商交易、年度合同电量集中交易、发电合同电量转让交易、月度集中竞争交易等四个交易品种，后续随着现货市场建立，交易品种将会更丰富。</p>
<p>年度集中竞价：为减少场外双边合同产生的利益分配不均衡，2018年广东省新增加了该类交易作为补充。</p>
<p>发电合同转让：为鼓励高参数、技术改造先进的大机组多发满发，2017年广东省增加了该类交易</p>
<p>2017年电力市场交易：</p>
<p>2017年广东电力市场交易电量突破千亿度，其中年度长协电量827.17亿度、月度集中竞价交易电量319.64亿度，培育市场主体6211个。</p>
<p>▲ 部分数据来源于广东省经济和信息化委网站公布数据</p>
<p>2018年随着市场主体准入条件进一步放宽，参与市场的用户进一步增多，市场化交易电量规模也进一步扩大。</p>
<p>电力现货市场建设：</p>
<p>广东电力市场改革不断深入，将逐步建立电能量现货市场、调频辅助服务市场和调峰辅助服务市场等运营规则，储能设施获得与其他资源同等身份参与电力市场的可能性变大。</p>
<p>▲ 从2017年第获批首批电力现货市场建设试点地区以来，广东电力现货市场建设节奏加快，取了较多阶段性的成果</p>
<p>南方（以广东起步）调频市场模拟运行情况：</p>
<p>2018年1-2月，南方（以广东起步）调频市场模拟运行期间，共交易调频里程共计323.49万兆瓦，平均日交易里程4.45万兆瓦，平均日调频补偿费用191.97万元，平均成交价格34.79元/兆瓦。</p>
<p>注：数据来源广东中调“南方区域（以广东起步）调频市场试运行情况汇报”</p>
<p>南方区域“两个细则”(2017版)：</p>
<p>新修订的《两个细则》首度承认了储能电站可提供充电调峰服务，并明确基本条件、补偿标准、考核标准等。</p>
<p>第三条本细则适用于南方区域地市级及以上电力调度机构直接调度的并与电力调度机构签订并网调度协议的容量为2MW/0.5小时及以上的储能电站。其他类型储能电站参照执行。</p>
<p>第十九条储能电站应具备自动发电控制（AGC）功能。</p>
<p>第二十一条储能电站根据电力调度机构指令进入充电状态的，按其提供充电调峰服务统计，对充电电量进行补偿，具体补偿标准为0.05 万元/兆瓦时。</p>
<p>智能电网专项规划：</p>
<p>响应国家智能电网发展指导意见和配电网建设改造行动计划等政策，积极开展智能电网专项规划，并明确推广储能系统与电网协调优化运行技术，应用储能构建综合能源利用体系，推进用户侧和配电网储能应用试点，提升电网可靠性和供电服务水平、提高电力设备利用率。电网企业对储能的重视将促进储能产业的发展和规模化应用。</p>
<p>▲ 9个智能电网示范区</p>
<p>03</p>
<p>规模化应用的问题与挑战</p>
<p>发电侧储能应用：</p>
<p>◆《广东调频辅助服务市场交易规则（试行）》的发布有效激励电厂进行灵活性改造，提升了系统调节性能；</p>
<p>◇ 目前部分电厂准备通过加装电池储能装置进行灵活性改造，储能的确迎来重要的发展机遇；</p>
<p>◆但电力调频辅助服务的分担共享机制还不健全，调频市场收益规模存在一定投资风险；</p>
<p>◇ 据悉，南方（以广东起步）调频市场正式运行时，市场机组总数约为153台</p>
<p>用户侧需求较大：</p>
<p>◆受储能投资成本和循环寿命等影响，储能在延缓电力输配设施扩容升级的技术经济性优势还不明显（甚至没优势）；</p>
<p>◇推动电网侧储能发展的政策和市场机制仍不完善，商业模式单一，储能的多元价值及其效益无法得到体现；</p>
<p>◆ 电网还缺少系统性的电网侧储能应用规划设计；</p>
<p>◇ 两个细则中的充电调峰服务，在实操层面还存在一定问题</p>
<p>用户侧储能应用：</p>
<p>◆ 应用模式单一，商业模式单一，主要靠削峰填谷获取收益；</p>
<p>◇ 广东广州、珠海、佛山、中山、东莞等5市峰谷价差不算太高，大工业峰谷价0.6997元/kWh（全国排第五），一般工商业0.9214元/kWh（全国排第三）；</p>
<p>◆管理制度不完善，补贴政策短期内不可实现，远期看电力现货市场体现用户侧储能等灵活性资源价值；</p>
<p>◇目前的市场环境下，“天时、地利、人和”兼备，才能获得较好的收益率</p>
<p>总结</p>
<p>1</p>
<p>广东负荷水平高、峰谷差大，对调峰调频等辅助服务的需求较高，特别是在新能源比例不但增大的背景下，系统对灵活的调峰、调频、备用的需求将进一步增大。但受储能技术成本和寿命的制约，应用规模仍较小，增长潜力较大。</p>
<p>2</p>
<p>受电力市场建设政策、能源规划政策等外部因素推动，以及电网自身升级改造内在需求驱动，储能将迎来快速发展的机遇，应该值得关注。</p>
<p>3</p>
<p>但总体来说需谨慎分析市场规模，并考虑市场规则变化和政策不完善的投资风险。</p>
<p>转载请注明来源：光储充一体化电站</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>IEEE-33节点配电网</title>
    <url>/2023/07/16/IEEE-33%E8%8A%82%E7%82%B9%E9%85%8D%E7%94%B5%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="回答1："><a href="#回答1：" class="headerlink" title="回答1："></a>回答1：</h1><p>IEEE-33节点配电网是一种典型的低压配电网结构，是电力系统中最常见的一种网络形式。该网络包括33个节点，其中包括三个变压器节点，30个负荷节点以及6个发电节点。该低压配电网结构通常被用于用电负荷较小的城市、乡村和工业园区的配电系统中。<br>IEEE-33节点配电网的设计理念是建立一个高效、稳定和经济的电力系统，以满足用户对电能的需求。其特点是节约空间、成本低廉、可靠性高以及维护成本低。这种网络结构具有较好的电压控制能力和电流平衡能力，可以满足用户对电力质量的要求。<br>在该低压配电网结构中，用户可以根据自己的需求选择不同的供电方式，包括单相电、双相电和三相电。同时，该网络还支持多种负荷类型，包括住宅、商业、工业和公共事业等不同用电负荷类型，可以更好地满足用户的要求。<br>总之，IEEE-33节点配电网作为一种低压配电网结构，具有版本性能、高效可靠、成本低廉等优点，可以为城市、乡村和工业园区的电力供应提供稳健的保障和支持。</p>
<h1 id="回答2："><a href="#回答2：" class="headerlink" title="回答2："></a>回答2：</h1><p>IEEE-33节点配电网是一个经典的电力系统仿真测试算例，广泛地应用于电力行业的研究、教学和实践。该配电网由33个节点组成，包含了传统配电网中的多种元件和设备，如变压器、开关、负荷、发电机等，以及典型的配电网拓扑结构，如环网、大量支路和单回路等。<br>在IEEE-33节点配电网中，每个节点都有独立的电压和电流参数，它们之间通过各种线路和设备相互连接。这些元件的特性参数，如阻抗、电容、电感等都是有限的，因此，在实际使用中，需要根据实际情况进行改动和修正，使其能更好地反映实际的配电网运行情况。<br>在研究IEEE-33节点配电网时，可以采用不同的仿真工具和算法，如潮流计算、短路计算、故障分析、保护设置等，用来评估和探究配电网的性能和特性，指导配电网的运行和管理，提高供电质量和可靠性等方面。同时，还可以用该配电网设计各种控制策略、保护方案、新能源接入等方面的应用研究。<br>总的来说，IEEE-33节点配电网是一个非常重要的电力系统仿真案例，它不仅具有较强的理论价值和实践意义，还为电力工程的发展和创新提供了重要的支撑和参考。</p>
<h1 id="回答3："><a href="#回答3：" class="headerlink" title="回答3："></a>回答3：</h1><p>IEEE-33节点配电网是指基于IEEE标准的33节点配电系统模型，该模型是研究和测试配电系统可靠性和稳定性的重要工具之一。这个模型包括33个节点、32条联接线路和3个高压源节点。<br>配电系统是指将高电压变压器输出的电能分配到低电压终端用户的系统。在现代城市和农村，配电系统越来越重要，配电安全和稳定运行对于经济和社会的发展都是至关重要的。因此，研究配电系统的可靠性、负荷调节、故障保护和能源管理等问题尤为重要，而IEEE33节点配电网模型为研究这些问题提供了良好的基础。<br>通过对IEEE-33节点配电网模型的研究，可以深入了解配电系统的运行机理和性能，提高配电系统的效率和可靠性。此外，该模型还可以用于测试和调整各种智能配电网应用程序和技术，如能量管理、分布式发电、电池储能和可靠性优化等。<br>总的来说，IEEE-33节点配电网模型是一个重要的工具，可以帮助研究者和工程师深入探究配电系统的运行特性，解决各种配电问题和优化能源管理。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>时空大数据及GIS在商业化选址中的探索应用</title>
    <url>/2023/07/15/%E6%97%B6%E7%A9%BA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%8AGIS%E5%9C%A8%E5%95%86%E4%B8%9A%E5%8C%96%E9%80%89%E5%9D%80%E4%B8%AD%E7%9A%84%E6%8E%A2%E7%B4%A2%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：陈旭<br>链接：<a href="https://www.zhihu.com/question/27115233/answer/2115892008">https://www.zhihu.com/question/27115233/answer/2115892008</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>本回答以某国产新势力造车企业的选址项目为例，讲述时空大数据及GIS在商业化选址中的探索应用。</p>
<ol>
<li>整体架构</li>
</ol>
<p>随着特斯拉和蔚来用直营模式在市场上逐渐站稳脚跟，更多车企意识到“用户思维”的重要性，因此他们也开始尝试改变销售模式，由批发转向零售，直面消费者。</p>
<p>直营模式的第一步就是要建立完整的营销渠道体系，其中包括销售门店选址、短期巡展商场选址、售后服务中心选址、品牌充电场站选址、线上新媒体广告投放选址、线下楼宇广告选址6个场景。</p>
<p>下图为利用时空大数据及GIS进行车企营销渠道选址的技术架构图，以新能源汽车轨迹数据、人口分布数据以及AOI数据为数据基础，对其进行清洗、处理、建模以及指标计算，通过数据了解目标群体客户居住在哪里、常去哪些商场、固定在哪里充电，从而帮助车企进行营销渠道选址。</p>
<p>利用时空大数据及GIS进行营销渠道选址的技术架构图</p>
<ol start="2">
<li>原始数据</li>
</ol>
<p>2.1 新能源汽车轨迹数据</p>
<p>车企依据国家标准（GBT32960.1-2016）实时从新能源汽车上采集车辆运行数据并汇聚到当地新能源汽车数据中心以及北京理工新能源汽车国家监测与管理平台。</p>
<p>采集的静态车辆属性数据包括车架号、车辆品牌，车辆型号、车辆购买年月等；采集的车辆动态运行数据包括位置数据、整车数据、电机数据、电驱数据、电池数据以及报警数据；采集频率是5~30秒一条。</p>
<p>国家标准（GBT32960.1-2016）规定采集的数据字段</p>
<p>下图为某辆车某次出行的连续轨迹数据，这辆车从浦东新区的中环森兰国际出发，经过中环高架路到达虹口区的海怡花园。</p>
<p>车辆轨迹数据示例</p>
<p>车辆轨迹数据示例车辆轨迹数据示例利用新能源汽车数据中的车辆品牌、车辆型号、购买年月并结合动态位置数据，可以了解目标客户群体的时空分布特征从而赋能选址工作。</p>
<p>2.2 人口分布数据</p>
<p>下图为人口分布数据示意图，利用人口分布数据可以清楚地了解城市内居民的时空分布特征，在大规模线上广告投放中可以准确地瞄准人群聚集区域进行投放，以最低的成本尽可能触达到更多的人口数量，节省大量不必要的成本支出。</p>
<p>人口分布数据</p>
<p>2.3 AOI数据</p>
<p>AOI数据（Area of Interest）指的是互联网电子地图中的兴趣面，包含名称、地址、类别、经纬度坐标四项基本信息，主要用于在地图中表达区域状的地理实体，如居民小区、商场、写字楼、产业园区、综合商场等。</p>
<p>AOI数据示例在营销渠道选址中使用AOI数据可以将非结构化的车辆轨迹数据以及人口分布数据落到具体的AOI实体边界中，以AOI为载体形成具体指标，例如某小区中高价值车辆的保有量、某商场中高价值车辆的停驻次数等，利用这些指标可以直接进行营销渠道选址。</p>
<ol start="3">
<li>数据清洗</li>
</ol>
<p>由于接入的车辆轨迹数据以及AOI数据存在空值率高、坐标偏移、坐标网格化、地理坐标系不统一、AOI实体缺失等问题。因此在使用数据之前需要进行数据清洗，清洗的步骤包括常规数据清洗、轨迹纠偏、网格化筛选、地理坐标系统一、AOI补充。</p>
<p>3.1 常规数据清洗</p>
<p>对车辆轨迹数据、人口分布数据以及AOI数据进行常规数据清洗，具体步骤包括：</p>
<p>对车辆静态属性数据、人口分布数据、AOI数据进行去重处理、缺失值及异常值处理。<br>剔除车辆轨迹数据中关键字段空置率的车辆数据，关键字段包括经纬度坐标、累计里程数、剩余电量<br>剔除车辆轨迹数据中关键字段异常率高的车辆数据。经度正常范围是70°<del>138°，纬度正常范围是2°</del>55°，累计里程值正常范围是0公里<del>5000000公里，剩余电量正常范围是0%</del>100%<br>针对车辆轨迹数据中剩余电量字段范围不一致的情况（有的车企电量最大值是100，有的车企电量最大值是255）进行一致化处理<br>针对人口分布数据中人口数量值字段的缺失值或异常值，利用均值插值的方法进行补充</p>
<p>人口分布数据插值处理</p>
<p>3.2 轨迹纠偏</p>
<p>由于GPS定位精度受到硬件及周边环境因素的干扰，车辆轨迹数据偶尔会出现坐标点偏移的情况</p>
<p>车辆轨迹数据坐标点偏移</p>
<p>针对轨迹偏移的情况，计算待判断坐标点与前后两个坐标点均值之间的距离，如果距离超过阈值（阈值一般是100米，针对采集频率的不同需要进行调整），则为偏移点需要剔除。</p>
<p>计算待判断坐标点与的前后两个坐标点均值之间的距离</p>
<p>3.3 网格化筛选</p>
<p>由于经纬度坐标值位数较长，在传输过程中可能因为通信协议的限制被强制取整，例如121.342313-&gt;121.34。存在这样问题的车辆轨迹数据在空间上呈网格化的特征，这样的数据对于时空行为特征探查是没有意义的，因此需要识别并剔除。</p>
<p>网格化的车辆轨迹数据</p>
<p>实际操作中用group by的方法提取每辆车唯一的经纬度坐标值，如果唯一的经纬度坐标数量与轨迹点总数量的比值过小，则车辆存在网格化的问题。</p>
<p>3.4 地理坐标系统一</p>
<p>不同的车企会根据不同的地理坐标系采集车辆轨迹数据，坐标系不统一会造成数据分析结果的偏差，因此在使用车辆轨迹数据之前先要确保地理坐标系的一致。</p>
<p>车辆轨迹坐标系与底图不匹配的情况</p>
<p>车辆轨迹坐标系与底图不匹配的情况</p>
<p>地理坐标系转换的方法可参考下面文章<br>陈旭：技术文档|利用Python进行地理坐标系统的转换90 赞同 · 51 评论文章</p>
<p>3.5 AOI数据补充</p>
<p>在实际操作中发现AOI数据存在重要地物缺失的问题，如下图所示为厦门AOI数据，其中SM广场一期和SM广场二期都缺失，这会对选址工作带来偏差。因此，在使用AOI数据之前，需要对缺失的重要地物进行补充。</p>
<p>厦门AOI数据缺少SM广场一期和SM广场二期</p>
<p>这边利用高德地图POI数据检验AOI数据的完整性，如下图所示，蓝绿色面图层是AOI数据，点图层是商场类POI数据，其中红色点是POI存在但AOI不存在的商场，针对这些缺失的商场进行手动补齐。运用相同的办法可以补充住宅小区、写字楼、产业园区等其他重要地物。</p>
<p>利用高德地图POI数据检验AOI数据的完整</p>
<p>性批量获取高德地图POI的方法可以参考下面这篇文章<br>陈旭：技术文档|利用Python获取高德POI兴趣点数据49 赞同 · 5 评论文章</p>
<ol start="4">
<li>数据处理</li>
</ol>
<p>4.1 次行切割</p>
<p>车辆轨迹数据属于非结构化数据，体量大且不能直接进行指标计算。因此，在指标计算之前需要建模将连续的车辆轨迹数据转变为只有起点和终点信息（包含经纬度坐标、时间、行驶里程、电量）的次行数据。</p>
<p>车辆轨迹数据变为次行数据</p>
<p>下图为次行切割模型的具体实现步骤，大概思路是先根据点与点之间的时间差进行自然切分，之后针对每段轨迹进行固定长度窗口切分并判断每个窗口的状态（行驶、停驻、充电），最后对相邻同状态的窗口进行合并形成次行数据。</p>
<p>次行切割模型步骤</p>
<p>4.2 居住地识别</p>
<p>在商业化选址中潜在客户的居住聚集区域是重要的参考依据，因此需要对次行数据进行建模并识别车主的居住地。</p>
<p>下图为某辆车一段时间内的次行数据，可以明显地看到这辆车的数据以南花园为中心散开，所以推测上南花园可能是这辆车的居住地。</p>
<p>某辆车的次行数据</p>
<p>在实际操作中通过以下步骤可以识别出车辆的居住地：<br>针对某辆车的次行数据，筛选17：00<del>24：00之间的到达坐标点以及6：00</del>10：00之间的出发坐标点，并形成一个坐标点的列表<br>利用DBSCAN算法对上面的坐标点列表进行密度聚类，得到若干个该车辆的聚集停留点<br>将聚集停留点与AOI数据进行空间匹配，在满足落到住宅小区前提下热度最高的聚集停留点就是该车辆的居住地。（可连续观测多个月数据来提高识别准确性）</p>
<p>4.3 空间匹配计算</p>
<p>通过建模得到车辆的次行数据以及居住地数据之后需要将这些坐标点与AOI数据进行空间匹配计算，最终将数字格式的经纬度坐标数据转换为具有实际意义的AOI实体。<br>例如某辆车某次的起点坐标是121.501601,31.23299，终点坐标是121.47663,31.232435，那么通过空间匹配计算我们就可以知道这辆车这次出行时从汤臣一品到人民广场来福士商场。<br>利用下图所示算法可以判断坐标点是否在AOI面内，或者也可以直接用Python中的GeoPandas库以及Java中GeoTools库完成这步计算。</p>
<p>判断坐标点是否在AOI面内的算法流程</p>
<p>利用上面的算法确实能够进行准确的空间匹配计算，但是对于大规模坐标点以及AOI面的计算效率较低，因此需要用技术手段来提高计算效率。</p>
<p>实际操作中，通过建立空间网格索引的方法来提高空间匹配计算的效率，用简单的浮点计算代替复杂的空间计算，下图为该算法的具体流程。</p>
<p>利用空间网格索引提高空间匹配计算的效率</p>
<ol start="5">
<li>指标计算</li>
</ol>
<p>经过数据清洗以及数据处理之后，已经将非结构化的车辆轨迹数据变成结构化的次行数据。接下来基于车辆行为日期类型、时间段、车辆价值、车辆购买时长6个数据维度进行计算，形成以AOI数据为载体的数据指标用于商业化选址。</p>
<p>数据维度包括5个方面：<br>车辆行为：停驻车辆数、充电车辆数、居住车辆数<br>车辆类型：乘用车、出租车、运营车、私家车<br>日期类型：工作日、休息日<br>时间段：23<del>6点、7</del>9点、10<del>16点、17</del>20点、21<del>22点月份：1月、2月、3月、4月、5月、6月、7月、8月、9月、10月、11月、12月<br>车辆价值：0</del>10万、10<del>20万、20</del>30万、30<del>40万、40万以上车辆<br>购买时长：0</del>1年、1<del>3年、3</del>5年、5~10年、10年以上</p>
<p>6个维度可以进行交叉计算得到对应的数据指标。</p>
<p>数据指标交叉计算在计算单个AOI数据指标的基础上，利用GIS中的缓冲区计算工具分别计算目标AOI周围1.5公里、3公里、5公里、10公里、15公里范围内的各项数据指标和。</p>
<p>缓冲区计算</p>
<ol start="6">
<li>选址场景</li>
</ol>
<p>车企商业化选址共有销售门店选址、巡展商场选址、售后服务中心选址、品牌充电站选址、线上广告投放选址、线下广告投放选址6个场景，针对不同的选址场景需要用不同的数据指标进行赋能。</p>
<p>销售门店是车企最重要的固定曝光点，是车企在当地城市中的旗舰标杆。销售门店需要选在具有稳定且带有巨大流量的商场，选址需要用到的数据指标包括（以某高端品牌车企为例，下同）：</p>
<p>所有车辆的停驻车辆数（判断商场人流量是否充足）<br>12个月的所有车辆的停驻车辆数（判断人流量是否稳定）<br>40万以上车辆的停驻车辆数（判断高净值人群是否经常光顾该商场）<br>1.5公里内40万以上车辆的居住车辆数（判断是否有大量高净值人群居住在商场周边，饭后闲逛能够有更多曝光）</p>
<p>巡展商场是车企的流动曝光点，相比销售门店成本较低且灵活性较强，一般一场巡展10天到半个月左右。巡展商场的选址逻辑和销售门店大致相同，在人流稳定的商场建立门店进行长期收割，在人流不太稳定的商场开展巡展进行定期收割，另外可以通过数据探查每个商场流量较高的月份并进行巡展。</p>
<p>售后服务中心是车企对已售出车辆提供养护及维修服务的场所，需要选在场地面积大且方便客户出行的区域。选址标准是以某城市所有售后服务中心为中心做15公里的缓冲区，所有缓冲区加起来需要覆盖80%的客户居住地。</p>
<p>售后服务中心选址</p>
<p>品牌充电站是车企给车主提供的增值服务，同时也是在潜在客户面前曝光的重要渠道。品牌充电站需要建立在两类地方，第一类是自己品牌车主聚集的居住地、工作地附近，目的是方便车主临时充电提升使用满意度；第二类是所有品牌车主聚集充电的地方，目的是提升在潜在客户（其他品牌车主）面前的曝光度。</p>
<p>线上广告指的是抖音、微信朋友圈等效果类广告投放，目的是获得更多潜在客户的电话号码。利用分时间段的40万以上车辆的停驻车辆数可以在时间和空间2个维度准确地找到目标客户群体，优化广告投放的时间和空间逻辑，避免大量不必要的成本支出。</p>
<p>线下广告指的是楼宇电梯广告、停车场道闸广告等。利用车龄5年以上的40万以上车辆的停驻车辆数等相关指标可以找到可能需要换车的高净值客户聚集的住宅小区。</p>
<ol start="7">
<li>展望</li>
</ol>
<p>未来可以利用更多数据辅助商业化选址，包括手机信令数据、商圈探针数据<br>利用时空大数据进行商业化选址的模式不仅仅可以应用于车企选址，零售行业、文旅行业都可以用<br>可以将本文所讲的内容打包成可以用的系统，开放给需要的人员使用（现在也正在做）</p>
<p>如果对本回答中出现的内容感兴趣，可以私聊我进行讨论~<br>如果我的回答对您有帮助，请不要吝啬您的赞和关注，谢谢~</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是GCJ02火星坐标系</title>
    <url>/2023/07/14/%E4%BB%80%E4%B9%88%E6%98%AFGCJ02%E7%81%AB%E6%98%9F%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>概述</p>
<p>在谷歌还没有发布谷歌地图时，在GIS领域常见的坐标系主要有WGS84经纬度坐标、北京54坐标或西安80坐标等；但自从谷歌地图发布之后，其海量的高清卫星免费影像是让整个GIS领域为之震惊的，但同时也为安全问题带来了一定的隐患。为了对实际坐标进行加密，于是国测局研究了一套算法，凡是公开发布的商业互联网地图，一定要在此加密算法的基础上进行发布，这样一来地图的坐标就与实地的坐标不相符了，于是大家把这种坐标戏称为“火星坐标”，这里我们就针对这一坐标作一些更为详细的说明。</p>
<h1 id="什么是火星坐标系？"><a href="#什么是火星坐标系？" class="headerlink" title="什么是火星坐标系？"></a>什么是火星坐标系？</h1><p>关于什么是火星坐标系，我们先来看看百度百科的解释。</p>
<p>火星坐标系</p>
<p>保密插件，也叫做加密插件或者加偏或者SM模组，是对真实地图或者导航坐标系统进行人为的加偏处理，按照一定的加偏算法，将真实的坐标加密成虚假的坐标。加偏处理不是线性的加偏，所以各地的偏移情况都会有所不同。加密后的坐标也常被人称为火星坐标系统。</p>
<p>中文名：火星坐标系统</p>
<p>别称：加密插件</p>
<p>外文名：无释义</p>
<p>性质：加密后的坐标</p>
<p>释义：国家保密插件</p>
<p>意义：真实的坐标加密成虚假的坐标</p>
<p>所有的电子地图、导航设备，都需要加入该保密插件。第一步，地图公司测绘地图，测绘完成后，送到国家测绘局，将真实坐标的电子地图，加密成“火星坐标”，这样的地图才是可以出版和发布的，然后才可以让GPS公司处理。第二步，所有的GPS公司，只要需要汽车导航的，需要用到导航电子地图的，都需要在软件中加入该保密算法，将COM口读出来的真实的坐标信号，加密转换成ZF要求的保密的坐标。这样，GPS导航仪和导航电子地图就可以完全匹配，GPS也就可以正常工作了。</p>
<h1 id="什么是GCJ-02？"><a href="#什么是GCJ-02？" class="headerlink" title="什么是GCJ-02？"></a>什么是GCJ-02？</h1><p>关于什么是GCJ-02，也先来看看百度百科的解释。</p>
<p>GCJ02</p>
<p>GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。</p>
<p>中文名:国家测量局02号标准</p>
<p>外文名:GCJ-02</p>
<p>它是一种对经纬度数据的加密算法，即加入随机的偏差。</p>
<p>国内出版的各种地图系统（包括电子形式），必须至少采用GCJ-02对地理位置进行首次加密。</p>
<p>火星坐标系的本质？<br>综上所述，其实火星坐标系和GCJ-02是同一种事物，它是国家测量(绘)局制定的02号标准，是一种对经纬度坐标进行非线性的随机加偏算法。</p>
<p>为了响应国家制定的标准，国内所有在线地图服务商（如百度地图、高德地图、搜狗地图和SOSO地图等）和国外部分在线地图服务商(如谷歌地图、必应地图和雅虎地图等)都必须进行GCJ-02加密才对公众进行开放，这就是为什么大家在用地图时总是发现有偏移的原因。</p>
<p>GCJ-02只是一种坐标偏移标准（算法），对投影没有任何限制，如果再以投影为基础作细分，则可以分为GCJ-02经纬度投影和GCJ-02 Web 墨卡托投影。在水经注万能地图下载器无论是导入或导出矢量数据时都可以对GCJ-02经纬度投影和GCJ-02墨卡托投影进行很好的支持。</p>
<p>下载器中的GCJ02坐标系</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>当然了，你可能发现有一些地图是没有偏移的，比如天地图、谷歌地球、谷歌卫星地图（国外服务器）、必应卫星地图和OpenStreetMap地图等，这里分别作出说明。</p>
<p>1）为什么天地图没有偏移</p>
<p>天地图是在国测局主导下生产建设的地图，是为了促进地理信息资源共享和高效利用，提高测绘地理信息公共服务能力和水平，改进测绘地理信息成果的服务方式，更好地满足国家信息化建设的需要，为社会公众的工作和生活提供方便。这样一个关乎国家民生的地图，你说能随意偏移吗，有必要偏移吗？</p>
<p>那么为什么其它百度或高德等公众地图就一定要用GCJ-02加密呢？制作过地图或搞过测绘的朋友一定了解，对于国家一些重要的机构是不能出现在地图中的（有地图测绘相关的法律法规），比如一些军事管理区或国防战备设施等，它就像一柄利剑，且能随意示人？对于这些敏感的重要信息，国家天地图肯定是可以进行了严格管控的，但对于其它商用地图，在监管困难的情况下，于是就制定了GCJ-02标准，这就是商用地图必须要采用GCJ-02加密的根本原因。</p>
<p>2）为什么谷歌地球没有偏移</p>
<p>谷歌地球（Google Earth）是针对全球的，坐标完全没有偏移，由于没有详细的标注信息，服务器不在国内，且也不是主要针对国内用户，因此ZF也没有对其采取强硬措施，但现在谷歌地球（Google Earth）越来越难登录，一般需要采取翻墙才能访问，这是不争的事实。</p>
<p>3）为什么谷歌卫星地图（国外服务器）没有偏移？</p>
<p>Web版谷歌地图分两种，一种是谷歌国外服务器在线地图，通过<a href="http://map.google.com访问,一个是谷歌国内服务器在线地图,通过http//map.google.cn%E8%AE%BF%E9%97%AE%E3%80%82">http://map.google.com访问，一个是谷歌国内服务器在线地图，通过http://map.google.cn访问。</a></p>
<p>而谷歌国外服务器在线地图，也分三种，分别是谷歌卫星地图、谷歌电子地图和谷歌地表地形图。</p>
<p>谷歌卫星地图同谷歌地球（Google Earth）一样，谷歌国外服务器在线地图的卫星地图，由于服务器不在国内，且也不是主要针对国内用户，因此卫星地图是没有偏移的，也没有详细的标注信息，而且访问也需要翻墙才可以。它与谷歌地球（Google Earth）卫星影像的主要区别是采用的坐标系是WGS84 Web墨卡托投影且有Google水印，而谷歌地球（Google Earth）卫星影像采用的是WGS84地球坐标系且没有Google水印，它们的共同点是坐标都没有偏移。</p>
<p>对于谷歌电子地图和谷歌地表地形图而言，由于有详细的标注信息，也在国家的管控下进行了GCJ-02加密。</p>
<p>4）为什么必应卫星地图没有偏移？</p>
<p>必应卫星地图的情况与谷歌卫星地图（国外服务）基本相同，投影为WGS84 Web 墨卡托且坐标没有偏移，而必应电子地图还是有偏移的。</p>
<p>5）为什么OpenStreetMap地图没有偏移？</p>
<p>OpenStreetMap是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图，相对于其它主流地图来讲，可能影响力还没有这么大，国内用户用得相对较少，信息的详细程序也比较有限，因此ZF还没有对其进行管控。</p>
<p>以上内容纯粹是揣测猜想,仅供大家参考,也欢迎业界专业人士能批评指正,以正本清源!</p>
<p>结语</p>
<p>以上就是GCJ02火星坐标系的详细说明，主要包括了什么是火星坐标系、什么是GCJ-02和火星坐标系的本质等功能。</p>
<p>转载自<a href="https://zhuanlan.zhihu.com/p/93612082">https://zhuanlan.zhihu.com/p/93612082</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>坐标系</tag>
      </tags>
  </entry>
  <entry>
    <title>CGJ02、BD09、西安80、北京54、CGCS2000常用坐标系详解</title>
    <url>/2023/07/13/CGJ02%E3%80%81BD09%E3%80%81%E8%A5%BF%E5%AE%8980%E3%80%81%E5%8C%97%E4%BA%AC54%E3%80%81CGCS2000%E5%B8%B8%E7%94%A8%E5%9D%90%E6%A0%87%E7%B3%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、万能地图下载器中的常用坐标系</p>
<p>水经注万能地图下载器中的常用的坐标系主要包括WGS84经纬度投影、WGS84 Web 墨卡托投影、WGS84 UTM 投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02经纬度投影、GCJ02 Web 墨卡托投影、BD09 经纬度投影和BD09 Web 墨卡托投影等。</p>
<p>其中，WGS84、WGS84 Web 墨卡托、GCJ02和BD09是近年来GIS系统（尤其是WebGIS）中的常用坐标系，而西安80、北京54和CGCS2000坐标是测绘中常用的坐标系。</p>
<p>本软件除了支持常用的坐标系外，还支持其它各种地理坐标系和投影坐标系，当在坐标投影转换时，选择“更多”可以选择其它坐标系。</p>
<p>对于不同的功能，本软件所支持的常用坐标系略有不同，本文将会对矢量导入导出、影像导出大图、影像导出瓦片和高程导出所支持的坐标系分别作出说明。</p>
<p>二、矢量导入导出坐标系</p>
<p>矢量导入主要包括导入下载范围和导入矢量数据叠加，这两中导入方式均支持WGS84经纬度投影、WGS84 Web 墨卡托投影、WGS84 UTM 投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02经纬度投影、GCJ02 Web 墨卡托投影、BD09 经纬度投影和BD09 Web 墨卡托投影等。</p>
<p>下图为导入沿线路径时，可选择的坐标投影。</p>
<p>下图为导入矢量数据时，可选择的坐标投影。</p>
<p>与导入数据相同，在将矢量数据导出时也可以进行WGS84经纬度投影、WGS84 Web 墨卡托投影、WGS84 UTM 投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02经纬度投影、GCJ02 Web 墨卡托投影、BD09 经纬度投影和BD09 Web 墨卡托投影等投影转换。</p>
<p>三、影像导出大图坐标系</p>
<p>在下载卫星影像并导出大图时，可支持导出WGS84经纬度投影、WGS84 Web 墨卡托投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02 Web 墨卡托投影和BD09 Web 墨卡托投影等，不支持导出GCJ02经纬度投影和BD09经纬度投影。</p>
<p>四、影像导出瓦片坐标系</p>
<p>在下载卫星影像导出瓦片时，只可以选择导出WGS84经纬度投影、WGS84 Web 墨卡托投影、GCJ02 Web 墨卡托投影和BD09墨卡托投影。</p>
<p>五、高程导出坐标系</p>
<p>在导出高程时，可支持导出WGS84经纬度投影、WGS84 Web 墨卡托投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02 Web 墨卡托投影和BD09 Web 墨卡托投影等，不支持导出GCJ02经纬度投影和BD09经纬度投影。</p>
<p>六、常用坐标系详解</p>
<p>（一）WGS84坐标系</p>
<p>WGS-84坐标系（World Geodetic System一1984 Coordinate System）</p>
<p>一种国际上采用的地心坐标系。坐标原点为地球质心，其地心空间直角坐标系的Z轴指向BIH （国际时间服务机构）1984.O定义的协议地球极（CTP)方向，X轴指向BIH 1984.0的零子午面和CTP赤道的交点，Y轴与Z轴、X轴垂直构成右手坐标系，称为1984年世界大地坐标系统。</p>
<p>（二）WGS84 Web墨卡托</p>
<p>Web墨卡托是2005年谷歌在谷歌地图中首次使用的，当时或更早的Web墨卡托使用者还是称其为世界墨卡托 World Mercator - Spherical Mercator (unofficial deprecated ESRI)，代号 WKID 54004 （在 EPSG:54004 或 ESRI:54004 中，非官方）。</p>
<p>在2006年，OSGeo在提出的 Tile Map Service (TMS) 标准中使用代号 OSGEO:41001，WGS84 / Simple Mercator - Spherical Mercator (unofficial deprecated OSGEO / Tile Map Service)。</p>
<p>2007年8月6日 Christopher Schmidt （OpenLayers的重要贡献者之一）在通过一次GIS讨论中为了在OpenLayers中使用谷歌投影，提出给谷歌投影（Web墨卡托）使用一个统一的代号（已有如54004、41001之类的代号）900913（也形似 Google），并与同年9月11日在OpenLayers的OpenLayers/Layer/SphericalMercator.js中正式使用代号 900913。</p>
<p>在2008年5月EPSG在6.15版本中正式（可能是谷歌地图取得了巨大成功）给谷歌地图投影赋予 CRS 代号 EPSG:3785（Popular Visualisation CRS / Mercator），这也是Web墨卡托正式被EPSG组织承认（由于Web墨卡托不是标准的地图投影，之前一直没有被EPSG没有收录）。</p>
<p>很快EPSG于2009年2月9号使用新代号 EPSG:3857 代替之前的 EPSG:3785，给谷歌地图投影方法命名为“公共可视化伪墨卡托投影”（PVPM），投影运算方法代号 1024。</p>
<p>至今，EPSG:3857（WGS 84 / Pseudo-Mercator） 代号是web墨卡托的正式代号。</p>
<p>在GIS界，离不开 ESRI，Web墨卡托的代号在 ESRI 中也有几个。最早在 ESRI 的软件中给Web墨卡托投影的称号为 102113（WGS 1984 Web Mercator），与 EPSG:3785 对应；后来使用 102100（WGS 1984 Web Mercator Auxiliary Sphere），与 EPSG:3857 对应。</p>
<p>在 ArcGIS 10.0 版本中，ESRI 正式使用 EPSG:3857 替换之前的 EPSG:102100。</p>
<p>总之，Web墨卡托现在的正式官方代号 EPSG:3857，同时 900913、3587、54004、41001、102113、102100 和 3785 等也是指Web墨卡托，虽然他们的具体定义会有一些差别，但他们在数学上是相等的。</p>
<p>Web墨卡托取得了巨大成功，如今主流的Web地图几乎都是使用的Web墨卡托，如国外的 Google Maps，OpenStreetMap，Bing Map，ArcGIS 和  Heremaps等，国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（由于国内政策的原因，国内地图会有加密要求，一般有两种情况，一种是在Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。</p>
<p>（三）WGS84 UTM</p>
<p>UTM投影全称为“通用横轴墨卡托投影”，英文名称为Universal Transverse Mercator，该坐标系是由美国军方在1947提出的。虽然我们仍然将其看作与“高斯－克吕格”相似的坐标系统，但实际上UTM采用了网格的分带（或分块）。除在美国本土采用Clarke 1866椭球体以外，UTM在世界其他地方都采用WGS84。</p>
<p>UTM是由美国制定，因此起始分带并不在本初子午线，而是在180度，因而所有美国本土都处于0－30带内。UTM投影采用6度分带，从东经180度（或西经180度）开始，自西向东算起，因此1带的中央经线为-177（-180 -(-6)），而0度经线为30带和31带的分界，这两带的分界分别是-3和3度。纬度采用8度分带，从80S到84N共20个纬度带（X带多4度），分别用C到X的字母来表示。为了避免和数字混淆，I和O没有采用。UTM的“false easting”值为500公里，而南半球UTM带的“false northing”为10000公里。</p>
<p>UTM是一种等角横轴割圆柱投影，圆柱割地球于南纬80度、北纬84度两条等高圈，被许多国家用作地形图的数学基础，如中国采用的高斯-克吕格投影就是UTM投影的一种变形，很多地理数据，如Landsat和Aster数据都应用UTM投影发布的。</p>
<p>UTM投影将北纬84度和南纬80度之间的地球表面积按经度6度划分为南北纵带(投影带)。从180度经线开始向东将这些投影带编号，从1编至60(北京处于第50带)。每个带再划分为纬差8度的四边形。两条标准纬线距中央经线为180KM左右,中央经线比例系数为0.9996，UTM北半球投影北伪偏移为零，南半球则为10000公里。</p>
<p>（四）GCJ02经纬度投影</p>
<p>GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。</p>
<p>它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。</p>
<p>该坐标系的坐标值为经纬度格式，单位为度。</p>
<p>这里的GCJ02经纬度投影，也就是在WGS84经纬度的基础之上，进行GCJ-02加偏。</p>
<p>（五）GCJ02 Web 墨卡托投影</p>
<p>GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。</p>
<p>它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。</p>
<p>该坐标系的坐标值为Web墨卡托格式，单位为米。</p>
<p>这里的GCJ02 Web 墨卡托，也就是在标准Web默卡托的基础之上，进行GCJ-02加偏。</p>
<p>（六）BD09 经纬度投影</p>
<p>BD09经纬度投影属于百度坐标系，它是在标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。</p>
<p>该坐标系的坐标值为经纬度格式，单位为度。</p>
<p>（七）BD09 Web 墨卡托影</p>
<p>BD09 Web 墨卡托属于百度坐标系，它是在标准Web墨卡托的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在Web墨卡托的基础之上进行了两次加偏。</p>
<p>该坐标系的坐标值为Web墨卡托格式，单位为米。</p>
<p>（八）北京54坐标系</p>
<p>中国成立以后，我国大地测量进入了全面发展时期，在全国范围内开展了正规的，全面的大地测量和测图工作，迫切需要建立一个参心大地坐标系。由于当时的”一边倒”政治趋向，故我国采用了前苏联的克拉索夫斯基椭球参数，并与前苏联1942年坐标系进行联测，通过计算建立了我国大地坐标系，定名为1954年北京坐标系。因此，1954年北京坐标系可以认为是前苏联1942年坐标系的延伸。T.A的原点不在北京而是在前苏联的普尔科沃。</p>
<p>自北京54坐标系统建立以来，在该坐标系内进行了许多地区的局部平差，其成果得到了广泛的应用。但是随着测绘新理论·新技术的不断发展，人们发现该坐标系存在很多缺点，为此，我国在1978年在西安召开了”全国天文大地网整体平差会议”，提出了建立属于我国自己的大地坐标系，即后来的1980西安坐标系。</p>
<p>（九）西安80坐标系</p>
<p>1978年4月在西安召开全国天文大地网平差会议，确定重新定位，建立我国新的坐标系。为此有了1980年国家大地坐标系。1980年国家大地坐标系采用地球椭球基本参数为1975年国际大地测量与地球物理联合会第十六届大会推荐的数据，即IAG 75地球椭球体。该坐标系的大地原点设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里。</p>
<p>中华人民共和国大地原点，由主体建筑·中心标志·仪器台·投影台4部分组成。</p>
<p>主体为7层塔楼式圆顶建筑，高25.8米，半球形玻璃钢屋顶，可自动开启，以便天文观测。中心标志是原点的核心部分，用玛瑙做成，半球顶部刻有”十”字线。T.A被镶嵌在稳定埋入地下的花岗岩标石外露部分的中央，永久稳固保留，”十”字中心就是测量起算中心，坐标为东经108度55分，北纬34度32分，海拔417.20米。仪器台建在中心标志上方，为空心圆柱形，高21.8米，顶部供安置测量仪器用。</p>
<p>（十）CGCS2000坐标系</p>
<p>2000中国大地坐标系(China Geodetic Coordinate System 2000，CGCS2000)，又称之为2000国家大地坐标系，是中国新一代大地坐标系，21世纪初已在中国正式实施。</p>
<p>20世纪50年代，为满足测绘工作的迫切需要，中国采用了1954年北京坐标系。1954年之后，随着天文大地网布设任务的完成，通过天文大地网整体平差，于20世纪80年代初中国又建立了1980西安坐标系。1954北京坐标系和1980西安坐标系在中国的经济建设和国防建设中发挥了巨大作用。</p>
<p>随着情况的变化和时间的推移，上述两个以经典测量技术为基础的局部大地坐标系，已经不能适应科学技术特别是空间技术发展，不能适应中国经济建设和国防建设需要。中国大地坐标系的更新换代，是经济建设、国防建设、社会发展和科技发展的客观需要。</p>
<p>以地球质量中心为原点的地心大地坐标系，是21世纪空间时代全球通用的基本大地坐标系。以空间技术为基础的地心大地坐标系，是中国新一代大地坐标系的适宜选择。地心大地坐标系可以满足大地测量、地球物理、天文、导航和航天应用以及经济、社会发展的广泛需求。历经多年，中国测绘、地震部门和科学院有关单位为建立中国新一代大地坐标系作了大量基础性工作，20世纪末先后建成全国 GPS一、二级网，国家GPS A、B级网，中国地壳运动观测网络和许多地壳形变网，为地心大地坐标系的实现奠定了较好的基础。中国大地坐标系更新换代的条件也已具备。</p>
<p>2000中国大地坐标系符合 ITRS(国际地球参考系统)的如下定义：</p>
<p>1)原点在包括海洋和大气的整个地球的质量中心；</p>
<p>2)长度单位为米(sI)。这一尺度同地心局部框架的TCG(地心坐标时)时间坐标一致；</p>
<p>3)定向在1984．0时与 BIH(国际时间局)的定向一致；</p>
<p>4)定向随时间的演变由整个地球的水平构造运动无净旋转条件保证。</p>
<p>以上定义对应一个直角坐标系，它的原点和轴定义如下：</p>
<p>1)原点 ：地球的质量中心；</p>
<p>2)Z轴：指向IERS参考极方向；</p>
<ol start="3">
<li>X轴：IERS参考子午面与通过原点且同z 轴正交的赤道面的交线；</li>
</ol>
<p>4)Y轴：完成右手地心地固直角坐标系。</p>
<p>CGCS2000的参考椭球为一等位旋转椭球。等位椭球(或水准椭球)定义为其椭球面是一等位面的椭球。CGCS2000的参考椭球的几何中心与坐标系的原点重合，旋转轴与坐标系的Z轴一致。参考椭球既是几何应用的参考面，又是地球表面上及空间正常重力场的参考面。</p>
<p>等位旋转椭球由4个独立常数定义—-CGCS2000参考椭球的定义常数是：</p>
<p>长半轴a=6378137.0m；</p>
<p>扁率f=1/298.257222101；</p>
<p>地球的地心引力常数 (包含大气层)GM = 3986004.418×E8m3s-2；</p>
<p>地球角速度w=7292115.0×E-11 rad S-1。</p>
<p>（十一）1985国家高程基准</p>
<p>我国于1956年规定以黄海(青岛)的多年平均海平面作为统一基面，叫”1956年黄海高程系统”，为中国第一个国家高程系统，从而结束了过去高程系统繁杂的局面。但由于计算这个基面所依据的青岛验潮站的资料系列（1950年～1956年）较短等原因，中国测绘主管部门决定重新计算黄海平均海面，以青岛验潮站1952年～1979年的潮汐观测资料为计算依据，叫”1985国家高程基准”。</p>
<p>我国的水准原点位于青岛观象山。T.A由1个原点5个附点构成水准原点网。在”1985国家高程基准”中水准原点的高程为72.2604米。这是根据青岛验潮站1985年以前的潮汐资料推求的平均海面为零点的起算高程，是国家高程控制的起算点。</p>
<p>由于国家水准原点实际高程并非为海拔0米，经国家测绘局批准，由专家精确移植水准原点信息数据，在青岛银海大世界内建起了”中华人民共和国水准零点”。</p>
<p>水准零点标志雕塑，高6米，重10余吨，底座像一个铅锤，寓意老一辈测量人工作的辛苦，顶部地球仪上有6个小圆球，寓意世界上6个著名的海拔原点。在零点雕塑的下面是一个观测井，观测井的底部设有一个价值不菲的巨大的红色玛瑙球，这个球体的顶平面就是我们国家海拔0米的地方。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>坐标系</tag>
      </tags>
  </entry>
  <entry>
    <title>用电量创新高背后：以储能解决供需矛盾正当时</title>
    <url>/2023/07/12/%E7%94%A8%E7%94%B5%E9%87%8F%E5%88%9B%E6%96%B0%E9%AB%98%E8%83%8C%E5%90%8E%EF%BC%9A%E4%BB%A5%E5%82%A8%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BE%9B%E9%9C%80%E7%9F%9B%E7%9B%BE%E6%AD%A3%E5%BD%93%E6%97%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>7月11日，中央深改委会议审议通过《关于深化电力体制改革加快构建新型电力系统的指导意见》，强调要深化电力体制改革，加快构建清洁低碳、安全充裕、经济高效、供需协同、灵活智能的新型电力系统，更好推动能源生产和消费革命，保障国家能源安全。</p>
<p>新型电力系统的关键是电力保供和电力系统稳定运行，而储能则是构建新型电力系统的关键一环。通过储能的规模化应用，电力系统由传统的源随荷动向源网荷储融合互动转变，从而实现电力的统筹协调，进一步解决电力供需不平衡等难题。</p>
<p>近段时间以来，进入迎峰度夏高峰期，高温预警不断，多地用电量创新高，电力供需矛盾不断凸显。</p>
<p>7月10日，国家能源集团单日完成发电量40.9亿千瓦时，刷新历史最高纪录，较前一日增长2.1亿千瓦时，超历史峰值0.4亿千瓦时。国家能源集团表示，华南、华东等省区最高负荷屡创新高，部分地区电力供需形势严峻。</p>
<p>同样，南方电网在7月10日的最高电力负荷达2.26亿千瓦，创历史新高，比去年最高负荷增加300万千瓦。今年以来，经济增长好于预期，南方区域电力需求逐步恢复。</p>
<p>电力阶段性供不应求几乎成为了每个夏季的难题。持续高温考验电企的供应能力，也让储能再次成为市场关注的焦点。电力供应紧张背景下，不少省份和企业为解决区域性、时段性供需矛盾在不断加大储能的装机量。</p>
<p>据中国化学与物理电源行业协会储能应用分会统计，今年1月份至5月份共有97个新型储能项目投运，装机功率达3.02GW，同比增长629.12%。</p>
<p>随着极端天气频发，以市场化为核心的新型电力系统建设迫在眉睫，而储能更是成为解决电力供需矛盾的重要抓手。去年以来，市场一直有声音质疑储能利用率太低，成本太高，储能的商业模式不够清晰等一系列问题。</p>
<p>不过，今年以来，用户侧储能发展喜人。目前，用户侧储能主要是依靠峰谷电价差套利，即在低电价时段充电，在高电价时段卖出，赚取电价差。</p>
<p>在夏季用电高峰，不少区域实行尖峰电价，峰时用能成本提高，也带来峰谷价差提升，从平抑高峰用电成本或峰谷套利的角度来看，用户侧储能的经济性已经显现。</p>
<p>从储能的应用场景来看，主要分为电源侧、电网侧和用户侧三大类。随着新型电力系统建设加速，除了用户侧储能不断发力，还应不断加大储能的应用场景向纵深拓展。在笔者看来，作为新建新能源发电项目的前置条件，电源侧储能应避免“建而不用”，加大风力、光伏等新能源电力并网和消纳是助力电力统筹的重要环节。同时，推动建立电网侧独立储能电站容量电价机制，鼓励并支持独立储能参与电力市场交易，并逐步完善交易规则。</p>
<p>来源：证券日报</p>
<p>作者：李春莲</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>各种国内地图坐标系总结</title>
    <url>/2023/07/11/%E5%90%84%E7%A7%8D%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、WGS-84坐标系：地心坐标系，GPS原始坐标体系</p>
<p>在中国，任何一个地图产品都不允许使用GPS坐标，据说是为了保密。</p>
<p>2、GCJ-02 坐标系：国测局坐标，火星坐标系</p>
<p>1）国测局02年发布的坐标体系，它是一种对经纬度数据的加密算法，即加入随机的偏差。</p>
<p>2）互联网地图在国内必须至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。</p>
<p>3）是国内最广泛使用的坐标体系，高德、腾讯、Google中国地图都使用它。</p>
<p>3、CGCS2000坐标系：国家大地坐标系</p>
<p>该坐标系是通过中国GPS 连续运行基准站、 空间大地控制网以及天文大地网与空间地网联合平差建立的地心大地坐标系统。</p>
<p>4、BD-09坐标系</p>
<p>百度中国地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p>
<p>5、搜狗坐标系</p>
<p>搜狗地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p>
<p>6、图吧坐标系</p>
<p>图吧地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p>
<p>7、思极坐标系</p>
<p>电网专用地图，自己封装的非线性坐标偏移算法得到。<br>思极地图开放平台 | 思极地图API SDK<br><a href="https://map.sgcc.com.cn/#/">https://map.sgcc.com.cn/#/</a><br><a href="https://map.sgcc.com.cn/products/epgis_portals/index.html#/">https://map.sgcc.com.cn/products/epgis_portals/index.html#/</a><br>————————————————<br>版权声明：本文为CSDN博主「吉&amp;祥」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/a734797702/article/details/121536753">https://blog.csdn.net/a734797702/article/details/121536753</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>坐标系</tag>
      </tags>
  </entry>
  <entry>
    <title>电网侧储能发展路线渐明</title>
    <url>/2023/07/10/%E7%94%B5%E7%BD%91%E4%BE%A7%E5%82%A8%E8%83%BD%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E6%B8%90%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“双碳”目标下，加快构建新型电力系统是必然趋势，也是一项长期的任务。新时代以来，我国把促进新能源和清洁能源发展放在更加突出的位置，2023年3月，我国非化石能源发电装机容量首次超过50%，储能作为构建新型电力系统的重要支撑，对改善新能源电源的系统友好性、改善负荷需求特性、推动新能源大规模高质量发展起着关键作用。根据2023年3月国家电化学储能电站安全监测信息平台发布的《2022年度电化学储能电站行业统计数据》1（以下简称“中电联统计数据”）报告，2022年电化学储能电站平均运行系数为0.17（相当于平均每天运行4.15h、年平均运行1516h）、平均利用系数为0.09（相当于平均每天利用2.27h、年平均利用829h），电化学储能电站发展呈现出蓄势待发的态势。受政策以及市场化机制的影响，截至2022年年底，我国电源侧、电网侧、用户侧储能累计投运总能量占比分别为48.4%、38.72%、12.88%，不同应用场景的电化学储能发展差异较大，本文将主要针对电网侧储能发展情况展开详细分析。</p>
<p>电网侧储能通常是指服务电力系统运行，以协助电力调度机构向电网提供电力辅助服务、延缓或替代输变电设施升级改造等为主要目的建设的储能电站。常见的电网侧储能应用场景包括独立储能（包括共享储能等）、替代型储能（包括变电站、应急电源等）等。中电联统计数据表明，截至2022年年底，电网侧储能电站在建55座、装机4.08GW/7.52GWh，累计投运78座、装机2.44GW/5.43GWh，累计投运总能量同比增长165.87%。其中独立储能累计投运总能量，在电网侧储能电站累计投运总能量中占比近90%，电网侧储能应用主要场景对比详见表1。</p>
<p>表1 电网侧储能应用主要场景对比</p>
<p>独立储能</p>
<p>替代型储能</p>
<p>定义</p>
<p>独立储能是以独立主体身份直接与电力调度机构签订并网调度协议，纳入电力并网运行及辅助服务管理的储能电站</p>
<p>替代型储能是延缓或替代电网输变电设备的储能电站</p>
<p>建设地点</p>
<p>根据具体的需求和应用场景而定，建设地点较为灵活</p>
<p>电网侧的关键节点，负荷中心地区、临时性负荷增加地区、阶段性供电可靠性需求提高地区等</p>
<p>主要作用</p>
<p>提供调峰、调频、系统备用、黑启动等辅助服务</p>
<p>延缓输配电扩容升级/替代偏远地区基本供电/替代保障供电等</p>
<p>收益方式</p>
<p>提供电力辅助服务收益/电力现货交易收益/容量租赁收益等</p>
<p>提供电力辅助服务/将替代型储能设施成本收益纳入输配电价回收等</p>
<p>一、独立储能</p>
<p>（一）独立储能规模</p>
<p>截至2022年年底，独立储能电站在建48座、装机3.82GW/7.19GWh，累计投运64座、装机2.1GW/4.86GWh，累计投运总能量同比增长159.13%。受各地区政策影响，目前独立储能电站主要分布在山东、湖南、宁夏、青海、河北，累计总能量占独立储能总能量的74.29%，独立储能装机区域分布呈现出明显不平衡。2022年，独立储能电站平均运行系数20.13（相当于平均每天运行3.03h、年平均运行1106h）、平均利用系数30.07（相当于平均每天利用1.61h、年平均利用586h），运行情况接近电化学储能电站平均水平（2022年电化学储能电站平均运行系数为0.17、平均利用系数为0.09）。</p>
<p>（二）独立储能发展相关政策</p>
<p>整体来看，近年来全国已有约30个省（自治区、直辖市）发布了独立储能相关的支持政策，主要聚焦投资建设（发展规划、投资补贴等）以及电站发展运营（提供电力辅助服务、共享租赁、现货交易等）等方面，各省（自治区、直辖市）发布的独立储能相关政策及装机量情况详见表2。</p>
<p>表2 独立储能政策及装机情况4</p>
<p>序号</p>
<p>省（自治区、直辖市）</p>
<p>政策名称</p>
<p>政策聚焦</p>
<p>发展情况</p>
<p>1</p>
<p>山东</p>
<p>1.《关于促进我省新型储能示范项目健康发展的若干措施》</p>
<p>投资建设</p>
<p>在建8座、装机861MW/1726MWh；</p>
<p>累计投运9座、装机505.95MW/1011.3MWh</p>
<p>2.《山东省电力现货市场交易规则（试行）》</p>
<p>3.《山东省电力并网运行管理实施细则（2023年修订版）》《山东省电力辅助服务管理实施细则（2023年修订版）》</p>
<p>发展运营</p>
<p>2</p>
<p>湖南</p>
<p>1.《关于加快推动湖南省电化学储能发展的实施意见》</p>
<p>投资建设</p>
<p>在建5座、装机600MW/1200MWh；</p>
<p>累计投运9座、装机308.45MW/916.9MWh</p>
<p>2.《湖南省电力辅助服务市场交易模拟运行规则》</p>
<p>发展运营</p>
<p>3</p>
<p>宁夏</p>
<p>1.《宁夏“十四五”新型储能发展实施方案》</p>
<p>2.《关于开展2022年新型储能项目试点工作的通知》</p>
<p>投资建设</p>
<p>在建4座、装机550MW/1100MWh；</p>
<p>累计投运3座、装机400MW/800MWh</p>
<p>3.《宁夏电力辅助服务市场运营规则》</p>
<p>4.《自治区发展改革委关于加快促进储能健康有序发展的通知》</p>
<p>发展运营</p>
<p>4</p>
<p>江苏</p>
<p>1.《江苏省“十四五”新型储能发展实施方案》</p>
<p>投资建设</p>
<p>在建8座、装机501.32MW/900.4MWh；</p>
<p>累计投运4座、装机143.88MW/259.6MWh</p>
<p>2.《江苏电力辅助服务（调峰）市场交易规则》</p>
<p>3.《苏州市吴江区分布式光伏规模化开发实施方案》</p>
<p>4.《关于无锡高新区（新吴区）关于节能降碳绿色发展的政策意见》</p>
<p>发展运营</p>
<p>5</p>
<p>湖北</p>
<p>1.《关于征集新型储能示范试点项目的通知》</p>
<p>投资建设</p>
<p>在建8座、装机461.55MW/914.6MWh</p>
<p>2.《湖北电力调频辅助服务市场交易规则（征求意见稿）》</p>
<p>发展运营</p>
<p>6</p>
<p>安徽</p>
<p>1.《安徽省新型储能发展规划》（2022—2025年）</p>
<p>投资建设</p>
<p>在建7座、装机441.5MW/735.8MWh；</p>
<p>累计投运1座、装机20.85MW/20MWh</p>
<p>2.《安徽电力调峰辅助服务市场运营规则（试行）》</p>
<p>3.《合肥市进一步促进光伏产业高质量发展若干政策实施细则》</p>
<p>4.《蚌埠市光伏建筑应用试点城市专项资金使用管理办法》</p>
<p>发展运营</p>
<p>7</p>
<p>青海</p>
<p>1.《青海电力市场管理实施细则（初稿）》</p>
<p>2.《青海电力辅助服务市场运营规则（试行）》</p>
<p>发展运营</p>
<p>累计投运3座、装机232MW/464MWh</p>
<p>8</p>
<p>山西</p>
<p>1.《山西省可再生能源发展“十四五”规划》</p>
<p>投资建设</p>
<p>在建1座、装机200MW/200MWh</p>
<p>2.《山西省电力市场规则汇编（试运行V12.0）》</p>
<p>3.《山西电力一次调频市场交易实施细则（试行）》</p>
<p>4.《关于印发太原市招商引资若干措施的通知》</p>
<p>发展运营</p>
<p>9</p>
<p>河北</p>
<p>1.《全省电网侧独立储能布局指导方案》</p>
<p>投资建设</p>
<p>累计投运8座、装机112.95MW/415.25MWh</p>
<p>10</p>
<p>河南</p>
<p>1.《加快我省新型储能发展的实施意见（征求意见稿）》</p>
<p>投资建设</p>
<p>累计投运16座、装机100.8MW/100.8MWh</p>
<p>2.《河南电力调峰辅助服务交易规则（试行）》</p>
<p>发展运营</p>
<p>11</p>
<p>辽宁</p>
<p>累计投运1座、装机100MW/400MWh</p>
<p>12</p>
<p>福建</p>
<p>1.《福建省“十四五”能源发展专项规划》</p>
<p>投资建设</p>
<p>在建1座、装机100MW/200MWh</p>
<p>2.《福建电力市场运营基本规则（试行）》</p>
<p>发展运营</p>
<p>13</p>
<p>甘肃</p>
<p>1.《甘肃省电力辅助服务市场运营规则（试行）》</p>
<p>投资建设</p>
<p>累计投运1座、装机60MW/240MWh</p>
<p>2.《甘肃电力现货市场建设方案（结算试运行暂行V2.2）》</p>
<p>发展运营</p>
<p>14</p>
<p>广东</p>
<p>1.《广东省推动新型储能产业高质量发展的指导意见》</p>
<p>投资建设</p>
<p>在建1座、装机70MW/140MWh；</p>
<p>累计投运4座、装机30MW/62MWh</p>
<p>2.《广东省新型储能参与电力市场交易实施方案》</p>
<p>3.《广东调频辅助服务市场交易实施细则》</p>
<p>4.《深圳市福田区支持战略性新兴产业和未来产业集群发展若干措施》</p>
<p>5.《关于印发〈肇庆高新区节约用电支持制造业发展补贴资金申报指南〉的通知》</p>
<p>发展运营</p>
<p>15</p>
<p>浙江</p>
<p>1.《关于浙江省加快新型储能示范应用的实施意见》</p>
<p>投资建设</p>
<p>在建4座、装机27.5MW/68MWh；</p>
<p>累计投运4座、装机78MW/156MWh</p>
<p>2.《浙江省第三方独立主体参与电力辅助服务市场交易规则（试行）（征求意见稿）》</p>
<p>3.《温州市关于推动新能源高质量发展的若干政策（征求意见稿）》</p>
<p>4.《舟山市普陀区清洁能源产业发展专项资金实施管理办法》</p>
<p>5.《杭州市萧山区电力保供三年行动方案（2022—2024）》</p>
<p>6.《海盐县贯彻&lt;浙江省推动经济高质量发展若干政策&gt;承接落实方案（征求意见稿）》</p>
<p>7.《海宁市发展和改革局关于加快推动新型储能发展的实施意见（征求意见稿）》</p>
<p>8.《关于加快推动婺城区新型储能发展的实施意见》</p>
<p>9.《诸暨市整市推进分布式光伏规模化开发工作方案（修订稿）》</p>
<p>发展运营</p>
<p>16</p>
<p>1.《天津滨海高新区促进新能源产业高质量发展办法》</p>
<p>发展运营</p>
<p>累计投运1座、装机10MW/10MWh</p>
<p>17</p>
<p>在建1座、装机5MW/10MWh</p>
<p>18</p>
<p>新疆</p>
<p>1.《关于加快推进新能源及关联产业协同发展的通知》</p>
<p>2.《新疆独立储能参与中长期交易实施细则（征求意见稿）》</p>
<p>投资建设</p>
<p>3.《关于建立健全支持新型储能健康有序发展配套政策的通知》</p>
<p>4.《新疆电力辅助服务市场运营规则（征求意见稿）》</p>
<p>发展运营</p>
<p>19</p>
<p>内蒙古</p>
<p>1.《内蒙古自治区人民政府办公厅关于加快推动新型储能发展的实施意见》</p>
<p>2.《内蒙古自治区支持新型储能发展的若干政策（2022—2025年）》</p>
<p>投资建设</p>
<p>3.《内蒙古自治区支持新型储能发展的若干政策（2022—2025年）》</p>
<p>发展运营</p>
<p>20</p>
<p>四川</p>
<p>1.《关于将储能设施纳入四川自动发电控制辅助服务市场试运行的通知》</p>
<p>2.《成都市能源结构调整十条政策措施》</p>
<p>3.《成都市发展和改革委员会关于申报2022年生态文明建设储能领域市级预算内基本建设投资项目的通知》</p>
<p>发展运营</p>
<p>21</p>
<p>1.《重庆电力调频辅助服务市场运营规则》</p>
<p>2.《重庆两江新区支持新型储能发展专项政策》</p>
<p>3.《铜梁区支持新型储能发展八条措施（试行）》</p>
<p>发展运营</p>
<p>22</p>
<p>西藏</p>
<p>1.《西藏电力辅助服务管理实施细则》</p>
<p>2.《西藏电力并网运行管理实施细则》</p>
<p>发展运营</p>
<p>23</p>
<p>广西</p>
<p>1.《广西新型储能发展规划（2023—2030年）》</p>
<p>2.《加快推动广西新型储能示范项目建设的若干措施（试行）》</p>
<p>投资建设</p>
<p>24</p>
<p>江西</p>
<p>1.《关于做好新型储能项目全过程管理工作的通知》</p>
<p>投资建设</p>
<p>2.《江西电力调频辅助服务市场运营规则》</p>
<p>发展运营</p>
<p>25</p>
<p>1.《北京市“十四五”新型储能电站发展专项规划》“十四五”中后期新型储能电站拟建项目征集</p>
<p>投资建设</p>
<p>2.《关于公开征集朝阳区2022年节能减碳项目的通知》</p>
<p>发展运营</p>
<p>26</p>
<p>贵州</p>
<p>1.《贵州省新型储能项目管理暂行办法（征求意见稿）》</p>
<p>投资建设</p>
<p>2.《贵州电力调峰辅助服务市场交易规则（修订版）》</p>
<p>发展运营</p>
<p>27</p>
<p>吉林</p>
<p>1.《吉林省新能源产业高质量发展战略规划（2022—2030年）》</p>
<p>投资建设</p>
<p>28</p>
<p>云南</p>
<p>1.《云南黑启动辅助服务市场交易规则（试行）》</p>
<p>发展运营</p>
<p>已发布的相关政策可以归纳为以下几个方面：</p>
<p>一是鼓励独立储能发展建设。2022年6月，国家发展和改革委员会印发《关于进一步推动新型储能参与电力市场和调度运用的通知》，指出新型储能可作为独立储能参与电力市场。目前，全国共有20个省（自治区、直辖市）出台了支持独立储能发展的相关政策，包括山东、河南在内的部分地区通过规划建设独立储能示范项目、鼓励配建储能转为独立储能等政策支持独立储能发展。</p>
<p>二是鼓励共享储能的发展。将储能容量进行共享租赁是独立储能的一种盈利模式，当前山东、河南、贵州、宁夏、广西、新疆等多地在其发布的政策中鼓励共享储能的发展，提出将新能源企业租赁的储能容量视为配建容量，容量租赁指导价格约为每年160~300元/kW。广西在《加快推动广西新型储能示范项目建设的若干措施（试行）》中明确，已通过容量租赁模式配置储能的市场化并网新能源项目，可暂不参与调峰辅助服务费用分摊。</p>
<p>三是鼓励独立储能参与电力现货交易。山东、山西、甘肃、青海、广东等5个省份明确了独立储能参与现货市场的规则细则。山东是我国第一个支持独立储能参与现货市场的省份，2022年9月山东印发《关于促进我省新型储能示范项目健康发展的若干措施》的通知指出，示范项目作为独立储能可参与电力现货市场，进入市场前，充电电量电价暂按电网企业代理购电价格标准执行，进入市场后，充电时为市场用户，从电力现货市场中直接购电，放电时为发电企业，其相应充电电量不承担输配电价与政府性基金与附加。</p>
<p>四是鼓励独立储能参与电力辅助服务市场。2018年起，我国已有20个省份明确了储能可以参与电力辅助服务的规则。根据电力辅助服务规则，包括独立储能在内的储能系统可以参与的交易品种主要包括调峰和调频。同时，规则对参与辅助服务的储能系统的容量进行了一定限制，一般为不低于5~10MW。</p>
<p>五是给予独立储能补贴支持。目前，已有江苏、浙江、山西、河南、广东等10余个地区出台了补贴支持政策，补贴方式包括放电补贴、容量补贴、投资补贴等。重庆对独立储能的补贴力度较大，重庆两江新区发布的《重庆两江新区支持新型储能发展专项政策》提出：对新引进的重点新型储能产业项目，自约定开工之日起两年内固定资产投资2000万元（含）以上的，经认定，按照该项目实际固定资产投资的15%给予支持。对单个项目的支持额度最高不超过3000万元。</p>
<p>（三）独立储能重点省份分析——以山东为例</p>
<p>结合上述政策的发布及独立储能的建设规模看，山东的独立储能发展走在全国前列，这与山东积极引导独立储能电站建设、助力独立储能经济性提升有关。山东作为能源消耗大省，由于地势和自然资源禀赋的原因，山东的水电装机规模较小，但风电和光伏的装机规模在逐年增大，这也使得电网在面对由于新能源电力的大规模接入而带来的对灵活调度资源需求升高的问题时，抽水蓄能无法有效发挥作用。因此，山东十分重视电化学储能发展。</p>
<p>从2020年开始，山东就在全国较早地推行新能源配储，并开始构建以峰谷分时电价为主的储能市场，但存在着经济性不高，用户配储积极性差等问题，为了进一步加强市场化引导，提高储能发展的内在动力，山东开始推动独立储能的发展。作为国内首个独立储能电站参与电力现货市场的省份，山东在支持独立储能发展方面的力度较大，发布了较多鼓励政策，并进一步明确了独立储能的盈利模式，这也是山东独立储能得以发展的基础。</p>
<p>整体来看，山东对独立储能发展的支持力度较大，明确了新型储能示范项目可以作为独立储能参与电力现货市场，并鼓励符合要求的新能源配储转为独立储能5。在经济性方面，山东规定了中长期市场储能的盈利模式6，并通过政策引导形成了独立储能容量共享租赁、参与电力辅助服务、峰谷价差套利、容量补偿等多个收益模式7。</p>
<p>二、替代型储能</p>
<p>（一）替代型储能规模</p>
<p>截至2022年年底，替代型储能电站在建7座、装机0.26GW/0.33GWh，累计投运14座、装机0.33GW/0.58GWh，累计投运总能量同比增长239.64%。2022年，替代型储能平均运行系数0.15（相当于平均每天运行3.61h、年平均运行1318.5h）、平均利用系数0.14（相当于平均每天利用3.37h、年平均利用1232h），运行情况优于电化学储能电站平均水平（2022年电化学储能电站平均运行系数为0.17、平均利用系数为0.09）。</p>
<p>（二）替代型储能发展相关政策</p>
<p>近年来，全国已有约20个省（自治区、直辖市）在相关政策中涉及了鼓励替代型储能发展的相关内容，各省（自治区、直辖市）发布的替代型储能相关政策及装机量情况详见表3。</p>
<p>表3 各省（自治区、直辖市）替代型储能政策及装机情况8</p>
<p>序号</p>
<p>省（自治区、直辖市）</p>
<p>政策名称</p>
<p>发展情况</p>
<p>1</p>
<p>宁夏</p>
<p>《宁夏“十四五”新型储能发展实施方案》</p>
<p>累计投运2座、装机200MW/400MWh</p>
<p>2</p>
<p>安徽</p>
<p>《安徽省新型储能发展规划》（2022—2025年）</p>
<p>在建1座、装机161MW/161MWh；</p>
<p>累计投运1座、装机10MW/10MWh</p>
<p>3</p>
<p>江苏</p>
<p>《江苏省“十四五”新型储能发展实施方案》</p>
<p>在建2座、装机80.64MW/140.8MWh；</p>
<p>累计投运3座、装机32.24MW/54.15MWh</p>
<p>4</p>
<p>《北京市“十四五”时期电力发展规划》</p>
<p>累计投运2座、装机29MW/44MWh</p>
<p>5</p>
<p>河南</p>
<p>《加快我省新型储能发展的实施意见（征求意见稿）》</p>
<p>在建2座、装机17.2MW/17.2MWh；</p>
<p>累计投运1座、装机48MW/48MWh</p>
<p>6</p>
<p>浙江</p>
<p>《浙江省“十四五”新型储能发展规划》</p>
<p>累计投运2座、装机6.35MW/9.4MWh</p>
<p>7</p>
<p>广东</p>
<p>《广东省推动新型储能产业高质量发展的指导意见》</p>
<p>累计投运1座、装机5.25MW/11.58MWh</p>
<p>8</p>
<p>在建1座、装机3.78MW/7.56MWh</p>
<p>9</p>
<p>西藏</p>
<p>《今冬明春及“十四五”期间电力保供方案》</p>
<p>累计投运1座、装机0.5MW/3.16MWh</p>
<p>10</p>
<p>河北</p>
<p>《河北省“十四五”新型储能发展规划》</p>
<p>在建1座、装机0.5MW/1MWh；</p>
<p>累计投运1座、装机2.7MW/0.81MWh</p>
<p>11</p>
<p>山西</p>
<p>《山西省可再生能源发展“十四五”规划》</p>
<p>12</p>
<p>湖北</p>
<p>《关于征集新型储能示范试点项目的通知》</p>
<p>13</p>
<p>广西</p>
<p>《广西新型储能发展规划（2023—2030年）》</p>
<p>14</p>
<p>四川</p>
<p>《四川省电源电网发展规划（2022—2025年）》</p>
<p>15</p>
<p>江西</p>
<p>《关于做好新型储能项目全过程管理工作的通知》</p>
<p>16</p>
<p>吉林</p>
<p>《吉林省新能源产业高质量发展战略规划（2022—2030年）》</p>
<p>17</p>
<p>新疆</p>
<p>《关于加快推进新能源及关联产业协同发展的通知》</p>
<p>18</p>
<p>山东</p>
<p>《山东省新型储能工程发展行动方案》</p>
<p>19</p>
<p>湖南</p>
<p>《湖南省推动能源绿色低碳转型做好碳达峰工作的实施方案》</p>
<p>20</p>
<p>贵州</p>
<p>《贵州省能源领域碳达峰实施方案》</p>
<p>21</p>
<p>《重庆市“十四五”电力发展规划（2021—2025年）》</p>
<p>整体来看，自2022年6月7日国家发展和改革委员会、国家能源局联合发布《关于进一步推动新型储能参与电力市场和调度运用的通知》后，已有约20个省（自治区、直辖市）参照文件精神出台了对于替代型储能发展的支持政策，提出在关键节点、电网末端及偏远地区等布局新型储能，发挥储能应急备用技术优势，探索将电网替代型储能设施成本收益纳入输配电价回收等。</p>
<p>（三）替代型储能发展情况分析</p>
<p>我国配电系统覆盖面广泛，尤其在偏远地区，配电网的负荷密度较低，供电半径较长，这导致位于配电系统末端的用户常常遭遇电压偏低的问题。因此在这些特定的场景下，与新建、扩容电网输配电设施相比，建设替代型储能可以更加便捷、经济地延缓或替代电网升级改造，替代性发挥输变电设施功能。例如，在西藏、新疆等偏远地区的电网末端，由于地理位置偏远、电力输送受限等因素，存在供电不足的问题。传统的电网扩容改造成本较高且时间较长，建设电网替代型储能，可以替代电网的输配电设施，经济灵活地增强电网薄弱区域供电保障能力。</p>
<p>结合上述对于替代型储能发展政策的分析，可以看出电网替代型储能的发展仍处于前期的探索阶段，但随着储能技术的逐步成熟，电网替代型储能需求也逐步显现。</p>
<p>三、电网侧储能发展趋势分析</p>
<p>在电网替代型储能方面，目前电网替代型储能的发展仍处于前期探索阶段，目前还存在着包括政策中对电网替代型储能界定不明、储能成本纳入输配电成本缺乏核定标准等问题。以上这些因素在一定范围内影响了电网侧储能的实际应用和企业投资的积极性。</p>
<p>然而，受到新能源的快速发展、电力系统的灵活性要求以及能源结构的转型等因素的影响，伴随着储能技术的不断进步和市场的成熟，对独立储能和电网替代型储能的应用需求正逐步凸显，一些实际的问题也正在通过政策等手段逐步解决。未来，考虑到电源负荷及电网情况，电网侧适合建设储能的地址相对有限，独立储能和电网替代型储能在面临较为广阔的发展前景的同时，伴随着有关政策的落地也将面临激烈的竞争。</p>
<p>四、相关建议</p>
<p>一是逐步扩大独立储能比例。政府及相关部门可参考抽水蓄能统一发展模式，采用统一规划、统一建设、接受电网调度与自调度相结合的模式大力发展独立储能。可由地方政府牵头，区域内各类能源企业集中建设独立/共享储能电站（新能源、电网、用户均可参与或主导），由电网进行调用以及结合电力市场情况进行电站自调度，并由政府向参建单位分配相应的新能源开发指标，以此实现政府、电网企业、发电企业的多方共赢，显著提升新能源消纳空间。</p>
<p>二是因地制宜配置电网替代型储能规模。结合当地新能源消纳、资源特性、网架结构、负荷特性、电网安全、电源结构等因素，由地方政府和电网公司牵头，确定电网替代型储能的配置需求，科学确定配置的合理比例，有序引导建设节奏。同时，对于电网替代型储能，建议在电力系统发展规划中予以明确。</p>
<p>三是构建电网侧长效成本疏导及市场机制。建立保障独立储能、替代型储能盈利的长效机制，完善电能量市场机制，明确独立储能、替代型储能参与电力市场交易规则，加大有偿调峰补偿力度，丰富交易品种，不断完善辅助服务市场建设。研究建立储能成本以电力辅助服务费、输配电价等形式向电力用户疏导的机制，规划出台容量电价机制。健全尖峰电价机制，适度拉大峰谷电价差，通过价格信号激励市场主体自发配置储能资源。</p>
<p>1.数据统计范围：国家电化学储能电站安全监测信息平台收集的全国电力安委会19家企业成员单位500kW/500kWh以上电化学储能电站数据。</p>
<p>2.运行系数=统计期间运行小时数与统计期间小时数的比值。</p>
<p>3.利用系数=统计期间实际传输电量（包括充电量和放电量）折合成额定功率时的运行小时数与统计期间小时数的比值。</p>
<p>5.2022年8月，山东省《关于促进我省新型储能示范项目健康发展的若干措施》，明确了新型储能示范项目可以作为独立储能可参与电力现货市场，鼓励新能源配储转为独立储能。</p>
<p>6.2021年4月，山东省能源局出台《关于开展储能示范应用的实施意见》，规定了中长期市场储能的盈利模式，主要是以储能参与调峰辅助服务市场、给予优先发电量计划奖励为主。</p>
<p>7.2022年8月，《关于促进我省新型储能示范项目健康发展的若干措施》的发布明确了新型储能示范项目可以作为独立储能可参与电力现货市场，并给予容量补偿，明确可以在全省范围内参与容量租赁，鼓励参与辅助交易。山东省能监办发布了《山东能源监管办关于征求《山东省电力并网运行管理实施细则（2023年修订版）》《山东省电力辅助服务管理实施细则（2023年修订版）》规范性文件意见的通知》，提出山东5MW/2h以上的独立储能电站可以提供电力辅助服务。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>华自科技“激活”电网侧新型储能</title>
    <url>/2023/07/09/%E5%8D%8E%E8%87%AA%E7%A7%91%E6%8A%80%E2%80%9C%E6%BF%80%E6%B4%BB%E2%80%9D%E7%94%B5%E7%BD%91%E4%BE%A7%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>华自科技“激活”电网侧新型储能<br>来自景气狙击手的雪球专栏</p>
<p>电网侧储能可有效提高电网安全水平，实现电能在时间和空间上的负荷匹配，增强可再生能源消纳能力，在电网系统备用、缓解高峰负荷供电压力和调峰调频方面意义重大。据了解，华自科技正开发建设的新型储能电站规模超过1GWh，未来还将继续发力电网侧、用户侧等各类储能应用场景。</p>
<p>近日，2022高工储能产业峰会在常州举办。1300余名储能产业链企业领袖、高层及行业人士参会。峰会上，华自科技储能系统首席工程师曾昭愈演讲的主题是《电网侧百兆瓦级储能系统关键技术应用》，针对电网侧储能的主要问题，分享了华自科技电网侧储能的关键技术，为电网侧新型储能的发展提供了范本。</p>
<p>曾昭愈指出，当前电网侧储能仍存在不少问题：</p>
<p>第一，目前储能系统对电网不友好。各分子系统通信接口、通信协议、信息模型等没有遵照电网规范；信息孤立，没有统一平台关联互动；一次调频、动态调压能力没有得到很好的响应；目前一些系统具备这个功能，但响应的效果依旧不理想。</p>
<p>第二，储能系统的调试比较困难。电网侧储能系统庞杂，很多设备需到达项目现场才能进行对接组装，随后才能够进行完整的调试。实际情况是，往往一个大的项目（尤其是上百兆瓦级的项目），在现场调试时不仅耗时耗力，而且在质量或时间可控性比较差。</p>
<p>第三，电池系统容量容易出现异常衰减。一般大的电网侧储能电站，由于生产制造的不一致性，会出现一系列问题。比如有可能是不同的厂家、电池供应商，他们生产制造、使用环境的不一致，尤其温度控制、阻抗匹配等不一致性，这些问题长时间积累以后，木桶效应会变得更为明显，更容易出现电池容量的不正常衰减。</p>
<p>第四，储能系统可维护性欠佳，新老电池不匹配，尤其是像电池出问题的时候，电池更换维护很麻烦。</p>
<p>第五，储能系统的安全风险仍然存在，尤其像电芯本质安全问题没有得到彻底的解决。</p>
<p>针对电网侧储能电站的上述这些问题，华自科技也探索了6种关键技术，逐步探索电网侧储能项目范本。华自科技电网侧储能技术主要包括：</p>
<p>1、系统架构升级。华自科技从传统的3S架构上升到4S架构，指的是从BMS+PCS+EMS上升到BMS+PCS+CCS+EMS。</p>
<p>传统的3S架构劣势在于，第一，EMS与常规的一些电站里面的监控是分离的，信息是孤立的，关联互动性差。第二，EMS需要处理海量数据，那么一次调频、动态调压这些对时效性要求比较高的，处理的速度难以响应。第三，3S系统的控制响应时间一般只能做到秒级。</p>
<p>华自科技提出由3S架构变成4S架构，主要从以下几个方面进行提升。第一，EMS常规监控的融合，实现多系统融合，关联互动性相应提高。第二，系统监视与控制系统分开，控制系统独立，控制策略处理速度快。我们常规的一些经济运行，数据分析就让EMS来处理。但对于一次调频或者动态调压这些功率的控制回路，就通过协调控制器来处理。第三，系统监视与功率调节控制网络分离。监控网络采用MMS，控制采用GOOSE网，这样控制网络传输速度明显加快，控制响应时间提升至毫秒级。</p>
<p>2、EMS监控技术。可实现大规模异构数据采集、电池全生命周期管理、安全稳定、多系统融合、控制策略、智能报表等。</p>
<p>大规模异构数据采集指的是数据采集支持100万级别规模，通过IEC6850、IEC104、IEC101、MODBUS/TCP/RTU等各种协议，实现保测装置、功率变换系统、电池管理系统、辅控系统的实时信息采集、分析和存储。</p>
<p>电池全生命周期管理指的是每颗电芯的全量数据采集，对历史数据进行回溯，通过大数据分析以及异常特征识别和提取，采用AI算法，建立电池全生命周期的数据模型，为智能运维提供参考。</p>
<p>安全稳定主要指的是服务器采用冗余配置、集群技术，确保不因部分软、硬件故障，影响整个系统功能的正常运行。根据网络采用分区隔离，不同安全区之间的数据访问，采用正向、反向电力专用物理隔离装置保证跨区数据安全。</p>
<p>由于实现实时百万级的采集数据处理，需对EMS监控各项性能指标提出要求。如画面显示的响应时间，不应小于1秒；SOE的分辨率，则小于2毫秒；CPU的负荷率小于30%；数据存储年限大于10年。</p>
<p>3、储能电站协调控制技术。指的是储能系统4S中的协调控制技术，需具备下面几点功能：一次调频、动态调压、AGV/AVC控制、源网荷储的紧急支撑，把这些功能从EMS里面单独剥离出来，相当于“专人干专事”，这样响应时间可到毫秒级；组网要求，支持主备双击冗余，采用GOOSE双光纤网络，能够支持多达128套PCS的快速控制，并支持分层扩展；网络架构实现监视与控制系统的分离，监视网络采用MMS，控制网络采用GOOSE通讯网。</p>
<p>4、PCS技术。可实现通信友好和功能友好。通信友好：能够支持MMS与GOOSE通信协议，通过GOOSE光纤接收协控功率快速调控指令，接口丰富，同时拥有光网口、电网口在不同网络通讯，无需通过其他协议再去转换。功能友好：具备一次调频、虚拟惯量支撑、高/低压穿越等基本功能。</p>
<p>5、高压模块式系统集成技术。华自科技1500V直流高压转化效率高，能量密度高，占地面积小。另外，无电池并联，无簇间环流，电池损耗小，衰减慢，可维护性也好，尤其可实现去工程化，在场站内就能完成所有设备试验，现场快速安装。</p>
<p>6、储能系统的安全防范技术。主要包括故障预警、故障录波等。故障预警指的是通过对电芯全量数据检测和智能分析，对历史数据进行智能分析，提前预警，提前处置；故障录波则指的是出现故障时，对故障过程中的设备动作进行录波，方便事故溯源及分析。</p>
<p>据悉，湖南邵阳城步儒林储能站设计容量为100MW/200MWh，由华自科技承建，已于2021年12月31日成功并网。该电站所用储能关键设备如：能量管理系统（EMS）、多能物联协调控制器（CCS）、储能变流器（PCS）等产自华自科技。</p>
<p>从去年并网到目前运行情况来看，场站情况稳定，在监控系统实现了100万点以上大数据支撑，各项控制器一次调频与动态调压的时间，响应在30毫秒以内。</p>
<p>华自科技主要为能源、工控、环保、水利等领域的客户提供核心的软硬件产品解决方案，到目前为止已为40多个国家范围内万座场站提供整体解决方案。近年来，华自科技在光伏、风电、储能、微网、能量管理、企业能源管理等领域多点布局，具备了勘察设计、系统集成、设备制造研发等综合服务能力。<br>（以上转自高工储能）</p>
<p>华自科技HZ3000-EMS 储能能量管理系统，为储能电站高效运行保驾护航<br>最后在贴一个上次分享的，华自科技储能：</p>
<p>华自科技国内储能十四五</p>
<p>作者：景气狙击手<br>链接：<a href="https://xueqiu.com/7327068282/223585548">https://xueqiu.com/7327068282/223585548</a><br>来源：雪球<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>储能行业研究：发电侧和用户侧经济性显现，中上游厂商或将受益</title>
    <url>/2023/07/08/%E5%82%A8%E8%83%BD%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6%EF%BC%9A%E5%8F%91%E7%94%B5%E4%BE%A7%E5%92%8C%E7%94%A8%E6%88%B7%E4%BE%A7%E7%BB%8F%E6%B5%8E%E6%80%A7%E6%98%BE%E7%8E%B0%EF%BC%8C%E4%B8%AD%E4%B8%8A%E6%B8%B8%E5%8E%82%E5%95%86%E6%88%96%E5%B0%86%E5%8F%97%E7%9B%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（报告出品方/作者：长城国瑞，黄文忠、张烨童）</p>
<p>一、 新型储能高速发展，中国储能装机增速快于全球</p>
<ol>
<li>储能产业链介绍</li>
</ol>
<p>储能产业链上游主要包括电池原材料、生产设备供应商等；中游主要为电池、电池管理系统、能量管理系统以及储能变流器供应商；下游主要为储能系统集成商、安装商以及终端用户。</p>
<ol start="2">
<li>储能技术应用领域广泛，电力系统的应用最突出</li>
</ol>
<p>储能技术的应用领域可以分为电力系统、通信基站、车载储能、移动储能、数据中心、UPS以及轨道交通、人工/机器智能、军事领域等。其中，在电力系统领域，储能的应用场景可分为发电侧、用户侧以及电网侧。储能在发电侧可用于系统调频、可再生能源并网、电力调峰、辅助动态运行等；在用户侧主要用于电力自发自用、峰谷价差套利、容量电费管理和提升供电可靠性等；在电网侧主要用于可再生能源并网、缓解电网阻塞、延缓输配电设备扩容升级等。</p>
<ol start="3">
<li>储能分类多样，新型储能正当时</li>
</ol>
<p>储能根据能量存储形式的不同，可分为电储能、热储能和氢储能。电储能是最主要的储能方式，按存储原理的不同可分为电化学储能和机械储能两种技术类型。其中，电化学储能是指各种二次电池储能，主要包括锂离子电池、铅蓄电池和钠硫电池等；机械储能主要包括抽水蓄能、压缩空气储能和飞轮储能等。按照 CNESA 口径，新型储能技术包括锂电池、钠硫电池、铅蓄电池、液流电池等电化学储能技术，以及飞轮储能和压缩空气储能。</p>
<p>3.1 全球储能装机增速加快</p>
<p>根据 CNESA 全球储能项目库的不完全统计，截至 2022 年底，全球已投运电力储能项目累计装机规模 237.2GW，同比增长 14.9%。其中，抽水蓄能的累计装机占比首次低于80%，比2021年同期下降 6.8 个百分点；新型储能的累计装机规模高达 45.7GW，同比增长79.9%，其中，锂离子电池占据绝对主导地位，市场份额高达 94.4%，同比提升3.5Pct。2016-2022 年，全球电力系统新型储能项目每年新增装机规模由0.7GW增加至20.4GW，年均复合增速达 75.4%；全球电力系统中已投运新型储能项目累计装机规模在全球已投运电力储能项目中占比由 1.2%增加至 19.3%，尽管现阶段新型储能技术在电力系统的装机规模依然不大，但开发增速加快，发展潜力巨大。</p>
<p>从全球新增投运新型储能项目分布地区来看，中国、欧洲和美国在全球储能市场形成三足鼎立的局面，三者市场份额合计 86%，比 2021 年同期上升 6 个百分点。</p>
<p>3.2 中国储能装机增速加快，新型储能高速发展</p>
<p>中国电力储能项目累计装机规模增速快于全球增速。根据CNESA 全球储能项目库的不完全统计，截至 2022 年底，中国已投运电力储能项目累计装机规模为59.8GW，在全球规模中占比 25.2%，同比增长 37.8%，增速快于全球增速，且较 2021 年增速提升15.9Pct。2016-2022年，中国已投运电力储能项目累计装机量年均复合增长率为 16.2%。抽水储能占比下降，新型储能累计装机规模高速发展。2022 年，从中国已投运的储能项目装机结构来看，仍以抽水储能为主，但抽水储能累计装机占比首次低于80%，为77.1%；新型储能高速发展，累计装机规模首次突破 10GW，达到13.1GW，同比增长129.8%，累计装机规模占比为 21.9%，较 2021 年增加了 9.4Pct。新型储能以锂离子电池储能为主，占比高达94.0%，铅蓄电池储能、压缩空气储能、液流电池储能、超级电容和飞轮储能占比分别为3.1%、1.5%、1.2%、0.1%和 0.1%。 从 2022 年新增装机规模看，中国新增投运电力储能项目装机规模首次突破15GW，达到16.5GW，其中新型储能新增规模创历史新高，达到 7.3GW，同比增长204.2%。</p>
<p>新型储能技术在电力系统中的应用迎来高速增长，其核心驱动因素来自于以下几个方面：一是锂电储能成本快速下降，技术经济性大幅提升；二是全球范围内可再生能源占比不断上升，电网层面需要储能来提升消纳与电网稳定性；三是电力自发自用需求推动家用储能市场快速增长；四是电力市场化与能源互联网持续推进助力储能产业发展；五是政策支持为储能发展创造良好市场机遇。</p>
<ol start="4">
<li>电源侧应用场景成为主流</li>
</ol>
<p>电源侧装机规模在全球及中国新增新型储能项目中占比最高。根据CNESA的统计，2021年全球新增新型储能项目中，电源侧、电网侧和用户侧中的新增装机占比基本都在30%左右，相对比较均衡，其中电源侧占比最高，为 37%。根据 CNESA 的数据统计，截至2021年，从中国累计投运的新型储能项目的应用分布上看，无论是累计装机规模还是新增装机规模，电源侧继 2020 年首次位列第一之后，2021 年继续保持装机规模第一的位置，所占比重均超过40%。截至 2021 年底，电源侧的累计装机规模超过 2.5GW，同比增长65%，其中，新增投运规模超过 1.0GW，同比增长 2%。 电源侧储能在电化学储能装机中占比接近 50%。新型储能中电化学储能占首要位置，据中电联统计，2022 年，电化学储能各应用场景新增装机占比与2021 年基本保持不变，其中，电源侧新增 3.87GWh，占比 49.24%，电网侧和用户侧分别占比43.13%和7.63%。</p>
<p>全球不同国家储能应用场景侧重点不同，电源侧可再生能源并网是主要应用方向。截至2021 年末，韩国、澳大利亚和日本在新能源发电侧的累计电化学储能装机应用占比均超过40%，德国和英国在电源侧辅助服务的使用占比分别为 61.80%、48.10%，中国、美国电化学储能在新能源发电侧、辅助服务和电网侧的应用三方并重。</p>
<p>二、 可再生能源并网配储受政策和需求双轮驱动，特定条件下已具备经济性</p>
<ol>
<li>促进电网消纳，强制配储政策驱动性强</li>
</ol>
<p>国内多地政府规定了对可再生能源并网侧保障性规模内的强制配储要求及支持政策，有望加快储能产业的发展。从总指引上看，2022 年 6 月《“十四五”可再生能源发展规划》表示：以储能促进新能源的高效消纳利用，保障可再生能源规模化发展。各地储能产业扶持政策积极响应，截至 2022 年末，已有 25 个省市区提出新能源配储需求，配储比例要求多在10%-20%之间，配储时长要求多在 2h 以上（部分省配置要求高达 4h）。另外部分地区对并网侧储能电站根据发电量给予 0.3-0.8 元/Kwh 补贴，各省市落实储能相关政策将进一步加大储能在新能源并网侧的应用，储能产业有望健康快速发展。</p>
<ol start="2">
<li>新能源并网侧配储需求持续提升</li>
</ol>
<p>随着新能源在总发电量的应用比例加大，新能源并网侧配储需求持续提升。2022年度，全口径并网风电、太阳能发电量分别同比增长 16.3%和 30.8%，分别达到7,623Gwh 和4,276Gwh。2016-2022 年，全口径非化石能源发电量占总发电量的比例从29.3%上升至36.2%。在新能源发电并网侧配储，将风电、太阳能转化的电力存储后移至其他时段并网，可以降低新能源出力波动、有效跟踪计划出力、提升新能源电站可调度性、降低弃风弃光率、有助于提升新能源消纳能力。因此，我们预计随着非化石能源发电的比重增长，配储需求持续提升。</p>
<ol start="3">
<li>大电站配储在特定条件下已具备经济性</li>
</ol>
<p>1）上网电价与电站配储 IRR 敏感性测算</p>
<p>假设电站规模为 100MW，配储 10%*2h，循环次数为 7000 次，在二类地区光伏有效利用小时数为 1300h/年。通过赋值不同的上网电价，测算出目前光伏电站三类资源区（光伏有效利用小时数分别为 1600h/1300h/1100h）的上网电价分别为0.32/0.40/0.48元/kWh 时，比较具备经济性（IRR&gt;5%）。</p>
<p>2）电站配储循环次数与 IRR 敏感性测算</p>
<p>假设电站规模为 100MW，配储 10%*2h，在二类地区光伏有效利用小时数为1300h/年，上网电价为 0.36 元/kWh。通过调整循环次数以及相对应的运营年限，测算出循环次数达 8500 次，电站配储收益率在 5%以上，具备经济性。</p>
<p>3）电站配储成本与 IRR 敏感性测算</p>
<p>假设电站规模为 100MW，配储 10%*2h，在二类地区光伏有效利用小时数为1300h/年，上网电价为 0.36 元/kWh。通过赋值不同的电站配储总成本，测算出配储后成本在 4.20 元/W 以下具备经济性。</p>
<ol start="4">
<li>新能源配储现状：需求空间有限，利用率和调度不足，转变定位或可迎来转机</li>
</ol>
<p>电源侧储能中新能源配储运行情况不佳，远低于火储、电网侧配储及用户侧配储。（1）新能源配储调用频次低。目前，新能源配储一般是在弃电时段进行充放运行，至多“一充一放”运行，部分区域配置的电化学储能基本未调用；电网侧、用户侧配储多为“两充两放”运行模式；火储调频由于受 AGC 调度指令响应，储能调用频繁。（2）新能源配储利用率低。据中电联统计，目前新能源配储的平均运行系数仅为0.06（日均运行小时 1.44h）、平均利用系数仅为 0.03（日均利用小时0.77h）、平均备用系数高达0.92（日均备用小时 22.17h）、平均日利用指数仅为 17%（日均等效利用次数0.22 次）。与火储、电网配储、用户侧配储相比，新能源配储平均两日才能实现一次完整的充电，且等效利用系数和日利用小时数均为最低。</p>
<p>新能源配储利用率的调度低的重要原因在于需求空间有限。随着电力市场化改革进程的深入推进，以可再生能源为主的能源结构调整不断倒逼现有煤电行业转型升级，占据主力地位的火电厂响应国家号召积极进行以热储能技术为主的灵活性改造，同时用户侧也在进行灵活性需求响应。新能源发电量并不会持续维持高位，电网侧消纳困难也不是一直存在，因此新能源配储如果局限于内部使用，那需求和应用场景、时段都会受到一定限制，进而导致新能源配储的利用率和调度明显低于火储、电网侧配储以及用户侧配储。 推动新能源+配建储能作为联合主体参与市场交易，增加新能源配储利用率和调用频次。上述提到的局限于内部使用则需求收到一定限制，若上升至解决整个电网的需求，新能源配储的利用率和调用频次或将得到改善。即在新能源配储的同时具备独立控制的要求和条件，可转为独立储能参与现货市场以及全省的调频辅助服务，那需求或将会大幅提升，利用率和调用不足的现状得到一定改善。目前国家和各地政府也在积极推动新能源配储运行机制的完善工作：</p>
<p>（1）国家政策推动。2022 年 5 月国家发改委和国家能源局发布《关于进一步推动新型储能参与电力市场和调度运用的通知》，其中提出鼓励配建新型储能与所属电源联合参与电力市场。以配建形式存在的新型储能项目，在完成站内计量、控制等相关系统改造并符合相关技术要求情况下，鼓励与所配建的其他类型电源联合并视为一个整体，按照现有相关规则参与电力市场，利用储能改善新能源涉网性能，保障新能源高效消纳利用。随着市场建设逐步成熟，鼓励探索同一储能主体可以按照部分容量独立、部分容量联合两种方式同时参与的市场模式。（2）地方政策推动。2023 年 2 月 22 日，山东能源监管办、山东省发展改革委、山东省能源局印发《关于 2023 年山东省电力现货市场结算试运行工作有关事项的通知》，首次明确了新能源与配建储能作为联合主体参与市场的方式。 其次，对于还未进行新能源配储的项目，还可通过集中建设储能电站实现新能源配储需求，新能源项目共享储能容量、分摊储能费用，降低成本的同时增加其利用率和调用频次。</p>
<p>三、 用电侧：工商业储能实现经济性，海外户储需求高增</p>
<ol>
<li>分时价差拉大，部分工商业储能已具备经济性</li>
</ol>
<p>国内因峰谷价差拉大，促进工商业储能配套以节省用电成本，工商业储能具备经济性。储能在用电侧主要功能为与工商业、户用等分布式电源配套或作为独立储能电站，盈利模式为峰谷价差套利或自发自用。2021 年 7 月，国家发改委印发《关于进一步完善分时电价机制的通知》，要求“系统峰谷差率超过 40%的地方，峰谷电价价差原则上不低于4:1，其他地方原则上不低于 3:1；尖峰电价在峰段电价基础上上浮比例原则上不低于 20%”。在电价谷段、平段时从电网向储能装置充电，在电价尖峰、峰值时段储能装置向电网负荷放电，通过削峰填谷可降低企业用电成本。 2023 年 3 月，我国多个省区的一般工商业峰谷平均价差超过0.7 元/kWh，且广东、山东地区的工商业峰谷价差甚至超过 1 元/kWh。据 CNESA 披露，0.7 元/kWh 正是用户侧储能实现经济性的门槛价差。因此，即使考虑到用户侧峰谷电价波动，电化学储能在我国部分省区工商业用户情景已具备经济性。</p>
<ol start="2">
<li>峰谷时段和峰谷价差的利用使得用户侧储能具备更可观的经济性</li>
</ol>
<p>相较于电网侧和电源侧储能项目，用户侧储能项目投资回收期更短。2022 年，广东省（珠三角五市）以全年平均 1.259 元/kWh 的价差位居第一。CNESA 通过对该地区用电侧工商业储能进行经济性分析，假设 10MW/20MWh 储能项目总投资为 4000 万元，系统循环效率90%，充放电深度 90%、全年运行 330 天，分析结果如下：广东省在执行尖峰电价以及2h 储能系统的充放电策略情境下，每日两充两放的度电净收益为 1.359 元/kWh（有尖峰）和0.985 元/kWh（无尖峰），静态回收周期约为 5.58 年。相较于电源侧和电网侧储能项目大多10 年以上的投资回收期来看，在峰谷价差较大的地方用户侧储能具有更可观的经济性。</p>
<ol start="3">
<li>全国各地储能补贴政策出台，助力工商业储能经济型的提升</li>
</ol>
<p>为鼓励工商业用户兴建储能电站，政府出台了一系列储能补贴政策，税收政策以及市场准入政策等，这在一定程度上降低了储能设备的投资成本和运营成本，提高了储能电站的收益水平，提升工商业储能经济性，有助于吸引更多的投资和资本进入工商业储能领域，提高行业的发展速度和规模。目前，全国各地正在实施的储能补贴政策超过30 项，主要集中在用户侧，并注重与分布式光伏相结合。补贴方式主要包括容量补贴、放电补贴和投资补贴，其中与分布式光伏结合的补贴方向最为主要。</p>
<ol start="4">
<li>峰谷价差高位在用电需求的增加下得以稳固，用户侧工商业储能配置需求提升</li>
</ol>
<p>我国第三产业和城乡居民用户的用电量占比不断提升，电力系统峰谷差率拉大，峰谷价差有望维持高位，继而提升储能配置需求。2016 年至 2022 年，第三产业用电量占全国全社会用电量比例从 13.5%上升至 17.2%，城乡居民用户用电量占比从13.6%上升至15.5%。2022年度，第三产业用电量达到 14,859 亿 kWh，同比增长 4.41%。随着电力市场化改革的推进，工商业用户逐步进入电力市场，分时电价机制完善、高耗能用电成本上升将刺激工商业用户的电化学储能配置需求。</p>
<p>工商业用电需求居高不下，限电政策的出台进一步提升工商业储能配置需求。对于用电需求量大的工商业用户来说，限电政策无疑不增加其用电焦虑，进而考虑配置光储一体系统来保障电力供应和正常生产。工商业储能或将成为国内企业实现紧急备电、维持正常经营、降低能源支出的重要手段。</p>
<ol start="5">
<li>海外户储需求景气度持续攀升</li>
</ol>
<p>2021 年全球户用储能需求爆发，2022 年，能源危机叠加过高电价导致需求进一步激发，其中欧洲为户储最大市场。2021 年下半年，能源危机爆发，欧洲天然气供应短缺导致电价大幅上涨甚至限电，欧洲居民新合同电价在年底也开始相应上涨。2022 年2 月俄乌冲突爆发，进一步加剧了能源危机，欧洲电力现货价格随之迎来骤增。据 TRADING ECONOMICS统计，德国电力现货月均价格在 2022 年 8 月迎来历史新高，为 571.20 欧元/MWh，而2021 年12月价格仅为 82.58 欧元/MWh。能源危机下电价持续上涨刺激户储需求进一步高增，当前欧洲为户储最大市场，其中德国占据 70%以上的新增储能市场，是欧洲户用储能的绝对主力军。2015-2021年，欧洲户储复合增速达 63%，增长十分快速。2021 年德国新增户用储能1.48GWh，同增45%，占全球的 34%；累计装机 3.92GWh，同比增加 60.60%，占全球的32%。2021 年德国光储渗透率为 3.60%，位居全球第一。未来随着居民电价以及光储系统成本的差额逐渐拉大，户储的经济性将会愈发显著。</p>
<p>四、电网侧：独立储能调峰调频+共享储能盈利模式，成熟模式仍在探索</p>
<p>我国电网侧储能商业模式尚未成熟，大体可分为输配电成本监管模式和竞争性业务模式两大类，前者可细分为有效资产回收模式和租赁模式，后者可细分为合同能源管理模式、两部制电价模式、辅助服务市场模式、现货交易市场模式和综合模式。其中，有效资产回收模式由于资产要进入输配电价核算，因此只能由业务受到监管的电网主业投资，其他可由社会资本投资。在探索成熟商业模式的道路上，2022 年，国家发展改革委、国家能源局先后发布《“十四五”新型储能发展实施方案》（以下简称《方案》）、《关于进一步推动新型储能参与电力市场和调度运用的通知》，要求在电网关键节点配置储能，提高大电网安全运行水平，在站址和走廊紧张地区延缓和替代输变电设施投资；并进一步明确了新型储能市场定位，逐步建立完善相关市场机制、价格机制和运行机制。《方案》提出建立电网侧独立储能电站的容量电价机制，即将容量电价对应的容量电费纳入输配电价回收，探索替代输配电的储能设施成本收益纳入输配电价。建议积极探索竞争性两部制电价机制，通过竞价模式降低容量电费和电量电费，优化资源配置。同时，建议积极整合电源、电网和用户侧储能资源，采取共享储能模式，争取多重收益。</p>
<ol>
<li>以独立储能形式通过调峰、调频获取市场收益</li>
</ol>
<p>独立储能指“独立式储能电站”，区别于新能源或者火电厂联合设立的形式，独立储能电站的“独立性”体现在具备独立计量、控制等技术条件，可以以独立主体身份直接与电力调度机构签订并网调度协议，不受位置限制，作为独立主体参与电力市场。独立储能建设渐入佳境，2022 年并网投运+启动项目总规模达16.5GW/35GWh。据统计，2022 全年并网投运电站 38 座，总规模 3GW/6GWh；启动施工建设和EPC/设备招标的电站109座，总规模 13.6GW/29GWh。2022 年公开宣布但未进入实质阶段的独立式储能电站142座，总规模 28.3GW/67.6GWh，将成为 2023 年独立式储能增长的最强储备力量。具体至各地区来看，宁夏独立式储能全年投运项目规模达到 0.9GW/1.8GWh，已进入实施阶段的项目超2GW/4GWh，宁夏已成为国内最大的独立式储能市场；山东引领“容量租赁+调峰/电力现货+容量补偿”的商业模式，2022 年启动了总计 29 个、总规模超过 3.1GW 的第二批市场项目，后续实际投运规模有待持续关注。</p>
<p>调峰基本原理即在负荷低谷时充电，在负荷高峰时放电，以维持用功功率平衡，主要通过赚取峰谷价差以及获取调峰度电补偿来获取收入。目前常用的调峰机组有燃煤火电机组和抽水储能机组，储能电站调峰占地面积少，在接收调峰调频指令后快速进行充放电，因此在电网调峰的应用日益增多。 调频是指当电力系统负荷或发电发生较大变化时联合常规电源调频，储能系统能够实现功率的正反双向调节，有效提升常规机组的调频性能指标，减少AGC 及调频考核费用，主要通过调频里程补偿获取收益。</p>
<ol start="2">
<li>共享储能优势明显，商业模式多样化</li>
</ol>
<p>共享储能是独立储能的一种商业运营模式，是将独立分散的电源侧、电网侧、用户侧储能资源进行整合，并交由电网进行统一协调，推动源、网、荷各端储能能力全面释放，提高储能资源利用率。从已开展的项目来看，商业模式归纳为 4 类：1）为新能源电站提供储能容量租赁服务，获取租赁收益，为当前大部分共享储能电站的主要收益来源；2）通过双边协商、双边竞价及单边调用等模式与新能源发电企业进行中长期电力交易；3）参与电力调峰、调频辅助服务，获取辅助服务收益；4）电力现货市场交易，实现峰谷价差套利。</p>
<p>共享储能可提高储能使用率，降低发电企业为强制配储的初始投资成本，规模化建设更利于集中管理。传统单个新能源场站配储利用率低，且新能源场站按固定比例配置储能需增加初始资本开支，此外，分散场站的储能难以实现多种电网侧辅助服务的统一调度结算。而由第三方或厂商负责投资、运维的共享储能电站以电网为纽带，可对多个分散的电网侧、电源侧、用户侧储能资源整合优化，通过向周边新能源电站收取容量租赁费回收投资，不仅可以满足强配储能有关要求，也可以更加集中参与电网调峰调频，规模化建设利于降低管理和运营成本。</p>
<p>五、储能市场空间测算</p>
<p>储能系统主要包括电池模组、逆变器、EMS、BMS 等多个部件。基于储能系统的构成，储能产业链上游包括电芯厂家和各类电子元器件厂家；储能产业链中游主要包括储能电池厂家、逆变器厂家、BMS 厂家、EMS 厂家以及储能系统生产商等；储能产业链下游则包括储能系统销售渠道（安装商、贸易商等）以及包括发电侧、电网侧和用户侧在内的各类用户。其中，储能电池和储能逆变器为储能系统两大关键材料，成本占比分别为60%、20%。因此，储能市场空间测算主要以测算储能逆变器以及储能锂电池市场规模为主。</p>
<p>CNESA 基于全球储能数据库，结合中国项目规划信息和政策发展规划，预测2027年中国新型储能累计规模在保守和理想场景下将分别达到 97.0GW、138.4GW，2023-2027 年CAGR分别为 49.3%、60.3%，且年度新增储能装机规模将呈平稳上升态势，年均新增储能装机约为16.6GW-25.1GW。我们结合上述数据做出以下假设： 1) 全球新型储能新增装机量同比增长 100%、95%、80%、50%、30%；2) 中国新型储能新增装机量同比增长 150%、100%、60%、50%、30%3) 储能逆变器单瓦时需求为 6.90 万台/GW； 4) 储能逆变器价格为 7036.79 元/台； 5) 储能运行时间 2h，储能锂电池放电深度 90%，储能锂电池单瓦时价格1 元//Wh经测算，我们预计 2027 年，全球及中国储能逆变器需求分别为1605.72 万台、654.81万台，市场规模将达到 1129.91 亿元、460.78 亿元；全球及中国储能锂电池需求分别为589.54GWh、240.41GWh，市场规模将达到 5895.40 亿元、2404.13 亿元。</p>
<p>六、投资分析</p>
<p>派能科技</p>
<p>公司主要从事磷酸铁锂电芯、模组及储能电池系统的研发、生产和销售，产品可广泛应用于电力系统的发、输、配、用等环节以及通信基站、车载储能、移动储能等场景，是行业领先的储能电池系统提供商，在全球电化学储能市场中具有较高品牌知名度和较强市场竞争力。2021-2022 年公司产品销售量分别为 1,540.34/3,535.40MWh，其中储能系统产品销售量分别为1,455.89/3,505.83MWh。 公司以海外户储为主要市场，与英、德、意等国领先的光伏、光储、储能系统提供商建立了长期稳定合作关系，在欧洲、非洲部分国家市场占有率极高，并同时积极拓展美洲、亚太区域等家用储能市场。此外公司还积极参与美洲、亚太区域和既有欧洲市场的电网级项目，为公司快速发展打下基础。据 IHS 统计，2019 年公司自主品牌家用储能产品出货量约占全球出货总量的 8.5%，位居全球第三名，仅次于特斯拉和 LG 化学；2020 年和2021 年，公司自主品牌家用储能产品出货量分别约占全球出货总量的 12%和 14%，均仅次于特斯拉，位居全球第二名。</p>
<p>在国内市场，公司同时关注长期战略客户和发展型客户，向全球领先的通信设备制造商中兴通讯提供通信基站后备锂电池；同时公司的大容量储能电池系统已在国内工商业储能、可再生能源配套储能、微电网储能等场景实现商用，积累了丰富的产品应用经验和优质客户资源。公司拥有产业链垂直整合的综合服务优势，是国内少数具备电芯、模组、电池管理系统及能量管理系统等储能核心部件的自主研发和生产能力，同时具备储能系统集成解决方案设计能力的企业。海外户储需求景气度的提升，有望助力公司业绩稳健增长；目前国内户储市场还未打开，未来随着相关政策的落地和实施，公司凭借成熟的产品和市场经验将具备先发优势。</p>
<p>阳光电源</p>
<p>公司专注于太阳能、风能、储能、电动汽车等新能源电源设备的研发、生产、销售和服务，主要产品有光伏逆变器、风电变流器、储能系统、新能源汽车驱动系统、水面光伏系统、智慧能源运维服务等，并致力于提供全球一流的清洁能源全生命周期解决方案。公司自成立之初就致力于以光伏逆变器为核心的光伏系统设备研发和生产，是国内最早从事逆变器产品研发生产的企业，产品连续四年发货量全球第一，截至2021 年12 月，阳光电源在全球市场已累计实现逆变设备装机超 224GW，2021 年光伏逆变器全球发货量47GW，其中国内 18GW，海外 29GW，出货量全球市占率 30%以上。</p>
<p>在储能系统领域，公司具备全球领先的新能源电源变换技术和一流的储能系统集成技术，专注于锂电池储能系统研发、生产、销售和服务，可提供储能变流器、锂电池、能量管理系统等储能核心设备，实现辅助新能源并网、电力调频调峰、需求侧响应、微电网、户用等储能系统解决方案，是全球一流的储能设备及系统解决方案供应商。目前公司储能系统广泛应用在美、英、德等成熟电力市场，不断强化风光储深度融合。2021 年公司储能系统发货量实现几何级增长，当年全球发货量达 3GWh。据 CNESA 披露，公司储能系统出货量连续五年位居第一。在电站投资开发业务领域，公司构建起以中国为根基、海外快速发展的多元业务协同产业布局，截至 2021 年 12 月，在全球累计开发建设光伏、风电项目超2500 万千瓦。同时紧抓户用市场爆发机遇，创新推出“家阳光”合作共建业务模式，与央国企携手合作，共同推进居民屋顶分布式光伏电站项目开发。2021 年，公司家庭光伏全年装机量同比增长超过500%，稳居户用第一阵营。公司在光伏逆变器、风电变流器、储能及电站投资开发等领域协同发展，凭借全球营销渠道布局海内外业务，加速全球战略部署，夯实市场地位。</p>
<p>锦浪科技</p>
<p>公司主要从事组串式逆变器研发、生产、销售和服务，主要产品为并网组串式逆变器和储能组串式逆变器，2021 年二者合计销售占比高达 91.13%。2019 -2021 年公司光伏逆变器业务的年均复合增长率为 66.39%。自 2019 年以来，公司通过全资子公司锦浪智慧从事新能源电力生产业务，进行太阳能光伏电站开发、建设及运营，以作为公司现有业务的重要补充，实现公司业务的多元化布局和产业链延伸。截至 2022 年 9 月 30 日，公司分布式光伏电站累计并网装机容量 239.63MW，2019-2021 年，公司营业收入年均复合增长率为70.53%。公司作为组串式逆变器龙头，储能逆变器业务占比不断提升，由2019 年的1.52%增加至2022H1 的 12.21%，2022H1 储能逆变器毛利率为 30.82%，显著高于并网逆变器24.92%，未来随着海外户储需求的不断增加，公司储能逆变器业务有望迎来快速增长。</p>
<p>固德威</p>
<p>公司主要从事太阳能、储能等新能源电力电源设备的研发、生产和销售，致力于为家庭、工商业用户及地面电站提供智慧能源管理等整体解决方案。公司产品主要包括光伏并网逆变器、储能产品和户用系统等，其中，光伏并网逆变器均为组串式逆变器，目前已广泛应用于住宅、商业屋顶、农场、地面电站等光伏发电系统。另外，公司已研发出并网及储能全线多个系列逆变器产品，功率覆盖范围广泛（0.7kW～250kW），可充分满足户用、扶贫、工商业及大型电站需求。其次，公司通过控股子公司昱德新能源积极布局户用光伏发电系统，为中小型经销商和家庭户用投资业主提供户用光伏系统技术支持和安装解决方案，逐步推进户用领域光伏系统品牌建设。 2021 年，公司推出两款储能锂电池产品，均可与其双向储能逆变器搭配使用，组成“光伏+储能”系统，实现家庭电力自发自用。公司产品立足中国，并针对不同国家的需求开发匹配的产品，并已批量销往德、意、澳等全球多个国家和地区。</p>
<p>公司经营业绩稳步增长，2020 年之后增速维持在 70%左右，2018-2021 年营业总收入的年复合增长率为 47.47%，且以海外营收为主，2021 年公司海外营收占比达到63.48%。光伏储能逆变器占比逐年提升，从 2018 年 5.27%提升至 2021 年 17.85%。公司整体销售毛利率约为30%，与并网逆变器毛利率接近，但低于储能逆变器。公司储能逆变器毛利率较高，2019年毛利率达到 52.64%，2021 年储能逆变器毛利率为 40.18%。未来随着海外户储需求则增加以及国内储能相关政策的大力推动，公司储能逆变器业务占比有望进一步提升，进而推动公司毛利率的增长。</p>
<p>（本文仅供参考，不代表我们的任何投资建议。如需使用相关信息，请参阅报告原文。）</p>
<p>精选报告来源：【未来智库】。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>路网数据获取网站整理</title>
    <url>/2023/07/07/%E8%B7%AF%E7%BD%91%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1 DIVA-GIS</p>
<p>网址：<a href="https://www.diva-gis.org/DIVA-GIS">https://www.diva-gis.org/DIVA-GIS</a></p>
<p>是美国加利福尼亚大学一位教授创办的地图制图与地理数据分析软件与网站。其网站“Free Spatial Data”部分具有全球大量GIS数据，包括行政区边界数据、高程数据、人口数据、路网数据等。值得一提的是，在这一网站获取国外数据比较靠谱，国内数据一定需要注意边界问题。</p>
<p>2 OSM</p>
<p>网址：<a href="https://www.openstreetmap.org/#map=13/39.9118/116.3756">https://www.openstreetmap.org/#map=13/39.9118/116.3756</a></p>
<p>OSM（OpenStreetMap）是一款创建自由、可编辑世界地图的合作项目。其包含全球行政区数据与路网数据、土地覆盖数据等GIS数据。需要下载时，点击左上角“Export”按钮即可。同样的，在这一网站获取国外数据比较靠谱，国内数据一定需要注意边界问题。</p>
<p>作者：疯狂学习GIS<br>链接：<a href="https://www.zhihu.com/question/52232596/answer/1829139823">https://www.zhihu.com/question/52232596/answer/1829139823</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>西南地区首个百兆瓦级电网侧独立储能电站在重庆成功并网</title>
    <url>/2023/07/07/%E8%A5%BF%E5%8D%97%E5%9C%B0%E5%8C%BA%E9%A6%96%E4%B8%AA%E7%99%BE%E5%85%86%E7%93%A6%E7%BA%A7%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E7%94%B5%E7%AB%99%E5%9C%A8%E9%87%8D%E5%BA%86%E6%88%90%E5%8A%9F%E5%B9%B6%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>7月6日凌晨时分，随着“合闸”命令的下达，位于西部(重庆)科学城的科学谷储能电站正式向国家电网倒送电，这标志着西南地区首个百兆瓦级电网侧独立储能电站成功并网。</p>
<p>科学谷储能电站占地面积31.2亩，共计安装有58台磷酸铁锂储能电池舱、29台变流升压一体机，每天最多可放电40万度，能满足约7万户家庭一天的用电需求。</p>
<p>储能电站本质上是一种可调可控的电能量载体，可为电网提供快速灵活调峰服务，被视为“建设在城市或电网负荷中心的抽水蓄能电站”。而科学谷储能电站参与电网频率调节的能力相当于4台60万级燃煤机组，每年预计可减少二氧化碳排放7.6万吨，节约标煤约2.7万吨。</p>
<p>(总台记者 张爽 刘鹏)</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>内蒙电力，一个能从国家电网手中分一杯羹的企业</title>
    <url>/2023/07/06/%E5%86%85%E8%92%99%E7%94%B5%E5%8A%9B%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%83%BD%E4%BB%8E%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%E6%89%8B%E4%B8%AD%E5%88%86%E4%B8%80%E6%9D%AF%E7%BE%B9%E7%9A%84%E4%BC%81%E4%B8%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内蒙，一个幅员辽阔，占中国全国总面积的12.3%的自治区；一个拥有3盟9市，横跨中国东北、华北、西北三大区的地区；一个电力运输由两大国企负责的地区。</p>
<p>两大电网</p>
<p>你可能会问：电力运输由两大国企负责，是怎么回事？大家可能都知道国家电网和南方电网，但因为内蒙，你还需要知道一个内蒙电力。</p>
<p>国家电网和南方电网基本负责了全国的电力运营。其中，国家电网负责华北、华中、华东、东北、西北，五大区域26个省市的电网运营，而南方电网负责广东、广西、海南、云南、贵州的电网运输。</p>
<p>内蒙电力</p>
<p>看似两大电网负责了全国，但内蒙就是那个例外。内蒙分为3盟9市，国家电网只负责赤峰、通辽、兴安盟、呼伦贝尔，其余8个盟市电网运营则属于内蒙电力。因此，内蒙电力成为了全国唯一独立的省级管理电网企业。</p>
<p>内蒙电力vs国家电网</p>
<p>由于负责盟市方位的原因，国家电网负责内蒙四个盟市的企业叫“国网内蒙古东部电力有限公司”（简称：蒙东电力），因此内蒙电力也被称为“蒙西电力”。因此二者并非隶属关系，而是并列关系。</p>
<p>能源类企业在内蒙还是比较受欢迎的，例如：国网蒙东电力、赤峰电力、国家能源以及内蒙电力。这类企业的福利待遇还是不错的。</p>
<p>那么灵魂一问来了——蒙东电力和内蒙电力哪个福利待遇更好一点呢？小编给不出具体年薪，就只能求助网友了，众网友的答案是：内蒙电力。</p>
<p>招聘岗位</p>
<p>说了这么多介绍，我们来说说内蒙电力到底招聘的岗位有哪些吧！中公小编根据去年内蒙电力的招聘公告总结出以下招聘类别。变电、配电类，输电运检类，通信检修类，信息网站维护类，财务审计类，法律事务类，文秘类，人力资源管理类，物流管理、电子商务类，能源与动力工程类等</p>
<p>根据2018年和2019年的公告日期，可以推算以下2020内蒙电力应该也是在12月份出公告，届时会通知大家的。到时候中公小编一定连带福利待遇一同告诉大家。</p>
<p>好了，今天关于内蒙电力和两大电网之间就讲这么多，不知道大家是不是更了解内蒙电力了呢。如果你喜欢我的文章，欢迎关注中公小编，为我点赞、评论、转发，中公小编每周都会为大家带来新的国企招聘资讯哦！</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新型储能政策专家交流系列12——是否可以参与需求侧响应？</title>
    <url>/2023/07/05/%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD%E6%94%BF%E7%AD%96%E4%B8%93%E5%AE%B6%E4%BA%A4%E6%B5%81%E7%B3%BB%E5%88%9712%E2%80%94%E2%80%94%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8F%82%E4%B8%8E%E9%9C%80%E6%B1%82%E4%BE%A7%E5%93%8D%E5%BA%94%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天和大家分享了新型储能政策专家交流系列的第十一部分：对用户侧是否可以减少购电成本？</p>
<p>今天和大家分享第十二部分：是否可以参与需求侧响应？</p>
<p>Q：请问是否可以参与需求侧响应？</p>
<p>A: 需求响应又称为辅助服务市场。</p>
<p>目前只有广东开展了用户储能参与辅助服务市场，其他开展电力现货市场的城市、省份目前还没有参与辅助服务的具体盈利模式，但目前是一个趋势，是马上要用的盈利模式。</p>
<p>之所以是未来趋势，因为辅助服务市场主要有三类：一类是火电灵活性改造来参与灵活性调节。第二类是储能，分为抽水蓄能和电化学，包括未来新型储能参与。第三类是需求侧响应，像虚拟电厂一样，通过配储能或者灵活性改造，进行联网和储能的聚合。</p>
<p>目前各地都在落实该盈利模式的相关政策，尽管目前靠这块进行实际盈利比较少，但是是未来的趋势。</p>
<p>新型储能政策专家交流系列的第十二部分的内容就分享到这里，明天和大家分享第十三部分的内容：参与需求侧相应的盈利机制是什么？</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新型储能政策专家交流系列8——会不会导致大量的配电储能转化为独立储能电站？</title>
    <url>/2023/07/04/%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD%E6%94%BF%E7%AD%96%E4%B8%93%E5%AE%B6%E4%BA%A4%E6%B5%81%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%A4%A7%E9%87%8F%E7%9A%84%E9%85%8D%E7%94%B5%E5%82%A8%E8%83%BD%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E7%94%B5%E7%AB%99%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天和大家分享了新型储能政策专家交流系列的第七部分：是不是因为成本在不断下降，所以容量电价不太好给？</p>
<p>今天和大家分享第八部分：会不会导致大量的配电储能转化为独立储能电站？</p>
<p>Q：新政策会不会导致大量的配电储能转化为独立储能电站，从而导致独立储能规模上特别多的情况？</p>
<p>A：首先，我们国家各省都出台了相关政策，新上的新能源、风光电站要配套足够的、满足标准的（10%-20%、1-2小时）储能，配套储能的最低标准是要满足的，比如一百万千瓦的风电厂的最低要求是要配十万千瓦、一小时的储能，即使配了十万千瓦储能，这十万千瓦储能是不能转为独立储能的，因为作为新能源的配额是必须要参与电网侧调节的，不能去转化成独立储能参与市场。所以最低的配套标准不能少，转化成独立储能的额度可能会有，但是有限。</p>
<p>第二点，政策里面也提到了要求有一个独立法人，新能源配套储能如果没有独立法人，转化成独立储能要满足相应的技术标准、安全标准。要并入电网、满足电网调度的话，要满足两个细则：发电机并网的细则和辅助服务的细则。对于爬坡和技术改造有技术要求，这些改造会增加成本，也要考虑一下投资和收益的情况，要看各地的独立储能发电市场的价格机制是不是划算，所以并不是都会选择转为独立储能。</p>
<p>第三点，如果要转化成独立储能的话，要有一个公司将这部分业务划分成独立业务，而且比较复杂，正常来讲储能和新能源发电厂是统一的一个电表出口， 如果要改造成独立储能的话，这一部分要从新能源电厂剥离出来，单独建一个电表单独并入电网，所以也会增加一些投资成本。但是如果辅助服务市场发展够快， 能给予补助补偿的话，多出来的储能可以转化成独立储能。</p>
<p>新型储能政策专家交流系列的第八部分的内容就分享到这里，明天和大家分享第九部分的内容：配电新型储能和所属电源联合参与电力市场，应该怎么理解？</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新型储能政策专家交流系列3——对于独立储能电站的运营、投资影响很大</title>
    <url>/2023/07/03/%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD%E6%94%BF%E7%AD%96%E4%B8%93%E5%AE%B6%E4%BA%A4%E6%B5%81%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%AF%B9%E4%BA%8E%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E7%94%B5%E7%AB%99%E7%9A%84%E8%BF%90%E8%90%A5%E3%80%81%E6%8A%95%E8%B5%84%E5%BD%B1%E5%93%8D%E5%BE%88%E5%A4%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天和大家分享了新型储能政策专家交流系列的第二部分：影响最大的是电网侧的储能</p>
<p>今天和大家分享第三部分：对于独立储能电站的运营、投资影响很大</p>
<p>虽然政策里面有提到用户储能， 但是也没有什么落地政策，没有什么太大作用。</p>
<p>本次政策对于独立储能电站的运营、投资影响很大，增加了盈利的机会，有利于储能的成本的疏导。</p>
<p>但是其实对于投资方的要求也更高了，这个通知里面提到要坚持以市场化方式为主，优化储能调度运行，各地要建立完善的市场机制和调度机制，这个说得比较虚。</p>
<p>总体上，未来投资独立储能电站的功率至少几万千瓦，甚至几十万千瓦。现在万里扬已经运营了一个300MW/600MWh 的储能电站，林洋也有，相当于接在500千伏电网的30万或者60万千瓦的火电厂的规模。未来建设的独立储能电站可能更多是大型的储能电站，几万千瓦的也会有，但是更大规模的运营成本更低一些，投资成本也可能会更低一些。</p>
<p>对于储能电站未来的投资方要求也更高一些，虽然政策明确说要统一调度，不搞特殊化，但是现在的火电厂，建在不同的地方对于年发电量的影响很大，需求比较大的地方就是躺着赚钱，因为电网会一直有调用的需求。如果选址不好，遇到阻塞，那么很可能发电和储能的利用小时数远远达不到平均水平，所以对于投资方要求也更高一些。</p>
<p>未来储能电站参与电力市场的推进也会更快一些，因为发改委、能源局级别比较高的通知都明确了它的成本的疏导，所以未来这方面各省的落地政策也会加快。对储能影响比较大的一个技术指标就是它的损耗，因为储能的技术路线还有技术标准或者质量极大地影响它的折旧。电化学储能也有折损，不同的技术路线、不同的厂家有一定的差异，这个最低要求是6千次，但是有的可以达到一万次，而且冲放很多次以后的衰减比较少。</p>
<p>未来的储能电站，储能的损耗高低会极大影响参与市场报价的策略。所以未来对选择的设备生产商要求也更高一些。山东的独立的储能电站已经开始运营了，可以关注一下他们运营的效果怎么样。</p>
<p>新型储能政策专家交流系列的第三部分的内容就分享到这里，明天和大家分享第四部分的内容：利好辅助服务市场</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>66个常用的遥感、地理、生态等数据下载平台汇总</title>
    <url>/2023/07/02/66%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E9%81%A5%E6%84%9F%E3%80%81%E5%9C%B0%E7%90%86%E3%80%81%E7%94%9F%E6%80%81%E7%AD%89%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自 GIS小巫师 <a href="https://zhuanlan.zhihu.com/p/591268421">https://zhuanlan.zhihu.com/p/591268421</a></p>
<p>1.中国科学院资源环境数据中心</p>
<p>数据：拥有丰富的数据集（库）</p>
<p>获取方法：注册申请下载</p>
<p><a href="https://www.resdc.cn/">https://www.resdc.cn</a></p>
<p>2.中国科学院地理空间数据云</p>
<p>数据：DEM、地形地貌、遥感等</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.gscloud.cn/">http://www.gscloud.cn</a></p>
<p>3.中国科学院地理空间数据共享中心</p>
<p>数据：GIS软件、地图等</p>
<p>获取方法：免费</p>
<p><a href="https://www.osgeo.cn/">https://www.osgeo.cn</a></p>
<p>4.中国科学院地理空间数据共享中心全球黑土数据库</p>
<p>数据：黑土数据</p>
<p>获取方法：免费</p>
<p><a href="https://www.osgeo.cn/data/w70a2">https://www.osgeo.cn/data/w70a2</a></p>
<p>5.中国科学院中国植物数据库</p>
<p>数据：植物种类检索</p>
<p>获取方法：开放</p>
<p><a href="http://ppbc.iplant.cn/">http://ppbc.iplant.cn</a></p>
<p>6.中国科学院生态系统评估与生态安全数据库</p>
<p>数据：生态系统评估数据</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.ecosystem.csdb.cn/index.jsp">http://www.ecosystem.csdb.cn/index.jsp</a></p>
<p>7.中国科学院国家地球系统科学数据中心地球物理科学数据中心</p>
<p>数据：地球物理</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://geospace.geodata.cn/">http://geospace.geodata.cn</a></p>
<p>8.中国科学院国家地球系统科学数据中心东亚古环境科学数据库</p>
<p>数据：古环境</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://paleodata.ieecas.cn/">http://paleodata.ieecas.cn/</a></p>
<p>9.中国科学院地球生物多样性数据库</p>
<p>数据：GBDB 生态</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.geobiodiversity.com/">http://www.geobiodiversity.com</a></p>
<p>10.中国科学院生态系统通量观测网络</p>
<p>数据：生态类</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.chinaflux.org/">http://www.chinaflux.org/</a></p>
<p>11.自然资源部国家地质资料公共服务</p>
<p>数据：地质资料类</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://mlzx.ngac.cn/">http://mlzx.ngac.cn</a></p>
<p>12.地质云</p>
<p>数据：与地质有关的数据</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://geocloud.cgs.gov.cn/">http://geocloud.cgs.gov.cn</a></p>
<p>13.全国地质资料馆</p>
<p>数据：地球化学、水文地质、区域地质等</p>
<p>获取方法：开放</p>
<p><a href="http://www.ngac.org.cn/">http://www.ngac.org.cn</a></p>
<p>14.中国地质调查局数字地质图</p>
<p>数据：地质图</p>
<p>获取方法：地质图</p>
<p>注册申请下载</p>
<p><a href="http://geodata.cgs.gov.cn/GeoData">http://geodata.cgs.gov.cn/GeoData</a></p>
<p>15.中国地质科学院地质数据共享网</p>
<p>数据：物化探、水文、岩矿、环境、构造等</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.geoscience.cn/">http://www.geoscience.cn</a></p>
<p>16.国家地质资料数据中心</p>
<p>数据：区调、航磁、地球化学</p>
<p>获取方法：开放</p>
<p><a href="http://dc.ngac.org.cn/">http://dc.ngac.org.cn</a></p>
<p>17.国家海洋信息中心</p>
<p>数据：海洋数据</p>
<p>获取方法：开放</p>
<p><a href="http://www.nmdis.org.cn/">http://www.nmdis.org.cn/</a></p>
<p>18.全国地理信息资源目录服务系统</p>
<p>数据：地理、测绘、遥感等数据</p>
<p>获取方法：开放</p>
<p><a href="https://www.webmap.cn/">https://www.webmap.cn</a></p>
<p>19.中国自然资源部标准地图服务</p>
<p>数据：标准地图</p>
<p>获取方法：开放</p>
<p><a href="http://bzdt.ch.mnr.gov.cn/">http://bzdt.ch.mnr.gov.cn</a></p>
<p>20.各地民政部门网站</p>
<p>数据：行政区划地图</p>
<p>获取方法：免费</p>
<p><a href="http://202.108.98.30/map">http://202.108.98.30/map</a></p>
<p>21.地理监测云平台</p>
<p>数据：矢量数据</p>
<p>获取方法：付费下载（数据服务企业）</p>
<p><a href="http://www.dsac.cn/">http://www.dsac.cn</a></p>
<p>22.中国地情网</p>
<p>数据：地理国情、地方志等</p>
<p>获取方法：开放</p>
<p><a href="http://diqing.difangzhi.cssn.cn/">http://diqing.difangzhi.cssn.cn</a></p>
<p>23.国家科技管理信息系统公共服务平台</p>
<p>数据：科技基础资源、科技文献、科技基金共享服务网</p>
<p>获取方法：开源</p>
<p><a href="https://service.most.gov.cn/">https://service.most.gov.cn/</a></p>
<p>24.国家自然科学基金查询系统</p>
<p>数据：基金项目查询、免费图书、科研资源</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://fund.keyanzhiku.com/">http://fund.keyanzhiku.com/</a></p>
<p>25.国家数据中心</p>
<p>数据：国家统计局数据</p>
<p>获取方法：需要内网登陆</p>
<p><a href="http://fund.keyanzhiku.com/">http://fund.keyanzhiku.com/</a></p>
<p>26.科创中国-科技经济融通平台</p>
<p>数据：试点城市、供需对接、科创人才、科研圈等</p>
<p>获取方法：开发</p>
<p><a href="https://www.kczg.org.cn/">https://www.kczg.org.cn</a></p>
<p>27.国家科技成果转换项目库</p>
<p>数据：成果导航、成果统计、政策法规、科技领域</p>
<p>获取方法：注册申请下载、专题部分开放</p>
<p><a href="https://www.nstad.cn/">https://www.nstad.cn</a></p>
<p>28.国家航天局</p>
<p>数据：中国航天、空间科学及应用、国际航天、科普与人物、政策介绍</p>
<p>获取方法：开放</p>
<p><a href="http://www.cnsa.gov.cn/">http://www.cnsa.gov.cn/</a></p>
<p>29.中国科学数据网</p>
<p>数据：期刊网站</p>
<p>获取方法：开放</p>
<p><a href="http://www.csdata.org/">http://www.csdata.org/</a></p>
<p>30.中国科技情报网</p>
<p>数据：研究报告、科技简报、创新政策、精品讲座、科技查新、专利分析、众创平台</p>
<p>获取方法：开放</p>
<p><a href="https://www.chinainfo.org.cn/">https://www.chinainfo.org.cn</a></p>
<p>31.中国科技共享网</p>
<p>数据：国家科学数据中心、国家资源库、服务案例</p>
<p>获取方法：开放</p>
<p><a href="https://www.escience.org.cn/">https://www.escience.org.cn</a></p>
<p>32.国家基础学科公共科学基础数据中心</p>
<p>数据：自然资源数据</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.nsdata.cn/">http://www.nsdata.cn/</a></p>
<p>33.中国工程科技知识中心</p>
<p>数据：工程科技数据</p>
<p>获取方法：开放</p>
<p><a href="http://www.ckcest.cn/">http://www.ckcest.cn</a></p>
<p>34.中国数字科技馆</p>
<p>数据：科普性质</p>
<p>获取方法：开放</p>
<p><a href="https://www.cdstm.cn/">https://www.cdstm.cn</a></p>
<p>35.中国科技成果网</p>
<p>数据：科技成果检索</p>
<p>获取方法：开放</p>
<p><a href="https://www.tech110.net/">https://www.tech110.net/</a></p>
<p>36.中科院数据云</p>
<p>数据：各类专题数据库</p>
<p>获取方法：<a href="http://www.csdb.cn/">http://www.csdb.cn</a></p>
<p>37.中国科学院专题数据库</p>
<p>数据：论文、专利、科研成果、版权软件、可许的数据库</p>
<p>获取方法：开放</p>
<p><a href="http://www.cas.cn/ky/kycc/kxsjk">http://www.cas.cn/ky/kycc/kxsjk</a></p>
<p>38.中国科学院国家综合地球观测数据共享平台</p>
<p>数据：卫星观测数据</p>
<p>获取方法：填表申请</p>
<p><a href="http://www.chinageoss.cn/">http://www.chinageoss.cn</a></p>
<p>39.北斗网</p>
<p>数据：北斗系统、资源、应用、专题</p>
<p>获取方法：开放</p>
<p><a href="http://www.beidou.gov.cn/">http://www.beidou.gov.cn/</a></p>
<p>40.资源遥感中心卫星数据（地调局航遥中心）</p>
<p>数据：资源遥感卫星数据</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.agrs.cgs.gov.cn/">http://www.agrs.cgs.gov.cn/</a></p>
<p>41.自然资源遥感卫星服务平台（地调局航遥中心）</p>
<p>数据：资源遥感卫星数据</p>
<p>获取方法：注册下载</p>
<p><a href="http://www.sasclouds.com/">http://www.sasclouds.com</a></p>
<p>42.国家标本资源平台</p>
<p>数据：标本库</p>
<p>获取方法：开放</p>
<p><a href="http://www.nsii.org.cn/">http://www.nsii.org.cn</a></p>
<p>43.国家岩矿化石标本资源共享平台</p>
<p>数据：标本库</p>
<p>获取方法：开放</p>
<p><a href="http://www.nimrf.net.cn/">http://www.nimrf.net.cn</a></p>
<p>44.地理信息知识专业服务系统</p>
<p>数据：地理信息、地图、地理、行政区划</p>
<p><a href="http://kmap.ckcest.cn/">http://kmap.ckcest.cn/</a></p>
<p>45.地理信息知识专业服务系统1:25万地图服务</p>
<p>数据：地图</p>
<p><a href="http://kmap.ckcest.cn/nationwideMap/index">http://kmap.ckcest.cn/nationwideMap/index</a></p>
<p>46.国家农业科学数据中心</p>
<p>数据：农业</p>
<p><a href="https://www.agridata.cn/">https://www.agridata.cn/</a></p>
<p>47.国家空间科学数据中心</p>
<p>数据：航空航天、天文、卫星、遥感</p>
<p><a href="https://www.nssdc.ac.cn/">https://www.nssdc.ac.cn/</a></p>
<p>48.国家生态科学数据中心</p>
<p>数据：生态</p>
<p><a href="http://www.cnern.org.cn/">http://www.cnern.org.cn/</a></p>
<p>49.国家气象科学数据中心</p>
<p>数据：气象</p>
<p><a href="https://data.cma.cn/">https://data.cma.cn/</a></p>
<p>50.国家地震科学数据中心</p>
<p>数据：地震</p>
<p><a href="https://data.earthquake.cn/">https://data.earthquake.cn/</a></p>
<p>51.国家冰川冻土沙漠科学数据中心</p>
<p>数据：冰川、冻土、沙漠</p>
<p><a href="http://www.ncdc.ac.cn/portal/">http://www.ncdc.ac.cn/portal/</a></p>
<p>52.国家林业数据中心</p>
<p>数据：林业</p>
<p><a href="http://www.forestdata.cn/">http://www.forestdata.cn/</a></p>
<p>53.国家人口健康科学数据中心</p>
<p>数据：健康</p>
<p><a href="https://www.ncmi.cn/">https://www.ncmi.cn/</a></p>
<p>54.中国地震信息网</p>
<p>数据：地震、活动断层</p>
<p>获取方法：开放</p>
<p><a href="http://www.csi.ac.cn/">http://www.csi.ac.cn</a></p>
<p>55.中国社会状况综合调查</p>
<p>数据：社会发展</p>
<p>获取方法：申请</p>
<p><a href="http://css.cssn.cn/">http://css.cssn.cn</a></p>
<p>56.中国社会质量基础数据库</p>
<p>数据：社会综合状况</p>
<p>获取方法：公开</p>
<p><a href="http://csqr.cass.cn/">http://csqr.cass.cn</a></p>
<p>57.中国发展门户网站（中国开发区）</p>
<p>数据：规划</p>
<p><a href="http://cn.chinagate.cn/zhuanti/zgkfq/node_7107942.htm">http://cn.chinagate.cn/zhuanti/zgkfq/node_7107942.htm</a></p>
<p>58.中国开发区</p>
<p>数据：规划</p>
<p><a href="https://www.cadz.org.cn/index.php/develop/index.html">https://www.cadz.org.cn/index.php/develop/index.html</a></p>
<p>59.中国生物物种名录</p>
<p>数据：物种</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://www.sp2000.org.cn/">http://www.sp2000.org.cn</a></p>
<p>60.中国家谱知识网</p>
<p>数据：家谱</p>
<p><a href="https://jiapu.library.sh.cn/">https://jiapu.library.sh.cn/</a></p>
<p>61.中国科学院国家土壤信息服务平台</p>
<p>数据：土壤数据</p>
<p>获取方法：开放</p>
<p><a href="http://www.soilinfo.cn/map">http://www.soilinfo.cn/map</a></p>
<p>62.中国科学院国家土壤科学数据中心</p>
<p>数据：土壤数据</p>
<p>获取方法：开放</p>
<p><a href="http://soil.geodata.cn/">http://soil.geodata.cn</a></p>
<p>63.中国科学院中国土壤数据库</p>
<p>数据：土壤数据</p>
<p>获取方法：开放</p>
<p><a href="http://vdb3.soil.csdb.cn/">http://vdb3.soil.csdb.cn</a></p>
<p>64.中国科学院地球大数据科学工程</p>
<p>数据：专项新闻、科研动态、项目动态、数据共享</p>
<p>获取方法：注册申请下载</p>
<p><a href="http://casearth.com/">http://casearth.com</a></p>
<p>65.中国科学院地球大数据科学工程数据共享服务系统</p>
<p>数据：搜索数据集</p>
<p>获取方法：开放</p>
<p><a href="http://data.casearth.cn/">http://data.casearth.cn</a></p>
<p>66.中国科学院青藏高原科学数据中心</p>
<p>数据：青藏高原相关地球科学数据</p>
<p>获取方法：注册申请下载</p>
<p><a href="https://data.tpdc.ac.cn/">https://data.tpdc.ac.cn</a></p>
<p>本文由地质掘墓人费心整理</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>微电网的官方定义与管理规定</title>
    <url>/2023/07/02/%E5%BE%AE%E7%94%B5%E7%BD%91%E7%9A%84%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%AE%A1%E7%90%86%E8%A7%84%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在刚刚公布的《微电网管理办法》中，对微电网的定义，备案、并网、运行的管理，优惠政策等做出规定。</p>
<p>1、微电网的定义与分类</p>
<p>1)定义</p>
<p>由分布式电源、用电负荷、配电设施.监控和保护装置等组成的小型发配用电系统。</p>
<p>2)分类</p>
<p>微电网分为并网型微电网和独立型微电网，可实现自我控制和自治管理。</p>
<p>并网型微电网既可以与外部电网并网运行，也可以离网独立运行;</p>
<p>独立型微电网不与外部电网连接，电力电量自我平衡。</p>
<p>2、微电网的特征</p>
<p>微电网的发展方向具备以下四个基本特征：</p>
<p>1)微型</p>
<p>主要体现在电压等级低，电压等级一般在35kV及以下;系统规模小，系统容量不大于20MW，通常为兆瓦级及以下。</p>
<p>2)清洁</p>
<p>电源以可再生为主，或以天然气多联供等综合利用为目标的型式;并网型微电网可再生装机容量与<em><strong>大负荷的比值在50</strong></em>，或综合利用效率在70***。</p>
<p>3)自治</p>
<p>微电网内部基本实现电力供需自平衡。并网型微电网与外部电网的年交换电量一般不***过年用电量的50%，独立运行时能保障重要负荷在一段时间内连续供电;独立型微电网应具有黑启动能力。</p>
<p>4)友好</p>
<p>可减少大规模分布式电源接入对电网造成的冲击，并网型微电网与外部电网的交换功率和时段具有可控性，通过对电源、负荷和储能系统的协同控制，实现与电网之间的功率交换。</p>
<p>3、微电网可与售电结合</p>
<p>在城市、商业、工业、新型城镇等地区鼓励建设以风、光.燃气三联供系统为基础的微电网，***综合利用效率;</p>
<p>在海岛、绿洲等偏远地区鼓励因地制宜建设***利用当地自然资源的微电网，促进独立供电技术与经营模式创新。</p>
<p>并网型微电网接入公用配电网及由此引起的公用配电网建设与改造原则上由电网企业承担。因特殊原因由项目业主建设的，电网企业、项目业主应协商***，并报管理部门备案。</p>
<p>鼓励微电网项目运营主体在具备售电公司准入条件、履行准入程序后，开展售电业务。支持微电网项目运营主体获得供电资质，依法取得电力业务许可证，开展配售电业务，并承担微电网内的保底供电服务。</p>
<p>在微电网项目服务范围内，鼓励建立购售双方自行协商的价格体系，构建冷、热、电多种市场交易机制。</p>
<p>微电网应公平承担社会责任，交易电量按政府规定标准缴纳政府性基金和政策性交叉补贴。研究并网型微电网与外部电网进行电量交换的价格机制。</p>
<p>4、对微电网的管理</p>
<p>微电网项目业主应与电网企业签订并网调度协议、购售电合同，明确双方责任和义务，确定电能计量、电价及电费结算、调度管理方式等。</p>
<p>并网型微电网的供电可靠性及电能质量应***国家及行业相关规范要求;独立型微电网的供电可靠性及电能质量可根据当地资源条件及项目技术经济条件适当调整，并接受管理部门监督。</p>
<p>微电网的并网运行和电力交换应接受电力调度机构统一调度，向电力调度机构上报必要的运行信息。</p>
<p>微电网运营主体应建立运行管理机构，负责微电网内分布式电源、储能与负荷的平衡，以及与大电网的电力交换，促进微电网内多种的协同供应和综合梯级利用。</p>
<p>并网型微电网可为电网提供调峰、负荷侧响应等辅助服务，在紧急情况下可作为地区应急电源，根据电力调度机构指令，为地区电网提供必要支持。</p>
<p>5、金融支持政策</p>
<p>鼓励地方政府和社会资本合作，以特许经营等万式开展微电网项目的建设和运营。</p>
<p>鼓励微电网项目单位通过发行企业债券、专项债券、项目收益债券、中期票据等方式直接融资，参照《配电网建设改造专项债券发行指引》号)，享有绿色信贷支持。</p>
<p>6、微电网案例</p>
<p>1)边远地区微电网</p>
<p>2)海岛微电网</p>
<p>3)城市微电网</p>
<p>政策原文</p>
<p>微电网作为“互联网+”智慧的重要支撑以及与大电网友好互动的技术手段，可以<em><strong>电力系统的</strong></em>性和可靠性，促进清洁的接入和就地消纳，提升利用效率，在节能减排中发挥重要作用，有利于建设节约型社会。为促进电力行业健康有序发展，推进电力体制改革，进一步规范微电网建设运营管理，逐步建立多元融合、供需互动、***配置的生产与消费体系，特制定本办法。</p>
<p>***章 定义与范围</p>
<p>***条 微电网是指由分布式电源、用电负荷、配电设施、监控和保护装置等组成的小型发配用电系统。微电网分为并网型微电网和独立型微电网，可实现自我控制和自治管理。并网型微电网既可以与外部电网并网运行，也可以离网独立运行;独立型微电网不与外部电网连接，电力电量自我平衡。</p>
<p>第二条 微电网作为整个电网系统的一部分和重要补充，可向特定用户提供经济、***、可靠的供电，是推动集中与分散相协调的新一代电网发展模式，其发展方向具备以下四个基本特征：</p>
<p>微型，主要体现在电压等级低，电压等级一般在35kV及以下;系统规模小，系统容量不大于20MW，通常为兆瓦级及以下。</p>
<p>清洁，电源以可再生为主，或以天然气多联供等综合利用为目标的型式;并网型微电网可再生装机容量与<em><strong>大负荷的比值在50</strong></em>，或综合利用效率在70***。</p>
<p>自治，微电网内部基本实现电力供需自平衡。并网型微电网与外部电网的年交换电量一般不***过年用电量的50%，独立运行时能保障重要负荷在一段时间内连续供电;独立型微电网应具有黑启动能力。</p>
<p>友好，可减少大规模分布式电源接入对电网造成的冲击，并网型微电网与外部电网的交换功率和时段具有可控性，通过对电源、负荷和储能系统的协同控制，实现与电网之间的功率交换。</p>
<p>第三条 微电网应适应新、分布式电源和电动汽车等快速发展，***多元化接入需求。结合城市、工商业园区、新型城镇、新农村以及海岛、绿洲等发展需要，鼓励利用当地资源，进行融合创新，培育生产和消费新业态。</p>
<p>第二章 建设管理</p>
<p>第四条 微电网发展规划应符合国家产业政策，并与发展规划、电力发展规划等专项规划相衔接。</p>
<p>第五条 省级管理部门应会同有关部门，将微电网项目纳入地区配电网规划，组织完善配电网结构，加快推进配电网智能化，为微电网发展提供保障。</p>
<p>第六条 电网企业应结合地区配电网规划，做好微电网公平接入服务。</p>
<p>第七条 简化微电网项目审批程序，根据微电网类型及构成，参照《政府核准的投资项目目录》、《企业投资项目核准和备案管理条例》，按项目建设内容整体核准。</p>
<p>第八条 微电网项目建设内容发生变更的，项目建设单位应当依照有关规定，事先以书面形式向原项目核准机关提出调整变更申请。原项目核准机关应当根据行政许可规定和项目具体变更情况，作出相关决定。</p>
<p>第九条 省级管理部门可按照微电网管理的需要，建立微电网建设、运行信息的统计报送机制，收集并统计相关数据和信息。</p>
<p>第三章 并入电网管理</p>
<p>第十条 微电网并入电网应符合技术、<em><strong>等有关程序要求，即符合国家及行业微电网技术标准，符合接入电网的</strong></em>标准。</p>
<p>第十一条 国家局会同有关部门拟定微电网并网标准，指导、监督各地并网管理工作。</p>
<p>第十二条 省级管理部门负责本地区并网管理工作，根据微电网类型及容量，组织制订并网业务管理相关制度和办法。</p>
<p>第十三条 省级管理部门应会同监管机构建立并网协调机制，做好公平开放接入的监督管理。</p>
<p>第十四条 电网企业应制定并公告微电网并网程序、时限、相关服务标准及细则，编制统一的并网调度协议和购售电合同示范文本，为微电网提供便捷、及时、***的接入电网服务。</p>
<p>第十五条 微电网项目业主应与电网企业签订并网调度协议、购售电合同，明确双方责任和义务，确定电能计量、电价及电费结算、调度管理方式等。</p>
<p>第十六条 并网型微电网接入公用配电网及由此引起的公用配电网建设与改造原则上由电网企业承担。因特殊原因由项目业主建设的，电网企业、项目业主应协商***，并报管理部门备案。</p>
<p>第四章 运行管理</p>
<p>第十七条 微电网项目运营主体要建立健全运行管理规章制度，保障项目<em><strong>可靠运行。并网型微电网的供电可靠性及电能质量应</strong></em>国家及行业相关规范要求;独立型微电网的供电可靠性及电能质量可根据当地资源条件及项目技术经济条件适当调整，并接受管理部门监督。</p>
<p>第十八条 微电网的并网运行和电力交换应接受电力调度机构统一调度，向电力调度机构上报必要的运行信息。</p>
<p>第十九条 微电网运营主体应建立运行管理机构，负责微电网内分布式电源、储能与负荷的平衡，以及与大电网的电力交换，促进微电网内多种的协同供应和综合梯级利用。</p>
<p>第二十条 并网型微电网可为电网提供调峰、负荷侧响应等辅助服务，在紧急情况下可作为地区应急电源，根据电力调度机构指令，为地区电网提供必要支持。</p>
<p>第五章 试点示范</p>
<p>第二十一条 依据《国家电力示范项目管理办法》，积极推动典型示范，从微电网存在形式与功能出发，因地制宜探索各类分布式和智能电网技术应用，构建完善的技术标准体系，推动产学研结合，提升装备制造能力，促进产业升级。</p>
<p>第二十二条 在城市、商业、工业、新型城镇等地区鼓励建设以风、光、燃气三联供系统为基础的微电网，<em><strong>综合利用效率;在海岛、绿洲等偏远地区鼓励因地制宜建设</strong></em>利用当地自然资源的微电网，促进独立供电技术与经营模式创新。</p>
<p>第二十三条 对示范项目实行优先并网，优先纳入政策性资金支持。对于效果突出、技术创新的项目，择优纳入国际交流合作和评奖***，在示范基础上逐步推广。</p>
<p>第六章 政策保障</p>
<p>第二十四条 微电网内部的分布式电源纳入当年的建设规模指标，可执行现有分布式和可再生的补贴政策。通过城镇电网建设改造、智能电网等现有专项建设基金专项，加大微电网建设的资金支持力度。</p>
<p>第二十五条 ***发挥市场机制作用，调动社会资本参与微电网建设的积极性。鼓励地方政府和社会资本合作，以特许经营等方式开展微电网项目的建设和运营。</p>
<p>第二十六条 鼓励微电网项目运营主体在具备售电公司准入条件、履行准入程序后，开展售电业务。支持微电网项目运营主体获得供电资质，依法取得电力业务许可证，开展配售电业务，并承担微电网内的保底供电服务。</p>
<p>第二十七条 鼓励微电网项目单位通过发行企业债券、专项债券、项目收益债券、中期票据等方式直接融资，参照《配电网建设改造专项债券发行指引》，享有绿色信贷支持。</p>
<p>第二十八条 在微电网项目服务范围内，鼓励建立购售双方自行协商的价格体系，构建冷、热、电多种市场交易机制。微电网应公平承担社会责任，交易电量按政府规定标准缴纳政府性基金和政策性交叉补贴。研究并网型微电网与外部电网进行电量交换的价格机制。</p>
<p>第二十九条 研究制定微电网所在地区的分时电价等需求侧管理政策，探索建立微电网可作为市场主体参与的可中断负荷调峰、电储能调峰调频等辅助服务补偿机制。研究新型备用容量定价机制，由微电网运营主体根据微电网自平衡情况自主申报备用容量，并统一缴纳相应的备用容量费用。</p>
<p>第七章 监督管理</p>
<p>第三十条 省级管理部门要密切跟踪微电网建设，建立健全考评机制，加强对微电网可再生就地消纳、综合利用效率、节能减排效益、建设投资回报等考核与评估。</p>
<p>第三十一条 国家局派出监管机构负责对微电网运行主体准入、电网公平开放等实施监管。</p>
<p>第八章 附则</p>
<p>第三十二条 本办法由国家发展改革委、国家局负责解释。各省级政府可依据本办法制定实施细则。</p>
<p>第三十三条 本办法自发布之日起施行，***期3年。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>独立储能四种储能盈利模式解析</title>
    <url>/2023/07/01/%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E5%9B%9B%E7%A7%8D%E5%82%A8%E8%83%BD%E7%9B%88%E5%88%A9%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>独立储能指的是独立储能电站，其独立性体现在可以以独立主体身份直接与电力调度机构签订并网调度协议，不受位置限制。</p>
<p>独立储能收益模式大致可分为如下四种：共享租赁、现货套利、辅助服务、容量电价。</p>
<p>01 共享租赁</p>
<p>共享储能是由第三方或厂商负责投资、运维，并作为出租方将储能系统的功率和容量以商品形式租赁给目标用户的一种商业运营模式，秉承“谁受益、谁付费”的原则向承租方收取租金。</p>
<p>用户可以在服务时限内享有储能充放电权力来满足自身供能需求，无需自主建设储能电站，大幅减低原始资金投入，充分考虑储能建设的成本和合理收益。</p>
<p>图：共享储能使新能源业主免于一次性资本开支</p>
<p>图片来源：中信建投</p>
<p>图：共享储能集中调度管理</p>
<p>图片来源：中信建投</p>
<p>对共享储能投资商而言，容量租赁费用是稳定的收入来源，国内一般在250-350元/kW/年之间，对于一座100MW的共享储能电站而言，容量租赁费用可达2500-3500万元/年。</p>
<p>02 现货套利</p>
<p>国家发改委、能源局《关于进一步推动新型储能参与电力市场和调度运用的通知》同时明确指出独立储能电站向电网送电的，其相应充电电量不承担输配电价和政府性基金及附加，约减少储能电站度电成本0.1-0.2元/kWh。政策提高储能电站经济性，推动国内储能行业快速发展。</p>
<p>图：现货市场分日前、实时（平衡）两个市场</p>
<p>图片来源：中信建投</p>
<p>山东是第一个独立储能进入电力现货市场的省份。根据《山东省电力现货市场交易规则(试行)(2022年试行版V1.0)》，独立储能电站可以自主选择参与调频市场或者电能量市场。在电能量市场中，储能电站“报量不报价”，在满足电网安全稳定运行和新能源消纳的条件下优先出清。在调频市场，储能电站须与发电机组同台竞价。</p>
<p>山东电力现货市场峰谷价差大，为独立储能电站创造更大盈利空间。以四月份结算试运行工作日报数据为例，山东实时电力现货市场平均价差为932.15元/MWh，其中最高价差为1380元/MWh；最低价差为4月4日的439.93元/MWh。高价差的现象为储能创造了更大收益空间。以最低价差的4月4日为例，最高电价出现在6、18、24时的三个时间点附近，而光伏出力高峰的9<del>15时之间，大约维持在-80元/MWh。这意味着四月份最低价差的4月4日，独立储能电站在光伏出力高峰（9</del>15时）储存电力，在17~19时之间释放电力，可以获得超300元/MWh的收益。</p>
<p>03 辅助服务</p>
<p>2021年8月，国家能源局正式印发新版《并网主体并网运行管理规定》和《电力系统辅助服务管理办法》（简称新版“两个细则”），正式承认了新型储能（包括电化学、压缩空气、飞轮、液流等）拥有独立的并网主体地位，需要遵守安全稳定运行相关规定的同时，也能参与辅助服务市场获取收益。</p>
<p>2022年6月，国家能源局南方监管局印发南方区域新版《两个细则》，将独立储能电站作为新主体纳入南方区域“两个细则”管理，进一步提升独立储能补偿标准，完善独立储能盈利机制，提高了独立储能电站准入门槛。目前，新型储能常见的辅助服务形式主要有调峰、调频（包括一次调频、二次调频）两类，具体收益额度各省不同，但调峰多为按调峰电量给予充电补偿，价格从0.15元/kWh（山东）到0.8元/kWh（宁夏）不等。而调频多为按调频里程基于补偿，根据机组（PCS）响应AGC调频指令的多少，补偿0.1-15元/MW的调频补偿。</p>
<p>04 容量电价</p>
<p>目前只有山东启动现货市场试运行后，参照火电标准给予电化学储能容量电价。储能与备用火电在系统中的作用类似，利用小时有很大的不确定性，仅靠电量电价难以维持经济性，因此需要容量电价予以“兜底”。</p>
<p>但与抽蓄、火电不同的是，电化学电站建设便捷，调节性能优异，国家政策方向是将电化学储能尽可能推向电力市场去获利，容量电价仅为电化学储能收益“保底”手段。</p>
<p>收益率分析：可支持项目资本金IRR8%-10%</p>
<p>独立（共享）储能从第一个项目落地青海以来，历经山东、山西、甘肃等省和国家层面的政策与实践探索，初步统计布局独立储能政策的省份已超过14个，收益模式各有不同，但不外乎共享租赁、现货套利、辅助服务、容量电价四类。我们可以看看山东和山西的收益模式。</p>
<p>山东：独立储能先锋，现货+租赁+容量电价模式</p>
<p>目前山东独立储能电站享有共享租赁、现货套利和容量电价补偿三种收益模式。据山东电力工程咨询院数据，该模式下100MW/200MWh独立储能电站每年有望获得现货套利收益约2000万元、共享租赁收益约3000万元，以及容量电价收益约600万元。在总投资约4.5亿元，融资成本4.65%的基础上，项目有望实现资本金收益率8%以上。</p>
<p>图：山东独立储能支持政策变迁</p>
<p>山西：首先启动一次调频辅助服务，收益率较高</p>
<p>山西属于国内首批8个电力现货交易示范省份之一，从2018年底就开始电力现货市场交易，2019、2020年分别运行了3个月，从2021年4月1日至今，一直执行现货交易政策，是现货交易运行时间最长的试点省份。通过几年的运行，山西省现货交易市场已逐渐成熟，政策基本趋于稳定，其中明确了独立储能参与现货交易的细则。</p>
<p>容量电价给予国内独立储能项目收益“兜底”，而以山东为代表的多个省份在独立储能的收益机制和商业模式上做出了许多有益探索。预计现货交易+共享租赁+辅助服务+容量电价的收益模式将在全国独立（共享）储能电站渗透。</p>
<p>收益机制的日渐丰富将显著提高独立储能项目的收益率。而只有储能项目获得了经济性，才能给供应链创造足够的盈利空间和利润弹性，最终带来业绩的放量。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>独立储能利好来了！两部委发文或优化商业模式，盈利空间就此打开</title>
    <url>/2023/06/30/%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E5%88%A9%E5%A5%BD%E6%9D%A5%E4%BA%86%EF%BC%81%E4%B8%A4%E9%83%A8%E5%A7%94%E5%8F%91%E6%96%87%E6%88%96%E4%BC%98%E5%8C%96%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%9B%88%E5%88%A9%E7%A9%BA%E9%97%B4%E5%B0%B1%E6%AD%A4%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《科创板日报》6月7日讯（编辑 郑远方），6月7日，发改委、国家能源局发布关于进一步推动新型储能参与电力市场和调度运用的通知（以下简称“《通知》”）。</p>
<p>继《关于促进新时代新能源高质量发展实施方案》、《“十四五”可再生能源发展规划》之后，这是近一周多以来，第三份明确提及储能在电力系统应用的国家政策文件。</p>
<p>本次《通知》提出，新型储能可作为独立储能参与电力市场。</p>
<p>加快推动独立储能参与电力市场配合电网调峰。加快推动独立储能参与中长期市场和现货市场；</p>
<p>充分发挥独立储能技术优势提供辅助服务；</p>
<p>独立储能电站向电网送电的，其相应充电电量不承担输配电价和政府性基金及附加。</p>
<p>同时，强调用户侧、电网侧储能发展。</p>
<p>一方面，在用户侧，鼓励进一步拉大电力中长期市场、现货市场上下限价格，引导用户侧主动配置新型储能，增加用户侧储能获取收益渠道；另一方面，在电网侧，研究建立电网侧独立储能电站容量电价机制，逐步推动电站参与电力市场，探索将电网替代型储能设施成本收益纳入输配电价回收。</p>
<ul>
<li>亮点一：独立储能官方定义明确</li>
</ul>
<p>什么是独立储能？本次《通知》针对独立储能给出了官方定义：具备独立计量、控制等技术条件，接入调度自动化系统可被电网监控和调度，符合相关标准规范和电力市场运营机构等有关方面要求，具有法人资格的新型储能项目，可转为独立储能，作为独立主体参与电力市场。</p>
<p>2021年7月，国家发改委、国家能源局发布《关于加快推动新型储能发展的指导意见》，从政策层面明确了独立储能的市场主体地位，商业模式也逐步成形。</p>
<p>随后，我国独立储能规模迅速扩大。据中关村储能产业技术联盟统计，去年全年，规划、投产、在建的独立储能电站总规模超过了17GW/34GW，设计超过20个省区。</p>
<ul>
<li>亮点二：降本增益迎来双重推进</li>
</ul>
<p>如今，山东、湖南、江苏、河北、浙江、安徽等多省已纷纷布局大规模独立储能项目。</p>
<p>其中，山东省独立储能示范项目已于今年3月进入市场运行。据光大证券计算，其收益来源于三部分，电价差+租赁费+容量电价*系数，运行成本中损失的度电价格为充电时刻节点电价+基金附加+输配电价+容量补偿电价，新能源配建储能的收益仅有租赁费。</p>
<p>换言之，正如分析师所言，从商业模式上，独立储能优于新能源配建储能，但仍需进一步拓展完整，这将很大程度的影响国内储能装机上量的进度。</p>
<p>彼时光大证券已提醒，重点观测两个方面：政策上，充电电价是否会减去输配电价和基金附加，改为只支付节点电价的模式；价差上，可持续观测山东发电侧的峰谷价差情况，以计算独立储能经济性。</p>
<p>而本次《通知》针对这两方面均作出具体且明确的指引，独立储能在降本、增益上或双双迎来进一步实质性推进。</p>
<p>一方面，文件指出，“独立储能电站向电网送电的，其相应充电电量不承担输配电价和政府性基金及附加”，则独立储能成本进一步下探——仅论上文山东一例中，“运行成本中损失的度电价格”四因素中，未来便有望减去两项。</p>
<p>另一方面，文件在用户侧“鼓励进一步拉大电力中长期市场、现货市场上下限价格”，则独立储能经济性有望迎来增长——同样以上文山东为例，在收益的“电价差+租赁费+容量电价*系数”三个组成因素中，电价差有望拉大。</p>
<p>天风证券指出，目前我国电网侧独立储能项目仍处发展初期，从政策看，独立储能项目主要依靠调峰、调频获得收益，未来，向新能源电站进行容量租赁获得租金，有望成为独立储能的增量收入。</p>
<p>A股公司中：</p>
<p>电池环节环节厂商包括宁德时代、亿纬锂能、国轩高科、鹏辉能源；</p>
<p>PCS领域公司有阳光电源、星云股份、盛弘股份、德业股份、禾望电气、锦浪科技、固德威；</p>
<p>系统集成领域厂商包括派能科技、思源电气、科士达；</p>
<p>储能消防与热管理公司包括英维克、青鸟消防、国安达、高澜股份、同飞股份；</p>
<p>此外，万里扬、林洋能源为独立储能运营商。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>储能行业深度研究报告：行业东风将至，新型储能其兴可待</title>
    <url>/2023/06/29/%E5%82%A8%E8%83%BD%E8%A1%8C%E4%B8%9A%E6%B7%B1%E5%BA%A6%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%EF%BC%9A%E8%A1%8C%E4%B8%9A%E4%B8%9C%E9%A3%8E%E5%B0%86%E8%87%B3%EF%BC%8C%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD%E5%85%B6%E5%85%B4%E5%8F%AF%E5%BE%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>储能行业深度研究报告：行业东风将至，新型储能其兴可待<br>未来智库|财经领域创作者2022-12-0210:21:30发布于安徽<br>（报告出品方/作者：西部证券，杨敬梅）</p>
<p>一、储能广泛应用于源网荷，保障新能源消纳</p>
<p>1.1风光装机占比不断提升，电力系统面临挑战</p>
<p>国内外风电光伏装机量快速提升，有望在未来能源结构中占据重要地位。现阶段，具备规模化开发的可再生清洁能源主要有水能、风能和太阳能，其中风能，光伏发展空间巨大，增速较快。根据国家能源局，2021年我国风电和光伏发电占总发电量的比重分别达到7.8%和3.9%，风光发电量占总发电量比重首次超过10%。我们预计，2025年中国与全球的光伏装机量将达到155/600GW，风电装机量将达到118/188GW。根据BCG的预计，至2030年我国能源装机中风电光伏的占比将接近一半，此后将在我国能源装机结构中占据愈发重要地位。</p>
<p>光伏、风电属于不稳定出力电源，影响电力系统稳定性。光伏、风电等新能源具有波动性、间歇性与随机性等特性，风电出力日内波动幅度最高可达80%，出力高峰出现在凌晨前后，午后到最低点，“逆负荷”特性更明显，光伏日内波动幅度100%，峰谷特性鲜明，正午达到当日波峰，正午前后均呈均匀回落态势，夜间出力为0，此外光伏易受天气影响，天气阴晴对光伏发电系统实际有功功率的影响非常明显，因此每日的实际有功功率也具有一定随机性。正是风电和光伏的这些不稳定的特点对发电量预测造成了难度，因此二者均属于不稳定出力的电源。随着风电光伏的大规模发展，并逐渐成为主流能源，这种间歇性、不稳定的能源将在发电端和用户端大规模装机，该情景下整个电力系统的平衡将难以实现。</p>
<p>储能是实现“碳达峰、碳中和”目标的重要支撑技术。目前电力系统是发输配用的单向平衡，通过发电端的调节达到与用户端的负荷平衡，且通过电网的调度来实现该功能。在新一轮能源革命中，如何有效抑制新能源发电的间歇性、波动性，提高新能源大规模并网发电稳定性成为关键性问题。为了实现以可再生能源为主体的电力系统的负荷平衡，储能将成为其关键支撑技术。储能技术的发展应用有利于平抑新能源电网波动，促进可再生能源消纳，推动主体能源由化石能源向可再生能源更替，助力早日实现“双碳”目标。</p>
<p>1.2储能广泛应用于源网荷，重要性不断凸显</p>
<p>储能行业应用场景丰富，主要可分为电源侧、电网侧和用户侧三类。电源侧对储能的需求场景类型较多，包括可再生能源并网、电力调峰、系统调频等；电网侧储能主要发挥支撑电力保供、提升系统调节能力、支撑新能源高比例外送以及替代输配电工程投资等作用；用户侧储能主要用于电力自发自用、峰谷价差套利、容量电费管理和提高供电可靠性等。然而，在实际应用中，储能的某一功能应用并不局限于单一应用场景，以平滑输出、跟踪出力计划为例，可同时应用于电源侧、电网侧和用户侧。从新型储能的应用分布上看，根据CNESA，2022年前三季度依旧是电网侧的新增装机规模最大，达到512.8MW，占据新型储能一半以上的市场份额，而网侧项目中有60%以上的份额是来自独立储能。</p>
<p>1.2.1发电侧：新能源并网与电力调峰的重要保障</p>
<p>储能在电源侧的主要应用场景包括可再生能源并网、电力调峰、辅助动态运行、系统调频等方面。在当前政策框架下，电源侧储能电站的收益点主要为削峰填谷带来的增发收益，跟踪发电计划避免考核所带来的损失等。此外，配备储能的光伏、风电项目也更容易获取新能源建设并网的指标。在未来准许可再生能源+储能参与电力辅助服务市场，明确调峰补偿后，电源侧储能还可获得参与电力辅助服务市场获取的收益和深度调峰收益。</p>
<p>1.2.2电网侧：构建新型电力系统的重要支撑</p>
<p>促进局部地区新能源消纳、替代输变电工程投资是当前电网侧新型储能主要功能。根据电规总院，当前我国已投运电网侧新型储能项目主要集中在山东、江苏、河南、湖南、青海、浙江、广东、福建等省份。当前电网侧新型储能发挥功能以促进局部地区新能源消纳、替代输变电工程投资为主。结合电力系统需求，电网侧新型储能本应发挥一些综合性、全局性功能，但是目前仍缺乏明确定位。</p>
<p>电网侧新型储能是未来新型电力系统构建的重要支撑。相比电源侧和负荷侧储能，电网侧新型储能布局在电网关键节点，单站规模较大，接入电压等级较高，且具备独立运行条件，因此更适宜参与全局统一调控，更具备系统性、全局性优势。以电力系统实际需求为导向，电网侧新型储能布局重点考虑支撑电力保供、提升系统调节能力、支撑高比例新能源外送、替代输配电工程投资四大应用场景。根据电规总院，综合考虑以上四类应用场景，“十四五”全国电网侧新型储能总需求规模约5500万千瓦，时长2~4小时。应用场景以支撑电力保供、提升地区电力系统调节能力为主，三北地区规模需求略高于中东部地区。</p>
<p>1.2.3用户侧：提升电力自发自用水平与峰谷价差套利</p>
<p>储能在用户侧的主要应用场景包括电力自发自用水平提升、峰谷价差套利、容量费用管理、提升电力可靠性和提高电能质量等方面。在当前政策框架下，用户侧储能电站的收益主要来自于峰谷价差带来的电费节省。在未来落实分布式可再生能源+储能参与电力辅助服务市场机制，补偿需求响应价值等政策进一步完善的情况下，用户侧储能电站的收益还可包括需求响应收益、延缓升级容量费用收益、参与电力辅助服务市场所获取的收益等部分。</p>
<p>二、储能装机快速提升，商业模式逐渐明晰</p>
<p>2.1国内外装机量快速提升，需求空间广阔</p>
<p>储能鼓励政策不断出台，新型储能独立市场主体地位逐渐明晰。自2017年国家能源局出台《关于促进储能技术与产业发展的指导意见》，明确促进我国储能技术与产业发展的重要意义、总体要求、重点任务和保障措施后，国内各类储能政策相继出台。2021年7月，国家发改委发布的《关于加快推动新型储能发展的指导意见》，提出至2025年，新型储能从商业化初期向规模化发展转变，装机规模达30GW以上。同月发布的《关于进一步完善分时电价机制的通知》，明确应合理拉大峰谷电价价差，系统峰谷差率超过40%的地方，峰谷电价价差原则上不低于4:1，其他地方原则上不低于3:1。2022年以来，更多储能产业鼓励政策出台，储能技术路径与商业模式发展不断明晰，新型储能可作为独立储能参与电力市场。</p>
<p>近年来全球储能装机量快速提升，国内发展大幅提速。根据CNESA，全球2021年新增装机量为18.3GW，同比增长181.30%，截至2021年底全球已投运储能项目的累计装机量达209.4GW，同比增长9.58%。中国储能行业起步较晚，但是近几年发展速度快。中国2021年新增装机量为7.7GW，同比增长140.63%，截至2021年底中国的累计装机量达到43.3GW，同比增长21.63%。2022年前三季度我国新增储能装机7.0GW，截至2022年9月底中国已投运电力储能项目累计装机规模50.3GW，同比+36%，环比一季度+7.5%，我们预计全年大多数项目的投产期都集中在四季度，特别是年底，届时装机规模一定会有大幅提升。</p>
<p>抽水储能仍占据主导地位，锂电池储能在新型储能中占比最高。全球范围内，截至2021年底，抽水储能占比86.2%，同比下降4.1%，但仍居于主导地位；除抽水蓄能外的储能方式为锂电池等新型储能，新型储能装机量上涨至13.9%，其中绝大部分为锂离子电池。国内方面，截至2022年9月，抽水蓄能累计装机占比持续走低之后，开始有所回升，比去年底上升了0.2个百分点，仍居主导地位。2022年前三季度新型储能（含熔融盐储能）新增装机933.8MW/1911.0MWh，累计装机规模7.24GW，锂电池装机仍占据最大比重。此外，国内首个百兆瓦级液流电池项目的投运，使得液流电池总装机比重达到0.30%。</p>
<p>2021年全球新增电化学储能市场主要集中在中国、美国、欧盟。根据CNESA的数据，2021年全球新增投运新型储能项目地区分布中，美国、欧洲、中国分别占比34%、22%、24%，美国、中国和欧洲依然引领全球储能市场的发展，三者合计占全球市场的80%。</p>
<p>22年我国储能项目中标量充沛，有力支撑行业增长。2022年以来我国储能市场招投标活跃，市场参与度高。根据储能与电力市场的统计，2022年10月国内储能中标量达到14.65GWh，环比增长355.5%，2022年前10月我国储能中标量达到32.2GWh，充沛的中标量将助力我国储能行业步入发展快车道。</p>
<p>新能源配储有望成为主流发展模式，配储比例及配储时长的提升有望进一步扩大储能需求。2021年以来，“新能源+储能”成为新能源行业重要的发展模式。截至2022年11月，全国已有近30个省份出台了“十四五”新型储能规划或新能源配置储能文件，对集中式光伏分布式光伏、以及风电的配套建设储能都提出了明确要求。总结来看，对于已公布强制配储政策的省市地区，新能源配储比例多集中在10%-15%，主流的储能时长为2小时。我们认为，随着未来新能源发电量占比的进一步提升，新能源强制配储将成为解决新能源消纳及维持电网稳定性的主流模式，预计明年会有更多省市地区发布配储政策，且配储比例和储能市场有望提升，长时储能领域有望受益。</p>
<p>大型光伏电站配储为23年行业需求重要拉动力，预计25年我国储能需求86.9GW/274.4GWh，21-25年CAGR为91%/116%，全球需求222.7GW/656.6GWh，22-25年CAGR为89%/110%。我们预计23年随着光伏降价，集中式光伏装机需求向好，占比提升，大型光伏电站配储将是我国储能行业重要拉动力，叠加我国分布式光伏配储与风电配储需求，预计2023年我国储能需求为31.3GW/74.8GWh，同比+116%/+146%。长期来看，随着新能源发电量占比的进一步提升，预计我国新能源的配储比例与配储时长都将提升，预计至2025年我国储能总需求将达到86.9GW/274.4GWh，21-25年CAGR为91%/116%。全球来看，预计2025年全球储能需求222.7GW/656.6GWh，22-25年CAGR为89%/110%。</p>
<p>2.2独立共享储能模式有望提升储能盈利能力</p>
<p>2.2.1独立共享储能相较新能源分散配储优势显著</p>
<p>新能源站分散配储存在存在项目利用率低、项目缺乏经济性、存在安全隐患以及难以参与现货市场盈利等弊端。1）根据今年11月中电联发布的《新能源配储能运行情况调研报告》，新能源配储在弃电期间至多一天一充一放运行，个别项目存在仅部分储能单元被调用、甚至基本不调用的情况，所调研电化学储能项目平均等效利用系数为12.2%，而新能源配储系数仅为6.1%，低于火电厂配储能（15.3%）、电网储能为（14.8%）以及用户储能（28.3%）。2）分散的配置方式无法体现规模效益，普遍存在运营成本高、效率低等问题，难以充分发挥储能作用，项目缺乏经济性。3）此外，在高成本压力下，部分项目选择了性能较差、投资成本较低的储能产品，增加了安全隐患。根据中电联，2022年1-8月，全国电化学储能项目非计划停机达到329次。4）最后，还因为新能源储能装机容量小，分散布置的储能参与现货市场交易成本太高，难以参与现货市场盈利，盈利模式难以拓展。</p>
<p>独立共享储能有效提高储能利用率、储能项目收益率以及市场对储能电站投资积极性。独立储能电站是指具备调度直控条件，以独立市场主体身份直接与电力调度机构签订并网调度协议，不受接入位置限制，纳入电力并网运行及辅助服务管理，并按照其接入位置与电网企业和相关发电企业或电力用户等相关方签订合同，约定各方权利义务的储能电站。而共享储能可以看作是独立储能的一种商业模式。简单而言，共享储能就是把独立分散在电网侧、电源侧、用户侧储能电站资源进行优化配置，最后由电网统一协调。独立共享储能具有灵活性强、适用场景广、分布广泛等优势，可以有效提高储能利用率和储能项目收益率；独立共享储能的投资主体清晰，更容易参与电力市场辅助服务及现货市场，从而推动资本对储能电站投资积极性。</p>
<p>2.2.2独立共享储能政策定位明晰，发展提速</p>
<p>早期电网侧储能试图通过输配电价将成本疏导至用户的模式终止。在早些时候，电网侧储能投资者的商业逻辑是为电网提供各类服务，并希望通过输配电价将成本疏导至用户，但该模式在有效监管机制方面尚不成熟，因此，2019年出台的《输配电定价成本监审办法》，以及2020年出台的《省级电网输配电价定价办法》，均明确规定电化学储能不能计入输配电定价成本，此后该模式终止。独立储能电站将以独立主体身份直接与电力调度机构签订并网调度协议。2022年3月，南方能源监管局就新版两个细则公开征求意见，文件对独立储能进行了重新定义，独立储能电站将以独立主体身份直接与电力调度机构签订并网调度协议，不受接入位置限制，纳入电力并网运行及辅助服务管理。6月7日《关于进一步推动新型储能参与电力市场和调度运用的通知》官方明确独立储能定义；解决独立储能电价问题，独立储能电站向电网送电的，其相应充电电量不承担输配电价和政府性基金及附加。2022年以来，国内多个省份发布了独立共享储能参与电力市场的相关政策措施。</p>
<p>独立储能规划建设提速，在各类型储能项目中的占比不断提升。根据中关村储能产业技术联盟的数据统计，2021全年规划、投产、在建的独立储能电站总规模超过了17GW/34GWh。进入2022年上半年，独立储能电站规划和开发提速。根据储能与电力系统统计，2022年上半年并网投运的独立储能电站共2座（国能江西余干旭坞储能电站、大连液流储能项目），启动施工建设的项目共17个，规模1.67GW/3.34GWh，进入/完成EPC和储能设备招标的项目共64个，规模7.42GW/14.76GWh。中标量来看，2022年10月独立储能中标量3.37GWh，环比提升81.5%。22年1-10月独立储能与新能源配储中标量分别达到12.25/6.45GWh，占中标量的比重分别为64%/34%（不含集采），独立储能已成为我国大储发展的主流商业模式。</p>
<p>2.2.3各省市积极探索商业模式，盈利能力有望提升</p>
<p>“新能源容量租赁+调峰辅助服务补偿租赁费”或“新能源容量租赁+现货市场价差”为当前独立储能两种主流商业模式。当前各个省份针对独立储能的商业模式有所区别，例如山东省（针对示范项目），新能源场站租赁费以外，还包括现货市场节点电价差以及按月度可用容量给予适当容量补偿费用，浙江省（针对示范项目）则为现货市场峰谷价差+辅助服务市场收入，新疆省为赠送新能源指标+充电补偿收益（0.55元/kWh），宁夏为优先发电量奖励+调峰收益（0.8/kWh，保证600次）+新能源容量租赁，山西省则主要为一次调频收益。需要指出的是，调频的市场容量较为有限。目前山西省AGC调频的总补偿费用大致是4亿元，仅靠调频无法支撑大规模储能的收益。未来若更多主体加入，市场会出现饱和的情况，补偿标准也会随之降低。因此，综合来看，独立储能主要的收益模式有两种：①新能源容量租赁+调峰辅助服务补偿租赁费，②新能源容量租赁+现货市场价差。除此外各个省还有其他相关收益。</p>
<p>1）新能源容量租赁</p>
<p>容量租赁费是是决定独立储能项目经济性的最关键因素之一。根据国家发改委发布的《关于鼓励可再生能源发电企业自建或购买调峰能力增加并网规模的通知》，确定了新能源场站可以通过租赁的模式租用独立储能电站的容量。租赁费目前没有明确的官方标准，大致在300元/kw·年左右，主要基于项目的收益要求。容量租赁费是目前独立储能最主要的收益来源之一，是决定独立储能项目经济性的最关键因素之一。目前，新能源储能容量租赁尚处于发展初期，对于100MW/200MWh的储能电站，按80%容量完成租赁，租赁标准300元/kW·年测算，全年容量租赁约2400万元。出租容量的实际使用权：部分省份归属储能电站，部分省份归于新能源电厂。山东的独立储能电站运营模式下，新能源租赁储能容量后，并不享有储能电站的实际使用权，对于储能电站的运营方来说，每一份容量可以获得租金、现货市场价差、容量补偿等多项收益。与之相异的是，甘肃省则规定，独立共享储能电站租赁容量，由新能源场站享有使用权，租赁后剩余容量按规定可参与容量市场。即甘肃省的储能电站只能在出租容量与参与辅助服务之间二选一，而不能同时享有二者收益。</p>
<p>2）调峰辅助服务补偿</p>
<p>调峰辅助服务补偿是大多数区域独立储能电站获取收益的最主要手段之一。储能调峰交易是指储能电站按照电力调度机构的指令，通过在低谷或弃风、弃光、弃水时段吸收电力，在其他时段释放电力，从而提供调峰服务的交易。截至目前，南方区域电网各省市、湖南、青海、宁夏等多个区域市场都出台了独立储能电站调峰补偿规则。作为不自己产生电力的储能设备，除了单次补偿价格，使用频次也是决定其盈利水平的关键。以山东省一个100MW/200MWh储能电站为例，独立储能电站调峰补偿0.2元/kWh，保证调用时长1000小时/年，全年可获得补偿2000万元。</p>
<p>3）电力现货市场</p>
<p>在电力现货市场中，储能电站作为独立市场主体可赚取发电侧峰谷电价差。储能电站作为独立市场主体，可按照自计划方式参与市场申报、优化出清，按照市场出清价格进行结算。储能电站根据电网负荷预测、供热计划、新能源预测出力，判断日前市场电价走势，申报运行日的充放电计划（如在晚低谷和午低谷充电，在早高峰和晚高峰放电），按照现货市场价格结算。进入电力现货市场后，充电时为市场用户，从电力现货市场直接购电；放电时为发电企业，在现货市场直接售电。其相应充电电量不承担输配电价和政府性基金及附加。</p>
<p>4）容量补偿</p>
<p>独立共享储能市场化容量补偿机制有望逐渐出台。11月25日，国家能源局发布了《电力现货市场基本规则（征求意见稿）》和《电力现货市场监管办法（征求意见稿）》。各地要按照国家总体部署，结合实际需要探索建立市场化容量补偿机制，用于激励各类电源投资建设、保障系统发电容量充裕度、调节能力和运行安全。目前山东省已出台独立共享储能电站容量补偿机制。《关于2022年山东省电力现货市场结算试运行工作有关事项的补充通知》指出，将坚持新型储能市场化发展方向，推动新型市场主体积极参与电力现货交易，按月度可用容量给予适当容量补偿费用。根据《2022年“稳中求进”高质量发展政策清单（第四批）的通知》，暂按电力市场规则中独立储能月度可用容量补偿的2倍标准执行，即为火电的1/12。</p>
<p>各省市独立共享储能电站经济性有差异，湖南等部分省份储能电站已经具备一定盈利能力。当前因国内各省市电力市场与相关政策的差异，独立共享储能电站的经济性也存在较大差异。根据7月山东电力交易中心介绍，山东省一个100MW/200MWh的储能电站，目前可获的收益来自容量租赁费用、现货市场价差收益、容量补偿费用，全年总计2000多万元的收益水平，仍然不足以支撑独立储能电站运营（参考三峡能源庆云储能示范项目的运营经验，该电站全年收益水平达到6000万元以上时有一定的经济性）。而在湖南省，以华自科技定城步儒林一期项目为例，该项目容量以全部出租，每年容量租赁收入即可达4480万元，电力辅助服务假设调用费用为每次400元/MWh（含试点项目所获取的峰谷价差收益），年收益2640万元，两项收入合计7120万元，项目已经有一定的盈利能力。</p>
<p>三、技术路线多点开花，商业化进展持续推进</p>
<p>储能应用场景的多样性决定了储能技术的多元化发展。不同应用场景对储能技术的性能要求有所不同，储能应用场景的多样性决定了储能技术的多元化发展。特别地，根据不同储能时长的需求，储能的应用场景可以分为容量型（≥4小时）、能量型（约1~2小时）、功率型（≤30分钟）和备用型（≥15分钟）四类。根据储能时长要求的不同进行储能类型划分，有助于推进以市场应用为导向的技术开发思路，使不同储能技术在各自适用的场景中发挥独特的性能优势。</p>
<p>3.1抽水蓄能：当前技术路线与商业化最为成熟</p>
<p>3.1.1基于上下水库实现能量转换，用途广泛</p>
<p>抽水蓄能利用电力负荷低谷时的电能抽水至上水库，在电力负荷高峰期再放水至下水库发电。抽水蓄能电站由两个相互连接且位于不同高度的水库组成。管道将上部和下部水库连接。在电力负荷低谷期，电动机将电能转化成机械能，通过将水从下部水库通过管道输送到上部水库，泵将它们转化为势能。在负荷高峰时，储存在上部水库中的水可以通过涡轮机返回到下部水库，由此从势能产生机械能，并在发电机的帮助下再次产生电能。储存的能量与水的总质量和上下两蓄水池之间的高度差的乘积成比例。</p>
<p>抽水蓄能电站在电力系统中发挥六大基本作用、三大现实作用以及六大需求展望。抽水蓄能机组凭借迅速而灵敏的开、停机性能，快速灵活的运行特点，在电力系统中发挥六大基础作用：储能、调峰填谷、调频、调相、紧急事故备用以及黑启动功能。</p>
<p>3.1.2装机量提升，行业进入高质量发展新阶段</p>
<p>基于新的时代背景和行业形式，“十四五”以来我国出台了一系列政策文件，指导、支持抽水蓄能发展。2021年4月30日，《国家发展改革委关于进一步完善抽水蓄能价格形成机制的意见》坚持以两部制电价为主体，进一步完善抽水蓄能价格形成机制；2021年9月17日，国家能源局《抽水蓄能中长期发展规划（2021-2035年）》表明，到2025年，抽水蓄能投产总规模较“十三五”翻一番，达到6200万千瓦以上；到2030年，抽水蓄能投产总规模较“十四五”再翻一番，达到1.2亿千瓦左右。</p>
<p>国内外抽水蓄能建设速度加快，我国累计装机容量位列世界第一。2020年以来全球抽水蓄能电站建设速度加快，根据CNESA，2021年累计装机达到181GW。国内方面，我国抽水蓄能快速发展，2001年装机容量仅为5GW，2021年我国装机容量达37GW，我国的单个抽水蓄能电站装机容量以及全国装机总量均位居全球首位。对比全球抽水蓄能装机量新增速度，我国在2021年表现优于全球平均水平，呈现巨幅上升趋势。2022年前三季度，我国抽水蓄能新增装机6.1GW，超过去年全年的5.2GW，累计装机量已达到43.1GW。</p>
<p>截至2021年底，我国已纳入规划的抽水蓄能站点资源总量约8.14亿千瓦，主要分布于西部地区，占比约37%；在建抽水电站规模为6153万千瓦。纳入规划的抽水蓄能站点资源总量中，重点实施项目4.21亿千瓦，规划储备项目3.05亿千瓦，其中9792万千瓦项目已经实施。</p>
<p>2022年上半年，开工和投产的抽水蓄能项目已达16个，总规模22.4GW，项目的总投资额超1370亿元。2022年上半年开工的抽蓄项目有10个，总规模14.1GW，主要分别于浙江、湖南、山西、湖北等地区。全面投产的项目有6个，总规模8.3GW，主要涉及广东、浙江、吉林等地区。国网新源和南方电网分别有3.8GW和2.4GW项目投运，此外三峡集团在浙江的长龙山抽水蓄能电站也已于6月并网投运。</p>
<p>3.1.3国内外抽蓄电价与商业模式逐渐明晰</p>
<p>国外抽水蓄能电站的盈利模式可以分为三种，即一体化内部结算、独立参与市场与租赁模式。在垂直一体化的电力体制下，抽水蓄能电站由一体化的电力公司所有并统一运营；在建立了竞争性批发电力市场地区，抽水蓄能电站在产权上已独立于电网，其电力产品通过相应的市场销售。通过参与现货市场、峰谷套利方式实现的收入约占其全部收入的30%<del>40%，参与辅助服务获得的收入占60%</del>70%；租赁模式下抽水蓄能电站所有权亦独立于电网，拥有抽水蓄能电站产权的企业将电站租赁给电网运营管理，抽水蓄能电站的盈利来源为运营权的让渡价值。</p>
<p>目前，我国抽水蓄能价格机制主要包括三种模式，即单一电量电价、单一容量电价、两部制电价。1）单一电量电价多用于2004年以前投产的抽蓄电站，国家发展改革委核定抽蓄电站的上网电价和抽水电价；2）单一容量电价是应用最普遍的机制，其计算出来的电费被称为“基本电费”，是因占用了用电容量而交纳的电费，电费数额是按变压器的容量（或运行中的最大需量）来计算的，由国家价格主管部门按照补偿固定成本和合理收益的原则，核定抽蓄电站的年租赁费，不再核定电价，租赁费一般由电网企业承担50%，发电企业和用户各承担25%；3）两部制电价在2014年被提出，把电价分为容量电价和电量电价两部分。容量电价主要体现抽蓄电站提供调峰、调频、调相和黑启动等辅助服务价值，电量电价反应的是企业的变动成本。</p>
<p>3.1.4产业链集中度较高，龙头优势竞争优势显著</p>
<p>基本形成全产业链发展体系和专业化发展模式。通过大型抽水蓄能电站建设实践，基本形成涵盖标准制定、规划设计、工程建设、装备制造、运营维护的全产业链发展体系和专业化发展模式。上游主要为设备供应，包括水轮机、水泵、压缩空气系统、监控系统、发电机、主变压器、调速系统等；中游主要为建设工程，包括电站建设与电站运营两个部分；下游主要服务于工业、商业以及居民用电，主要起到调峰、填谷、调频、调相、储能、事故备用等功能。</p>
<p>2021年核准抽水蓄能电站平均单位千瓦静态总投资5367元/kW，抽水蓄能电站投资中机电设备及安装工程占比最高，建筑工程投资占比次之。抽水蓄能电站建设条件个体差异明显，造价水平与工程建设条件和装机规模密切相关。一般情况下，抽水蓄能电站单位造价随装机规模增加而显著降低。而抽水蓄能电站的投资占比前三位为机电设备及安装工程（26%）、建筑工程（25%）、建设期利息（14%）。</p>
<p>1）上游水轮发电机组：包括水轮机和发电机两个关键装置，主要厂商包括哈尔滨电气、东方电气和浙富控股。水轮机是利用水流流动带动水轮转动的装置，将水流的机械能转化为叶轮机械能；发电机是将水轮的机械能转化为电能的装置。目前国内主要生产水轮发电机的厂商包括哈尔滨电气、东方电气、浙富控股这三家，2021年三家的水轮发电机组产量分别为9.55GW、8.10GW、0.81GW。</p>
<p>2）中游规划建设：国内抽水蓄能建设主要采用EPC模式。中国电建是国内规模最大、影响力最强水利水电建设企业，承担了国内抽水蓄能电站大部分规划、勘测设计、施工建造、设备安装、工程监理等工作，在抽水蓄能规划设计、抽水蓄能建设市占率分别在90%、80%左右。2021年，中国电建抽水蓄能业务新签合同202.40亿元，同比增长342.90%。</p>
<p>3）下游投资运营：主要企业有国网新源、南网双调，国网新源占据领先地位。截至2021年底，国网新源公司在运和在建抽水蓄能规模分别为2351、4578万kW，占比分别约64.6%和74.4%，在抽水蓄能开发建设及运营市场中占据绝对领导地位。中国抽水蓄能的建设企业主要有中国电建、中国能建所属工程局。此外，中国安能、中国铁建等企业也参与抽水蓄能电站部分地下工程建设。</p>
<p>3.2锂电池储能：在新型储能中发展领先</p>
<p>完整的电化学储能系统主要由电池组、电池管理系统（BMS）、能量管理系统（EMS）、储能变流器（PCS）以及其他电气设备构成。电池组是储能系统最主要的构成部分，负责能量存储；电池管理系统主要负责电池的监测、评估、保护以及均衡等；能量管理系统负责数据采集、网络监控和能量调度等；储能变流器可以控制储能电池组的充电和放电过程，进行交直流的变换。储能产业链上游主要包括电池、电池管理系统、能量管理系统以及储能变流器供应商；中游为系统集成商和安装商，下游主要为终端用户等。根据前瞻产业研究院，电池是电化学储能系统中最重要的部分，占储能系统成本的60%，PCS构成20%，EMS构成10%，BMS构成5%，其他配件构成5%。</p>
<p>3.2.1锂离子电池：上下游产业链较为成熟</p>
<p>在众多电化学储能技术路线中，锂离子电池已经建立了较为健全的产业链。如下图所示，锂电产业链上游主要为矿产及加工品，包括锂、镍、钴等；中游主要为锂电池制造、电池系统集成组装等；下游的应用领域主要为储能电池、动力电池、消费电池等。</p>
<p>离子电池主要依靠锂离子在正极和负极之间移动来工作，主要材料包括正极材料、负极材料、电解液和隔膜四大部分。锂离子电池主要依靠锂离子在正极和负极之间移动来工作。在充放电过程中，锂离子在两个电极之间往返嵌入和脱嵌：充电时，锂离子从正极脱嵌，经过电解质嵌入负极，负极处于富锂状态；放电时则相反。锂电池主要材料包括正极材料、负极材料、电解液和隔膜四大部分，正极材料决定电池的容量、寿命等多方面核心性能，一般占锂电池总成本高达40%左右，是锂电池产业链中最重要的环节。</p>
<p>储能电芯封装制造与动力电池类似，主要为方形、圆柱和软包三种形式。电池封装工艺的发展趋势本质是在保证安全性的前提下提升电池能量密度上限。即利用电芯外壳的支撑作用，减少模组结构件使用，提升电池包的能量密度。软包外壳的支撑较弱，因此中期来看方形和圆柱电池更能适应结构上的创新。比亚迪的刀片电池既是将电芯设计成扁片长条形状，在安全上保证电芯有足够大的散热面积，同时提高电池包的空间利用率，从而提高能量密度。目前已经应用于储能系统（BYDCube）。</p>
<p>3.2.2变流器：决定输出电能的质量和特征</p>
<p>储能变流器是连接电源、电池与电网的核心环节，通常由DC/AC双向变流器、控制单元等构成。它的主要作用在于实现电网与储能电池能量的双向转换控制。在并网条件下，根据能量管理系统的指令，储能变流器对电池进行充放电以平滑风电、光伏等新能源出力；在离网条件下为负荷提供电压和频率支持。储能变流器通常由DC/AC双向变流器、控制单元等构成，其中，控制单元接收控制指令，根据功率指令的符号及大小控制变流器对电池进行充放电，实现有功功率和无功功率调节。储能变流器通过接口与电池管理系统连接以获取电池组状态信息，实现对电池的保护性充放电，确保电池运行安全。储能变流器决定着输出电能的质量和特征，从而很大程度上影响着电池的寿命。储能变流器主要有并网和离网两种工作模式。在并网模式下，储能变流器可实现电池组与电网之间的双向能量转换。在负荷低谷期，储能变流器可根据电网调度或本地控制的要求，把电网的交流电整流成直流电，给电池组充电；在负荷高峰期，储能变流器可把电池组中的直流电逆变成交流电，反送到电网中。同时，在电能质量不好时，储能变流器还可吸收或提供有功功率，提供无功补偿等。在离网模式下，储能变流器可根据实际需要与主电网脱开，给本地的部分负荷提供满足电网电能质量要求的电能。</p>
<p>3.2.3BMS、EMS与温控：锂电储能系统的重要组成</p>
<p>BMS：由主控单元、从控单元、信息采集单元、信息传输及显示单元等组成，主要作用在于对电池状态进行检测。电池管理系统（BatteryManagementSystem，BMS）基本工作原理为微控制单元采集传感器提供的电流、电压、温度等电池工作参数，分析电池的工作情况，估算其剩余电量决定是否启动保护电路或进行均衡。典型的BMS由硬件电路、底层软件和应用层软件构成。其中，硬件电路是BMS的基础，包括元器件和印制电路板等；软件系统是BMS实现功能的主体和主要附加值所在。BMS行业目前专注于储能BMS开发的厂商比较少，专业BMS供应商（如电装、亿能电子、妙益科技等）、动力电池BMS供应商（如三星、LG、宁德时代、特斯拉、上汽集团、长安汽车等）等均可提供储能BMS产品。</p>
<p>EMS：运用自动化、信息化等专业技术，对储能系统能源供应、存储、输送等环节实施的动态监控和数字化管理，从而实现监控、预测、平衡、优化等功能。能量管理系统（EnergyManagementSystem，EMS）主要包括信息采集终端、通信管理机、系统平台硬件以及系统软件等部分。通过信息采集终端、通信管理机、数据采集器等硬件设备，实现信息信号的采集、交换和传递。根据PowerLab，硬件成本在能源管理系统总成本的占比一般不超过50%，信息采集终端和通信管理机等硬件设备国内产业链已相当成熟，在系统软件方面，由于EMS公司需了解电网的运行特点和核心诉求，因此国内储能EMS相关公司主要为国网系公司，如南瑞继保、许继集团、国电南瑞、平高电气等，此外还有四方股份、宝光股份等。</p>
<p>储能温控系统冷却：主要包括风冷、液冷、热管冷却、相变冷却四种方式。相较而言，热管冷却和相变冷却的设计更加复杂，成本更高，当前尚未在储能温控方案中实际应用。目前电化学储能温控以风冷和液冷为主。1）风冷：以空气为冷却介质，利用对流换热降低电池温度，具备方案成熟、结构简单、易维护、成本低等优点，是当前储能温控主力方案。但由于空气的比热容低，导热系数低，风冷一般应用于功率密度较低场景，如通信基站、小型地面电站等。2）液冷：主要以水、乙二醇水溶液等液体为冷却介质，通过对流将电池产生的热量带走，结构较为复杂，安全等级要求高，所以液冷成本明显高于风冷，但其优点明显，散热效率高且均匀、能耗较低、占地面积小、系统适应性。随着储能系统规模和能量密度的逐渐提高，液冷能量密度高、占地面积小、能耗低的综合优势会进一步凸显。3）热管冷却：利用热管的热超导性能，依靠封闭管壳内工质相变来实现换热，有冷端风冷和冷端液冷两种。冷端风冷是通过管内冷空气冷却管外热空气，冷端液冷是管内冷却水冷却管外热空气。热管具有高导热、等温、热流方向可逆、热流密度可变、恒温等优点。目前主要应用于核电工程、太阳能集热、航天工程等领域，在大容量电池系统中的应用仍处于实验室阶段。4）相变冷：却是用相变材料将电池包裹或者把相变材料压制成板状夹在单体电池之间，再利用相变材料发生相变吸收热量。它最大缺点是导热系数低、导热性能差，储热和散热速度都很低，无法用于电池的高产热工况。在相变材料中添加其他导热性能好的材料，可以显著的提高散热效率和散热速度。</p>
<p>3.3钠离子电池：安全、成本较低，原材料丰富</p>
<p>3.3.1工作原理类似锂电池，材料相差较大</p>
<p>钠离子电池本质是在充放电过程中由钠离子在正负极间嵌入脱出实现电荷转移，与锂离子电池的工作原理类似。钠离子电池充电时，Na+从正极脱出，经电解液穿过隔膜嵌入负极，使正极处于高电势的贫钠态，负极处于低电势的富钠态。放电过程与之相反，Na+从负极脱出，经由电解液穿过隔膜嵌入正极材料中，使正极恢复到富钠态。为保持电荷的平衡，充放电过程中有相同数量的电子经外电路传递，与Na+一起在正负极间迁移，使正负极分别发生氧化和还原反应。</p>
<p>与锂离子电池类似，钠离子电池同样拥有正极、负极、隔膜和电解液四大部分，但材料相差较大，仅有隔膜无明显变化。目前钠离子电池处于示范应用阶段。1）正极：按正极材料分，钠离子电池主要有层状氧化物、隧道型氧化物、普鲁士蓝类化合物和聚阴离子型化合物体系，目前中科海钠采用层状金属氧化物作为正极，宁德时代采用普鲁士白（普鲁士蓝的一种）和层状氧化物。</p>
<p>负极：一般具有嵌入钠离子能力高，体积变形小、扩散通道好、化学稳定性高等特点。锂电池主要使用石墨作为负极材料，而钠离子电池负极可以选取过渡金属氧化物、合金材料、无定型碳等。隔膜：钠离子电池与锂离子电池可以通用主流隔膜类型。电解液：主要为六氟磷酸钠，比锂电池电解液所使用的六氟磷酸锂价格更低；同锂离子电池一样，钠离子电池也可兼容固态电解质。集流体：是汇集电流的结构或零件，也是钠离子电池成本低于锂离子电池的主要原因之一。钠离子电池的正负极集流体可使用铝箔。对应锂离子集流体，成本可下降7%-9%。</p>
<p>3.3.2能量密度较低，但安全性更高，降本空间大</p>
<p>技术性能方面，钠离子电池能量密度和循环寿命均次于锂离子电池。钠离子电池的能量密度在100-150Wh/kg，与磷酸铁锂电池的能量密度仍存在一定差距。其次，目前钠离子电池循环次数普遍在2000次左右，较锂离子电池低30%左右，主要是由于钠离子半径较锂离子大，反应过程中嵌入脱出难度大。储能时长方面与锂离子基本相似，主要应用于4小时以内的储能系统。钠离子电池材料成本较磷酸铁锂可下降30%-40%。根据中科海纳，若钠离子电池选用NaCuFeMnO/软碳体系，锂离子电池选用磷酸铁锂/石墨体系，则钠离子电池材料成本较磷酸铁锂可下降30%-40%，单体电池成本发展期约为0.3-0.5元/Wh。</p>
<p>3.3.3积极关注产业链上下游公司</p>
<p>能量密度提升是锂离子电池的创新趋势之一。正极材料中目前具有潜在商业化价值的有普鲁士白和层状氧化物两类材料，克容量已经达到了160mAh/g，与现有的锂离子电池正极材料接近。负极材料中，硬碳材料是最有前景的钠离子电池负极材料。硬碳材料具有丰富的碳源、低成本、且无毒环保，克容量（350mAh/g）已基本与石墨材料（约360mAh/g）接近。产业链建设方面，三重需求的叠加带动下，钠离子电池产业化进程有望加速以降低成本。钠离子龙头企业表示将在2023年基本形成产业链。未来钠离子电池产业链成熟后，可与锂离子电池形成互补。除了应用于储能领域，钠离子电池还可以应用于电动两轮车和低端电动车。因此未来对于钠离子电池的市场需求不仅仅由储能带动。在三重需求的叠加带动下，可能加速钠离子电池的产业化进程。</p>
<p>3.4全钒液流电池：长时储能领域优势显著</p>
<p>3.4.1利用钒离子化合价变化实现充放电</p>
<p>全钒液流电池目前是产业链建设和技术成熟度最高的液流电池技术。液流电池是一种活性物质存在于液态电解质中的电池技术，电解液在电堆外部，在循环泵的推动下流经电堆，实现化学能与电能的转换。根据正负极电解质溶液中活性电对种类的不同，液流电池可分为铁铬液流电池、锌溴液流电池、全铁液流电池、全钒液流电池等。其中全钒液流电池正负极氧化还原电对的电化学反应动力学良好，在无外加催化剂的情况下即可达到较高的功率密度。而且该电池在运行过程中无明显析氢、析氧副反应，具有优良的可靠性。因此，全钒液流电池技术得到了长足的发展，已进入大规模商业示范运行和市场开拓阶段。</p>
<p>3.4.2安全、可循环，适用于长时储能</p>
<p>优势：全钒液流电池具有安全性高、储能规模大、充放电循环寿命长、电解液可循环利用、生命周期中性价比高、环境友好等优点。1）全钒液流电池安全性高，运行可靠，电解液可重复利用，对环境友好。全钒液流电池电解液为钒离子的硫酸水溶液，只要控制充放电截至电压并保持存放空间通风良好便不存在爆炸风险。电池中正、负极电解液储能活性物质同为钒离子，不会发生储能容量的不可逆衰减，常年运行造成的容量衰减可以通过在线或离线再生反复循环利用。同时当全钒液流电池废弃时，电堆和系统的主要原材料为碳材料、塑料和金属材料，环境负荷小。大连融科储能技术发展有限公司2012年12月在辽宁省法库国电龙源卧牛石50MW风电场建设的5MW/10MWh储能电站运行了近9年时，储能容量有所衰减，经过在线恢复后，储能容量恢复到了10MWh。2）输出功率和储能容量相互独立，适用于大规模、大容量、长时储能。全钒液流电池储能系统的输出功率由电堆的大小和数量决定，通常在数百瓦至数百兆瓦；储能容量由电解液的体积决定，通常在在数百千瓦时至数百兆瓦时。增大电堆电极面积和电堆数量就可增加输出功率；增加电解液的体积可以增加储能容量。适合于需要大规模、大容量、长时间储能装备的应用场合。</p>
<p>全钒液流电池储能时长越长，单位容量价格越便宜，性价比高，是长时储能技术的最佳选择。根据张华民《全钒液流电池的技术进展、不同储能时长系统的价格分析及展望》，除电解液外的电池储能价格为1500元/kWh。当储能时长为1h系统的市场价格为6000元/kW。当储能时长为1h，不包括电解液的储能系统的价格为6000元/kW，加上电解液的价格1500元/kWh，储能系统的总价格是7500元/kWh。当储能时长为4h的以后，不包括电解液的储能系统价格每小时分摊1500元，储能系统的总价格就是3000元/kWh。同样地，如果储能时长分别为8h和10h储能系统的总价格2250元/kWh和2100元/kWh。可以明显看出，由于全钒液流电池的输出功率和储能容量可以相互独立，储能时长越长，价格越便宜。</p>
<p>3）能量转换效率高，启动速度快，无相变化，充放电状态切换响应迅速。全钒液流电池在室温条件下运行，电解质溶液在电解液储罐和电堆之间循环流动，在充、放电过程中没有相变化。所以，充放电状态切换响应迅速，既可用于调幅调频、可再生能源并网，又可用于辅助服务、电网调峰及紧急备用储能电站。4）全钒液流电池储能系统采用模块化设计，易于系统集成和规模放大。全钒液流电池电堆是由多个单电池按压滤机方式叠合而成的。目前，产业化的单体电堆的额定输出功率一般在30～80kW。储能系统通常是由多个单元储能系统模块组成，单元储能系统模块额定输出功率一般在500kW左右。与其他电池相比，全钒液流电池电堆和电池单元储能系统模块额定输出功率大，均匀性好，易于集成和规模放大。</p>
<p>5）具有强的过载能力和深放电能力。储能系统运行时，电解质溶液活性物质扩散的影响较小且电极反应活性高，活化极化较小。电池储能系统具有很好的过载能力，充放电没有记忆效应，具有很好的深放电能力。</p>
<p>3.4.3众多企业深入布局，商业化快速推进</p>
<p>全钒液流电池商业化进程快速推进，行业进入发展快车道。2022年9月20日，国内首个GWh级全钒液流储能电站——新疆察布查尔县250MW/1000MWh全钒液流电池储能配套1GW市场化光伏项目开工，计划2023年年底前并网。同月，全钒液流电池储能系统也迎来首个GWh级别集采。中核汇能日前发布今年目前规模最大的一次储能系统集采，总采购规模5.5GWh，其中包含1GWh全钒液流电池储能系统。10月30日，大连百兆级液流电池储能调峰电站并网发电，该电站是国家能源局批准建设的首个国家级大型化学储能示范项目，应用全钒液流电池储能技术。2022年3月，国家发改委和国家能源局联合发布《“十四五”新型储能发展实施方案》明确提出，将百兆瓦级液流电池技术纳入“十四五”新型储能核心技术装备攻关重点方向之一。</p>
<p>钒电解液以及构成电堆的离子交换膜、电极、双极板等环节是技术开发和完善产业链布局的重点领域。全钒液流电池产业链上游原材料有五氧化二钒、硫酸等电解液的原材料，双极板、离子交换膜、电极等；中游核心部件有电解液、电堆、储液罐、循环模块和控制系统；下游主要应用于配置可再生能源、工商业储能和电力辅助系统等。全钒液流电池产业链中构成电解液输送系统的管路、循环泵、控制阀件、传感器、换热器等辅助部件和设备在化工领域较为常见，电池管理控制系统所需的硬件支持是电力电子行业基本元件，产业链也比较成熟。电池特有的关键材料包括钒电解液以及构成电堆的离子交换膜、电极、双极板等，这些环节也是技术开发和完善产业链布局的重点领域。</p>
<p>1.上游原材料：核心资源为钒，我国储量全球第一</p>
<p>全钒液流电池的上游原料环节重点资源为钒，中国钒矿的储量和产量均居世界首位。美国地质调查局统计数据显示，截至2022年全球钒资源约6300万吨，已探明钒资源主要分布在中国、俄罗斯、南非和澳大利亚，其中我国占比高达33%。从产量来看，中国钒矿产量同样位居世界前列，据美国地质调查局显示，2021年全球钒矿产量11万吨，其中中国钒矿资源产量7.3万吨，2021年中国钒矿产量占全球最高，达到66.36%。</p>
<p>从企业布局来看，国内钒资源产能相对集中，攀钢钒钛、河钢股份等在钒钛资源综合使用和钒产品生产方面处于世界领先地位。从产能情况来看，攀钢钒钛目前具备超过4万吨钒制品产能（以五氧化二钒计），2021年公司累计完成钒制品（以五氧化二钒计）4.33万吨，同比增长1.93%；河钢股份2021年度钒制品产能为2.2万吨左右，主要产品为五氧化二钒、氧化钒、钒铁、氮化钒铁、钒铝合金等，两者合计占据约一半的国内市场份额。此外建龙、成渝钒钛、四川德胜等也具备万吨以上的产能，国内钒资源产能相对集中。</p>
<p>2.电解液与电堆：全钒液流电池核心部件</p>
<p>全钒液流电池核心部件主要由电解液和电堆构成，后者受上游钒资源的价格波动影响。电解液主要原材料为五氧化二钒以及硫酸这部分成本约占电池成本的40%，上游钒资源的价格波动影响全钒液流电池的成本。电堆主要由离子交换膜、电极、双极板等构成，目前离子交换膜很大程度上依赖进口，成本偏高，导致同规模下电池总成本较高，电堆成本约占电池总成本37%。</p>
<p>全钒液流电池产业链成熟，国内外均有企业深耕全钒液流电池各关键部件。电解液供应国内主要由大连博融新材料提供，国外企业有美国史查克和德国电冶金公司；涉及离子交换膜的主要企业有国内的苏州科润新材料、东岳集团以及美国杜邦、德国Fumatach、美国戈尔等；电极制造商有国内旭能翰源、日本东丽、日本东邦、美国郝克利等；双极板主要为国内中科能源材料与旭能翰源；全钒液流整机制造企业主要有大连融科储能技术发展有限公司、北京普能世纪科技有限公司以及上海电气储能科技、日本住友电工、美国UniEnergyTechnologies等。</p>
<p>3.5铁铬液流电池：原材料丰富，前景广阔</p>
<p>3.5.1铁铬电子对价态变化实现能量转换</p>
<p>铁铬液流电池是产业上最早出现的液流电池技术，利用铁铬电对的价态变化实现能量转换。铁铬电池分别采用Fe3+/Fe2+电对和Cr3+/Cr2+作为正极和负极的活性物质，通过活性金属的价态变化实现电能与化学能相互转换与能量储存。在铁铬液流电池中，活性物质储存于电解液中，具有流动性，可以实现电化学反应场所（电极）与储能活性物质在空间上的分离，电池功率与容量设计相对独立，适合大规模蓄电储能需求。</p>
<p>铁铬电池系统主要由功率单元（单电池、电堆或电堆模块）、储能单元（电解液及储罐）、电解液输送单元（管路、阀门、泵、换热器等）电池管理系统等组成。作为铁铬电池的核心部件，功率单元在一定程度上决定了系统的能量转换效率和建设成本。根据应用领域不同，功率单元可以分为单电池、电堆和大功率模块等。其中，铁铬电池单电池是电堆及系统的基本单元，单电池主要通过离子传导膜将正负极电解液进行分离，两侧分别由电极、液流框、集流体等部件组成的正负极半电池，然后通过夹板及紧固件进行压紧而成；电堆又由多个单－电池通过叠加形式进行紧固而成，每组单电池之间通过双极板进行连接，具有多个电解液循环管道和统一电流输出的组合体，一定数量的电堆再组合电解液循环系统、电气系统、能量转换系统及辅助设备构成大功率模块的基本组成单元。</p>
<p>3.5.2铬铁矿丰富叠加电化学技术优势，大储前景广阔</p>
<p>1.优势：铁铬电池较其他电化学电池具有明显的技术优势，在大规模储能技术应用前景广阔。根据铁铬电池的工作原理及结构特点，其高安全、高灵活性和长寿命的技术特点使其在可再生能源发电储能装置、电网调峰调频、电网削峰填谷、不间断电源或应急电源等领域拥有很广阔的应用前景。</p>
<p>1）电对元素特性叠加水性电解质溶液，铁铬电池系统安全性较高。铁-铬液流电池的电解质溶液为含有Fe3+/Fe2+电对和Cr3+/Cr2+电对的水性溶液，不会发生燃烧或爆炸的风险。且电解质溶液储存在两个分离的储液罐中，电池堆与储液罐分离，在常温常压下运行，安全性高。即使在运行过程中，隔膜发生破裂，正负极活性物质发生互混，也不会引起燃烧和爆炸。</p>
<p>2）适配储能循环寿命长，模块/定制化设计灵活稳定。铁-铬液流电池在充放电过程中，电极材料只提供反应界面，本身不参与反应，而且电极反应均为液相反应，无相态变化，不会发生类似同态电极的脱落成片结构坍塌等问题，可以长期保持稳定状态，理论充放电循坏次数可以达到10000次，与全钒液流电池持平，寿命远远高于钠硫电池、锂离子电池和铅酸电池。另外铁铬液流电池的额定功率和额定容量是独立的，功率大小取决于电池堆，容量大小取决于电解质溶液，可以根据用户需求进行功率和容量的量身定制。而且其电能储存在电解质溶液内，而电解质溶液存储在储罐里，不存在自放电现象，尤其适用于做备用电源等。因而方便进行模块化设计，通过电堆组合维持系统的性能稳定。</p>
<p>3）原材料资源丰富，环境适应性强，叠加回收优势成本较低。铁-铬液流电池的电解质溶液原材料资源丰富且成本较低，铬铁矿全球探明储量达到了5.1亿吨，较钒/锂储量优势明显，不会出现短期内资源制约发展的情况。另外电池在使用过程中，金属铁和铬离子只发生价态变化，并不会被消耗，可以永久性循环使用、节约资源，另外铁铬电池电堆及系统废弃时，碳材料和树脂材料均可以作为燃料使用，部分金属则可以继续使用，因此铁铬电池回收简单、残余价值高、环境负荷小，因而是可持续发展的储能技术。相较全钒液流电池，铁铬电池的成本占比最大的部分是膜、PCS以及铁铬电解液，铁铬液流电池的膜占比是全钒液流电池的两倍，但膜的成本较低，另外Fe3+的低氧化特性也可以使用低廉的碳氢化合物膜，也可以进一步降低铁铬液流电池的成本。此外其电解液占比仅为9%，所以其经济实惠的优势明显展露出来。</p>
<p>2.劣势：铁铬电池负极活性弱，容易受制于Cr离子金属特性而产生析氢问题。铁-铬液流电池负极Cr2+/Cr3+电对相较于正极Fe2+/Fe3+电对在电极上的反应活性较差，是影响电池性能的主要原因之一。且Cr3+离子电化学反应活性较差、易老化、易发生析氢反应、容量衰减快、能量效率低等原因仍然限制着铁铬液流电池商业化发展。另外反应过程中电池正负极电解液一定程度上会形成交叉感染，所以需要配备循环泵、电控设备等辅助设备，增加了系统的复杂性。</p>
<p>3.5.3产业链上下游公司有望受益</p>
<p>铁铬铁铬液流电池的整个系统由能量单元（电解液及储罐）、功率单元（单电池、电堆或电堆模块）、输运系统（管路、阀门、泵、换热器等）、控制系统、附加设施等部分组成，其中能量单元和功率单元是核心模块。铁铬液流电池的正负极电解液为含有铁离子和铬离子的溶液，是其真正的储能介质，能量单元的核心。产业链条为上游铬矿经过冶炼生成铬盐，中游铬盐加工进而用于生产铁铬液流电池，下游铬中间品多范围跨行业应用于钢铁、电池、皮革等行业。</p>
<p>铬产业链条行业覆盖范围广，跨度较大。铬铁矿按工业用途划分为冶金级、化工级、耐火级和铸石级，其中冶金级铬铁矿全球产量占比超过95%。因耐磨、耐高温、耐腐蚀及其亲铁性的性质，冶金级铬铁矿被冶炼成铬铁合金被添加到不锈钢、特钢等钢材中。不锈钢是目前铬元素最大的消费下游，因含有镍铬而具有不锈、耐蚀性主要特性。铬铁按不同含碳量分为高碳铬铁（含碳为4<del>8%）、中碳铬铁（含碳为0.5</del>4%）、低碳铬铁（含碳0.15~0.50%）、微碳铬铁（含碳为0.06%）、超微碳铬铁（含碳小于0.03%）。中、低、微碳铬铁由高碳铬铁添加硅石冶炼成，因其含碳量少也被用广泛于加工特殊钢材。另外化工级铬矿还可以加工成氧化铬绿、三氧化铬、红矾钠等铬盐，用于颜料、涂料、陶瓷、饲料、电镀、合金、皮革等众多行业等。铬铁电解法和铬盐碳还原法可提纯至金属铬。随铁铬液流电池的商业化，未来电池领域或将成为新的消费增长点。上游产业链：全球铬铁矿资源丰富，铬铁矿资源总量超过120亿吨，主要分布于南非、津巴布韦、哈萨克斯坦、巴基斯坦、土耳其和印度等国家，已探明总铬铁矿储量约75亿吨。其中南非资源量最大，约占世界资源总量的一半，是全球最大的铬资源出口国。南非、津巴布韦、哈萨克斯坦铬铁矿资源量约占世界铬铁矿探明资源总量的95%。其中津巴布韦虽铬矿储量丰富，但开发程度较低，于2021年宣布禁矿。哈萨克斯坦铬矿多用于本国生产，出口量较低。</p>
<p>铬资源缺少，随着高碳铬铁产量爬坡，头部矿业将享受超额收益。随着中国不锈钢的需求不断起量，铬矿需求将不断上升，国际上铬铁价格将面临长期压力，再加上宏观政策上对铬铁矿加工贸易的限制，因此会长期出现国内铬铁行业发展力不足，对国外矿石依存度过高，上游受制于矿石供应商，所以头部矿业将享受市场增长赋予的超额收益。</p>
<p>下游储能：国内对铁/铬液流电池的研究始于20世纪90年代，早期以跟踪研究为主。中科院大连化学物理研究所的衣宝廉院士团队于1992年曾经推出过270W的小型铁/铬液流电池电堆。中科院大连化物所和沈阳的金属所的研究中，负极析氢与电解液离子互混问题长期难以解决。2019年11月，中国国家电投公司所属的中央研究院和上海发电设备成套设计研究院联合项目团队研发的国内首个31.25kW铁/铬液流电池电堆“容和一号”成功下线，经测试，性能指标满足设计参数要求。首批次共8台电堆，应用于张家口战石沟光伏电站250kW/1.5MWh铁-铬液流电池储能示范项目，并已于2020年12月投入试运行，成为国内首座百千瓦级铁-铬液流电池储能示范电站。2022年1月，“容和一号”量产线投产，单条产线可年产5000台“容和一号”电堆，标志着铁/铬液流电池储能技术产业化向前迈进了一大步，为液流电池储能技术带来了新的增长点。与此同时，国家电投还在内蒙古霍林河启动了全球首个兆瓦级铁/铬液流电池储能示范项目建设，预计将在22年年底投产，届时将再度刷新全球铁/铬液流电池储能系统的最大实证容量纪录。</p>
<p>发展趋势：铁铬液流电池材料的改进是未来实现产业化大规模推广的关键。铁铬当前负极铬离子的活性还有待提高，析氢副反应影响较大，离子传导膜在高温运行条件下的溶胀依然较大，循环稳定性较差等。未来依然需要适配储能进行技术创新和突破：1）电池材料改进：优化离子传导膜的离子选择性以提高库仑效率，选择合适的添加剂降低析氢副反应的影响，提高活性物质的电化学反应以及电极材料的活性以降低电池的电化学极化，另外提高双极板的电导率以及减小离子传导膜、电极、双极板的厚度，从而降低电池的欧姆极化。2）电池结构设计优化：降低电解液的流动阻力，提高电解液分布均匀性以及过电势分布均匀性，以降低电池的浓差极化，缩短电子、质子的传递路径，提高传质效率。3）降低成本：铁铬液流电池对膜的要求较低，非氟磺酸膜实现突破后可以替代价格昂贵的全氟磺酸膜，将进一步降低电池成本，进而推动铁铬液流电池的产业化应用。</p>
<p>3.6重力储能：商业化早期，发展潜力巨大</p>
<p>3.6.1重力储能利用重力与高差实现电力充放</p>
<p>重力储能作为物理储能，利用重力与高差实现电力充放。实现新重力储能是一种机械式储能，储能介质分为水和固体物质，基于高度落差对储能介质进行升降来实现储能系统的充放电过程。水介质型重力储能系统可以借助密封良好的管道、竖井等结构，其选址的灵活性和储能容量受到地形和水源限制。固体重物型重力储能主要借助山体、地下竖井、人工结构物等结构，重物一般选择密度较高的物质，如金属、水泥、砂石等以实现较高的能量密度。根据重力储能的储能介质和落差实现路径的不同，目前将重力储能分为以下4类：新型抽水储能、基于构筑物高度差的重力储能、基于山体落差的重力储能和基于地下竖井的重力储能。</p>
<p>3.6.2EV公司推出EVx系统，在中国布局首个商业化案例</p>
<p>EnergyVault公司提出混凝土砌块储能，开拓重力储能新方向。在基于构筑物高度差的重力储能技术路径中，EnergyVault公司提出以混凝土砌块储能塔为基础的重力储能发电方案，其原理是电力充裕时，起重机将储能模组EVx从地上吊起，像积木一样往高处堆放，当模组堆叠在高处时，系统完全“充电”，每个储能模组代表约1MW的势能；当需要电力时，系统会协调储能模组EVx排出。2020年，EV公司在初期储电吊塔EV1产品的基础上研发了可以进行机组模块拼装的EVRC储能产品，并在瑞士当地建设了一些项目示范中心，与当地电网嫁接进行项目试验。2021年推出了EVx平台，其储能模组EVx和弹性中心EVRC储能容量在10MWh以上，可满足电网2~12小时的弹性储能。</p>
<p>3.6.3中国天楹：如东项目稳步推进，已签订多份战略合作协议</p>
<p>中国天楹与EnergyVault公司实现深度绑定，积极拓展重力储能业务。2022年1月30日，中国天楹旗下控股子公司AtlasRenewableLLC与重力储能技术开发商EnergyVault公司签署了《技能答应运用协议》，EV公司授权Atlas在中国区（含香港和澳门）独家运用答应技能建造和运营重力储能体系设备。中国首个应用EV公司技术的100MWh重力储能项目将在江苏如东县落地。今年7月，全球首个25MW/100MWh重力储能示范项目已开始灌注桩基施工进入实际动工阶段，项目预计将于2023年年初投入商业运营。今年以来中国天楹先后签署多个重力储能战略合作协议。今年以来，中国天楹与贵州毕节人民政府、内蒙通辽市人民政府、湖北省宜昌市人民政府、中国投资协会、三峡建工、中建七局、国家电投、中电建、国网综能等单位达成战略合作，合作内容均有涉及重力储能。毕节市“风光水储”一体化能源基地，将建设不低于40万千瓦时的重力储能项目；通辽千万千瓦级风光储氢氨一体化零碳产业园，重力储能规模2GWh；与国家电投浙江公司协议中，在长三角地区获取不低于1GWh重力储能项目；与中电建水电公司协议中，力争在“十四五”期间在全国共同开发投资不少于2GW的重力储能电站。</p>
<p>3.7压缩空气储能：技术进步快，商业化快速推进</p>
<p>3.7.1实现能量的存储及跨时间、空间转移和利用</p>
<p>压缩空气储能系统采用压缩空气作为储能载体，是一种以机械设备实现能量存储及跨时间、空间转移和利用的物理储能技术。压缩空气储能系统主要分为储能和释能两个工作过程：储能时电动机驱动压缩机将环境空气压缩至高压状态并存入储气装置，电能在该过程中转化为压缩空气的内能和压力势能；释能时，储气装置中存储的压缩空气进入空气透平膨胀机中膨胀做功发电，压缩空气中蕴含的内能和压力势能在该过程中重新转化为电能。作为一种极具发展潜力的物理储能技术，压缩空气储能可广泛应用于电源侧、电网侧和用户侧。</p>
<p>3.7.2压缩空气储能技术发展潜力巨大</p>
<p>传统压缩空气储能采用天然气补燃方式，实际运行效率较低。压缩空气储能技术因具有规模大、灵活性强等特点，被认为具有较大的发展潜力和应用前景。目前投入商业应用的大型压缩空气储能电站仅有德国的Huntorf电站和美国的McIntosh电站，两者均采用传统的天然气补燃方式，且实际运行效率较低，可见压缩空气储能技术的研究与发展存在巨大空间。传统型的压缩空气储能技术是以燃气发电为基础展开的，以德国Huntorf和美国的McIntosh电站为例，主要特征是在电能输岀时从洞穴中排岀的高压空气先在燃烧器内与天然气实现掺混燃烧，温度提升后再进入膨胀机做功。</p>
<p>3.7.3多个项目落地，商业化进程快速推进</p>
<p>国内多个压缩空气储能项目顺利落地，商业化进程快速推进。我国压缩空气储能技术研究起步较晚，2005年开始发展，但进步迅速，2016年建立示范工程项目，技术已进入全球先进水平。2021年9月23日，山东肥城压缩空气储能调峰电站项目正式实现并网发电，这标志着国际首个盐穴先进压缩空气储能电站已进入正式商业运行状态。2022年5月26日，金坛盐穴压缩空气储能国家试验示范项目举行投产仪式，标志着世界首座非补燃压缩空气储能电站正式投入商业运行。</p>
<p>3.7.4国内相关产业链基本形成</p>
<p>我国通过对压缩空气储能项目的不断示范运行，已经构建了产业链的雏形，产业链上企业已有20余家。1）盐穴资源：鲁银投资、苏盐井神、雪天盐业等。2）压缩、换热及透平机组：陕鼓动力、金通灵、东方电气等。3）储气装置：压力容器企业。4）系统集成于并网管理：中科院工程热物理研究所、科远智慧、中储国能、中科院理化所等。5）系统安装：中国电建、中国能建、华能集团、浙建集团等。6）终端用户：风电光伏网站、电网公司、大型工商业等。</p>
<p>3.8熔盐储能：光热发展提速，熔盐应用场景广</p>
<p>熔盐储能是通过熔盐在低温时吸纳能量，在高温时放出能量的物理储能技术。熔盐储能系统可应用于太阳能热发电中，也可作为新型储能设施应用于以新能源为主体的新型电力系统中；同时，熔盐储能系统也是目前能够应用于火（热）电机组灵活性改造，实现冷热电汽多联供、提供综合能源服务的最佳解决方案。熔盐储能系统主要包括熔盐加热系统、熔盐储热系统、蒸汽发生系统。</p>
<p>3.8.1光热兼具新能源发电+储能属性</p>
<p>光热基于“光能-热能-机械能-电能”的转化发电，且自带大容量、低成本的储能系统。太阳能热发电利用大量反射镜以聚焦的方式将太阳直射光聚集起来，加热工质并进行储存，再利用高温工质产生高温高压的蒸汽，驱动汽轮发电机组发电。光热系统主要由聚光系统、吸热系统、储换热系统以及发电系统组成，分别可以实现太阳能的聚集、转换、电力输出以及辅助的功能。其中储热系统将加热后的介质（熔盐）进行储存，换热系统在需要发电时利用高温熔盐与水进行热交换，以产生高温高压的蒸汽。储换热系统使得光热发电自带大容量、低成本的储能系统，可实现24小时连续、稳定发电，也可按需求满足早晚高峰、尖峰时段及夜间用电。</p>
<p>塔式发电效率高、成本下降空间大，未来有望成为主流发电技术路线。塔式熔盐储能光热发电因其较高的系统效率，较大的成本下降空间，预计未来会成为主流的光热发电技术路线。目前，在全球主要国家和地区投运的太阳能热发电项目中，槽式技术路线占比约76%，塔式约20%，线性菲涅尔技术（以下简称线菲）约4%。而在我国已建成的太阳能热发电系统中，塔式技术路线占比约60%，槽式技术路线占比28%，线菲约占12%。</p>
<p>3.8.2光热储能价值日益凸显，重新进入发展快车道</p>
<p>行业支持政策持续出台，新疆风光大基地鼓励光伏与储热型光热发电以9∶1规模配建。近年来，国内及各省市相继出台多向光热行业相关鼓励政策，支持行业发展。2021年10月国务院印发的《2030年前碳达峰行动方案》中就明确提出：积极发展太阳能光热发电，推动建立光热发电与光伏发电、风电互补调节的风光热综合可再生能源发电基地。2022年3月新疆发改委在《服务推进自治区大型风电光伏基地建设操作指引(1.0版)》中特别指出，对建设4小时以上时长储能项目的企业，允许配建储能规模4倍的风电光伏发电项目；鼓励光伏与储热型光热发电以9∶1规模配建。</p>
<p>受成本因素制约，示范项目后光热行业发展有所放缓。2016年，我国安排了首批光热发电示范项目建设共20个项目，134.9万千瓦装机，分布在北方五个省区，电价1.15元/千瓦时。同时，国家鼓励地方相关部门对光热企业采取税费减免、财政补贴、绿色信贷、土地优惠等措施，多措并举促进光热发电产业发展。2018年，国家能源局布置的多能互补项目中，有光热发电项目。但由于光热发电成本较高，所以在国家能源局批复的首批20个太阳能热发电示范项目中，截至2021年底只有7个项目并网发电。根据CSTA，截至2021年底，我国太阳能热发电累计装机容量538MW（含MW级以上规模的发电系统）。</p>
<p>光热储能价值日益凸显，行业重新进入发展快车道。2021年，在经历了近两年的发展放缓后，中国光热发电行业迎来了承上启下的新元年。随着新能源装机规模不断扩张，光热发电“储发一体”优势凸显，与光伏、风电协同互补，在清洁供电的同时保证电网的高效稳定，光热发展重新迈入快车道，近一年来行业招投标火热。新疆于7月4日公布了2022年第二批市场化并网新能源项目清单，总计66个项目，储能总规模6922.5MW，其中光热项目共13个，规模合计1350MW（已按照项目进展记入下列项目统计表，其中6个项目已经开工），占比23.2%，储能时长为8~12小时。</p>
<p>3.8.3光热成本主要由聚光、吸热、储换热系统决定</p>
<p>聚光、吸热、储换热系统是决定光热电站成本的主要因素。光热电站的投资成本与功率和储能时长正相关。根据首航高科与可胜技术的数据，6小时储热100MW塔式太阳能热发电站的总投资在16<del>17亿元之间，12小时储热100MW塔式太阳能热发电站的总投资在25</del>30亿元之间。按照功能划分，电站投资主要发生在集热系统（聚光系统、吸热系统），储换热系统（包括储热系统、蒸汽发生系统）热力系统，供水系统，水处理系统，热工控制系统电气系统，附属生产工程以及厂址相关工程及其他费用。从下图可以看出：聚光、吸热、储换热系统约占整个电站成本的77%左右，是决定太阳能光热发电站造价高低最重要的因素。</p>
<p>太阳能热发电产业链体系可分为研发、设计、制造、安装、运维等环节。1）研发体系主要包括相关大、专院校，各大研究院所及各企业的研究部门；2）设计体系主要包括从事发电行业的设计单位，新能源和可再生能源的设计单位，具有相应资质的设计单位；3）制造体系主要包括各大制造企业（国企、民企、合资企业），大专院校、研究院所的生产单位等；4）安装体系主要包括专业电力安装单位和工业建设安装单位。</p>
<p>3.8.4熔盐储能系统是多个应用场景的良好解决方案</p>
<p>除了光热发电，熔盐储能还可以应用于火电灵活性改造、光伏风电园区储能、综合能源服务等场景。熔盐储能是通过熔盐在低温时吸纳能量，在高温时放出能量的低成本、高效率的储能技术，主要包括熔盐加热系统、熔盐储热系统、蒸汽发生系统。熔盐储能系统不仅可应用于太阳能热发电中，也可作为新型储能设施应用于以新能源为主体的新型电力系统中；同时，熔盐储能系统也是目前能够应用于火（热）电机组灵活性改造，实现冷热电汽多联供、提供综合能源服务的良好解决方案。</p>
<p>3.9总结与展望：关注商业化、降本与长时储能</p>
<p>我国储能技术与国际先进水平不断缩小，多项新型储能技术有望进入商业化或推广应用阶段。经过“十二五”和“十三五”期间国家和产业的持续投入，中国储能技术的水平快速提升，压缩空气储能、储热储冷、铅蓄电池、锂离子电池、液流电池和钠离子电池技术已达到或接近世界先进水平；抽水蓄能、飞轮储能、超级电容器和储能新技术和世界先进水平还有一定的差距，但总体上差距在逐步缩小。在国内商业化进程方面，抽水蓄能的发展最为成熟，电化学中的铅酸电池、锂离子电池商业化进程靠前，此外压缩空气储能、熔盐储能、液流电池即将进入商业化阶段，而重力储能与钠离子电池中大致处于工程示范阶段。</p>
<p>电力项目经济评价的方法中，平准化电力成本（levelizedcostofelectricity，LCOE）是一种用于分析各种发电技术成本问题的主要指标。对于各种储能技术，以储能系统的放电电量为基准，采用平准化电力成本方法来分析比较不同的储能技术的成本。为了上文储能技术离线的度电成本进行测算，我们设定了一些通用假设，贷款利率为4.9%，贷款比例为80%，贷款年限为10年，资本金回报率为8%，加权平均回报率为5.5%，年通胀率为2%。经过我们测算，抽水蓄能、锂离子电池、钠离子电池、全钒液流电池、压缩空气储能、重力储能及光热储能的LCOE分别为0.55/0.81/0.62/1.10/0.48/0.70/0.50元/kWh。传统的抽水蓄能在全生命周期内平均成本有一定优势，但压缩空气储能、光热储能、钠离子储能等技术已经有了较好的经济性，而全钒液流电池的储能时长延长后会更有经济性。</p>
<p>长时储能是未来重要趋势，相关储能技术有望受益。国内各地政府主管部门陆续出台文件支持4小时以上容量型储能的应用。2022年3月，内蒙古自治区能源局发布文件，要求新增负荷所配置的新能源项目配建储能比例不低于新能源配置规模的15%（4小时），存量自备负荷部分按需配置储能比例。新疆维吾尔自治区发改委出台《服务推进自治区大型风电光伏基地建设操作指引（1.0版）》，提出以储能规模确定新能源项目；建设不低于4小时时长储能项目的企业，允许配建储能规模4倍的风电光伏发电项目。随着新能源装机规模的提升和长时储能技术的进步，4小时以上的新型长时储能技术将逐步进入商业化应用，满足电力系统长时储能的服务需求。我们认为，在未来通过超长时间尺度和中长时间尺度储能技术和高比例可再生能源主动支持技术，解决大规模可再生能源发电功率波动平抑和从小时到天为单位周期变化的调节需求，将是储能行业的重要发展趋势。因此，在长时储能领域具备优势的储能技术，例如光热储能、压缩空气储能、液流电池、重力储能技术路线有望受益。</p>
<p>四、电化学储能产业链上市公司梳理</p>
<p>4.1储能电池：宁德时代为行业绝对龙头</p>
<p>2021年，中国新增投运的新型储能项目中，装机规模排名前十位的储能技术提供商（指具有储能技术本体生产能力且向客户提供储能技术本体的企业），依次为：宁德时代、中储国能、亿纬动力、鹏辉能源、南都电源、海基新能源、力神、远景动力、中创新航和中天科技。储能电池厂商主营业务呈现较为分散且多元化，宁德时代为储能电池领域绝对龙头。储能电池中游电池芯生产商大部分拥有自主研发、生产和销售的能力，多采用直销的方式方便为客户进行电池定制化服务，在境内境外均有销售业务布局。储能电池系统厂商主营业务呈现较为分散且多元化的局面。专注于单一储能电池赛道的生产商较少，大部分企业布局储能电池系统、锂电池行业以及动力电池相关产品、通信业务、资源再生行业等多项业务。根据CNESA，2021年度，全球市场中储能电池（不含基站、数据中心备电电池）出货量排名前十位的中国储能技术提供商，依次为：宁德时代、鹏辉能源、比亚迪、亿纬动力、派能科技、国轩高科、海基新能源、中创新航、南都电源和中天科技。根据CNESA，2022年上半年，中国企业储能电池出货量达44.9GWh，出货量排在前五位的企业分别是：宁德时代、比亚迪、亿纬锂能、鹏辉能源和瑞浦兰钧。宁德时代以大储市场为主，比亚迪、亿纬锂能大储和家储并重，鹏辉能源领先家储市场。</p>
<p>4.1.1宁德时代：储能电池环节龙头地位持续稳固</p>
<p>2021年公司储能系统实现营收136.2亿元，同比大增601.01%。根据CNESA数据，2021年储能技术（主要为电池）供应商出货量排名中，宁德时代出货位居第一且优势巨大。储能产品方面，宁德时代储能系统主要采用磷酸铁锂作为正极材料，产品以方形电池为主，主要用于发电、输配电和用电领域，涵盖大型太阳能或风能发电储能配套、工业企业储能、商业楼宇及数据中心储能、储能充电站、通信基站后备电池等，能够克服风能或太阳能发电不规则的输出特点、弥补线损功率补偿、跟踪计划削峰填谷，有效提高风力及光伏发电系统能源利用率以及用电领域峰谷电之间的平衡，有助于能源的最大化利用。2022年上半年，宁德时代储能系统实现营收127.36亿元，同比+171.41%。</p>
<p>4.1.2亿纬锂能：积极扩产，战略布局储能市场</p>
<p>公司深度布局储能市场，产能有望快速提升。1）2021年6月10日和2021年8月2日，公司分别与荆门高新区管委会就年产104.5GWh新能源动力储能电池产业园和年产30GWh动力储能电池项目签订《战略投资协议》。2）2021年10月27日，公司与成都管委会签署了《亿纬锂能50GWh动力储能电池项目战略合作框架协议》，就公司在成都管委会所辖区域内新征土地建设“亿纬锂能50GWh动力储能电池项目”达成相关约定。3）2022年5月17日，公司拟与云南省玉溪高新技术产业开发区管理委员会就公司在玉溪高新技术产业开发区龙泉片区投资建设锂电池生产项目相关事宜签订《投资协议》。本项目计划投资30亿元，建设10GWh动力储能电池项目。4）2022年6月7日和2022年6月23日，公司拟与曲靖市人民政府、曲靖经济技术开发区管理委员会就公司在曲靖经开区管委会区域内投资建设“年产10GWh动力储能电池项目”相关事宜签订《年产10GWh动力储能电池项目投资协议》。本项目总投资约30亿元，固定资产投资约23亿元。5）2022年6月7日和2022年6月23日，公司及子公司亿纬储能拟与武汉东湖新技术开发区管理委员会就在武汉东湖新技术开发区建设亿纬锂能储能总部及储能技术研究院项目相关事宜签订《武汉东湖新技术开发区管理委员会与惠州亿纬锂能股份有限公司关于亿纬锂能储能总部及储能技术研究院项目的合作协议》。本项目总投资约30亿元。</p>
<p>4.1.3鹏辉能源：聚焦储能业务，锂电老兵再起航</p>
<p>公司为最早涉及储能行业的锂电公司之一，是业内领先的储能电池解决方案供应商。根据中关村储能产业技术联盟（CNESA）数据统计，2021年度，鹏辉能源在全球储能电池（不含基站、数据中心备电电池）出货量排名top10中国企业中排名第二；另外在国内新增投运装机规模TOP10储能技术提供商排名中获得第四。公司储能业务收入大幅提升，客户优势显著。2022年上半年公司储能收入同比增长近三倍，占总收入比例也大幅提升至50%，其中户用储能收入同比增长6倍以上。大型储能电池方面，继续与阳光电源、天合光能、南方电网加深合作，并与中节能、三峡电能、智光电气开始合作。户储电池方面，合作的新老客户有阳光电源、德业股份、三晶电气、古瑞瓦特等头部客户。在便携储能市场，公司继续与国内头部客户开展大规模合作，同时开拓了公牛等新客户。在市场订单激增背景下，公司加大各园区储能产能建设投入，持续推动产能释放，反哺订单需求，刺激业绩增长。</p>
<p>4.1.4德方纳米：磷酸铁锂正极龙头，绑定优质客户</p>
<p>公司积极扩产，应对动力和储能市场高增长需求。2021年，公司曲靖磷铁、曲靖德方一期项目及二期项目产能释放，产能持续提升，截至目前公司已建成纳米磷酸铁锂产能26.5万吨/年，同时积极推进与合资公司德方亿纬“年产10万吨纳米磷酸铁锂项目”和宜宾德方时代“年产8万吨磷酸铁锂项目”，规划到2025年底纳米磷酸铁锂产能达34.5万吨/年；公司已建成磷酸锰铁锂产能11万吨/年，规划到2025年底磷酸锰铁锂产能达44万吨/年，合计磷酸盐系正极产能78.5万吨；同时公司积极挖掘液相法工艺潜力，推出补锂剂产品，在建补锂剂产能5,000吨/年，规划到2025年底补锂剂产能达2.5万吨/年。</p>
<p>4.1.5华宝新能：全球便携储能龙头，产品优品牌强渠道深</p>
<p>公司产品矩阵较为丰富，对各细分市场进行全范围覆盖。根据对市面上五家主流便携式储能公司产品进行统计，便携式储能产品容量在99Wh至6071Wh区间，目前，市面上产品集中在1000Wh以内，产品种类占总体比例约为59.62%；便携式储能产品容量在2000Wh及以下的比例约为86.54%，随着上游电芯等原材料成本降低及体积能量密度逐步提升，预计便携式储能产品单位容量将呈现上升趋势。华宝新能Jackery和电小二两大品牌包含产品容量类型达11种，产品容量覆盖范围从0-2500Wh，预计可以覆盖90%以上便携储能消费者群体需求，由于公司主要市场在海外，因此海外主打品牌Jackery在产品容量划分上更为精细，满足各细分市场消费者需求。正浩科技、GoalZero、德兰明海、安克创新产品容量类型分别为9/8/11/3种，华宝新能与德兰明海产品矩阵最为丰富，相比同行业具备比较优势。总体来看，公司深耕便携储能产品，精准把握市场需求，针对如近郊露营、自驾露营、长途自驾等不同使用场景以及偶尔、定期、经常等使用频率设计不同容量产品，实现全市场产品基本覆盖，突显出公司较强的产品开发能力和制造能力。</p>
<p>4.1.6派能科技：家用储能龙头，业绩处于高速成长期</p>
<p>公司是国内少数具备电芯、模组、电池管理系统及能量管理系统等储能核心部件的自主研发和生产能力，同时具备储能系统集成解决方案设计能力的企业之一。公司产品线实现Wh级到MWh级无缝覆盖，并可通过集装箱系统扩展至百MWh，能够覆盖从家庭到工商业再到电网、大型新能源发电站等各种场景，为用户提供全场景解决方案。并且公司在向客户交付大型储能电池系统时，能够结合储能应用场景的电气环境和用户需求，为发电侧、电网侧、工商业等各类场景打造“一站式”储能解决方案。</p>
<p>4.2储能PCS：竞争格局较为集中，龙头份额提升</p>
<p>储能PCS竞争格局与光伏逆变器行业有一定重叠，市场较为集中，头部企业市占率提升。在储能PCS环节，聚集了包括上能电气、德业股份、固德威、锦浪科技、阳光电源等企业，其中大多数以海外市场为主。在国内市场，2021年国内储能逆变器装机排名中，上能电气占据榜首，分列二、三位的是科华数能和索英电气。全球市场出货量前三则分别为阳光电源、科华数据和比亚迪。</p>
<p>4.2.1阳光电源：逆变器龙头，市场地位稳固</p>
<p>阳光电源可提供储能变流器、锂电池、能量管理系统等储能核心设备。阳光电源储能业务依托全球领先的电力电子、电化学、电网支撑“三电融合”技术，打造专业储能集成系统，专注于锂电池储能系统研发、生产、销售和服务，可提供储能变流器、锂电池、能量管理系统等储能核心设备，实现辅助新能源并网、电力调频调峰、需求侧响应、微电网、户用等储能系统解决方案，是全球一流的储能设备及系统解决方案供应商。</p>
<p>4.2.2德业股份：储能逆变器比例快速上升</p>
<p>逆变器产品布局广泛，三套马车并驾齐驱。公司研发实力深厚。基于公司原家电领域电子控制技术、人才储备和产品开发经验，公司自主研发了三电平SVPWM驱动技术、单相三相锁相环技术以及带MPPT算法的太阳能控制系统等逆变器产品的相关技术，可以有效的提高太阳能的利用率、逆变器的电能转换率，并保证逆变器稳定性。截至2022年，公司已经形成组串式并网、储能及微型逆变器三大类产品并驾齐驱的产品矩阵。</p>
<p>4.2.3昱能科技：微型逆变器领跑者，长坡厚雪潜力大</p>
<p>在储能产品方面，公司掌握了交流耦合储能系统控制技术和低压储能控制技术等2项核心技术。基于前述核心技术实力，公司研发的储能产品可以交流耦合方式与光伏并网逆变器系统一起组成微网系统，具有低压组件接入和低压电池接入的安全优点，同时具备自发自用、备用电源等工作模式。随着“光伏+储能”结合的用电模式逐渐成为全球的普遍共识，储能作为保障连续电力供应的首选解决方案及核心技术，逐渐得到世界各国的高度重视，其市场前景十分广阔。加快光储布局，有望打造昱能一体化生态体系。公司研发的光储一体系统主要包括单相储能系统ELS系列、三相ELT系列牡丹台储能逆变器可以独立支持一个储能系统功能。两类产品均已交流耦合方式与光伏并网逆变器系统一起构成微网系统。公司交流耦合方式支持低压组件接入与低压电池接入，安全性能方面更具优势，同时兼具自发自用、备用电源功能。</p>
<p>4.2.4固德威：专注于太阳能、储能等新能源电力逆变器</p>
<p>公司已研发并网及储能全线多个系列光伏逆变器产品，功率覆盖0.7kW～250kW，充分满足户用、扶贫、工商业及大型电站需求。公司产品立足中国，并已批量销往德国、意大利、澳大利亚、韩国、荷兰、印度、比利时、土耳其、墨西哥、巴西、美国、波兰、南非等全球多个国家和地区，产品性能优异。公司于2021年推出两款储能锂电池产品：LynxHomeU系列低压电池和LynxHomeF系列高压电池。两款电池均可以与固德威双向储能逆变器搭配使用，组成“光伏+储能”系统，实现电力自发自用。22Q3公司逆变器出货达20万台以上，其中户用储能逆变器出货占比达30%左右。</p>
<p>4.2.5上能电气：深度布局国内储能市场</p>
<p>公司储能产品为双向变流器相关产品，主要应用于发电侧。发电侧以大型储能电站为主，设备需融入电网生态体系，对项目招投标参与方要求严格，准入壁垒较高。公司储能产品包括交流储能变流器、直流储能变流器及储能集成系统：1）交流储能变流器，已具有140~3450kW全功率段范围产品，适用于发、输、配、用电网侧及微电网等多用应用场合。2）直流储能变流器：采用125kW/182kW模块化设计，应用于光伏电站直流侧，可解决因组件超配导致的弃光损失问题。3）储能集成系统：采用磷酸铁锂电池，适用于发电侧、电网侧、用户侧及微电网等储能领域。公司储能产品已大规模应用在“光伏+储能”、“风电+储能”、火电联合储能调频、用户侧储能、独立储能电站等领域。2021年公司完成了磴口县100MW光伏治沙储能竞价项目、远景安徽怀远10MW风电储能一体化示范项目、永州蚂蝗塘20MW/40MWh新能源配套储能电站等多个项目的并网运行，同时，山东省首批“5+2”大型储能示范项目中，为3个项目供应了储能变流器系统。</p>
<p>4.2.6锦浪科技：储能逆变器有望开启第二增长极</p>
<p>2021年储能逆变器实现370%以上高速增长。公司主要产品为组串式逆变器，按能量是否可以储存，公司逆变器可分为并网组串式逆变器和储能组串式逆变器。2021年公司储能逆变器业务收入1.76亿元，同比+370.85%。Q1储能逆变器在手订单5.4万台，对应3.5亿元。2022Q3储能占比总出货数的25%，占比不断提升，海外出货储能占比更高。公司的自主品牌产品销往巴西、美国、英国、荷兰、澳大利亚、墨西哥、印度等全球多个国家和地区。</p>
<p>4.3BMS、EMS及系统集成：格局较为分散</p>
<p>电池管理系统和能量管理系统行业竞争格局较为分散。从BMS各产业链的代表企业来看，上游集成电路行业的代表企业有士兰微、中芯国际、台积电等；印制电路板代表企业有鹏鼎控股、东山精密、深南电路等。在中游BMS行业，目前专注于储能BMS开发的厂商比较少，专业BMS供应商（如电装、亿能电子、妙益科技等）、动力电池BMS供应商（如三星、LG、宁德时代、特斯拉、上汽集团、长安汽车等）等均可提供储能BMS产品。在EMS领域，主要企业为国网系公司，代表企业有南瑞继保、许继集团、国电南瑞、平高电气等，此外还有四方股份、宝光股份等。</p>
<p>4.3.1四方股份：关注大储机会，打开第二曲线</p>
<p>传统业务有望稳步增长。输变电保护和自动化系统业务方面，公司持续深耕电网业务，用户订单增加，交货合同额增加，业务稳健增长。公司智能电网业务为输变电领域提供从1000kV特高压到10kV低压全系列的保护、自动化产品及解决方案，技术水平处于国际前列。发电与企业电力系统业务方面，受益于清洁能源的快速建设，叠加持续提升自身供应链管理能力，扩大重点客户的市场占有率，截至2022H1，公司新签合同额同比增长76%，有望持续贡献业绩。</p>
<p>4.3.2华自科技：自营储能电站盈利能力较好，储能项目储备丰富</p>
<p>公司定位为设备及服务供应商，既承揽储能EPC项目，也提供除电芯外的其他储能产品（包括EMS，BMS，PCS，CCS（协调控制器），智能监控等设备等），已在湖南布局了超过1.2GWH的电网侧的储能指标。公司自营独立共享储能电站盈利能力较好。1）容量租赁收入：城步儒林100MW/200MWh储能电站项目已完成一期建设，根据相关合同，共计获得含税收入为2240万元/年，全部建成后可获得容量租赁收入（含税）约4，480万元/年。此外，根据相关政策，如果项目并网时间较早，可享受一定的容量补偿。2）电力辅助服务：按照每次调用规模及调用次数，电网公司给储能电站支付费用。假设调用330天/1年，每天一次充放，调用费用为每次400元/MWh（含示范项目享受的峰谷价差收益），预计一个100MW/200MWh的储能电站的电力辅助服务收入（含税）约为2640万元/年。两项收入合计，第一年无容量补贴/1.3倍容量补贴/1.5倍容量补贴的收入合计7120/8464/9360万元，此后几年因电池容量衰减而递减。</p>
<p>（本文仅供参考，不代表我们的任何投资建议。如需使用相关信息，请参阅报告原文。）</p>
<p>精选报告来源：【未来智库】。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>储能行业专题研究报告：国内大储市场分析</title>
    <url>/2023/06/28/%E5%82%A8%E8%83%BD%E8%A1%8C%E4%B8%9A%E4%B8%93%E9%A2%98%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%EF%BC%9A%E5%9B%BD%E5%86%85%E5%A4%A7%E5%82%A8%E5%B8%82%E5%9C%BA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（报告出品方/作者：平安证券，皮秀、张之尧）</p>
<p>一、市场回顾：政策驱动大储市场发展，各地步伐不同<br>1.1市场概况：国内储能产业方兴未艾，大储是增长主力</p>
<p>储能是建设高比例新能源供给消纳体系、提高电网柔性和灵活性的关键技术。储能是将不易储存的电能转化为机械能、化学能等形式储存起来，供需要时使用的技术。储能系统可动态吸收并储存来自发电侧或电网的电能，在需要时释放，从而改变电能生产、输送和使用同步完成的模式，使得实时平衡的“刚性”电力系统变得更加“柔性”。风电、光伏等可再生能源存在间歇性和波动性等固有特性，灵活性不足，其大规模并网往往对电能质量、输配电稳定性、电能利用效率等存在影响，储能系统可以通过跟踪计划出力、调峰调频、负荷侧管理等方式，提高电能质量、输配电稳定性，并减少弃风弃光，推动可再生能源的大规模应用。发改委《关于促进储能技术与产业发展的指导意见》明确指出，储能能够显著提高风、光等可再生能源的消纳水平，支撑分布式电力及微网，是推动主体能源由化石能源向可再生能源更替的关键技术。</p>
<p>国内储能装机高速增长，表前大储为装机主力。全球新型储能产业快速发展，2021年全球累计装机达25.37GW，同比增长67.8%。我国是全球新型储能装机的主力市场之一，2021年新型储能新增投运项目规模占全球的24%。2021年，我国新型储能累计装机5.73GW，同比增长74.7%；新增装机2.45GW。从存量装机场景来看，大储项目（电源侧和电网侧）是国内装机主力，2021年占据了全国新型储能装机的76%。</p>
<p>2022年大储装机再创新高，独立储能和新能源配储平分秋色。据中国化学与物理电源行业协会初步统计，2022年我国新增投运新型储能装机6.21GW/14.32GWh，则按照功率计算的增速为153.5%，装机增势强劲。储能与电力市场统计，在年内投运的新型储能项目容量中，新能源配储和独立储能是装机的两大主要类型，容量占比分别为45%和44%；用户侧储能占据10%（含3个10小时铅炭项目）。</p>
<p>2022年全年招标项目44GWh，独立储能独占鳌头，容量占比近五成。根据储能与电力市场统计，2022年国内完成招标的储能项目容量达44GWh，总规模超过2022年新型储能装机量的三倍。若进展顺利，2022年完成招标的项目将在2023年开启实质性建设并逐步投运，2023年仍将是国内储能建设大年。从招投标项目类型来看，独立储能项目招投标最为火热，2022年完成招投标的独立储能项目共计20.93GWh，占比48%，或将成为未来一年国内储能装机的主流类型，为国内储能市场注入新的成长动能。</p>
<p>1.2政策回顾：从规模增长到市场成型，储能成长性有支撑</p>
<p>政策顶层设计引领，储能发展路径明晰。现阶段，我国储能产业发展阶段尚早，市场化仍在探索中，大型储能系统的应用经济性不强，主要由政策驱动。“十三五”以来，我国储能产业战略定位逐渐明确，发展路径逐步成型：“十三五”期间，政策明确了储能产业的战略定位，提出了十三五“商业化初期”、十四五“规模化发展”的两个阶段性目标，并强调储能产业“市场化发展”的工作重点。“十四五”开年以来，在“双碳”目标引领下，我国出台了一系列政策。这些政策确立了储能产业的阶段性目标，奠定了技术方案、应用领域和参与主体“多元化”的发展基调，并通过市场机制的规划，为产业发展保驾护航。在政策引领下，我国储能产业实现规模化发展在即；装机规模强势增长的同时，市场机制也将逐步探索完善，引导储能产业向市场化发展过渡。</p>
<p>新能源“配额制”规定推动，形成大储装机规模刚需。储能产业发展前期，储能电站商业模式尚不明确、经济性不明显，新能源项目强制配储成为储能装机的主要推动力。</p>
<p>“强配”政策逐步落地，成为大储装机增长强劲助力。2021年，国家发改委、国家能源局发布《关于鼓励可再生能源发电企业自建或购买调峰能力增加并网规模的通知》，鼓励发电企业自建储能或调峰能力增加并网规模，超过电网企业保障性并网以外的规模初期按照功率15%的挂钩比例（时长4小时以上，下同）配建调峰能力，按照20%以上挂钩比例进行配建的优先并网，“强配”政策首次上升到全国范围。上述政策出台前后，各地亦纷纷推出新能源强制配储政策，其中大部分省份要求的配储比例不低于装机容量的10%，配储时长在2小时以上；储能容量可以通过自行配建或购买/租赁满足。随着各地新能源装机持续增长，储能“配额制”将为大储装机提供强劲的成长助力。</p>
<p>“配额制”是新能源消纳责任分摊原则的体现，推动储能和可再生能源装机协调发展。在我国，可再生能源消纳的主要责任由电网企业承担；随着新能源装机和发电比例增加，电网消纳压力随之增长。“配额制”体现了令发电企业适当承担并网消纳责任的导向，具有一定合理性。《通知》规定，电网企业承担可再生能源消纳的主体责任，承担保障性并网责任；同时，鼓励发电企业通过自建或购买调峰能力，适当承担消纳责任，以额外增加并网规模。这在当时一定程度上解答了储能“由谁买单”的问题，有助于推动可再生能源和储能协调发展。</p>
<p>政策认可+市场完善，独立储能商业模式有望逐渐跑通，推动大储建设投资加速。独立储能指不依托于新能源电站，作为独立主体参与电力市场的储能项目。与新能源配储模式相比，独立储能由电站业主之外的第三方投资并运营，理论上可通过容量租赁、辅助服务、峰谷套利、容量补偿等方式获得收益，收益模式更为多样，是储能从规模化迈向市场化发展的重要形式。2021年底开始，国内出台了一系列独立储能相关政策，独立储能作为储能项目的新形式，逐渐崭露头角。</p>
<p>2021年12月，国家能源局《电力并网运行管理规定》和《电力辅助服务管理办法》明确了新型储能的独立市场主体地位，独立储能模式正式登上舞台。</p>
<p>2022年6月，国家发改委、国家能源局发布了《关于进一步推动新型储能参与电力市场和调度运用的通知》，允许符合条件的新型储能项目转为独立储能，鼓励新能源配建项目通过技术改造满足相关条件后转为独立储能，扩大了独立储能项目来源；《通知》同时规定，独立储能电站向电网送电的，其相应充电电量不承担输配电价和政府性基金及附加，进一步提升了独立储能模式的经济性。</p>
<p>年内，各省依自身情况探索推进辅助服务市场和电力现货市场建设，为独立储能参与市场、实现经济性铺路，山东、山西、甘肃等省份已走在国内前列，为独立储能模式积累经验。随着政策完善和市场发展，独立储能项目商业模式有望逐渐理顺、实现经济性，推动储能项目投资建设加速。</p>
<p>政策引领、市场完善，国内大储商业模式正逐渐成型。政策对现阶段我国储能产业的发展起关键引领作用，而“以市场为主导”、“激发市场活力”一直是储能政策部署的一大重点。整体而言，我国储能产业呈现出市场参与者多元化、商业模式逐步丰富、收益空间提升、成本传导畅通的发展趋势，有望逐步向市场化迈进。</p>
<p>1.3地域差异：因地制宜，各省储能发展模式和进程不一</p>
<p>我国地大物博，各省（直辖市、自治区）能源特征、电力市场发展情况等各不相同，因此储能在各地区的发展模式和进程也存在区别。储能发展前期，国内储能装机由电力市场化程度高的省份主导，用户侧亦占据一定比例。</p>
<p>2019-2020年，储能仍属于商业化初期阶段，新能源大规模配储尚未推行，广东省作为较早开启辅助服务试点的省份引领新型储能装机；同时，广东、江苏在用户侧储能领域起步较早，用户侧储能为上述两省提供了一定增量。这一阶段，储能属于“十三五”对应的商业化初期，各省储能装机量均不高，各省新增装机不超过300MW。</p>
<p>2021年，新能源配储鼓励政策首次上升到全国范围，山东省“共享储能”模式异军突起，成为2021年国内储能装机第一大省。同时，电力市场化程度高的广东、江苏、湖南亦维持了较高装机量。</p>
<p>大储强劲增长，各省装机主力形式不同。2022年，国内大储新增并网项目主要包括新能源配储和独立储能两类。各省装机形式存在一定区别，内蒙古、新疆、甘肃、西藏新增项目以新能源配储为主，上述省份新能源装机比例高，可再生能源大规模装机造成消纳与输配电压力，形成新能源配储需求；宁夏、山东、湖北、湖南是独立储能装机大省，独立储能相关项目稳步落地。</p>
<p>招标布局：西北、华北招标火热，新能源配储和独立储能齐头并进。2022年，国内完成招标的储能项目容量达44GWh。分地区来看，新疆、内蒙古、宁夏、山西、山东为储能部署前五大省级行政区，招标规模均超过2GWh。</p>
<p>大基地落地+4h储能配置需求，驱动内蒙古、新疆等地区储能部署。新疆、内蒙古是2022年储能项目招标规模前两大省份，招标规模分别为5.0和3.9GWh。上述地区风光资源优良，是风光大基地部署的主要区域；加之4小时配储时长的要求，内蒙古和新疆大储项目部署或将继续增长。</p>
<p>宁夏、山西、山东独立储能模式探索步伐领先，或将成为独立储能装机“排头兵”。2022年储能招标前五大省份中，宁夏、山西和山东独立储能发展步伐领先。宁夏鼓励新型储能项目试点，给予试点项目0.8元/kWh调峰服务补偿，补偿价格全国最高；山西和山东辅助服务市场已较为成熟，且均为电力现货市场首批试点省份，独立储能收益模式较为多样，项目储备丰富。上述省份积极推进电力市场化，在独立储能模式方面作出较多先行尝试，独立储能模式有望成为其储能装机的主要驱动力。</p>
<p>“十四五”储能装机规划累计超130GWh，各省发展节奏不同。截至2023年1月底，全国已有24个省级行政区公布了“十四五”末新型储能装机目标，合计达65GW，按≥2h装机时长估算，则到2025年末各省新型储能累计装机目标可超过130GWh。分地区来看，装机规划在5GW以上的省份主要集中在西北和华北地区，均为风、光装机大省，其中，青、甘、宁新能源装机占比均已超过50%。在上述地区，储能为新能源的消纳和外送提供灵活性资源，并有助于减缓高比例可再生能源并网对电网的冲击。与此同时，华东各省新型储能装机规划亦较为亮眼，其储能项目在承接风光配储需求的同时，有望通过更为市场化的方式获得回报。</p>
<p>二、市场展望：独立储能引领成长，2025年将达到90GWh<br>2.1发展趋势：新能源配储和独立储能殊途同归，独立储能有望成为大储主流形式</p>
<p>“新能源配储”和“独立储能”是现阶段大储项目的两种主要形式，长期或将殊途同归。据前述统计，在2022年投运的新型储能项目容量中，新能源配储和独立储能是装机的两大主要类型，容量占比分别为45%和44%。新能源配储和独立储能是目前大储采用的主要分类口径，两者运营主体和调用方式不同，但其装机需求均源于可再生能源并网对灵活性资源的需求，作用没有实质区别。短期来看，新能源配储由各地强配政策驱动，装机需求存在一定刚性；同时，独立储能作为市场化主体，商业模式完善后将取代一部分新能源配储装机。长期而言，两者或将殊途同归，不再有明显界限。</p>
<p>大储分类口径从“电网侧储能”变化到“独立储能”，体现了发展阶段和驱动因素的变化。从统计口径来看，国外大储项目通常称为Utility-Scale（公用事业级规模）/Grid-Scale（电网级规模）项目，通常翻译为表前储能或大储，分类内通常不再进行细分。国内前期将大储项目分类为“电源侧”和“电网侧”两类，2022年开始，独立储能模式逐渐成型，部分统计中开始将“新能源配储”和“独立储能”作为两个主要统计口径。电网侧储能、独立储能等概念在实际应用中界限较为模糊，尚无明确定义，更大程度上是一种约定俗成的划分，其分类大致反映了储能项目不同发展阶段，及装机的驱动因素。</p>
<p>早期主要根据接入位置划分为“电源侧”和“电网侧”，两者界限逐渐模糊。</p>
<p>储能产业发展前期项目统计口径往往采用设备或项目接入位置来划分，分为电源侧、电网侧和用户侧。电源侧项目指与发电机组配套安装的储能项目，包括新能源（风、光）配储和火储联合调频项目；电网侧项目指接入点位于发电厂关口表外、用户侧电表外的可由电网直接调度的储能电站，地理位置限制相对较小，以输配电基础设施为主。用户侧（“表后”）项目是安装于电力用户电表后的项目，包括户用和工商业储能，单体规模相对较小，不属于“大储”类型。</p>
<p>储能项目逐渐跨越接入位置约束，电源侧和电网侧界限逐渐模糊。随着国内可再生能源装机占比逐步增长、辅助服务市场日益成型，越来越多的储能项目开始跨越接入位置的约束，提供多重服务。根据CNESA《储能产业研究白皮书2022》，2021年国内电源侧、电网侧新型储能项目最主要的服务类型均为“支持可再生能源并网”和“辅助服务”。除小部分作为输配电基础设施的储能系统外，电源侧和电网侧储能系统在实际应用中差别正逐渐缩小。</p>
<p>“独立储能”模式逐渐崭露头角，“新能源配储”和“独立储能”成为另一种常见的划分口径。</p>
<p>独立储能模式推出初期，通常纳入电网侧口径进行统计。2021年12月，国家能源局“两个细则”认可了新型储能的独立市场地位，储能可作为独立市场主体参与辅助服务交易，独立储能模式正式登上舞台。独立储能推出初期通常被分类为“电网侧”项目，这一划分具有一定的合理性，一方面由于其接入位置并非电源侧和用户侧，另一方面其服务价值主要通过向电网提供辅助服务体现。</p>
<p>随着独立储能“容量租赁”商业模式发展完善，“电网侧”分类逐渐不够合理。目前独立储能的常见获利模式包括“容量租赁”和“辅助服务”两种，通常同时使用。容量租赁指储能电站将部分容量租赁给新能源企业使用，帮助其满足并网配储比例要求，并收取租赁费用。这一商业模式下，独立储能出租部分的容量理论上应归属于新能源企业，将其定位为“电源侧”和“电网侧”似乎均不合适。</p>
<p>新能源强配+独立储能模式崭露头角，产生新的划分口径。2022年，独立储能项目成为投资热点，年内项目招标容量占全国的48%，独立储能地位日益重要。同时，容量租赁模式尚未完全成熟，较大部分新能源配储要求仍需新能源企业自建满足，“新能源配储”在大储项目中仍占据客观体量。原使用的分类口径中，“新能源配储”和“独立储能”分别成为了“电源侧”和“电网侧”分类中占比最高、增速最快的板块。为了更恰当地反映项目类型，部分机构开始将“独立储能”和“新能源配储”作为大储的两大主要统计口径。</p>
<p>目前新能源配储和独立储能模式存在较为明显的区别。一方面，并网主体不同。新能源配储项目依托于新能源场站存在，并网主体仍为新能源发电项目；独立储能则作为独立主体并网、接受电网调用，部分地区规定其应当具有独立法人主体身份。另一方面，收益模式不同。新能源配储不能独立参与电力市场，收益来源有限，主要用于为风光电站获得并网资格，以及减少弃风弃光、减少发电偏差考核等，储能利用率不足成为一大难题；独立储能则除了出租容量外，还可以参与电力市场，通过辅助服务和峰谷套利方式获利。</p>
<p>现存新能源配储项目存在一定局限性：利用率不足，调用模式和收益模式仍有望完善。根据中电联2022年12月发布的《新能源配储能运行情况调研报告》，国内新能源配储项目调用率不足，至多弃电期间一天一充一放运行，个别项目存在仅部分储能单元被调用、甚至基本不调用的情况，平均等效利用系数仅6.1%。该报告认为，国内现存新能源配储项目规模较小、装机分散，且配置上未考虑风、光发电对配储的差异性需求，导致可用性较差；加之收益模式尚不完善，回报机制不清晰，导致新能源企业对配储项目的使用率并不高。储能项目的调用模式和收益模式仍有待完善。</p>
<p>“新能源配储”和“独立储能”长期或将殊途同归，界限不再明显。</p>
<p>从形式上来看，新能源强配要求可通过租赁独立储能满足，且新能源配储项目可转换为独立储能。一方面，在规定了新能源项目储能配比的20个省级行政区中，大部分地区明确表示可自建或购买容量（例如河南、贵州），部分地区规定以共享储能形式建设（如辽宁），独立储能项目可以满足强配要求。另一方面，2022年6月《关于进一步推动新型储能参与电力市场和调度运用的通知》允许符合条件（或经改造符合条件）的储能项目转为独立储能项目，两者界限不再明显。</p>
<p>从实质上来看，两者均源于可再生能源装机对灵活性资源的需求，且使用功能并无本质区别。无论新能源配储提高发电利用率和电能质量，还是独立储能的辅助服务和峰谷套利，本质上都是用于解决可再生能源并网对电力系统产生的冲击，为电力系统提供容量价值、能量价值和可靠性价值，实际可应用领域没有本质差别。</p>
<p>未来，独立储能有望成为大储的主流形式。独立储能项目单体规模通常较新能源配储项目更大，易于电网调度，且收益模式多元，或可解决新能源配储项目调用模式和收益模式上的不足。各地积极鼓励独立储能发展，各省发布的22.2GW/53.8GWh新型储能示范项目中，独立储能或集中共享储能项目达20.0GW/47.4GWh，功率规模占比高达92%。长期而言，独立储能作为主体参与市场，有助于充分发挥市场作用，为储能的容量价值、能量价值和可靠性价值进行定价，并灵活调用储能资源，有望成为大储的主流形式。</p>
<p>2.2商业模式：独立储能经济性成为关键看点，关注重点地区收益模式</p>
<p>独立储能有望成为大储加速发展的主要动力，商业模式成为市场关注重点。国内大储装机的核心驱动因素在于两个方面：“政策强配”提供规模支撑，新能源装机的增长、以及配储比例与时长的增加，为大储装机规模增长提供一定保障；“商业模式”推动装机加速，大储商业模式若在一些地区率先跑通，有望极大提高投资方的积极性，变“被动强配”为“主动装机”，推动大储项目加速落地。大储项目中，新能源配储收益模式不明确，在新能源场站可研中一般被看作成本项；独立储能作为独立市场主体，理论收益模式丰富，其商业模式成为市场关注的重点。</p>
<p>独立储能项目储备量庞大，经济性成为项目落地“临门一脚”。2022年，国内已启动建设或完成招标的独立储能项目共计29GWh，公开宣布但未进入实质阶段的独立储能项目达67.7GWh，分别约为2022年国内新型储能装机量的2倍和4倍，项目储备规模庞大。独立储能项目规划量可观的同时，对于项目实质推进的进度，业内存在一定疑虑：商业模式不明确的情况下，业主方可能存在一定观望情绪。例如，2022年山西省、甘肃省在建或完成招标的项目均超过4GWh，但尚未有项目投运；广东、内蒙规划项目分别超过12GWh/8GWh，但实质性进展项目较少。各地区独立储能收益模式和收益水平不尽相同，我们认为，重点地区独立储能的经济性，很可能成为项目落地的“临门一脚”，是2023年装机能否再度超预期的关键因素。因此，我们将对几个重点省份的独立储能收益模式进行解读。</p>
<p>理论上，独立储能收益模式有4种：容量租赁、辅助服务、峰谷套利和容量补偿。容量租赁，指独立储能电站将部分容量出租给新能源场站，满足其配储需求，收取租赁费用。现阶段，容量租赁是各省份独立储能收益的主要来源。辅助服务，指参与调峰、调频等辅助服务市场，获取辅助服务收益。目前各地储能电站可参与的辅助服务品种各不相同，包括调峰、一次调频、AGC调频等。峰谷套利，指利用日内电价差异，通过高峰放电低谷充电来获得价差收益，已开展电力现货市场的省份中，独立储能电站可以此方式获利。容量补偿，指部分地区按容量给予独立储能电站的补贴。</p>
<p>不同地区独立储能装机进展各异。从装机进展来看，2022年宁夏、山东、湖南、湖北独立储能电站投运规模最大；从项目部署来看，2022年山东、山西、甘肃、宁夏、湖南投运或启动的独立储能项目规模超过3GWh，居国内前列。独立储能装机进展受各省新能源装机量和配套收益政策影响，例如独立储能收益模式最为完善的山东省，其启动项目规模也居全国首位。此外，广东、内蒙古、河南具有可观的项目储备量，独立储能发展潜力充足。</p>
<p>从收益模式来看，独立储能收益模式和收益水平与各省电力市场建设进程、新能源配储政策等多因素有关，各省之间存在差异，项目经济性难以一概而论。考虑容量分配和运维难度，目前国内储能电站较为典型的收益模式包括：容量租赁+调峰辅助服务（绝大部分省份）；容量租赁+现货市场+容量补偿（山东）；容量租赁+现货市场+一次调频（山西）。</p>
<p>容量租赁是独立储能最主要的收益模式之一，各省独立储能电站均采用容量租赁模式获得收益，价格通常在300-350元/kW·年。由于各省在强配要求、新能源装机量、租赁政策和供需等方面存在差异，因此储能电站实际租出比例和单位收益有所不同。</p>
<p>辅助服务是各地区探索的重点，收益模式逐渐完善。调峰、调频服务通常不能同时参与，目前调峰是辅助服务最常见的品种，除电力现货市场试点省份外，大部分地区储能电站通过调峰获得辅助服务收益。部分省份根据自身情况创新辅助服务品种和参与机制：山西省在全国首次针对独立储能设立一次调频辅助服务市场；甘肃省在全国范围内首次为储能电站开放调峰容量市场；青海省则首次提出，储能电站可同时参与调频、调峰市场，或同时参与调频、现货电能量市场，提高储能利用率。</p>
<p>峰谷套利方面，“8+6”两批电力现货试点省份中，山东、山西、甘肃制定了储能参与现货市场的规则细则，储能电站理论上可参与现货市场进行峰谷套利（与调峰不同时存在）。其中，山东已开始了储能参与现货市场的实践，2022年现货市场不间断结算试运行中，已有6家（共503MW）独立储能电站参与现货电能量市场交易。</p>
<p>容量补偿属于地方补贴，目前山东和浙江省给予独立储能电站容量补偿支持。</p>
<p>各主要省份独立储能电站在理想状况下的年度收益估算如下。假设说明如下：</p>
<p>容量租赁：常见容量租赁单价为250-350元/Wh不等，除单独说明省份外，我们取300元/Wh单价的假设，并假设容量全部租出。湖南容量租赁收益参考《储能科学与技术》登载文献的测算数据（供不应求，单价较高）；广东省暂无强制配储要求，因此容量租赁模式获益有限，以辅助服务为主要收益来源。</p>
<p>辅助服务：山西即将推出的一次调频辅助服务费用较高，储能与电力市场假设采用10MW/20MWh容量参与一次调频，可获年度收益为14850万元，但由于此市场容量可能有限（2022年山西省辅助服务市场全年补偿6亿元），实际收益未必能达到该水平。宁夏、广东调峰辅助服务补偿全国最高，分别为0.8元和0.792元/kWh，假设全年折合满充满放300次计算。湖南参考《储能科学与技术》登载文献的调研数据。甘肃调峰容量补偿（合计约1900万元）和容量租赁不共存，暂不考虑参与调峰容量市场，估计参与基础调峰/调频辅助服务收益2000万元/年。</p>
<p>峰谷套利：山东、山西基于现货市场实际运行数据计算（储能与电力市场测算），假设价格可完全预测；甘肃省尚无现货市场运行数据，但该省峰谷价差较小（其工商业代理购电价差约0.2元/kWh，全国最低），因此估算其现货市场收益水平略低于山东、山西。</p>
<p>我们简化测算，容量100MW/200MWh的独立储能电站，其年度收益达到6000万元时，IRR可达7%。由此可见，几个主要省份独立储能电站在理论上已经可实现经济性。我们采用简化假设：假设每年收益固定不变；成本费用（含融资成本）总和2000万元/年，电站生命周期15年；初始建造价格参考2022年2h储能电站EPC招标均价1.8元，则估算当年度收益为6000万元时，IRR可达7%；年度收益上升至7000万元时，IRR可上升至11%，独立储能电站经济性可期。</p>
<p>独立储能前景可期，实际运营收益如何仍需观察。目前国内独立储能实际投运案例较为有限，容量租赁实际出租比例和成交价格、辅助服务调用频率和补偿幅度、现货市场推广等实际情况，仍有待继续观察。本报告的测算可以为理解各省独立储能收益模式提供基本的框架，为后续追踪独立储能重点市场的政策发展及装机进度预测提供基础。</p>
<p>2.3市场空间：国内大储市场2023年有望超过30GWh</p>
<p>根据前文分析，无论独立储能还是新能源配储，本质上均源自可再生能源装机对灵活性资源的需求。因此，国内大储装机需求主要由集中式新能源装机量（存量装机暂无强配要求，此处暂仅考虑每年新增）以及配储比例（政策强配和独立储能商业模式跑通，均对储能新增渗透率有影响）两者决定。因此，我们采用集中式新能源新增装机及配储率，对国内大储市场空间进行估算。</p>
<p>风电装机：2022年，国内新增并网风电装机37.63GW，同比减少21%。按照近期召开全国能源工作会议的指引，到2023年年底全国风电累计装机规模将达到4.3亿千瓦左右，意味着2023年新增并网规模将达到65GW左右。实际上，随着陆上和海上风机技术的进步和价格的持续下降，招标端已经明显放量，2022年前三季度国内风机招标规模达到76.3GW，同比增长82%，估计2022全年风机招标规模达到100GW左右，这些为2023年及以后国内风电需求放量奠定基础。我们看好2023年国内风机吊装规模达到70GW；预计2024/2025年风机吊装规模分别将达到84/100GW。</p>
<p>光伏装机：2022年全国光伏新增装机87.41GW，同比增长60.3%。展望2023年，国内光伏新增装机有望进一步增长；根据近期全国能源工作会议的指引，到2023年年底全国太阳能发电累积装机规模达4.9亿千瓦左右，意味着2023年新增并网规模将达到100GW左右。实际上，自2022年11月底以来，硅料价格基于供需关系的变化已经大幅回落，有望推动组件价格的快速下降，进而刺激光伏终端需求，近期中国电建启动2023年度总规模26GW的光伏组件集采也反映了这一趋势。我们对2023年国内光伏需求更为乐观，预计2023年国内光伏新增装机有望实现30%及以上的增长，达到115GW。我们预计2024/2025年光伏新增装机增速分别为26%和24%，新增装机量分别为145/180GW。集中式光伏占比方面，2022年前三季度集中式光伏占总装机的1/3，我们预计2023-2025年随着大基地项目落地、地面电站投资回暖，集中式光伏占比有所增加，占比分别为45%、40%、40%。</p>
<p>配储比例假设：根据全国新能源消纳监测预警中心数据，2022年前三季度全国风电、光伏利用率分别达到98%和99%，消纳情况较好，且现阶段尚未出台存量风光电站强制配储的要求，因此暂不考虑存量风光配储，仅对每年风光装机增量的储能配套比例和时长进行假设。根据计算，2022年新增风光项目储能配置率平均为11.2%/2h（不区分新能源/独立储能项目），我们假设2023/2024/2025年储能配置率分别为13%/17%/21%，时长分别为2.1h/2.3h/2.5h。</p>
<p>我们预测，2023年国内大储新增装机有望达到33.2GWh，同比增长124.8%；到2025年，国内大储新增装机量有望进一步增长至90.2GWh，2022-2025年复合增长率达83%。</p>
<p>三、产业链：关注电池、PCS与集成、储能安全等环节机会<br>3.1大储产业链各环节介绍</p>
<p>产业图谱：大储产业链主要包括上游储能设备、中游系统集成、下游电站等环节。其中，储能电池和PCS是大储产业链价值量最大的两个环节，分别约占系统成本的60%和15%；储能安全环节重要性日益凸显，温控、消防环节分别约占系统成本的2~5%，液冷方案渗透率的提升和Pack级消防的推广或将进一步提升板块价值量。系统集成环节参与者众多，专业集成商、大功率PCS厂商、老牌电力设备厂商均有参与。</p>
<p>电池环节：国内企业全球竞争力强，大储开启第二成长曲线。储能锂电池市场高速增长，根据起点锂电数据，2021年全球储能锂电池出货量共计70.6GWh；高工锂电最新统计，2022年全年我国企业储能锂电池出货量达到130GWh，同比高增171%。竞争格局方面，国内锂电企业在动力电池技术和产业链方面全球领先，在新兴的储能锂电池市场也迅速占据了出众的市场份额。从竞争格局来看，宁德时代为储能电池绝对龙头，市占率全球领先；比亚迪、鹏辉、亿纬、国轩等占据第二梯队，储能电池贡献业绩占比逐步提升。我们认为，国内企业在储能电池环节竞争力强，有望受益于国内和全球大储市场加速发展，赢得动力电池之外的第二成长曲线；随着国内独立储能模式的逐步推广，具备技术优势、产品性能优良的电池企业有望获得长足竞争力。</p>
<p>PCS：主要参与者为光伏逆变器厂商，多向下布局系统集成环节。国内大储PCS头部企业大多为光伏逆变器厂商，在全球市场已有较为领先的地位。大储PCS环节主要厂商包括阳光电源、科华数据、上能电气等，上述企业在自身赛道均已有多年积累，凭借对电网的理解向下一体化进入系统集成环节，在大储集成赛道已具备一定地位。</p>
<p>系统集成：国内市场空间可期、竞争格局尚不明确，相关企业业绩有望受益于装机提速+毛利改善。国内系统集成环节参与者众多，专业集成商、大功率PCS厂商、老牌电力设备厂商均有参与。从竞争格局来看，目前国内大储集成市场竞争格局较为松散，2021年国内市场前5大厂商出货量在500-800MWh之间，差距不大，尚无明显的龙头；海外市场分散而广阔，存在一定进入壁垒，除阳光电源等头部企业外，其它厂商尚处于海外布局阶段，逐渐打开市场，国内集成企业之间的直接竞争尚不明显。集成环节，具备项目案例积累、对电网的深度理解、以及核心部件（主要为PCS）自研的企业具备优良的竞争优势。2023年，受益于硅料价格回落，国内光伏装机预期较为乐观，且相关厂商对储能系统成本的接受度有望增加，大储装机有望提速；同时，上游碳酸锂成本压力有望放松，储能系统集成环节利润受挤压的情况有望改善，与大储装机直接相关的PCS和系统集成相关企业业绩有望受益。</p>
<p>储能温控：参与者技术较为成熟，储能新赛道带来潜在增量。大储电站所用的锂电池单体容量大，280Ah以上大电芯渐成主流，其面临的热管理问题更为严苛，温控设备成为大储建设必不可少的环节。目前储能温控可采用风冷和液冷方案，对应传统行业的温控技术均较为成熟，目前赛道主要参与者包括精密温控、工业温控、汽车温控企业，随着储能温控需求增长，相关企业有望迎来新的业绩增量。</p>
<p>储能消防：安全是重中之重，新国标出台或将为赛道参与者带来新机遇。储能锂电池存在热失控的可能性，带来消防隐患，大型集中式储能电站中电池数量庞大，单个电芯的热失控可能带来连锁反应，产生火灾的严重后果。大储规模化增长的同时，相关部门对储能安全的重视程度日渐提升。新国标《电化学储能电站安全规程》（GB/T42288-2022）将于2023年7月1日开始实施，新规要求“锂离子电池室/舱自动灭火系统的最小保护单元宜为电池模块”，即实现Pack级保护，有望推动消防在储能系统中的价值量进一步提升。储能消防产品包括探测预警装置和灭火装置等，Pack级解决方案的实现难度高，相关企业需要与电池/BMS企业合作研发，存在一定壁垒，赛道竞争格局较好。目前国内储能消防赛道主要参与者为青鸟消防、国安达：青鸟消防为赛道龙头，具备站级、舱级、Pack级的储能消防解决方案；国安达在电力消防行业积累扎实，旗下储能消防产品已处于小批量供货阶段。</p>
<p>3.2重点公司分析</p>
<p>3.2.1电池环节：优质储能电池供给仍稀缺，高“含储量”电池企业业绩弹性大</p>
<p>亿纬锂能：储能电池占比稳步提升，大容量新品有望放量。</p>
<p>储能电池有望贡献强劲业绩增量。公司是国内大圆柱电池龙头，动力、储能电池市场地位领先。公司储能电池收入占比逐渐提升、在手订单充足，随着布局产能逐渐释放，储能电池营收有望达到公司动力电池板块（公司统计口径，包含动力和储能电池，区分于消费电池、材料等）的一半以上，成为营收的重要增长来源。公司规划到2025年将实现电力储能100GWh产能规模，储能电池有望贡献强劲的业绩增量。公司280Ah、560Ah产品契合大储需求，成长性可期。公司把握储能行业趋势，积极布局新产品，卡位大储赛道。公司2021年推出280Ah储能电芯，同年获得北美UL9540A认证，海内外产品需求旺盛；2022年11月亿纬林洋10GWh280Ah储能电池正式投产，有望进一步提高交付能力。2022年10月，公司发布560Ah储能电池新品，单只电池可储存1.792kWh能量，循环寿命超过12000次，可以简化集成成本、提高集装箱电量6.5%，产品预计2024Q2开启交付。公司储能电池产品和产能布局持续加速，成长性可期。</p>
<p>大圆柱电池头部企业，46系大圆柱放量可期。公司布局4680和4695电池，2022年6月在湖北荆门拟投资43.75亿元建设年产20GWh大圆柱46系列电池项目。2022年9月拿到宝马2025年“新世代”车型46系大圆柱电池定点，并将在欧洲匈牙利新建20GWh的电池工厂。同时还获得大运汽车等车企定点。特斯拉4680电池量产在即，大圆柱市场空间有望打开，公司作为国内大圆柱电池龙头，业绩有望受益。</p>
<p>鹏辉能源：战略聚焦储能，大储户储齐发力。</p>
<p>聚焦储能赛道，实力业内领先。公司是最早涉及储能行业的锂电公司之一，储能电池解决方案业内领先，产品包括家储/大储/通信储能电池。2021年，公司在CNESA中国企业全球储能电池出货量排名中位列第二。公司储能业务占比逐渐提升，截至2022年上半年已经提升至50%，远期规划储能电池业务占比提升到80%以上。公司储能电池出货量中，目前户储占一半以上，后续大储有望受益于全球装机高增趋势，贡献业绩增量。合作领先客户，大储放量在即。公司储能电池覆盖户储、大储、通讯等场景，户储及便携式储能客户有阳光电源、艾罗、三晶、RCT、德业股份、正浩、公牛等；大型储能客户有阳光电源、三峡电能、中节能、智光电气、天合光能、特变电工等；通讯储能客户有中国铁塔、中国移动等。大储方面，公司被阳光电源评为“2021年度优秀供应商”（2022年评选尚未公布），获得头部客户青睐；2022年内，公司分别和智光电气、三峡电能、中电建新能源集团等集成/EPC厂商达成战略合作，为后续发力大储提供了基础；海外市场方面，公司280Ah电芯获得北美UL9540A认证，150Ah电芯获得TÜV南德全球首个IEC62619:2022认证，大储海内外业务均有望向好。</p>
<p>3.2.2PCS和系统集成环节：装机提速、毛利改善，头部企业加速成长。</p>
<p>阳光电源：光储业务受益于硅料价格下行，龙头成长性领先。</p>
<p>光伏逆变器：龙头地位稳固，光伏逆变器业务增长有望持续。公司是光伏逆变器全球龙头，2021年全球出货47GW，居全球首位。公司光伏逆变器产品布局全面，涵盖10~8800kW功率范围，远销全球150多个国家和地区。展望2023年，我们认为光伏装机需求有望大幅受益于硅料价格回落，地面电站、分布式装机同步发力，公司逆变器营收有望持续增长。储能业务：大功率PCS产品、IGBT拿货能力构成壁垒，业绩增长确定性强。公司是大储PCS全国龙头，储能系统业务足迹遍布中、美、英、德、日等多个国家和地区，锂电储能装机规模连续六年位居中国企业第一。大储变流器环节存在一定壁垒，包括大功率产品的技术积累、IGBT的供应能力、对电网的理解等，公司作为头部企业，大储业务竞争实力强。公司在调研公告中预计2023年大储产品出货量有望达到15GWh，实现翻倍增长；同时，考虑到硅料降价带来客户端成本压力的放松，以及碳酸锂价格对利润挤压的减轻，公司盈利能力也有望进一步提升，实现量利齐升。</p>
<p>南网科技：储能EPC引领成长，业绩增长确定性强。</p>
<p>业务布局涵盖技术服务+智能设备，储能业务占比持续提升。公司脱胎于广东电科院，第一大股东为南方电网。公司主营业务包括技术服务+智能设备两大类，技术服务包括“储能系统技术服务”和“试验检测及调试服务”两类；智能设备包括智能监测设备、智能配用电设备和机器人及无人机3个类别。公司储能业务（属于新能源装备事业部）包括EPC和并网检测调试服务，2022年上半年已全面向承接EPC业务转型，独立调试业务规模和占比逐步降低。公司在手订单饱满，前三季度累计中标储能EPC项目320MW/429MWh，中标金额共计10.27亿元，在手订单饱满，储能业务占比有望持续增长。订单质量优、成本控制强，储能业务盈利能力有保障。2022年上半年，公司综合毛利率31.26%，其中新能源事业部（储能业务所属事业部）毛利率17.30%。公司通过把控储能EPC订单质量，以及电芯集采、Pack产线自建等方式，保障储能EPC业务毛利率表现，盈利能力优良。</p>
<p>南网区域储能装机有望高速发展，公司业绩增长空间大、确定性强。2021年5月，南方电网在《南方电网公司建设新型电力系统行动方案(2021-2030年)白皮书》中提出，“十四五”期间推动新能源配套新型储能20GW，增长空间广阔。广东省2022年公布的独立储能项目储备已超过12GWh，电力现货市场的常态化运营和辅助服务市场的完善有望推动其储能项目加速落地，南网区域储能装机增长可期。公司对电源侧以及电网侧各项技术特性有着深刻的理解，技术实力突出，有望把握南网及全国大储装机增长机遇，业绩增长空间大。</p>
<p>科华数据：数据中心+储能双轮驱动，海内外业务全面布局。</p>
<p>数据中心+新能源双轮驱动，储能PCS和集成市场地位领先。公司旗下有“科华数据”和“科华数能”两大业务主体，数据中心相关业务和新能源业务双轮驱动。数据中心方面，公司是数据中心UPS全国龙头，主要产品包括模块化UPS电源、电池箱、配电柜等，业绩稳定增长。新能源业务方面，公司重点发力储能业务，2021储能PCS国内和全球出货量在国内企业中均排名第二；储能系统集成领域，2021年国内和海外出货量在中国企业中排名前十。海内外储能业务齐发力，大储、户储均有布局。大储方面，2022年公司逆变器解决方案入围中国能建、中核（南京）、中国电建、中石油及国家电投等大型国央企集采项目，规模达到GW级；公司已面向全球发布S³液冷储能系统，产品具备主动安全、智能高效、精简灵活等优势，市场反馈较好。户储方面，公司iStorageE产品在手订单充足，与欧、美、澳客户签署共计400MWh订单，顺利打开市场。公司储能业务布局全面，大储市场地位突出，业绩有望持续增长。</p>
<p>3.2.4储能安全环节：竞争格局较好，环节价值量有望持续提升。</p>
<p>英维克：储能温控龙头，长期成长性出色。</p>
<p>公司是国内精密温控龙头，业务覆盖储能温控、数据中心温控等。公司是国内精密温控领域的龙头企业，主要产品包括机房温控节能设备（用于数据中心）、户外机柜温控节能设备（用于储能电站）、轨交列车空调等，风冷、液冷产品布局全面、技术领先。公司储能温控市场地位领先，业绩增长迅速。储能温控领域，公司是最早涉足电化学储能系统温控的厂商，长年在国内储能温控行业处于领导地位，也是众多国内储能系统提供商的主力温控产品供应商，储能温控客户包括宁德时代、阳光电源、比亚迪、南都、科陆、平高集团、海博思创以及国外主流系统集成商和电池厂商。公司储能温控业务高速增长，2022年上半年储能温控贡献营收2.5亿元，同比增长68%，占上半年营收的29%。</p>
<p>上半年数据中心温控业务需求承压，未来有望持续向好。2022年上半年，由于疫情等因素影响，公司机房温控节能产品营收3.70亿元，同比下降30%，拖累了整体业绩；但三季度以来业绩已出现明显好转。数据中心是发展数字经济的基石，是重要的“新基建”设施之一，高耗能一直是数据中心应用的痛点，各地政策严控数据中心PUE（电能使用效率）。液冷方案被视为降低PUE的革命性方案之一，渗透率有望持续提升，数据中心温控价值量提高。公司是数据中心温控领域头部企业，在受益于行业整体价值量提升的同时；有望在液冷渗透率提升趋势下占据更大的市场份额。</p>
<p>青鸟消防：储能消防龙头，“三条主线”成长逻辑优。</p>
<p>储能消防：大储装机高增+行业标准化，细分龙头业绩有望大幅受益。消防是保障大型储能电站安全的重要一环，目前国内储能消防产品尚未标准化，在储能系统中价值量占比仅2%，低于国外5%左右水平。随着大储装机增长，以及2023年新国标《电化学储能电站安全规程》（GB/T为建议性标准）的出台，储能消防细分赛道价值量有望大幅提升，开拓百亿级市场。公司重视储能业务新机遇，2022年成立储能消防业务群组，从市场拓展端和产品研发端同步发力。目前公司储能消防业内领先，已形成站级、舱级、Pack级的储能消防解决方案，是业内极少数可以做到Pack级保护的公司之一。公司提前卡位储能消防赛道，成为细分赛道龙头，业绩有望受益。民用消防：地产产业链复苏，提振行业需求；竞争格局向头部集中，公司份额增长。民用消防产品市场规模约1000亿元上下，增速与GDP、地产行业增速挂钩，整体增长较为稳健。目前行业竞争格局分散，中小企业繁多，市场份额仍长期存在向头部企业集中的趋势。公司作为赛道龙头，市占率有望继续扩大。</p>
<p>工业消防：高门槛、高毛利率的国产替代赛道，公司扎实布局、业绩高速增长。工业消防产品市场约百余亿元，产品技术壁垒高，市场由霍尼韦尔、西门子等国际巨头占据，国产替代空间广阔。国内企业入局者较少，包括公司、翼捷股份、安可信等，参与者工业消防产品毛利率可达50%以上。公司工业消防营收快速增长，产品涵盖传统工业行业（钢铁石化等）、泛工业行业（地铁轨交等）、中高端制造（医药化工、锂电等），2022年上半年公司工业消防报警产品实现营收2,072.09万元，同比大幅增长203.18%，基数小、增长强劲，仍有上升空间。</p>
<p>四、投资分析<br>国内大储市场蓬勃向上，有望实现高速发展。政策引领下，我国储能产业实现规模化发展在即。考虑全国新能源装机的增长、配储比例与时长的增加，以及独立储能商业模式的推动，我们看好国内大储市场发展，预计2023年国内大储新增装机有望达33.2GWh（同比+124.8%）；2025年新增装机量有望增至90.2GWh，2022-2025年CAGR达83%。</p>
<p>储能商业模式因地制宜，重点区域独立储能理论上已具备经济性。独立储能项目储备规模庞大，或将成为引领国内大储装机的主要驱动力，但市场对其商业模式存在一定疑问。独立储能项目业主能否摆脱观望情绪、加速装机，商业模式是关键。各省独立储能收益模式和补偿标准各不相同，我们关注独立储能发展的6个主要省份山东、山西、宁夏、湖南、甘肃、广东，分别分析其独立储能收益模式，理论IRR可达7%及以上。但目前国内独立储能投运案例较为有限，规模发展后如何实现经济性，仍有待继续观察。</p>
<p>国内大储市场高景气方向确定，独立储能商业模式落地或进一步刺激装机增速提升。本报告的分析可以为理解各省独立储能收益模式提供基本的框架，为后续追踪独立储能重点市场的政策发展及装机进度预测提供基础，有助于捕捉国内大储赛道的边际变化。以此框架为始，后续我们将对国内大储市场进行持续跟踪：市场空间方面，一是关注各地实际批复的新能源项目配储比例情况，二是关注项目招标和建设情况；商业模式方面，一是关注重点省份独立储能相关政策的出台，二是关注各地独立储能投运项目的实际运营情况。</p>
<p>看好国内大储市场机遇，关注重点环节参与者。我国是全球最主要的储能市场之一，储能装机有望持续增长。国内储能各环节企业在全球竞争实力强，在国内市场“近水楼台”占据主要份额，分享市场增长红利。对各环节参与者而言，国内大储市场的优势在于准入环境上较海外市场相对友好，无贸易保护风险，确定性强；但局限性在于，储能在新能源配储模式下被视为成本项，存在压价现象，影响企业相关业务的毛利表现。我们认为，国内储能市场具备优良的成长性，且随着储能调用模式和收益模式逐步改善，其低价低质模式有望改善，技术和产品领先的企业毛利率存在改善空间。</p>
<p>（本文仅供参考，不代表我们的任何投资建议。如需使用相关信息，请参阅报告原文。）</p>
<p>精选报告来源：【未来智库】。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新型储能政策专家交流系列2——影响最大的是电网侧的储能</title>
    <url>/2023/06/27/%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD%E6%94%BF%E7%AD%96%E4%B8%93%E5%AE%B6%E4%BA%A4%E6%B5%81%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E5%BD%B1%E5%93%8D%E6%9C%80%E5%A4%A7%E7%9A%84%E6%98%AF%E7%94%B5%E7%BD%91%E4%BE%A7%E7%9A%84%E5%82%A8%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天和大家分享了新型储能政策专家交流系列的第一部分：对于发电侧储能有一定的利好</p>
<p>今天和大家分享第二部分：影响最大的是电网侧的储能</p>
<p>现在我们正常的独立储能基本等同于电网侧储能，独立储能参与市场有几个媒介，第一就是调峰，主要是参与电力现货市场或者辅助服务市场（电力市场又分为几个，中长期市场又分为中长期的零售市场和批发市场，分时电价就属于中长期零售市场）。如果现货市场没有建成的话，当地的市场就主要采用分时电价，如果现货市场建成之后，储能就更多采用的调峰的方式参与电力现货市场。如果电力现货市场没有完全建成，有的省份采用电力现货市场加上调峰的辅助服务两个市场结合的过渡方式。</p>
<p>目前电网侧储能参与电力市场最主要的途径就是电力现货市场或者辅助服务市 场、调峰市场，简单来说就是峰谷差套利，就是在用电低谷的时候把电存储起来， 然后在用电高峰、电价比较高的时候再把电放出去。</p>
<p>为什么这次政策对电网侧的储能影响最大？</p>
<p>因为文件提到，独立储能电站向电网送电的，其相应充电电量不承担输配电价和政府性基金及附加。当低谷充电时，对于电网来说相当于是负荷，而且独立储能电站参与电网调节的要求比较高，基本都是万千瓦时级别以上，有的可以到达几十万千瓦时，容量很大。容量大的储能就相当于一个大用户，它要承担输配电价，这部分成本很大。</p>
<p>这个政策提到，对于满足条件的独立储能电站，充电电量可以不承担输配电价和和政府基金及附加。对于一个正常的工商业用户来讲，基本用的一度电里面50%的成本是上网侧的电价，33%是输配电价，还有14%左右的增值税，和4%左右的政府基金及附加，这两个一共就是37%，大概四成的比例。所以这个政策如果能落实的话，独立储能电站充电的成本可以降低4成，所以对于电网侧独立储能电站影响还是很大的。</p>
<p>独立储能的盈利方面，除了调峰，后面的盈利空间还有调频，主要是参与辅助服务市场，调峰、调频和备用等等。但是这一部分收益不是稳定的，因为辅助服务主要是电网对于储能电站的调用，不是一直都有，而是根据电网的需求。但是调一次的补偿价格很高，可以获得超额收益。所以目前独立储能电站可以获得收益的方式就是调峰加调频。</p>
<p>以后电网侧独立储能获得收益的方式还很多，大概预期比较高就是容量市场。未来的话一些风光发电厂，可以不自建储能，而是通过购买储能电站的指标作为共享储能或者容量租赁，所以独立储能电站可以把容量指标租给周围新能源的运营商，这也是一个盈利的模式。未来独立储能电站主要就是调峰加调频加容量市场。</p>
<p>所以总体来讲的话，这个政策对于电网侧储能影响最大。</p>
<p>新型储能政策专家交流系列的第二部分的内容就分享到这里，明天和大家分享第三部分的内容：对于独立储能电站的运营、投资影响很大</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新型储能政策专家交流系列1——对于发电侧储能有一定的利好</title>
    <url>/2023/06/26/%E6%96%B0%E5%9E%8B%E5%82%A8%E8%83%BD%E6%94%BF%E7%AD%96%E4%B8%93%E5%AE%B6%E4%BA%A4%E6%B5%81%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E5%AF%B9%E4%BA%8E%E5%8F%91%E7%94%B5%E4%BE%A7%E5%82%A8%E8%83%BD%E6%9C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E5%88%A9%E5%A5%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDM4OTE5NA==&amp;mid=2247489497&amp;idx=2&amp;sn=d15d054765364e4dfb65f50cb25b3a45&amp;chksm=fc099afccb7e13ea3b1205d777e1c75776690c83de22d35d7d2655ca5398625c079a8a2699c7&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU2MDM4OTE5NA==&amp;mid=2247489497&amp;idx=2&amp;sn=d15d054765364e4dfb65f50cb25b3a45&amp;chksm=fc099afccb7e13ea3b1205d777e1c75776690c83de22d35d7d2655ca5398625c079a8a2699c7&amp;scene=21#wechat_redirect</a></p>
<p>今天分享第一部分：对于发电侧储能有一定的利好</p>
<p>政策里面提到要鼓励参与市场、推进可再生能源与储能协调发展，目前全国已经有差不多20多个省市已经出台了“可再生能源配套储能政策”，这个储能政策之前是建议，但是现在新上的项目如果要进入保障性购电的名录，就要满足新建的新能源配套的政策要求，各地基本上是10%到20%，大概一两个小时、两三个小时，各地差异蛮大，如果想让更多的电量被电网以保障性购电的价格收购的话，这些储能是必须要配的。</p>
<p>从过去一两年电网、电源侧增长的新型储能配套来看，这些储能基本没有用，这些储能只会增加新能源投资方的成本。因为我们国家除了少数省市（山东）新能源参与电力现货市场有一定的要求外，全国绝大多数省市新能源参与电力市场只对电量有要求，对它的曲线没有严格的执行要求。所以新能源不管发多发少，用不用这些配备的储能的影响都不大。但是这次文件提到，具备独立计量、控制等技术条件，接入调度自动化系统可被电网监控和调度，符合相关标准规范和电力市场运营机构等有关方面要求，具有法人资格的新型储能项目可以转为独立储能，作为独立主体参与市场。</p>
<p>从电网侧来说，这些储能应该是调度口径的，就是能被各级电网公司的调度部门调度的，所以对并网的约束要求高了一些，我们知道火电厂分为正常的并网电场、热电场、自备电厂，自备电场是不属于调度口径管辖的，储能也是，不接入电网、不接受调度的储能不能算是独立储能。这次政策明确了独立储能的定义，但是具体的还要看各地的具体政策。</p>
<p>总的来说，对发电侧的储能有一定的好处，新能源配的储能有最低要求，为了 保障新能源自己建的电厂的正常运行，要求内的部分储能是不能动的，比如一 百万千瓦的光伏电站，要配一个10万千瓦、持续一个小时的储能，这个10万千瓦、一个小时的储能是不能转为独立储能自己用的，只有超过配储能要求的部分才有条件转为独立储能参与电力市场，并不是只要满足条件都可以转为独立储能。对于新能源运营商，通过再建一个公司，可以把租赁的、第三方投资的储能，或者是自己的配套储能，转到一个独立的法人，这样是有条件将它们转化成独立储能的。</p>
<p>所以，对于新能源的投资方是有利好的，但是这个政策还没有落地，还只是一个建议稿，没有具体的数字，不是特别明确，但总的来说还是有价值的。</p>
<p>新型储能政策专家交流系列的第一部分的内容就分享到这里，明天和大家分享第二部分的内容：影响最大的是电网侧的储能</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>iEMS智慧能源综合管理系统</title>
    <url>/2023/06/25/iEMS%E6%99%BA%E6%85%A7%E8%83%BD%E6%BA%90%E7%BB%BC%E5%90%88%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电享科技智慧储能与微网管理系统，简称iEMS，可实现对能源微网和光储充电站的设备数据采集和协调控制，为系统安全、稳定、高效运行提供保障，使经济效益有效提高。</p>
<p>通过Energy AI技术，对海量能源运行数据进行采集和深度分析,对智能电网模型、太阳能和风能模型、BSS运营模型、需求侧数据模型等持续模拟训练，实现了精准的需求侧响应、发电量预测、BSS运营预测致力于推动与实现“碳达峰、碳中和”目标。</p>
<h1 id="产品优势"><a href="#产品优势" class="headerlink" title="产品优势"></a>产品优势</h1><h2 id="智能化运行策略"><a href="#智能化运行策略" class="headerlink" title="智能化运行策略"></a>智能化运行策略</h2><p>内置科学高效化的多套运行策略，可根据实际需求自动选择与切换</p>
<h2 id="智能AI算法模型"><a href="#智能AI算法模型" class="headerlink" title="智能AI算法模型"></a>智能AI算法模型</h2><p>自学习的微网控制算法模型，适配实际环境，追求更高收益。</p>
<h2 id="电池全生命周期管理"><a href="#电池全生命周期管理" class="headerlink" title="电池全生命周期管理"></a>电池全生命周期管理</h2><p>远程体检获取储能电池健康数据，为光储充电站生命周期保驾护航。</p>
<h2 id="丰富的API接口"><a href="#丰富的API接口" class="headerlink" title="丰富的API接口"></a>丰富的API接口</h2><p>提供丰富多样的API接口实现与第三方生态伙伴的设备与系统对接。</p>
<h2 id="兼容性强"><a href="#兼容性强" class="headerlink" title="兼容性强"></a>兼容性强</h2><p>广泛兼容市场主流的光伏、储能、充电桩设备厂家。</p>
<h2 id="多业务场景"><a href="#多业务场景" class="headerlink" title="多业务场景"></a>多业务场景</h2><p>灵活适用于光伏、储能、充电桩、光储充一体等多种业务场景。</p>
<h2 id="云端集控"><a href="#云端集控" class="headerlink" title="云端集控"></a>云端集控</h2><p>云端+场站架构，既可以实现单场站本地部署，也可以实现站群云端管理。</p>
<h2 id="灵活配置"><a href="#灵活配置" class="headerlink" title="灵活配置"></a>灵活配置</h2><p>针对不同的业务场景，可灵活按需配置功能组件，包括储能管理、光伏管理充电站管理等。</p>
<h1 id="产品功能"><a href="#产品功能" class="headerlink" title="产品功能"></a>产品功能</h1><h2 id="实时数据监测"><a href="#实时数据监测" class="headerlink" title="实时数据监测"></a>实时数据监测</h2><ul>
<li>7*24小时实时精准展示市电、光伏、储能、充电桩、微网的运行数据。</li>
<li>以多维度的数据分析与统计能耗与收益数据，并可视化展示。</li>
<li>支持场站与云端远程随时随地实时掌控电站状态。</li>
<li>场站运行报表实时推送。</li>
</ul>
<h2 id="能耗分析"><a href="#能耗分析" class="headerlink" title="能耗分析"></a>能耗分析</h2><ul>
<li>设备全生命周期管理，分析异常点规律。</li>
<li>数据相关性分析，找到设备、策略与能耗的关系。</li>
<li>找到能耗优化点，提升能源转换效率。</li>
</ul>
<h2 id="智能预测"><a href="#智能预测" class="headerlink" title="智能预测"></a>智能预测</h2><ul>
<li>负荷的预测与调控。</li>
<li>需求侧响应分析预测与管理。</li>
<li>光伏发电预测分析。</li>
<li>电池充放电模型分析，SOH预测。</li>
</ul>
<h2 id="高效管理"><a href="#高效管理" class="headerlink" title="高效管理"></a>高效管理</h2><ul>
<li>设备异常与故障及时预警通知。</li>
<li>线上线下24小时高效运维管理。</li>
<li>集控管理，运行策略下发电站。</li>
<li>智慧组网大屏，能源驾驶舱。</li>
</ul>
<h1 id="用户价值"><a href="#用户价值" class="headerlink" title="用户价值"></a>用户价值</h1><h2 id="家庭用户"><a href="#家庭用户" class="headerlink" title="家庭用户"></a>家庭用户</h2><p>帮助用户有效地实现了绿色能源的自发自用，节省电费，保障24小时用电需求。</p>
<h2 id="商业楼宇"><a href="#商业楼宇" class="headerlink" title="商业楼宇"></a>商业楼宇</h2><p>助力管理方全方位把控商业建筑用能监测，保障用能安全，创造高效、舒适楼宇管理体验和用户体验。</p>
<h2 id="工厂企业"><a href="#工厂企业" class="headerlink" title="工厂企业"></a>工厂企业</h2><p>安全生产，节能减排，提升效益，承担社会责任，树立绿色生产优质企业形象。</p>
<h2 id="产业园区"><a href="#产业园区" class="headerlink" title="产业园区"></a>产业园区</h2><p>提高园区供电可靠性，降低园区用能成本、提升新能源消费比例。</p>
<h2 id="能源投资运营商"><a href="#能源投资运营商" class="headerlink" title="能源投资运营商"></a>能源投资运营商</h2><p>能源综合利用，服务用户，实现商用目标，增加收益。</p>
<h2 id="新能源OEM"><a href="#新能源OEM" class="headerlink" title="新能源OEM"></a>新能源OEM</h2><p>实现动力电池梯次利用，降低电池成本。</p>
<h2 id="EPC"><a href="#EPC" class="headerlink" title="EPC"></a>EPC</h2><p>配合总包单位完成客户需求，提升总包竞争力。</p>
<h2 id="发电侧"><a href="#发电侧" class="headerlink" title="发电侧"></a>发电侧</h2><p>平滑新能源发电，提高新能源消纳能力，减少弃风弃光</p>
<h1 id="客户案例"><a href="#客户案例" class="headerlink" title="客户案例"></a>客户案例</h1><h2 id="CQC中认南信光储充一体化"><a href="#CQC中认南信光储充一体化" class="headerlink" title="CQC中认南信光储充一体化"></a>CQC中认南信光储充一体化</h2><ul>
<li><p>项目概括：<br>南京信息职业技术学院光储充一体化实训教学项目由南京信息职业技术学院、中认南信(江苏)检测技术有限公司、上海电享信息科技有限公司合作建设，于2021年2月正式投入运行，项目规模为屋顶光伏+储能电站+梯次利用电池+直流充电桩+交流充电桩，其中储能电池容量可根据实验和教学需要进行拓展。</p>
</li>
<li><p>项目价值：<br>本项目同时配置了上海电享信息科技自主开发的智慧能源管理系统（iEMS），实现了对光储充微电网的数据采集、数据分析、策略切换和协调控制，可进行梯次利用电池应用、电池大数据分析、光储充一体化微电网系统、电动汽车V2G技术、能源数字化等领域的实验研究工作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>海南自贸港首个电网侧独立储能项目开工</title>
    <url>/2023/06/24/%E6%B5%B7%E5%8D%97%E8%87%AA%E8%B4%B8%E6%B8%AF%E9%A6%96%E4%B8%AA%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%B7%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>9月16日，南方电网公司海南海口电网侧独立储能项目开工。这是海南自贸港首个电网侧独立储能项目。</p>
<p>该项目位于海口市秀英区药谷开发区。近年来，随着海口药谷企业集聚，药谷变电站主变负载率持续增长，存在主变重过载情况。项目建成后，将大幅缓解药谷开发区用电负荷紧张和药谷变电站主变重过载情况，提高药谷片区的供电可靠性。</p>
<p>海南海口药谷电网侧独立电池储能项目规模5MW/10MWh，由南方电网调峰调频(广东)储能科技有限公司建设。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>南方电网首个百兆瓦时级电网侧独立储能项目开工</title>
    <url>/2023/06/23/%E5%8D%97%E6%96%B9%E7%94%B5%E7%BD%91%E9%A6%96%E4%B8%AA%E7%99%BE%E5%85%86%E7%93%A6%E6%97%B6%E7%BA%A7%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%B7%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日，调峰调频公司广东梅州五华、海南海口药谷电网侧独立电池储能项目正式开工，预计今年年底并网投产。</p>
<p>据了解，广东梅州五华电网侧独立电池储能项目规模为70MW/140WMh，位于广东省梅州市五华县河东工业园区，是广东省能源局和南方电网公司的示范项目，也是南方电网首个百兆瓦时级电网侧独立储能项目。该项目首次研发应用浸没式储能电池系统，可有效提升消防安全性，建成后将助力“双碳”目标实现，服务新型电力系统建设，有效促进新能源就地消纳，保障电力系统安全稳定运行。</p>
<p>海南海口药谷电网侧独立电池储能项目规模为5MW/10MWh，位于海南省海口市秀英区药谷开发区，是调峰调频公司服务海南加快建设自由贸易港和新型电力系统建设先行地的具体措施。目前药谷变电站主变负载率持续增长，存在主变重过载情况。项目建成后，将大幅缓解药谷开发区用电负荷紧张和药谷变电站主变重过载情况，提高药谷片区的供电可靠性，为海南电网提供优质辅助服务。</p>
<p>调峰调频公司表示，下一步将科学规划建设绿色储能电站，发挥电池储能电站启停迅速、实时跟随电网需求的优势，充分体现储能电站综合效益，大力促进新能源消纳，为推动构建新型电力系统、实现“双碳”目标提供有力保障，为地方经济社会发展提供坚强电力支撑。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽首个电网侧独立储能项目在宣城市宣州区成功并网</title>
    <url>/2023/06/22/%E5%AE%89%E5%BE%BD%E9%A6%96%E4%B8%AA%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%AE%A3%E5%9F%8E%E5%B8%82%E5%AE%A3%E5%B7%9E%E5%8C%BA%E6%88%90%E5%8A%9F%E5%B9%B6%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日，安徽省首个电网侧独立储能项目在宣城市宣州区成功并网。该项目投产运行后，可有效提升电网消纳能力，提升电网系统弹性和灵活性，标志着我省电网侧新型储能应用实现新突破。</p>
<p>宣城项目一期并网规模达到20MW/20MWh，通过全生命周期储能安全系统技术和系统融合技术创新应用，适用于调峰、调频等多种应用场景，具备毫秒级功率响应速度，可实现充放电快速转换，安全、高效、可靠。项目投产运行后，可大幅提升我省电网利用效率，“平滑”光伏与风电的间歇性、波动性出力，有利于新能源消纳。</p>
<p>近年来，我省大力推进以新能源为主体的新型电力系统建设，积极推动能源绿色低碳转型。截至2021年底，全省累计建成可再生能源装机容量2965万千瓦，占总装机容量的35.02%。随着新能源渗透率持续提升，电网面临接入消纳能力不足的考验。在当前火力调峰等其他调峰能力受限情况下，电网侧储能成为全行业关注的电网接入消纳解决方案。省能源发展“十四五”规划明确提出探索电化学储能等新型储能应用，提高新能源消纳和存储能力，力争到2025 年全省电化学等新型储能规模达到300万千瓦。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>浙江首个大型电网侧独立储能项目完成并网测试</title>
    <url>/2023/06/21/%E6%B5%99%E6%B1%9F%E9%A6%96%E4%B8%AA%E5%A4%A7%E5%9E%8B%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E5%B9%B6%E7%BD%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日，浙江萧电储能电站完成首个大型电网侧独立储能项目并网测试工作。该项目采用智光电气技术研制的6-35kV/移动式储能/新能源并网检测装置。</p>
<p>据了解，萧电储能电站是浙江省内首个大型电网侧独立储能示范项目，该项目利用萧电一期两台退役燃煤机组场地建设，建设规模为100MW/200MWh，第一阶段配置储能容量为50MW/100MWh，其参与电网AGC频率调节能力相当于2台60万级燃煤机组，是一座集中布置、集中调控、独立统调的大型电化学储能示范电站。本次并网测试可全面体现储能电站的并网特性，保障其并网后安全可靠运行，为储能电站在电网侧大规模推广应用提供经验借鉴。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>万里扬：预计2022年全年盈利，电网侧独立储能电站是今年发展重点</title>
    <url>/2023/06/20/%E4%B8%87%E9%87%8C%E6%89%AC%EF%BC%9A%E9%A2%84%E8%AE%A12022%E5%B9%B4%E5%85%A8%E5%B9%B4%E7%9B%88%E5%88%A9%EF%BC%8C%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E7%94%B5%E7%AB%99%E6%98%AF%E4%BB%8A%E5%B9%B4%E5%8F%91%E5%B1%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1月14日，万里扬发布业绩预告，预计2022年全年盈利3亿元至4亿元，同比上年增140.14%至153.51%。</p>
<p>公告中解释本次业绩变动的原因为：“2022年得益于奇瑞汽车销量大幅增长，公司配套奇瑞汽车的乘用车变速器业务经营情况良好；纯电动车减速器产品前期研发和客户开拓都比较顺利，预计从2023年开始陆续会有一些新的车型产品量产，这块业务的增量空间较大。”</p>
<p>据悉，公司预计今年会有多个新能源汽车零部件新项目落地，同时将开工并建成多个电网侧独立储能电站。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>浙江宁波最大电网侧独立储能电站并网</title>
    <url>/2023/06/19/%E6%B5%99%E6%B1%9F%E5%AE%81%E6%B3%A2%E6%9C%80%E5%A4%A7%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E7%94%B5%E7%AB%99%E5%B9%B6%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浙江宁波首个百万兆瓦时级别储能电站——朗辰储能电站项目的升压站日前顺利并网。</p>
<p>朗辰储能电站是目前宁波地区最大的电网侧独立储能电站项目，该项目属于电化学储能电站，于去年被列入浙江省“十四五”第一批新型储能示范项目。</p>
<p>本期建设规模为50兆瓦/100兆瓦时，主要采用磷酸铁锂、钛酸锂两种电池，在用电低谷时充满电、在用电高峰时释放电，其中磷酸铁锂电池用于调峰、钛酸锂电池用于调频。</p>
<p>该储能项目预计今年6月完全投产后，每天最高可为宁波地区提供约100MWh错峰电量，不仅能缓解用电高峰期的变电站供电压力，同时也为迎峰度夏增添保障。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>甘肃酒泉：年内计划电网侧独立储能装机达26万千瓦以上、力争电源侧储能达80万千瓦</title>
    <url>/2023/06/18/%E7%94%98%E8%82%83%E9%85%92%E6%B3%89%EF%BC%9A%E5%B9%B4%E5%86%85%E8%AE%A1%E5%88%92%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E8%A3%85%E6%9C%BA%E8%BE%BE26%E4%B8%87%E5%8D%83%E7%93%A6%E4%BB%A5%E4%B8%8A%E3%80%81%E5%8A%9B%E4%BA%89%E7%94%B5%E6%BA%90%E4%BE%A7%E5%82%A8%E8%83%BD%E8%BE%BE80%E4%B8%87%E5%8D%83%E7%93%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近年来，酒泉市抢抓“双碳”机遇，紧紧围绕新能源大基地建设，开启新一轮新能源大规模开发，新能源装机累计达到2102万千瓦，占总电力装机的84.2%，新能源高占比电源系统特征明显。</p>
<p>一是电源装机规模较大。持续加强调峰火电灵活性改造，完成了华能酒泉热电厂1、2号机组30%超低负荷安全运行灵活性深度调峰改造，机组启停调峰期间，河西地区新能源消纳能力可增加19.8万千瓦时，增发新能源电量435.6万千瓦时；建成祁绍直流配套常乐电厂一期2×100万千瓦配套调峰火电项目，今年年底前常乐电厂二期2×100万千瓦调峰火电项目建成投运后，祁绍直流外送能力将提升至800万千瓦。常乐电厂三期2×100万千瓦省内消纳调峰火电项目开工建设，预计2025年建成投运。常乐电厂一、二、三期全部投运后，可支撑河西地区新能源基地年均发电600亿千瓦时，外送400亿千瓦时，为酒泉乃至全省构建以新能源为主体的新型电力系统，实现火电和新能源大范围优化配置和打捆送出创造了有利条件。积极配建电源侧新型储能电站，目前全市新能源配建电源侧新型储能电站23万千瓦，力争年内规模达到80万千瓦。建成光热装机21万千瓦，在建装机51万千瓦，力争年内全市光热装机达到72万千瓦，为加速构建新型电力系统提供强力支撑。</p>
<p>二是电网外送能力较强。建成祁韶直流±800千伏特高压直流通道1条，750千伏变电站4座，公网330千伏变电站12座，对外通过9条750千伏输电线路与周边电网连接，形成了以750千伏酒泉变、莫高变、敦煌变、沙洲变为中心的坚强主网结构。玉门、金塔2个750千伏输变电工程已完成核准，建成后玉门、金塔片区可新增新能源接入能力680万千瓦，酒泉新能源基地电力输送能力将进一步提升，网架结构进一步优化。全市建成电网侧储能电站6万千瓦，年内计划电网侧独立储能电站装机规模达到26万千瓦以上。</p>
<p>三是负荷示范作用突出。加快推进宝丰多晶硅上下游协同项目建设，按照“虚拟电厂”电价模式结算电量电费，项目计划年内建成投运；加大“源网荷储”一体化项目示范应用，全市列入全省“十四五”首批“源网荷储”一体化示范项目装机规模70万千瓦。按照源、网、储项目与负荷项目同步规划、同步建设、同步投产的原则，积极稳妥推动“源网荷储”一体化项目建设，尽快形成可复制、可应用、可推广的新型负荷侧电力系统建设经验，逐步扩大“源网荷储”一体化项目建设规模。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>内蒙古首个电网侧独立储能电站成功并网</title>
    <url>/2023/06/17/%E5%86%85%E8%92%99%E5%8F%A4%E9%A6%96%E4%B8%AA%E7%94%B5%E7%BD%91%E4%BE%A7%E7%8B%AC%E7%AB%8B%E5%82%A8%E8%83%BD%E7%94%B5%E7%AB%99%E6%88%90%E5%8A%9F%E5%B9%B6%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日，内蒙古自治区首个电网侧独立储能项目——乌兰察布远景能源关键节点电网侧储能电站示范项目接网工程完成核相工作，各项参数正常，一、二次设备运行正常，并网成功。该项目对于提升地区新能源消纳能力、电网调峰能力具有重要意义，也标志着内蒙古自治区电网侧新型储能应用实现新突破。</p>
<p>乌兰察布远景能源关键节点电网侧储能电站示范项目作为内蒙古重点新型储能示范项目，对于落实“双碳”目标具有示范意义。内蒙古电力集团乌兰察布供电公司高度重视项目的建设，以最大力度支持储能电站并网投产工作，自项目启动以来，乌兰察布供电公司争取以最短的时间完成了电网配套项目的核准工作，于2022年6月15日开工建设。为满足客户需求，为项目扩建35千伏出线1回，并采用电缆沟直埋的方式敷设280米新建单回电缆，电缆直接通至用户侧，项目在220千伏杭宁达莱变电站建成60兆瓦时储能电站，最大充放电功率达30兆瓦。</p>
<p>在项目建设中，乌兰察布供电公司大力压缩电网侧各环节的时限，提高电力部门介入的服务效率和可靠性。在项目投运前，各专业协调联动，主动提供电力延伸服务，帮助客户完成电网侧工程验收以及并网调度协议签订在内的全流程、各环节工作，体贴入微的供电服务得到了客户的高度评价。</p>
<p>储能电站的建设，有利于提升220千伏杭宁达莱变的供电能力、增大电网调峰调频的能力、提高供电可靠性；对于促进新能源消纳、优化潮流分布、积累电网侧储能运行经验，推动源网荷储系统升级应用起到了示范引领作用。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle内存信息查询</title>
    <url>/2023/06/16/Oracle%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SGA是系统全局区，是Oracle中可以共享的内存。</p>
<p>1、关联业务表</p>
<pre><code>select * from v$sga; 
select * from v$sgainfo;
select * from v$memory_dynamic_components;
select * from v$sgastat
</code></pre>
<p>Fixed Size 是固定区域，用于存储SGA各组件的信息。固定区域的大小随平台和版本而变化。<br>Variable Size  是可变区域，包括共享池、Java池、大池。<br>Database Buffers 是数据库高速缓冲区。<br>Redo Buffers 是重做日志缓冲区。</p>
<p>2、关联查询</p>
<p>2.1、查看高速缓冲区（Database Buffer Cache）的实际大小</p>
<pre><code>select name,bytes/1024/1024 || &#39;M&#39; from v$sgainfo 
    where name = &#39;Buffer Cache Size&#39;;
</code></pre>
<p>2.2、查看共享池(Shared Pool)的实际大小</p>
<pre><code>select name,bytes/1024/1024 || &#39;M&#39; from v$sgainfo
    where name = &#39;Shared Pool Size&#39;;

select component,(current_size/1024/1024) || &#39;M&#39; from v$memory_dynamic_components
    where component =&#39;shared pool&#39;;
</code></pre>
<p>2.3、查看JAVA池的实际大小</p>
<pre><code>select name,bytes/1024/1024 || &#39;M&#39; from v$sgainfo
    where name = &#39;Java Pool Size&#39;;
 
select component,(current_size/1024/1024) || &#39;M&#39; from v$memory_dynamic_components
    where component =&#39;java pool&#39;;
</code></pre>
<p>2.4、查看大池的实际大小</p>
<pre><code>select name,bytes/1024/1024 || &#39;M&#39; from v$sgainfo
    where name = &#39;Large Pool Size&#39;;
 
select component,(current_size/1024/1024) || &#39;M&#39; from v$memory_dynamic_components
    where component =&#39;large pool&#39;;
</code></pre>
<p>2.5、查看 共享池、JAVA池、大池的剩余空间</p>
<pre><code>---共享池的剩余空间
select * from v$sgastat where name = &#39;free memory&#39; and Pool = &#39;shared pool&#39;;
 
---JAVA池的剩余空间
select * from v$sgastat where name = &#39;free memory&#39; and Pool = &#39;java pool&#39;;
 
---大池的剩余空间
select * from v$sgastat where name = &#39;free memory&#39; and Pool = &#39;large pool&#39;;
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>关于oracle数据库性能监控指标（二）</title>
    <url>/2023/06/15/%E5%85%B3%E4%BA%8Eoracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、查看版本号</p>
<pre><code>SELECT * FROM v$version;
</code></pre>
<p>2、查看进程信息</p>
<pre><code>--查看系统当前进程的连接数
select count(*) from v$process;
--查看当前系统允许的进程连接数
select value from v$parameter where name = &#39;processes&#39;;
</code></pre>
<p>3、当前连接会话数以及当前并发连接个数</p>
<pre><code>--查看系统当前会话的连接数
select count(*) from v$session;
--查看当前系统的并发连接数
select count(*) from v$session where status=&#39;ACTIVE&#39;;
--当前活跃用户会话数
Select count(*)from v$session where status=&#39;ACTIVE&#39; and USERNAME is not null;
--当前活跃系统会话数
Select count(*)from v$session where USER#=0;
--当前非活跃会话数
Select count(*)from v$session where status=&#39;INACTIVE&#39;;
</code></pre>
<p>4、数据库实例上次重启时间</p>
<pre><code>select instance_name, to_char(startup_time,&#39;mm/dd/yyyy hh24:mi:ss&#39;) as startup_time from v$instance;

SELECT * FROM v$instance;
</code></pre>
<p>5、查询表空间使用率</p>
<pre><code>--查看数据文件大小
select file_name, bytes / 1024 / 1024 || &#39;M&#39; &quot;size&quot; from dba_data_files;
select name, bytes / 1024 / 1024 as M from v$datafile;
select * from dba_data_files;

select a.tablespace_name, total, free, (total - free) as usage
  from (select tablespace_name, sum(bytes) / 1024 / 1024 as total
          from dba_data_files
         group by tablespace_name) a,
       (select tablespace_name, sum(bytes) / 1024 / 1024 as free
          from dba_free_space
         group by tablespace_name) b
 where a.tablespace_name = b.tablespace_name
 ORDER BY 1;

SELECT UPPER(F.TABLESPACE_NAME) &quot;表空间名&quot;,
       D.TOT_GROOTTE_MB &quot;表空间大小(M)&quot;,
       D.TOT_GROOTTE_MB - F.TOTAL_BYTES &quot;已使用空间(M)&quot;,
       TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,
                     2),
               &#39;990.99&#39;) || &#39;%&#39; &quot;使用比&quot;,
       F.TOTAL_BYTES &quot;空闲空间(M)&quot;,
       F.MAX_BYTES &quot;最大块(M)&quot;
  FROM (SELECT TABLESPACE_NAME,
               ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES,
               ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES
          FROM SYS.DBA_FREE_SPACE
         GROUP BY TABLESPACE_NAME) F,
       (SELECT DD.TABLESPACE_NAME,
               ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB
          FROM SYS.DBA_DATA_FILES DD
         GROUP BY DD.TABLESPACE_NAME) D
 WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME
 ORDER BY 1;
</code></pre>
<p>6、查看总消耗时间最多的前10条SQL语句</p>
<pre><code>select *
  from (select v.sql_id,
               v.child_number,
               v.sql_text,
               v.elapsed_time,
               v.cpu_time,
               v.disk_reads,
               rank() over(order by v.elapsed_time desc) elapsed_rank
          from v$sql v) a
 where elapsed_rank &lt;= 10;
</code></pre>
<p>7、查看CPU消耗时间最多的前10条SQL语句</p>
<pre><code>select *
  from (select v.sql_id,
               v.child_number,
               v.sql_text,
               v.elapsed_time,
               v.cpu_time,
               v.disk_reads,
               rank() over(order by v.cpu_time desc) elapsed_rank
          from v$sql v) a
 where elapsed_rank &lt;= 10;
</code></pre>
<p>8、查看消耗磁盘读取最多的前10条SQL语句</p>
<pre><code>select *
  from (select v.sql_id,
               v.child_number,
               v.sql_text,
               v.elapsed_time,
               v.cpu_time,
               v.disk_reads,
               rank() over(order by v.disk_reads desc) elapsed_rank
          from v$sql v) a
 where elapsed_rank &lt;= 10;
</code></pre>
<p>9、IOps和IO吞吐量 （oracle 11g）</p>
<pre><code>select sum(decode(name,
                  &#39;physical read IO requests&#39;,
                  value,
                  &#39;physical write IO requests&#39;,
                  value,
                  0)) as iops,
       sum(decode(name,
                  &#39;physical read bytes&#39;,
                  value,
                  &#39;physical write bytes&#39;,
                  value,
                  0)) / 1024 / 1024 as mbps
  from v$sysstat
 where name in (&#39;physical read IO requests&#39;,
                &#39;physical write IO requests&#39;,
                &#39;physical read bytes&#39;,
                &#39;physical read total bytes&#39;,
                &#39;physical write bytes&#39;,
                &#39;physical write total bytes&#39;,
                &#39;physical read total IO requests&#39;,
                &#39;physical write total IO requests&#39;);

SELECT sum(decode(name,
                  &#39;physical read IO requests&#39;,
                  value,
                  &#39;physical write lO requests&#39;,
                  value,
                  0)) AS iops,
       sum(decode(name,
                  &#39;physical read bytes&#39;,
                  value,
                  &#39;physical write bytes&#39;,
                  value,
                  0)) / 1024 / 1024 AS mbps
  FROM v$sysstat
 WHERE name IN (&#39;physical read IO requests&#39;,
                &#39;physical write IO requests&#39;,
                &#39;physical read bytes&#39;,
                &#39;physical read total bytes&#39;,
                &#39;physical write bytes&#39;,
                &#39;physical write total bytes&#39;,
                &#39;physical read total IO requests&#39;,
                &#39;physical write total IO requests&#39;);
 
</code></pre>
<p>10、内存使用情况</p>
<p>SGA / PGA 使用情况<br>– pctused: 使用率</p>
<pre><code>select name,
       total,
       round(total - free, 2) used,
       round(free, 2) free,
       round((total - free) / total * 100, 2) pctused
  from (select &#39;SGA&#39; name,
               (select sum(value / 1024 / 1024) from v$sga) total,
               (select sum(bytes / 1024 / 1024)
                  from v$sgastat
                 where name = &#39;free memory&#39;) free
          from dual)
union
select name,
       total,
       round(used, 2) used,
       round(total - used, 2) free,
       round(used / total * 100, 2) pctused
  from (select &#39;PGA&#39; name,
               (select value / 1024 / 1024 total
                  from v$pgastat
                 where name = &#39;aggregate PGA target parameter&#39;) total,
               (select value / 1024 / 1024 used
                  from v$pgastat
                 where name = &#39;total PGA allocated&#39;) used
          from dual);
</code></pre>
<p>11、查询执行最慢的sql</p>
<pre><code>select *
  from (select sa.SQL_TEXT,
               sa.SQL_FULLTEXT,
               sa.EXECUTIONS &quot;执行次数&quot;,
               round(sa.ELAPSED_TIME / 1000000, 2) &quot;总执行时间&quot;,
               round(sa.ELAPSED_TIME / 1000000 / sa.EXECUTIONS, 2) &quot;平均执行时间&quot;,
               sa.COMMAND_TYPE,
               sa.PARSING_USER_ID &quot;用户ID&quot;,
               u.USERNAME &quot;用户名&quot;,
               sa.HASH_VALUE
          from v$sqlarea sa
          left join all_users u
            on sa.PARSING_USER_ID = u.user_id
         where sa.EXECUTIONS &gt; 0
         order by sa.ELAPSED_TIME / sa.EXECUTIONS desc)
 where rownum &lt;= 50;
</code></pre>
<p>12、查询次数最多的sql</p>
<pre><code>select *
 from (select s.SQL_TEXT,
        s.EXECUTIONS &quot;执行次数&quot;,
        s.PARSING_USER_ID &quot;用户名&quot;,
        rank() over(order by EXECUTIONS desc) EXEC_RANK
     from v$sql s
     left join all_users u
      on u.USER_ID = s.PARSING_USER_ID) t
 where exec_rank &lt;= 100;
</code></pre>
<p>13、Oracl查询SQL语句执行的耗时</p>
<pre><code>select a.sql_text SQL语句,
       b.etime 执行耗时,
       c.user_id 用户ID,
       c.SAMPLE_TIME 执行时间,
       c.INSTANCE_NUMBER 实例数,
       u.username 用户名, a.sql_id SQL编号
  from dba_hist_sqltext a,
       (select sql_id, ELAPSED_TIME_DELTA / 1000000 as etime
          from dba_hist_sqlstat
         where ELAPSED_TIME_DELTA / 1000000 &gt;= 1) b,
       dba_hist_active_sess_history c,
       dba_users u
 where a.sql_id = b.sql_id
   and u.username = &#39;SYNC_PLUS_1_20190109&#39;
   and c.user_id = u.user_id
   and b.sql_id = c.sql_id
  -- and a.sql_text like &#39;%insert into GK_ZWVCH_HSC_NEW      select  %&#39;
 order by  SAMPLE_TIME desc,
  b.etime desc;
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>关于oracle数据库性能监控指标（一）</title>
    <url>/2023/06/14/%E5%85%B3%E4%BA%8Eoracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、当前连接会话数以及当前并发连接个数</p>
<pre><code>-- 当前活跃用户会话数
Select count(*) from v$session where status=&#39;ACTIVE&#39; and USERNAME is not null;
-- 当前活跃系统会话数
Select count(*) from v$session where USER# = 0;
-- 当前非活跃会话数
Select count(*) from v$session where status=&#39;INACTIVE&#39;
</code></pre>
<p>2、表空间利用率(各个表空间的大小以及使用情况)</p>
<pre><code>SELECT UPPER(F.TABLESPACE_NAME) &quot;表空间名&quot;,
       D.TOT_GROOTTE_MB &quot;表空间大小(M)&quot;,
       D.TOT_GROOTTE_MB - F.TOTAL_BYTES &quot;已使用空间(M)&quot;,
       TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,
                     2),
               &#39;990.99&#39;) || &#39;%&#39; &quot;使用比&quot;,
       F.TOTAL_BYTES &quot;空闲空间(M)&quot;,
       F.MAX_BYTES &quot;最大块(M)&quot;
  FROM (SELECT TABLESPACE_NAME,
               ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES,
               ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES
          FROM SYS.DBA_FREE_SPACE
         GROUP BY TABLESPACE_NAME) F,
       (SELECT DD.TABLESPACE_NAME,
               ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB
          FROM SYS.DBA_DATA_FILES DD
         GROUP BY DD.TABLESPACE_NAME) D
 WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME
 ORDER BY 1;
</code></pre>
<p>3、Oracle IOPS(每秒的IO)和吞吐量</p>
<p>网上给出的答案是这样的。我对这个答案有一些疑惑，如果是物理io请求，那么这样得到的是io的总数，而不是每秒的io啊，另一个方法请看第 18 条。</p>
<pre><code>SELECT sum(decode(name,
                  &#39;physical read IO requests&#39;,
                  value,
                  &#39;physical write IO requests&#39;,
                  value,
                  0)) AS iops,
       sum(decode(name,
                  &#39;physical read bytes&#39;,
                  value,
                  &#39;physical write bytes&#39;,
                  value,
                  0)) / 1024 / 1024 AS mbps
  FROM v$sysstat
 WHERE name IN (&#39;physical read IO requests&#39;,
                &#39;physical write IO requests&#39;,
                &#39;physical read bytes&#39;,
                &#39;physical read total bytes&#39;,
                &#39;physical write bytes&#39;,
                &#39;physical write total bytes&#39;,
                &#39;physical read total IO requests&#39;,
                &#39;physical write total IO requests&#39;);
</code></pre>
<p>4、碎片程度</p>
<pre><code>SELECT tablespace_name,
       round(sqrt(max(blocks) / sum(blocks)) *
             (100 / sqrt(sqrt(count(blocks)))),
             2) FSFI
  FROM dba_free_space
 GROUP BY tablespace_name
 ORDER BY 1;
</code></pre>
<p>5、高速缓存命中率</p>
<pre><code>-- 高速缓存命中率
SELECT NAME,
       PHYSICAL_READS,
       DB_BLOCK_GETS,
       CONSISTENT_GETS,
       1 - (PHYSICAL_READS / (DB_BLOCK_GETS + CONSISTENT_GETS)) &quot;Hit Ratio&quot;
  FROM V$BUFFER_POOL_STATISTICS
 WHERE NAME = &#39;DEFAULT&#39;;
-- 或者
SELECT physical_reads,
       db_block_gets,
       consistent_gets,
       NAME,
       100 * (1 - (physical_reads /
       (consistent_gets + db_block_gets - physical_reads))) &quot;Data Buffer Hit Ratio&quot;
  FROM v$buffer_pool_statistics;

-- 共享池命中率
select sum(pinhits - reloads) / sum(pins) * 100 &quot;hit radio&quot;
  from v$librarycache;

-- 共享区字典缓冲区命中率
select sum(gets - getmisses - usage - fixed) / sum(gets) from v$rowcache;

-- 共享区缓存命中率
select sum(pins - reloads) / sum(pins) from v$librarycache;
</code></pre>
<p>6、库高速缓存命中率</p>
<pre><code>SELECT TO_CHAR(ROUND((1 - SUM(getmisses) / SUM(gets)) * 100, 1)) || &#39;%&#39; &quot;Dictionary Cache Hit Ratio&quot;
  FROM v$rowcache;
</code></pre>
<p>7、字典缓存命中率</p>
<pre><code>SELECT sum(gets - getmisses - usage - fixed) / sum(gets) FROM v$rowcache;
</code></pre>
<p>8、空闲的共享池内存</p>
<pre><code>SELECT *
  FROM V$SGASTAT
 WHERE NAME = &#39;free memory&#39;
   AND POOL = &#39;shared pool&#39;;
</code></pre>
<p>9、共享池使用率</p>
<pre><code>SELECT (1 - ROUND(BYTES / (select sum(value) &quot;total sga MB&quot; from v$sga), 2)) * 100 || &#39;%&#39;
  FROM V$SGASTAT
 WHERE NAME = &#39;free memory&#39;
   AND POOL = &#39;shared pool&#39;;
</code></pre>
<p>10、数据库服务启动时间</p>
<pre><code>select * from sys.v_$instance;
</code></pre>
<p>11、共享缓冲池中重做日志命中率</p>
<pre><code>SELECT name,
       gets,
       misses,
       immediate_gets,
       immediate_misses,
       Decode(gets, 0, 0, misses / gets * 100) ratio1,
       Decode(immediate_gets + immediate_misses,
              0,
              0,
              immediate_misses / (immediate_gets + immediate_misses) * 100) ratio2
  FROM v$latch
 WHERE name IN (&#39;redo allocation&#39;, &#39;redo copy&#39;);
</code></pre>
<p>12、当前oracle所有进程执行进度</p>
<pre><code>--当前进程的数量
select count(*) from v$process;

SELECT A.USERNAME,
       A.TARGET,
       A.SID,
       a.SERIAL#,
       A.OPNAME,
       ROUND(A.SOFAR * 100 / A.TOTALWORK, 0) || &#39;%&#39; AS &quot;执行进度&quot;,
       A.TIME_REMAINING &quot;剩余秒数&quot;,
       TRUNC(A.TIME_REMAINING / 60, 2) &quot;剩余分钟&quot;,
       TRUNC(A.TIME_REMAINING / 60 / 60, 2) &quot;剩余小时&quot;,
       B.SQL_TEXT &quot;执行SQL&quot;,
       B.LAST_ACTIVE_TIME &quot;开始时间&quot;
  FROM V$SESSION_LONGOPS A, V$SQLAREA B
 WHERE A.TIME_REMAINING &lt;&gt; 0
   AND A.SQL_ADDRESS = B.ADDRESS
   AND A.SQL_HASH_VALUE = B.HASH_VALUE
</code></pre>
<p>13a、查询SGA和PGA的使用情况</p>
<pre><code>select name,
       round(total, 2),
       round(total - free, 2) used,
       round(free, 2) free,
       round((total - free) / total * 100, 2) pctused
  from (select &#39;SGA&#39; name,
               (select sum(value / 1024 / 1024) from v$sga) total,
               (select sum(bytes / 1024 / 1024)
                  from v$sgastat
                 where name = &#39;free memory&#39;) free
          from dual)
union
select name,
       round(total, 2),
       round(used, 2) used,
       round(total - used, 2) free,
       round(used / total * 100, 2) pctused
  from (select &#39;PGA&#39; name,
               (select value / 1024 / 1024 total
                  from v$pgastat
                 where name = &#39;aggregate PGA target parameter&#39;) total,
               (select value / 1024 / 1024 used
                  from v$pgastat
                 where name = &#39;total PGA allocated&#39;) used
          from dual);
</code></pre>
<p>13b、查看会话的内存占用情况</p>
<pre><code>SELECT server &quot;连接类型&quot;,
       s.username &quot;用户名&quot;,
       OSUSEr &quot;系统用户&quot;,
       NAME,
       round(VALUE / 1024 / 1024, 2) &quot;占用内存(M)&quot;,
       s.SID &quot;会话ID&quot;,
       s.serial# 会话序列号,
       spid &quot;系统进程ID&quot;,
       p.PGA_USED_MEM,
       p.PGA_ALLOC_MEM,
       p.PGA_FREEABLE_MEM,
       p.PGA_MAX_MEM
  FROM v$session s, v$sesstat st, v$statname sn, v$process p
 WHERE st.SID = s.SID
   AND st.statistic# = sn.statistic#
   AND sn.NAME LIKE &#39;session pga memory&#39;
   AND p.addr = s.paddr
 ORDER BY VALUE DESC;
</code></pre>
<p>14、查询耗时最长的10条sql</p>
<pre><code>select *
  from (select v.sql_id,
               v.child_number,
               v.sql_text,
               v.elapsed_time,
               v.cpu_time,
               v.disk_reads,
               rank() over(order by v.elapsed_time desc) elapsed_rank
          from v$sql v) a
 where elapsed_rank &lt;= 10;
</code></pre>
<p>15、MTS</p>
<pre><code>select busy / (busy + idle) shared_servers_busy from v$dispatcher;
</code></pre>
<p>16、表级锁</p>
<pre><code>select sess.sid,
       sess.serial#,
       lo.oracle_username,
       lo.os_user_name,
       ao.object_name,
       lo.locked_mode
  from v$locked_object lo, dba_objects ao, v$session sess
 where ao.object_id = lo.object_id
   and lo.session_id = sess.sid;
</code></pre>
<p>17、正在等待锁的所有会话</p>
<pre><code>SELECT * FROM DBA_WAITERS;
</code></pre>
<p>18、TPS,QPS,MBPS</p>
<pre><code>SELECT &#39;Qps|&#39; AS begin1,
       (SELECT sum(value)
          FROM gv$sysmetric
         WHERE metric_name = &#39;I/O Requests per Second&#39;) AS b1,
       &#39;|&#39; AS end1,
       &#39;Tps|&#39; AS begin2,
       (SELECT sum(value)
          FROM gv$sysmetric
         WHERE metric_name = &#39;User Transaction Per Sec&#39;) AS b2,
       &#39;|&#39; AS end2,
       &#39;Mbps|&#39; AS begin3,
       (SELECT sum(value)
          FROM gv$sysmetric
         WHERE metric_name = &#39;I/O Megabytes per Second&#39;) AS b3,
       &#39;|&#39; AS end3
  FROM dual;
</code></pre>
<p>19、数据库容量大小（GB）以及数据库各个表空间大小</p>
<pre><code>-- 数据库总大小
SELECT ROUND(SUM(BYTES) / 1024 / 1024 / 1024, 2) || &#39;GB&#39;
  FROM DBA_DATA_FILES;
-- 数据库各个表空间大小
select tablespace_name, sum(bytes) / 1024 / 1024 as MB
  from dba_data_files
 group by tablespace_name;
</code></pre>
<p>20、审计信息</p>
<pre><code>-- 具体的审计信息
select * from dba_audit_trail;
--是否打开审计功能 (默认是未开启，NONE表示未开启，其他的应该就是开启，比如 DB_EXTENDED)
SELECT * from v$parameter WHERE name = &#39;audit_trail&#39;;
</code></pre>
<p>21、当前数据库的版本信息</p>
<pre><code>SELECT * from v$version;
</code></pre>
<p>22、获取不用用户不同操作的审计执行频率</p>
<pre><code>SELECT username, action_name, count(*) c
  FROM dba_audit_trail
 GROUP BY username, action_name
 ORDER BY c DESC;
</code></pre>
<p>23、查询不同用户的连接数</p>
<pre><code>SELECT username, count(username)
  FROM v$session
 WHERE username IS NOT NULL
 GROUP BY username;
</code></pre>
<p>24、被锁定或者已经过期的用户</p>
<pre><code>select username, lock_date
  from dba_users
 WHERE ACCOUNT_STATUS in (&#39;LOCKED&#39;, &#39;EXPIRED &amp; LOCKED&#39;)
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle的SGA、PGA是什么？有什么用？</title>
    <url>/2023/06/13/Oracle%E7%9A%84SGA%E3%80%81PGA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PGA(程序缓存区)与SGA(系统全局区)类似，都是Oracle数据库系统为会话在服务器内存中分配的区域。不过两者的作用不同，共享程度也不同。</p>
<p>SGA系统全局区顾名思义，是对系统内的所有进程都是共享的。当多个用户同时连接到一个例程时，所有的用户进程、服务进程都可以共享使用这个SGA区。为此这个SGA的主要用途就是为不同用户之间的进程与服务进程提供一个交流的平台。除了这个作用，另外有一个重要的作用就是各种数据库的操作主要就是在这个SGA区内完成。</p>
<p>而PGA程序缓冲区则主要是为了某个用户进程所服务的。这个内存区不是共享的，只有这个用户的服务进程本身才能够访问它自己的PGA区。做个形象的比喻，SGA就好像是操作系统上的一个共享文件夹，不同用户可以以此为平台进行数据方面的交流。而PGA就好像是操作系统上的一个私有文件夹，只有这个文件夹的所有者才能够进行访问，其他用户都不能够访问。虽然程序缓存区不像其他用户的进程开放，但是这个内存区仍然肩负着一些重要的使命，如数据排序、权限控制等等都离不开这个内存区。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle查看表空间使用情况</title>
    <url>/2023/06/12/Oracle%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><p>1、查看所有表空间大小</p>
<pre><code>select tablespace_name,sum(bytes)/1024/1024 from dba_data_files group by tablespace_name;
</code></pre>
<p>2、未使用的表空间大小</p>
<pre><code>select tablespace_name,sum(bytes)/1024/1024 from dba_free_space   
group by tablespace_name;   
</code></pre>
<p>3、所以使用空间可以这样计算</p>
<pre><code>select a.tablespace_name,total,free,total-free used from   
( select tablespace_name,sum(bytes)/1024/1024 total from dba_data_files   
group by tablespace_name) a,   
( select tablespace_name,sum(bytes)/1024/1024 free from dba_free_space   
group by tablespace_name) b   
where a.tablespace_name=b.tablespace_name;   
</code></pre>
<p>4、还有在命令行情况下如何将结果放到一个文件里。</p>
<pre><code>SQL&gt; spool out.txt   
SQL&gt; select * from v$database;   
SQL&gt; spool off
</code></pre>
<p>5、查询所有的表空间</p>
<pre><code>select tablespace_name from dba_tablespaces  
</code></pre>
<p>6、查看表空间中分布的用户信息</p>
<pre><code>select tablespace_name, owner,sum(bytes) from dba_segments   
group by tablespace_name, owner   
</code></pre>
<h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><p>查看Oracle数据库表空间大小，是否需要增加表空间的数据文件<br>在数据库管理中，磁盘空间不足是DBA都会遇到的问题，问题比较常见。</p>
<p>1、查看表空间已经使用的百分比</p>
<pre><code>select a.tablespace_name,a.bytes/1024/1024 &quot;Sum MB&quot;,(a.bytes-b.bytes)/1024/1024 &quot;used MB&quot;,b.bytes/1024/1024 &quot;free MB&quot;,round(((a.bytes-b.bytes)/a.bytes)*100,2) &quot;percent_used&quot;  
from  
(select tablespace_name,sum(bytes) bytes from dba_data_files group by tablespace_name) a,   
(select tablespace_name,sum(bytes) bytes,max(bytes) largest from dba_free_space group by tablespace_name) b   
where a.tablespace_name=b.tablespace_name   
order by ((a.bytes-b.bytes)/a.bytes) desc  
</code></pre>
<p>“Sum MB”表示表空间所有的数据文件总共在操作系统占用磁盘空间的大小<br>比如：test表空间有2个数据文件，datafile1为300MB，datafile2为400MB，那么test表空间的“Sum MB”就是700MB<br>“userd MB”表示表空间已经使用了多少<br>“free MB”表示表空间剩余多少<br>“percent_user”表示已经使用的百分比</p>
<p>2、比如从1中查看到MLOG_NORM_SPACE表空间已使用百分比达到90%以上，可以查看该表空间总共有几个数</p>
<p>据文件，每个数据文件是否自动扩展，可以自动扩展的最大值。</p>
<pre><code>select file_name,tablespace_name,bytes/1024/1024 &quot;bytes MB&quot;,maxbytes/1024/1024 &quot;maxbytes MB&quot; from dba_data_files  
  where tablespace_name=&#39;MLOG_NORM_SPACE&#39;;   
</code></pre>
<p>2.1、查看 xxx 表空间是否为自动扩展</p>
<pre><code>select file_id,file_name,tablespace_name,autoextensible,increment_by from dba_data_files order by file_id desc;  
select file_id,file_name,tablespace_name,autoextensible,increment_by from dba_data_files order by file_id desc;
</code></pre>
<p>3、比如MLOG_NORM_SPACE表空间目前的大小为19GB，但最大每个数据文件只能为20GB，数据文件快要写满，可以增加表空间的数据文件<br>用操作系统UNIX、Linux中的df -g命令(查看下可以使用的磁盘空间大小)<br>获取创建表空间的语句：</p>
<pre><code>select    dbms_metadata.get_ddl(&#39;TABLESPACE&#39;,&#39;MLOG_NORM_SPACE&#39;)   from    dual;  
select dbms_metadata.get_ddl(&#39;TABLESPACE&#39;,&#39;MLOG_NORM_SPACE&#39;) from dual;
</code></pre>
<p>4、确认磁盘空间足够，增加一个数据文件</p>
<pre><code>alter    tablespace    MLOG_NORM_SPACE   
add    datafile   &#39;/oracle/oms/oradata/mlog/Mlog_Norm_data001.dbf&#39;  
size    10M    autoextend   on    maxsize    20G 
</code></pre>
<p>5、验证已经增加的数据文件</p>
<pre><code>select    file_name,file_id,tablespace_name   from    dba_data_files   
where    tablespace_name=&#39;MLOG_NORM_SPACE&#39; 
</code></pre>
<p>6、如果删除表空间数据文件，如下：</p>
<pre><code>alter    tablespace    MLOG_NORM_SPACE   
drop     datafile &#39;/oracle/oms/oradata/mlog/Mlog_Norm_data001.dbf&#39;  
</code></pre>
<p>转自<a href="http://space.itpub.net/12778571/viewspace-582695">http://space.itpub.net/12778571/viewspace-582695</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle监控的关键指标</title>
    <url>/2023/06/11/Oracle%E7%9B%91%E6%8E%A7%E7%9A%84%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、监控事例的等待</p>
<pre><code>select event,
       sum(decode(wait_Time, 0, 0, 1)) &quot;Prev&quot;,
       sum(decode(wait_Time, 0, 1, 0)) &quot;Curr&quot;,
       count(*) &quot;Tot&quot;
  from v$session_Wait
 group by event
 order by 4;
</code></pre>
<p>2、回滚段的争用情况</p>
<pre><code>select name, waits, gets, waits / gets &quot;Ratio&quot;
  from v$rollstat a, v$rollname b
 where a.usn = b.usn;
</code></pre>
<p>3、监控表空间的 I/O 比例</p>
<pre><code>select df.tablespace_name name,
       df.file_name       &quot;file&quot;,
       f.phyrds           pyr,
       f.phyblkrd         pbr,
       f.phywrts          pyw,
       f.phyblkwrt        pbw
  from v$filestat f, dba_data_files df
 where f.file# = df.file_id
 order by df.tablespace_name;
</code></pre>
<p>4、监控文件系统的 I/O 比例</p>
<pre><code>select substr(a.file#, 1, 2) &quot;#&quot;,
       substr(a.name, 1, 30) &quot;Name&quot;,
       a.status,
       a.bytes,
       b.phyrds,
       b.phywrts
  from v$datafile a, v$filestat b
 where a.file# = b.file#;
</code></pre>
<p>5、在某个用户下找所有的索引</p>
<pre><code>select user_indexes.table_name,
       user_indexes.index_name,
       uniqueness,
       column_name
  from user_ind_columns, user_indexes
 where user_ind_columns.index_name = user_indexes.index_name
   and user_ind_columns.table_name = user_indexes.table_name
 order by user_indexes.table_type,
          user_indexes.table_name,
          user_indexes.index_name,
          column_position;
</code></pre>
<p>6、监控 SGA 的命中率</p>
<pre><code>select a.value + b.value &quot;logical_reads&quot;,
       c.value &quot;phys_reads&quot;,
       round(100 * ((a.value + b.value) - c.value) / (a.value + b.value)) &quot;BUFFER HIT RATIO&quot;
  from v$sysstat a, v$sysstat b, v$sysstat c
 where a.statistic# = 38
   and b.statistic# = 39
   and c.statistic# = 40;
</code></pre>
<p>7、监控 SGA 中字典缓冲区的命中率</p>
<pre><code>select parameter,
       gets,
       Getmisses,
       getmisses / (gets + getmisses) * 100 &quot;miss ratio&quot;,
       (1 - (sum(getmisses) / (sum(gets) + sum(getmisses)))) * 100 &quot;Hit ratio&quot;
  from v$rowcache
 where gets + getmisses &lt;&gt; 0
 group by parameter, gets, getmisses;
</code></pre>
<p>8、监控 SGA 中共享缓存区的命中率，应该小于1%</p>
<pre><code>select sum(pins) &quot;Total Pins&quot;,
       sum(reloads) &quot;Total Reloads&quot;,
       sum(reloads) / sum(pins) * 100 libcache
  from v$librarycache;

select sum(pinhits - reloads) / sum(pins) &quot;hit radio&quot;,
       sum(reloads) / sum(pins) &quot;reload percent&quot;
  from v$librarycache;
</code></pre>
<p>9、显示所有数据库对象的类别和大小</p>
<pre><code>select count(name) num_instances,
       type,
       sum(source_size) source_size,
       sum(parsed_size) parsed_size,
       sum(code_size) code_size,
       sum(error_size) error_size,
       sum(source_size) + sum(parsed_size) + sum(code_size) +
       sum(error_size) size_required
  from dba_object_size
 group by type
 order by 2;
</code></pre>
<p>10、监控 SGA 中重做日志缓存区的命中率，应该小于1%</p>
<pre><code>SELECT name,
       gets,
       misses,
       immediate_gets,
       immediate_misses,
       Decode(gets, 0, 0, misses / gets * 100) ratio1,
       Decode(immediate_gets + immediate_misses,
              0,
              0,
              immediate_misses / (immediate_gets + immediate_misses) * 100) ratio2
  FROM v$latch
 WHERE name IN (&#39;redo allocation&#39;, &#39;redo copy&#39;);
</code></pre>
<p>11、监控内存和硬盘的排序比率<br>最好使它小于 .10，增加 sort_area_size</p>
<pre><code>SELECT name, value FROM v$sysstat WHERE name IN (&#39;sorts (memory)&#39;, &#39;sorts (disk)&#39;);    
</code></pre>
<p>12、监控当前数据库谁在运行什么SQL语句</p>
<pre><code>SELECT osuser, username, sql_text
  from v$session a, v$sqltext b
 where a.sql_address = b.address
 order by address, piece;
</code></pre>
<p>13、监控字典缓冲区</p>
<pre><code>SELECT (SUM(PINS - RELOADS)) / SUM(PINS) &quot;LIB CACHE&quot; FROM V$LIBRARYCACHE;
SELECT (SUM(GETS - GETMISSES - USAGE - FIXED)) / SUM(GETS) &quot;ROW CACHE&quot;
  FROM V$ROWCACHE;
SELECT SUM(PINS) &quot;EXECUTIONS&quot;, SUM(RELOADS) &quot;CACHE MISSES WHILE EXECUTING&quot;
  FROM V$LIBRARYCACHE;
</code></pre>
<p>后者除以前者，此比率小于1%，接近0%为好。</p>
<pre><code>  SELECT SUM(GETS) &quot;DICTIONARY GETS&quot;,
         SUM(GETMISSES) &quot;DICTIONARY CACHE GET MISSES&quot;
    FROM V$ROWCACHE
</code></pre>
<p>14、找ORACLE字符集</p>
<pre><code>select * from sys.props$ where name=&#39;NLS_CHARACTERSET&#39;;   
</code></pre>
<p>15、监控 MTS</p>
<pre><code>select busy / (busy + idle) &quot;shared servers busy&quot; from v$dispatcher;
</code></pre>
<p>此值大于0.5时，参数需加大</p>
<pre><code>  select sum(wait) / sum(totalq) &quot;dispatcher waits&quot;
    from v$queue
   where type = &#39;dispatcher&#39;;
select count(*) from v$dispatcher;
select servers_highwater from v$mts;
</code></pre>
<p>servers_highwater接近mts_max_servers时，参数需加大</p>
<p>16、碎片程度</p>
<pre><code>select tablespace_name,count(tablespace_name) from dba_free_space group by tablespace_name      
having count(tablespace_name)&gt;10;     
 
alter tablespace name coalesce;     
alter table name deallocate unused;     
 
create or replace view ts_blocks_v as     
select tablespace_name,block_id,bytes,blocks,&#39;free space&#39; segment_name from dba_free_space     
union all     
select tablespace_name,block_id,bytes,blocks,segment_name from dba_extents;     
 
select * from ts_blocks_v;     
 
select tablespace_name,sum(bytes),max(bytes),count(block_id) from dba_free_space      
group by tablespace_name;     
</code></pre>
<p>查看碎片程度高的表     </p>
<pre><code>SELECT segment_name table_name , COUNT(*) extents     
FROM dba_segments WHERE owner NOT IN (&#39;SYS&#39;, &#39;SYSTEM&#39;) GROUP BY segment_name     
HAVING COUNT(*) = (SELECT MAX( COUNT(*) ) FROM dba_segments GROUP BY segment_name);  
</code></pre>
<p>17、表、索引的存储情况检查</p>
<pre><code>select segment_name,sum(bytes),count(*) ext_quan from dba_extents where      
tablespace_name=&#39;&amp;tablespace_name&#39; and segment_type=&#39;TABLE&#39; group by tablespace_name,segment_name;     

select segment_name,count(*) from dba_extents where segment_type=&#39;INDEX&#39; and owner=&#39;&amp;owner&#39;     
group by segment_name;
</code></pre>
<p>18、找使用CPU多的用户session</p>
<pre><code>select a.sid,spid,status,substr(a.program,1,10) prog,a.terminal,osuser,value/60/100 value     
from v$session a,v$process b,v$sesstat c     
where c.statistic#=12 and c.sid=a.sid and a.paddr=b.addr order by value desc
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>REST模式：POST，GET，PUT，DELETE，PATCH的含义与区别</title>
    <url>/2023/06/10/REST%E6%A8%A1%E5%BC%8F%EF%BC%9APOST%EF%BC%8CGET%EF%BC%8CPUT%EF%BC%8CDELETE%EF%BC%8CPATCH%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>根据HTTP规范:</p>
<ol>
<li><p>GET 用于信息获取，而且是安全的和幂等的<br>GET请求是安全的。所谓安全是指不管进行多少次操作，资源的状态都不会改变。该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。</p>
</li>
<li><p>POST 用于创建数据，不是安全和幂等的<br>POST请求既不是安全的，也不是幂等的，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建出了若干的资源。</p>
</li>
<li><p>PUT 用于创建或完整更新数据，而且是安全和幂等的<br>PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改完整的数据内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。</p>
</li>
<li><p>DELETE 用于删除数据，而且是安全和幂等的<br>DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作，无论进行多少次DELETE操作，其结果并没有不同。</p>
</li>
<li><p>PATCH 用于更新部分数据，不是安全和幂等的<br>PATCH请求是对PUT请求的补充，一般用来对已知资源部分更新，是后来新出的标准，GitHub Api也开始使用。</p>
</li>
</ol>
<p>更多详细的介绍可以参考RESTful[<a href="http://sofish.github.io/restcookbook/]%E6%89%8B%E5%86%8C">http://sofish.github.io/restcookbook/]手册</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「Marsin_csdn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Marsin_csdn/article/details/123956033">https://blog.csdn.net/Marsin_csdn/article/details/123956033</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title>政策再加码，国办发文让充电更方便</title>
    <url>/2023/06/09/%E6%94%BF%E7%AD%96%E5%86%8D%E5%8A%A0%E7%A0%81%EF%BC%8C%E5%9B%BD%E5%8A%9E%E5%8F%91%E6%96%87%E8%AE%A9%E5%85%85%E7%94%B5%E6%9B%B4%E6%96%B9%E4%BE%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>充电桩是新能源汽车快速发展不可或缺的一环，对于新能源汽车车主及观望者来说，充电问题始终是最大的关注点之一。近日，国务院办公厅印发《关于进一步构建高质量充电基础设施体系的指导意见》（以下简称《指导意见》），对充电基础设施建设作出具体部署。</p>
<p>截至2022年底，全国新能源汽车保有量达1310万辆，其中纯电动汽车保有量为1045万辆，而全国充电基础设施累计数量为521万台。全国新能源汽车保有量与全国累计建成充电桩数量的比例约为2.5:1。当前充电桩数量并不能完全满足新能源汽车的充电需求，如何让充电变得更方便，也是《指导意见》关注的重点。</p>
<p>《指导意见》为新能源汽车充电基础设施建设指出发展目标——到2030年，基本建成覆盖广泛、规模适度、结构合理、功能完善的高质量充电基础设施体系，有力支撑新能源汽车产业发展，有效满足人民群众出行充电需求。</p>
<p>西南大学经济管理学院教授、博士生导师刘自敏在接受人民网“强观察”栏目记者采访时表示，在“双碳”目标的大背景下，能源结构转型势在必行，而新能源汽车革命正是大势所趋。高质量的充电基础设施建立之后，新能源汽车的普及率会进一步提高，刺激消费市场的同时，也将更好地推动“双碳”目标的实现。</p>
<p>在城市充电网络方面，《指导意见》指出，以“两区”（居住区、办公区）、“三中心”（商业中心、工业中心、休闲中心）为重点，推动城市充电网络从中心城区向城区边缘、从优先发展区域向其他区域有序延伸。</p>
<p>“在一定程度上能够解决城市居民高峰期充电难的问题。”刘自敏表示，《指导意见》提出在居住区积极推广智能有序慢充为主、应急快充为辅的充电基础设施，在办公区和“三中心”等城市专用和公用区域因地制宜布局建设快慢结合的公共充电基础设施，主要是从空间上有效调节上班族人群充电难的问题。</p>
<p>他还提到，充电高峰期也应与电价相关联。有些地市在凌晨时段电价降低，如果能从这方面引导消费者，让充电高峰期不仅仅局限于集中时段，而是更加均匀地分布，充电难的问题也能得到有效解决。</p>
<p>此外，《指导意见》多项举措都涉及到农村充电设施的布局，提出要建设有效覆盖农村地区的充电网络。</p>
<p>记者梳理发现，近期，国家频频出台政策促进农村地区充换电设施发展。</p>
<p>5月5日，国常会部署加快建设充电基础设施，更好支持新能源汽车下乡和乡村振兴；5月17日，国家发展改革委、国家能源局印发《关于加快推进充电基础设施建设更好支持新能源汽车下乡和乡村振兴的实施意见》，支持农村地区购买使用新能源汽车。</p>
<p>在刘自敏看来，自2020年国家开展新能源汽车下乡活动以来，新能源汽车在农村销量不断增加，但充电设施基础薄弱。“新能源汽车在乡村市场具有比城市更大的普及潜力，但只有基础设施得到较好保障的情况下，农村新能源汽车的潜在需求才会转化为更大的消费需求和真正的购买行为。”</p>
<p>“《指导意见》提出的积极推动在县级城市城区建设公共直流快充站是个亮点。”刘自敏表示，农村地区的人口密度不同于城市，在物流或资金流相对密集的区域去布局充电基础设施，能够起到有效推动城镇化发展和经济聚集的作用。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s监控指标及原因</title>
    <url>/2023/06/08/k8s%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E5%8F%8A%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Kubernetes 每天可以生成数百万个新指标。监控集群健康状况最具挑战性的方面之一是筛选哪些指标是重要的，需要收集和关注。</p>
<p>在本文中，我将定义应该监控和创建警报的 16 个关键 Kubernetes 指标。公司组织的列表可能略有不同，但在制定组织的 Kubernetes 监控策略时，这 16 个是了解k8s集群监控状态最好的指标。</p>
<p>原文链接：<a href="https://www.circonus.com/2020/12/12-critical-kubernetes-health-conditions-you-need-to-monitor-and-why/">https://www.circonus.com/2020/12/12-critical-kubernetes-health-conditions-you-need-to-monitor-and-why/</a><br><a href="https://zhuanlan.zhihu.com/p/439374032">https://zhuanlan.zhihu.com/p/439374032</a></p>
<h1 id="1、Crash-Loops"><a href="#1、Crash-Loops" class="headerlink" title="1、Crash Loops"></a>1、Crash Loops</h1><p>crash loops是指 pod 启动、崩溃，然后不断尝试重新启动但不能（它在循环中不断崩溃和重新启动）。当发生这种情况时，应用程序将无法运行。</p>
<p>可能是由 pod 中的应用程序崩溃引起的<br>可能是由 pod 或部署过程中的错误配置引起的<br>当发生crash loops时，需要查看日志来解决问题。<br>可以使用开源组件kube-eventer来推送事件。</p>
<h1 id="2、CPU-Utilization"><a href="#2、CPU-Utilization" class="headerlink" title="2、CPU Utilization"></a>2、CPU Utilization</h1><p>CPU 使用率就是节点正在使用的 CPU 的使用率。出于两个原因进行监控很重要：</p>
<p>应用程序不能使用完应用程序分配的cpu。如果应用程序受 CPU 限制，则需要增加 CPU 分配或者增加pod数量。最终需要增加服务器来解决。<br>你不希望你的 CPU 坐在那里闲置。如果服务器 CPU 使用率一直很低，可能过度分配了资源并可能浪费金钱。</p>
<h1 id="3、Disk-Pressure"><a href="#3、Disk-Pressure" class="headerlink" title="3、Disk Pressure"></a>3、Disk Pressure</h1><p>根据 Kubernetes 配置中设置的阈值，磁盘压力是指示节点使用过多磁盘空间或使用磁盘空间过快的条件。</p>
<p>如果应用程序合法地需要更多空间，这可能意味着需要添加更多磁盘空间。<br>应用程序行为异常并以意外的方式过早地填满了磁盘。</p>
<h1 id="4、Memory-Pressure"><a href="#4、Memory-Pressure" class="headerlink" title="4、Memory Pressure"></a>4、Memory Pressure</h1><p>Memory Pressure是另一种资源状况，表明节点内存不足。</p>
<p>需要注意这种情况，因为这可能意味应用程序中存在内存泄漏。</p>
<h1 id="5、PID-Pressure"><a href="#5、PID-Pressure" class="headerlink" title="5、PID Pressure"></a>5、PID Pressure</h1><p>PID 压力是一种罕见的情况，即 Pod 或容器产生过多进程并使节点缺乏可用进程 ID。</p>
<p>每个节点都有有限数量的进程 ID 来分配给正在运行的进程；<br>如果 ID 用完，则无法启动其他进程。<br>Kubernetes 允许为 pod 设置 PID 阈值以限制它们执行失控进程生成的能力，而 PID 压力条件意味着一个或多个 pod 正在用完分配的 PID，需要进行检查。</p>
<h1 id="6、Network-Unavailable"><a href="#6、Network-Unavailable" class="headerlink" title="6、Network Unavailable"></a>6、Network Unavailable</h1><p>所有节点都需要网络连接，Network Unavailable此状态表明节点的网络连接有问题。</p>
<p>要么设置不正确（由于路由耗尽或配置错误），要么与硬件的网络连接存在物理问题。<br>可以使用开源组件KubeNurse进行集群网络监控</p>
<h1 id="7、Job-Failures"><a href="#7、Job-Failures" class="headerlink" title="7、Job Failures"></a>7、Job Failures</h1><p>作业旨在在有限的时间内运行 Pod，并在完成预期功能后将其释放。</p>
<p>如果作业因节点崩溃或重新启动或资源耗尽而未能成功完成，需要要知道作业失败。<br>通常并不意味着您的应用程序无法访问，但如果不加以修复，它可能会导致以后会出现问题。<br>可以使用开源组件kube-eventer来推送事件。</p>
<h1 id="8、Persistent-Volume-Failures"><a href="#8、Persistent-Volume-Failures" class="headerlink" title="8、Persistent Volume Failures"></a>8、Persistent Volume Failures</h1><p>持久卷是在集群上指定的存储资源，可用作任何请求它的 Pod 的持久存储。在它们的生命周期中，它们被绑定到一个 Pod，然后在该 Pod 不再需要时回收。</p>
<p>如果该回收因任何原因失败，需要知道的持久存储有问题。</p>
<h1 id="9、Pod-Pending-Delays"><a href="#9、Pod-Pending-Delays" class="headerlink" title="9、Pod Pending Delays"></a>9、Pod Pending Delays</h1><p>在 pod 的生命周期中，如果它正在等待在节点上进行调度，则其状态为“pending”。如果它停留在“pending”状态，通常意味着没有足够的资源来安排和部署 pod。</p>
<p>将需要更新 CPU 和内存分配、删除 Pod 或向集群添加更多节点。<br>可以使用开源组件kube-eventer来推送事件。</p>
<h1 id="10、Deployment-Glitches"><a href="#10、Deployment-Glitches" class="headerlink" title="10、Deployment Glitches"></a>10、Deployment Glitches</h1><p>Deployment Glitches部署用于管理无状态应用程序——其中 Pod 是可互换的，不需要能够访问任何特定的单个 Pod，而只需访问特定类型的 Pod。</p>
<p>需要密切关注部署以确保它们正确完成。最好的方法是确保观察到的部署数量与所需的部署数量相匹配。如果不匹配，则一个或多个部署失败。</p>
<h1 id="11、StatefulSets-Not-Ready"><a href="#11、StatefulSets-Not-Ready" class="headerlink" title="11、StatefulSets Not Ready"></a>11、StatefulSets Not Ready</h1><p>StatefulSets 用于管理有状态的应用程序，其中 Pod 具有特定的角色，需要访问其他特定的 Pod；而不是像部署那样只需要特定类型的 pod。</p>
<p>确保观察到的 StatefulSet 的数量与所需的 StatefulSet 的数量相匹配。如果不匹配，则一个或多个 StatefulSet 失败。<br>可以使用开源组件kube-eventer来推送事件。</p>
<h1 id="12、DaemonSets-Not-Ready"><a href="#12、DaemonSets-Not-Ready" class="headerlink" title="12、DaemonSets Not Ready"></a>12、DaemonSets Not Ready</h1><p>DaemonSets 用于管理需要在集群中的所有节点上运行的服务或应用程序。每个节点上运行日志收集守护进程（filebeat）或监控服务，需要使用 DaemonSet。</p>
<p>确保观察到的 DaemonSet 数量与所需的 DaemonSet 数量相匹配。如果不匹配，则一个或多个 DaemonSet 失败。<br>可以使用开源组件kube-eventer来推送事件。</p>
<h1 id="13、etcd-Leaders"><a href="#13、etcd-Leaders" class="headerlink" title="13、etcd Leaders"></a>13、etcd Leaders</h1><p>etcd 集群应该总是有一个领导者（除了在改变领导者的过程中，这应该很少发生）。</p>
<p>etcd_server_has_leader，etcd中是否有leader。<br>leader的改变次数etcd_server_leader_changes_seen_total，则可能表明 etcd 集群中存在连接或资源问题。</p>
<h1 id="14、Scheduler-Problems"><a href="#14、Scheduler-Problems" class="headerlink" title="14、Scheduler Problems"></a>14、Scheduler Problems</h1><p>调度器有两个方面值得关注。</p>
<p>应该进行监控，scheduler_schedule_attempts_total{result:unschedulable}因为不可调度 Pod 的增加可能意味着您的集群存在资源问题。<br>其次，应该使用上述延迟指标之一密切关注调度程序延迟。Pod 调度延迟的增加可能会导致其他问题，也可能表明集群中存在资源问题。</p>
<h1 id="15、Events"><a href="#15、Events" class="headerlink" title="15、Events"></a>15、Events</h1><p>除了从 Kubernetes 集群收集数字指标之外，从集群收集和跟踪事件也很有用。集群事件能监控 pod 生命周期并观察重大的 pod 故障，并且观察从集群流出的事件速率可以是一个很好的早期预警指标。如果事件发生率突然或显着变化，则可能表明出现问题。</p>
<p>可以使用开源组件kube-eventer来推送事件。</p>
<h1 id="16、Application-Metrics"><a href="#16、Application-Metrics" class="headerlink" title="16、Application Metrics"></a>16、Application Metrics</h1><p>与我们上面检查的其他指标和事件不同，应用程序指标不是从 Kubernetes 本身发出的，而是从集群运行的工作负载发出的。从应用程序的角度来看，这种遥测可以是重要的任何内容：错误响应、请求延迟、处理时间等。关于如何收集应用程序指标有两种哲学。</p>
<p>第一个（直到最近才被广泛采用）是指标应该从应用程序“推送”到收集端点。<br>第二个指标收集理念（越来越广泛采用）是指标应该由收集代理从应用程序中“拉取”。这使得应用程序更容易编写，因为他们所要做的就是适当地发布他们的指标，但应用程序不必担心如何提取或抓取这些指标。这就是 OpenMetrics 的工作方式，也是收集 Kubernetes 集群指标的方式。当此技术与收集代理的服务发现相结合时，它创建了一种强大的方法，可以从集群应用程序中收集您需要的任何类型的指标。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>与 Kubernetes 的大多数方面一样，监控 Kubernetes 运行状况可能是一个复杂且具有挑战性的过程。很容易不知所措。通过了解最需要关注的高价值的指标，至少可以开始制定一项策略，能够过滤掉集群产生的大量数据噪音，并更有信心解决最重要的问题，以确保良好的体验。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>服务器性能</tag>
        <tag>监控指标</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器性能监控及其指标介绍</title>
    <url>/2023/06/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%85%B6%E6%8C%87%E6%A0%87%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>服务器的性能监控，在历史的长河里，随时计算机的发展也在进行着变化。从最开始的手动登录服务器检查问题，包括有哪些人登录到服务器，打开日志，运行过哪些命令，慢慢地变为现在的专业监控软件，集成化的监测性能指标，智能关联分析，使服务器的性能监控更加全完更加完善。那么针对服务器的性能我们需要了解具体哪些性能点，才能更好的判断服务器的运行状态呢？ 以下介绍一些较重要的性能汇总要点和软件。</p>
<h1 id="性能汇总要点"><a href="#性能汇总要点" class="headerlink" title="性能汇总要点"></a>性能汇总要点</h1><h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><p>检查CPU使用情况，查看正在处理器使用的百分比。根据具体需求，你可能需要了解CPU总体使用情况以及按流程或用户划分的细节，查看流程和用户的额外颗粒度，在问题出现时更容易进行故障排除。</p>
<h2 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h2><p>总共用了多少内存以及单个进程和用户进和。根据需要，可以按百分比和/或GB/MB监控内存之使用情况。</p>
<h2 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h2><p>使用了多少磁盘空间。与内存使用情况类似，可以按百分比或空间来监控磁盘使用情况。还应该跟踪inode的使用情况，Inode用于存储系统中文件系统对象的信息。耗尽inode不常见，但还是要检查一下，如果你碰巧知道服务器上运行的应用程序往往有很多小文件，就像一些CI/CD工具那样。</p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>对于虚拟服务器，正常运行时间是服务器运行的时间。监控主要是为了查看服务器是否经历了意外重启。</p>
<h2 id="网络活动"><a href="#网络活动" class="headerlink" title="网络活动"></a>网络活动</h2><p>监控网络流量需要哪些精确度，取决于服务器托管的内容。在通常情况下，即使运行静态站点但未主动访问的服务器也会看到运行在其上的其他进程的I/O，服务器网络不应该降到0。</p>
<h2 id="Swap使用"><a href="#Swap使用" class="headerlink" title="Swap使用"></a>Swap使用</h2><p>Swap交换空间是保留的磁盘空间，是在可用内存不足时补充内存使用量。你的系统如何积极地使用交换空间取决于如何在1（低）到100（高）的范围内配置它的“swappiness”。如果要在系统内出现内存问题时允许进行一些交换而不完全禁用它（为0），使用10或更小的值是一个常态。当查看“交换空间使用情况”时，我们通常会看交换空间使用情况是否显著上升。如果真是如此，需要查内存和其他资源，看看自己是否可以挖掘到原因。</p>
<h1 id="Linux下相关命令"><a href="#Linux下相关命令" class="headerlink" title="Linux下相关命令"></a>Linux下相关命令</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>一个很方便的工具，允许我们查看正常运行时间，内存使用情况，CPU使用情况以及交换空间等内容。我们还可以查看其它信息：包括其它正在运行的进程，用于运行该进程的命令等。通过按q键退出top命令行。</p>
<h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>htop是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。与传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。与top相比，htop有如下的优点：</p>
<p>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</p>
<p>在启动上，比top 更快。杀进程时不需要输入进程号。htop 支持鼠标操作。</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>这是一个监控网络数据包的强大工具。例如，我们可以使用它来侦听服务器实例上的所有网络流量，或限制为仅侦听来自特定源和/或目标端口的流量。可以使用ctrl + C退出。</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>允许我们查看服务器上的网络连接的内容和方式，包括将表信息路由为TCP/UDP连接及其进程。后者的常见组合是-tlnpu。如果你需要，还可以使用-c运行命令以进行连续监控。</p>
<h2 id="nmon"><a href="#nmon" class="headerlink" title="nmon"></a>nmon</h2><p>a.k.a. Nigel的监控器，允许我们查看有关服务器的更详细的信息。与htop命令类似，nmon也是交互式的，因此需要通过一系列菜单来查看有关CPU处理器，磁盘等的信息。退出时，请使用q或ctrl + C。</p>
<h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>查看服务器运行时间的简便方法。如果你希望查看持续时间的正常运行时间而不是服务器启动的时间戳，请使用 -pretty参数。</p>
<h2 id="proc-meminfo"><a href="#proc-meminfo" class="headerlink" title="/proc/meminfo"></a>/proc/meminfo</h2><p>可以使用自己喜欢的编辑器来查看此文件，能够深入了解当前的活动/可用内存的使用情况。</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>要查看没有进程信息的空闲与已用内存，请使用free命令。默认情况下，这些值以字节为单位，如果你希望以兆字节或千兆字节的形式查看输出，建议附加-h 参数。</p>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>允许管理员查看系统上安装的所有卷的总磁盘使用情况。默认为1K块大小，建议附加-h以查看兆字节和/或千兆字节的输出结果 df -h。</p>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>以指定目录中的所有对象（文件，目录）递归打印文件系统对象的磁盘使用情况。要注意：如果没有指定目录，则使用root根目录（/），结果很快超过你的终端！如果只想查看目录中项目使用了多少磁盘，请使用-sh。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>服务器性能</tag>
        <tag>监控指标</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年中国新能源汽车保有量达1310万辆，同比增长67.13%</title>
    <url>/2023/06/06/2022%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E4%BF%9D%E6%9C%89%E9%87%8F%E8%BE%BE1310%E4%B8%87%E8%BE%86%EF%BC%8C%E5%90%8C%E6%AF%94%E5%A2%9E%E9%95%BF67-13/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>中新社北京1月11日电 (记者 郭超凯)记者11日从中国公安部获悉，据统计，2022年全国机动车保有量达4.17亿辆，机动车驾驶人达5.02亿人；全国新能源汽车保有量达1310万辆，同比增长67.13%。</p>
<p>截至2022年底，全国机动车保有量达4.17亿辆，扣除报废注销量比2021年增加2129万辆，增长5.39%，2022年全国新注册登记机动车3478万辆。汽车保有量达3.19亿辆，占机动车总量76.59%，比2021年增加1752万辆，增长5.81%，全国新注册登记汽车2323万辆。摩托车保有量达8072万辆，占机动车总量19.38%，比2021年增加513万辆，增长6.79%，全国新注册登记摩托车1130万辆。</p>
<p>全国有84个城市的汽车保有量超过百万辆，同比增加5个城市，39个城市超200万辆，21个城市超300万辆。其中，北京、成都、重庆、上海超过500万辆，苏州、郑州、西安、武汉超过400万辆。</p>
<p>据知，截至2022年底，全国新能源汽车保有量达1310万辆，占汽车总量的4.10%，扣除报废注销量比2021年增加526万辆，增长67.13%。其中，纯电动汽车保有量1045万辆，占新能源汽车总量的79.78%。</p>
<p>2022年全国新注册登记新能源汽车535万辆，占新注册登记汽车总量的23.05%，与上年相比增加240万辆，增长81.48%。新注册登记新能源汽车数量从2018年的107万辆到2022年的535万辆，呈高速增长态势。</p>
<p>汽车转让登记数量持续增长，二手车交易市场活跃。截至2022年底，全国公安交管部门共办理机动车转让登记业务3027万笔。其中，汽车转移登记业务2869万笔，占94.80%。近五年，二手汽车转让登记与汽车新车注册登记数量的比例由0.77上升至1.24，超过汽车新车注册登记量。</p>
<p>2022年，公安部会同商务部等部门推出系列便利二手车交易登记改革新措施，全面实行经销二手车“单独签注、核发临牌”，异地直接办理交易登记的二手小客车310万辆，更好促进二手车流通。</p>
<p>据介绍，截至2022年底，全国机动车驾驶人数量达5.02亿人，其中汽车驾驶人4.64亿人，占驾驶人总数92.54%。2022年，全国新领证驾驶人2923万人。</p>
<p>2022年4月1日起实施的《机动车驾驶证申领和使用规定》(公安部令第162号)新增“轻型牵引挂车”准驾车型(C6)，目前已取得C6准驾车型驾驶人数量达44万人，更好满足民众驾驶小型旅居挂车出行需求，促进房车旅游新业态发展。(完)</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年中国充电桩行业市场规模、行业发展运行现状分析</title>
    <url>/2023/06/05/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%85%85%E7%94%B5%E6%A1%A9%E8%A1%8C%E4%B8%9A%E5%B8%82%E5%9C%BA%E8%A7%84%E6%A8%A1%E3%80%81%E8%A1%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%BF%90%E8%A1%8C%E7%8E%B0%E7%8A%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>充电桩，功能类似于加油站里面的加油机，可以固定在地面或墙壁，安装于公共建筑(公共楼宇、商场、公共停车场等)和居民小区停车场或充电站内，可以根据不同的电压等级为各种型号的电动汽车充电。</p>
<p>2023年中国充电桩行业市场规模 中国充电桩行业发展运行现状分析</p>
<p>充电桩的输入端与交流电网直接连接，输出端都装有充电插头用于为电动汽车充电。充电桩一般提供常规充电和快速充电两种充电方式，人们可以使用特定的充电卡在充电桩提供的人机交互操作界面上刷卡使用，进行相应的充电方式、充电时间、费用数据打印等操作，充电桩显示屏能显示充电量、费用、充电时间等数据。根据《国民经济行业分类与代码》(GB_T_4754-2011)的分类标准，充电桩所属行业可归类为：C制造业C38电气机械和器材制造业C382输配电及控制设备制造C3829其他输配电及控制设备制造。</p>
<p>作为推动新能源汽车持续发展的重要基础，充电桩是我国城市新型基础设施建设的重点方向之一。未来随着新能源汽车渗透率水平持续提升，将倒逼相关基础设施的加速建设与完善，充电桩行业将进一步发展与扩张，市场前景广阔。根据相关数据，2023年中国充电桩行业市场规模能突破1000亿元的水平。</p>
<p>根据中研普华产业研究院发布的《2023-2028年中国充电桩行业深度分析与投资战略研究报告》显示：</p>
<p>中国充电桩行业运行现状分析</p>
<p>第一节 中国充电桩行业发展状况分析</p>
<p>一、中国充电桩行业发展概况及特点</p>
<p>观望期(2010年及以前)：2009年1月财政部、科技部、工业和信息化部、发展改革委等四部门于2009年1月共同启动十城千辆节能与新能源汽车示范推广应用工程，计划用3年左右的时间，每年发展10个城市，每个城市推出1000辆新能源汽车开展示范运行。然而，科技部《“十城千辆”节能与新能源汽车示范推广试点工程2010年工作报告》显示，2010年25个城市新增新能源汽车5888辆，2009-2010年合计约1万辆，其中电动汽车仅2842辆。在这一阶段，充电设施建设主体——国家电网主要进行集中式充换电场站建设，截至2010年共建设充电站76座，充电桩1122个，桩车比仅约10%。</p>
<p>快速增长期(2011-2012年)：充电站和充电桩数量快速增长，尤其是2011年充电桩保有量由2010年的1122个增长至6800个，年增长率超过406%。桩车比逐年提高，2012年达到54.9%(EVI统计的新能源汽车及充电桩数量均偏低，桩车比为70.1%，有一定出入)，呈现出充电设施超前于新能源汽车发展的态势。</p>
<p>回落期(2013年)：2012年是新能源汽车“十城千辆”示范推广工作的最后一年，由于推广成果远远落后于预期(原计划至2012年全国新能源汽车的运营规模占到汽车市场份额的10%)，加上充电站盈利模式尚未明晰，大部分充电站处于亏本运营状态，充电设施建设速度明显回落。2013年新增充电站和充电桩的数量分别为68座和4872个，同比增长分别为-75.9%和-55.1%。</p>
<p>重新加速期(2014年)：政策和市场的双轮驱动充电设施建设。政策方面，2013年底和2014年初两批新能源汽车推广应用城市的确定，加速了各地充电设施建设规划的集中出台;市场方面，2014年新能源汽车销量的快速增长，尤其是比亚迪插电式混合动力车——秦的爆发式增长，催生了充电设施需求的增长，2014年充电站和充电桩的同比增长率分别为282.4%和72.1%。</p>
<p>2015年及以后：充电设施建设将大幅提速。《关于新能源汽车充电设施建设奖励的通知》、《关于电动汽车用电价格政策有关问题的通知》及《关于加快推进新能源汽车在交通运输行业推广应用的实施意见》等重磅政策的密集发布，以及比亚迪插电式混合动力车唐、江淮iEV5、众泰及北汽EV200等一系列具有市场竞争力的车型的上市，驱动充电设施在2015年迎来第二次超前建设。</p>
<p>早在2017年，新能源桩车比(充电桩与车辆数量之比)已经从2015年的1:12提升到了1:3.8，这就意味着平均不到4辆新能源车共用1个充电桩。而在目前，新能源充电桩的数量依旧在飞速地提升中。按照国家发展规划，2020年将有480万个充电桩落地，这当中投入的金额为1440亿元。</p>
<p>2018年底，国家电网、南方电网、特来电、蓝天伟业、万帮充电等充电设施运营龙头企业，共同发起设立一家合资公司——河北雄安联行网络科技股份有限公司，希望成为能够接入全国90%以上充电桩的平台。这次“国家队”与民营龙头玩家的合作，或许意味着电动汽车充电服务行业正展开一轮整合大潮，产业集中度将进一步提高。近几年，中国私人充电桩数量超过公共类充电桩数量。</p>
<p>受下游新能源汽车市场驱动，中国充电桩需求快速增长。随着新能源电动汽车终端销量和渗透率高速增长，配套设备充电桩需求快速增长。且我国人口密度大、高速公路里程长的人口及道路特点对国内充电站和充电桩的数量以及充电效率提出了更高的要求。“十四五”规划明确充电桩建设目标，为各省市充电桩行业发展提供重要动力。2022年1月21日国家发改委、国家能源局等十部门近日印发《关于进一步提升电动汽车充电基础设施服务保障能力的实施意见》，明确到“十四五”末，我国电动汽车充电保障能力进一步提升，可满足超过2000万辆电动汽车充电需求。随后，31个省市相继出台了一系列相关政策和规划为中国充电桩行业的发展提供了重要动力，其中北京、广东、上海、海南等省市明确规划了2025年充电桩建设规模，进一步推动中国充电桩行业的快速发展。</p>
<p>我国充电基础设施建设基本满足新能源汽车需求。2022年我国充电基础设施保有量达到521万台，新能源汽车保有量为1310万辆，车桩比为2.5:1。从增量角度看，2022年我国充电基础设施增量为259.3万台，新能源汽车销量为688.7万辆，车桩增量比为2.7:1。其中，公共充电桩增量为65.1万台，同比上升91.6%，随车配建私人充电桩增量为194.2万台，同比上升225.5%。公共充电桩占比下滑至34.5%。从电流类型来看，公共充电桩直流占比为42.4%。</p>
<p>二、中国充电桩行业发展存在的问题及对策</p>
<p>1、接口标准待统一，成本支出巨大，影响了充电桩行业的快速发展。</p>
<p>目前国际上最主要的充电标准有两种：CCS和CHAde-MO，前者是欧美国家通行的直流快速联合充电标准系统(Combo Charg-ing System，简称CCS);后者是日本电动汽车协会和日本电动车充电协会推出的标准。这也是美国市场目前在使用的两种直流快充标准。就目前而言，日本标准CHAde-MO的势头很猛，除了日系车在美国的高占有率直接带动了CHAdeMO标准的使用，日本政府的推广力度也大大加强了日系充电标准的接受度。而欧盟也从最初的打压，到不得不接受。</p>
<p>也就在CHAdeMO与CCS争夺谁是国际标准进行如火如荼之季，我国充电国标却迟迟未能出台，这不可避免地导致国内已经建成的大批充电桩因为充电接口的不兼容而利用率低下，资源浪费严重，且导致提前布局的相关经营企业盈利情况不容乐观。</p>
<p>充电桩属于公共设施，牵涉多个利益相关方，投入大，产出少，其实更适合垄断企业运营。充电桩类似于电信行业的基站，投资成本巨大，它只有覆盖更多的用户，才能有效降低成本。</p>
<p>更改接口标准不仅是对单一的接口部件作出改变，由于各种标准的接口直径不同，差之分毫就可能出现安全隐患，因此往往需要将整块铁板拆下来重新安装，人力费和材料费都是新增成本。针对快充充电机改造还要对充电设施内部的电缆、配电设施进行多方调整，这个成本不亚于重新投资。</p>
<p>纯从数字角度来看，中日联合能取得压倒性优势，即使相对倾向欧洲立场的美国，在中日新标准成为事实上的世界标准之后，很可能也会采用中日新标准。</p>
<p>2、国内低端生产企业的恶性竞争制约了电源、充电桩行业的发展</p>
<p>我国低研发能力、低创新能力及低制造能力的电源、充电桩生产企业过多，低水平重复建设现象严重。这些企业往往通过恶性的价格竞争获取市场，价格战的结果使得电源、充电桩行业利润普遍降低，企业积累利润的速度减慢，致使装备升级和研发投入不足，企业发展缺乏后劲。</p>
<p>3、研发投入不足，产业持续发展能力较弱</p>
<p>我国目前电源产品技术含量不高，缺乏核心自主知识产权，并且由于资金和技术实力不足的限制很难进行新产品的研发，在短期利益的驱使下企业开展新产品的深入研究和开发动力不足，产品技术含量低，导致电源行业技术含量提升缓慢，提高自主创新能力，有利于充电桩行业的发展。</p>
<p>三、新能源汽车仍存在“充电慢”的核心痛点</p>
<p>随着整车带电量和续航里程提升，充电便利性成为制约电动车使用体验提升的一大因素。以部分热销纯电动车型为例，支持快充的纯电动车平均理论充电倍率约为1C，即实现SOC30%-80%(StateofCharge，即荷电状态，用来反映电池的剩余容量)需要充电约30分钟。而在实践中，大部分纯电车实现SOC30%-80%需要充电40-50分钟、仅可行驶约150-200km，“充电慢”依然是纯电动乘用车行业的核心痛点。</p>
<p>四、高压快充已成为充电难题的重要解决方案</p>
<p>为提升消费者充电体验，可通过继续改善车桩比，或大幅缩减充电时间，来满足消费者快充的需求。而在快充方面，目前两条技术路线：提高充电电流和提升充电电压。从不同的实践来看，高压快充能够在更宽范围内实现最大功率充电，更能匹配未来快充需求：</p>
<p>1)大电流路线：推广程度低，对热管理要求高。根据焦耳定律(公式Q=I2Rt)，电流的提升将大幅增加充电过程中的热量，对散热要求很高，例如特斯拉大电流快充方案，其V3超充桩峰值工作电流超过600A，需要使用更粗的线束，同时对散热技术要求更高，且仅能在5%-27%SOC实现250kW最大充电功率，高效充电并非全程覆盖。目前国内车厂并没有在散热方案上做大幅定制化改动，且大电流充电桩很大程度上依赖自建体系，推广成本高。</p>
<p>2)高电压路线：是目前车厂普遍采用的模式，可兼顾降低能耗、提高续航、减少重量、节省空间等优点。目前受限于硅基IGBT功率器件的耐压能力，车企普遍采用的快充方案是400V高压平台，即以250A电流可以实现100kW的充电功率(100kW功率充电10min可行驶约100km)。自保时捷推出800V高电压平台后(实现300KW功率，高压线束减少一半)，此后各大车企开启对800V高压平台的研究与布局。800V电压平台相较于400V平台，工作电流更小，进而节省线束体积、降低电路内阻损耗，变相提升了功率密度和能量使用效率。</p>
<p>五、中国充电桩行业商业模式分析</p>
<p>目前，我国充电桩的商业模式主要有“充电桩+商品零售+服务消费”模式，“充电APP+云服务+远程智能管理”模式，“整车厂商+设备制造商+运营商+用户”模式。</p>
<p>电改放开后，充电设施建设实现市场化，民营资本等有望进入，而充电桩企业具备熟悉市场的优势，同时转向下游环节所带来的协同效应也将充分显现。随着各界资本纷纷进入充电运营领域，设备企业+资本进行的转型将带来各种运营模式的创新。当前，我国充电桩行业的创新商业模式有常州众筹模式、“电桩”模式、PPP模式、特锐德模式、华贸中心模式等等。另外，目前国际主流的充电桩运营模式有三种，分别是政府为主导的充电桩运营模式、电网企业为主导的充电桩运营模式、汽车厂商为主导的充电桩运营模式。</p>
<p>充电桩的建设需要大量资金，目前看来，政府以及电网、民营资本、汽车企业等多个渠道均有资金注入这个业务。但充电桩业务仍需探索明朗的盈利模式，才能吸引更多社会资本参与到充电设施的建设中。</p>
<p>目前全球充电桩行业的主要盈利模式有：借力电改，批发+零售电力盈利模式;中规中矩，收取充电服务费盈利模式;换个思路，瞄准停车市场蓝海模式;开放思维，充电服务生态系统盈利模式;众人拾柴，众筹建桩;美国的免费充电桩模式等等。</p>
<p>行业的商业模式是以新能源汽车充电设备、电气设备、电力设备、电源设备制造为主业，以电源及充电桩产品应用中先进的解决方案系统集成、制造技术为保障，以为国内外电源及新能源行业提供技术服务为补充，实现销售以获取利润。</p>
<p>在为客户提供技术支持的同时，行业还提供电源产品及充电设备。行业的商业模式整合了的研发能力、可靠的质量控制、稳定的顾客资源，保障行业在市场竞争中处于有利地位。</p>
<p>(一)行业的经营模式行业以新能源汽车产业链为企业战略业务核心，利用产品和技术优势，与产品用户保持稳定的伙伴关系，在合作中实现共赢。围绕新能源电动汽车生产使用的各种测试、生产电源设备以及充电设备进行产业分布。</p>
<p>行业在经营模式上，借鉴阿米巴经营模式(把行业细分成所谓“阿米巴”的小集体，并委以经营重任，从而培育出许多具有经营者意识的领导者)等先进经营模式，结合行业实际情况，为更进一步解放发展生产力，力求全员参与经营，形成了具有行业本身特色的经营模式。</p>
<p>行业内部以客户需求为核心，按照业务流程设置岗位节点，以需求供给关系确定组织架构，即每个岗位节点即为上个岗位节点的供给方，同时也承担着下一个岗位节点的需求任务。</p>
<p>(二)行业的销售模式行业产品的销售采用“订单销售”模式。行业销售中心签订销售合同，合同签订后，销售中心根据合同，编制产品制造单，下发到品保部、采购部、事业部，各部门根据产品制造单的要求制定各自的作业计划并实施，保证产品如期按时完成。生产完成由品保部终检，产品合格后，通知销售中心，销售中心联系物流部门进行产品发运。</p>
<p>(三)行业的盈利模式行业通过研发、生产满足客户要求的电源、充电桩产品实现业务收入。盈利增长点来自于产品加工增值，行业通过优良的产品品质和良好的服务，保障了行业稳定的客户群和稳步增长的业务收入。</p>
<p>1、改进工艺流程，降低成本，提高利润行业通过不断改进产品的加工工艺流程，采用新技术、新方法提高生产效率，降低废品率，提高材料利用率，降低人工成本及固定成本费用，进而提升利润空间。</p>
<p>2、利用技术优势，为客户提供整体解决方案，创造新的利润增长点行业主要的竞争优势就是技术优势、研发优势，行业能够利用自身优势，为客户提供整体解决方案，在出售产品的同时，取得超过产品本身的超附加值，从而提升行业的整体效益。</p>
<p>3、争取政府科技攻关项目，取得政府科技资金的支持行业具备较强的研发实力，已完成多项政府科技创新项目，取得了政府科技资金的支持。随着国家对实体经济支持力度的加大，有研发能力的优秀企业，必将会继续得到政府科技基金的支持。行业将加大科技研发的投入，争取更多政府科研项目资金的支持。</p>
<p>第二节 充电桩行业发展现状分析</p>
<p>一、充电桩行业投资现状</p>
<p>1、充电桩投资规模分析</p>
<p>充电桩行业投资分为公共充电桩和私人充电桩两大类。因私人购车比重提高，私人充电桩建设投资占比提高。2020年受“新基建”政策推动，充电站与公共充电桩新增数量大幅增长，行业投资规模显著回升，2022我国充电桩投资规模达到了369.09亿元，其中公共充电桩投资规模大幅增长至281.66亿元，私人桩投资规模增长至87.43亿元。</p>
<p>2、充电桩检测投资规模分析</p>
<p>由于新基建的提出，充电桩成为助力国家稳增长的重要力量，充电桩投建速度有望加快，整体充电桩制造市场呈现周期向上的特征。同属于新基建范畴内的5G，大数据和人工智能的应用都可以加快新能源汽车的推广，从而带动充电桩建设，加速推动充电桩行业发展;窗口期也将缩短，优胜劣汰即将加速。2022年充电桩检测投资规模达到89.2亿元。</p>
<p>二、充电桩行业市场规模分析</p>
<p>1、充电设施市场规模分析</p>
<p>2022年我国充电基础设施继续高速增长，年增长数量达到260万台左右，累计数量约520万台。</p>
<p>2、充电桩市场规模分析</p>
<p>图表：2020-2022年中国充电桩行业市场规模(单位：亿元)</p>
<p>数据来源：中研普华产业研究院</p>
<p>新能源汽车充电问题被认为是新能源汽车推广的“最后一公里”，对于推广发展新能源汽车至关重要。近年来，中国新能源充电桩行业市场规模一直保持增长趋势，市场规模从2017年的72亿元增长至2021年的418.7亿元，复合年均增长率高达42.2%。2022年市场规模达到809.6亿元。随着新能源汽车的超预期增长，充电桩产业链有望迎来风口，2023年市场规模将突破千亿元。</p>
<p>本报告由中研普华咨询公司领衔撰写，在大量周密的市场调研基础上，主要依据了国家统计局、国家商务部、国家发改委、国家经济信息中心、国务院发展研究中心、工信部、中国行业研究网、全国及海外多种相关报纸杂志的基础信息等公布和提供的大量资料和数据，客观、多角度地对中国充电桩市场进行了分析研究。</p>
<p>报告在总结中国充电桩发展历程的基础上，结合新时期的各方面因素，对中国充电桩的发展趋势给予了细致和审慎的预测论证。报告资料详实，图表丰富，既有深入的分析，又有直观的比较，为充电桩企业在激烈的市场竞争中洞察先机，能准确及时的针对自身环境调整经营策略。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>充电设施分类</title>
    <url>/2023/06/04/%E5%85%85%E7%94%B5%E8%AE%BE%E6%96%BD%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、以安装条件进行分类，主要分为立式充电桩和壁挂充电桩立式充电桩无需靠墙，适用于户外停车位或小区停车位，而壁挂式充电桩必须依靠墙体固定，适用于室内和地下停车位。</p>
<p>2、以服务对象进行分类，主要分为公共充电桩、专用充电桩和自用充电桩。公共充电桩由政府机关等具有公共服务性质的机构置办，服务对象面向任何电动汽车车主，例如公共停车场。而专用充电桩多为企业建造，服务对象为客户和内部人员，例如商场停车场。自用充电桩为私人充电桩，安装于私人领域，不对外开放</p>
<p>3、以安装地点防护等级进行分类,主要分为室内充电桩和室外充电桩</p>
<p>4、以充电接口的数量进行分类，主要分为一桩一充和一桩多充。目前市场上充电桩以一桩一充式为主，在公交停车场这样大型停车场中，需要多充式充电桩,同步支持多台电动车充电,不但加快充电效率，也节省了人工。</p>
<p>5、以充电类型进行分类，主要分为交流充电桩和直流充电桩。交流充电桩一般是小电流、桩体较小、安装灵活、充满电一般在6-8个小时，适用于小型乘用电动车，多应用于公共停车场、大型购物中心和社区车库中，家用充电桩也多为交流充电桩。而直流充电桩一般是大电流,短时间内充电量更大、桩体较大、占用面积大(散热)。直流充电桩适用于电动大巴、中巴、混合动力公交车、电动轿车、出租车、工程车等快速直流充电。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>千万级的大风电并网都存在什么问题</title>
    <url>/2023/06/03/%E5%8D%83%E4%B8%87%E7%BA%A7%E7%9A%84%E5%A4%A7%E9%A3%8E%E7%94%B5%E5%B9%B6%E7%BD%91%E9%83%BD%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/21878327/answer/36981268">https://www.zhihu.com/question/21878327/answer/36981268</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>在回答这个问题之前，先扯点别的东西，学习下他国经验。</p>
<p>提及风电，言必称丹麦，2013年丹麦电力有近4成来自于风力，这是个很夸张的数字。</p>
<p>那丹麦乃至欧美的风电并网和我国的大规模风电并网有什么不同呢？</p>
<p>数量级不同</p>
<p>中国所谓‘大规模’指的是千万千瓦级风场，而欧美的‘大规模’指的是几十万千瓦级的风场；中国所说的‘远距离’指的是几百上千公里的输送，欧美的‘远距离’基本上在一百公里左右。以美国得克萨斯为例，在美国算是大型风场，其最大风电场仅为73万千瓦，风电集中输送也仅有上百公里。</p>
<p>并网思路不同</p>
<p>我国风电存在“大基地建设，大规模送出”的思路，欧美则是“”分散接入，就地消纳“的思路，这里先不提好坏，只说事实。德国2006年风电场装机容量小于50MW，接入110kV以下配电网规模约占总量的70%；丹麦风电机组主要接入30kV及以下网络，2006年底丹麦风电装机容量中，约88%接入低压网络和10～30kV配电网。</p>
<p>能源结构不同</p>
<p>欧洲燃气、燃油发电和水电比例大，调峰能力强。拿丹麦来说，丹麦的地理位置优越，北有水力发电站，南有火电发电厂。因此当风力不够的时候，可以从挪威引进环保的水电。电力的互送非常频繁，一年中，丹麦要进出口的电相当于该国总用电量的30%。而我国幅员辽阔，电源负荷分布不均，而且电源以火电为主，调节能力相对较差，具体的下面细说。</p>
<p>对电网的要求</p>
<p>不同欧洲风电基本是分散接入，对电网用户侧的智能化要求是比较高的，而欧洲电网也是围绕这个方向在发展；而我国的大规模送出则是另一个课题了，面对的困难也不一样。所以，欧洲有些风电并网的经验可以借鉴，但是很多困难却是特殊的。</p>
<p>下面具体说说千万级风电并网的问题。</p>
<p>能源结构</p>
<p>上面已经提到了，这里详细的描述下。</p>
<p>风电大家都知道是具有波动性的，从一年中风电场每天平均输出功率看，每天最大和最少发电量至少相差约40～50倍。从微观上分析一天内的输出功率变化，风电在24小时内仍处于非常不稳定状态，输出功率(兆瓦)在0～100之间随机波动。</p>
<p>而且，夜晚用电负荷处于低谷时段风电发电出力往往较大，即使常规电源降出力，当风电规模达到一定程度（大于低谷用电负荷），也难免出现限电弃风。下图为风电出力曲线和负荷需求曲线对照。</p>
<p>风电的波动性带来的是它需要对应合理的电源进行调峰，从而来满足负荷平衡。而我国以煤电为主的电网难以为风电做深度调峰的。2012年我国煤电发电量占总发电量的73.9%。而欧美国家的能源结构是以石油、天然气等为主，其中美国27%是天然气发电;英国燃气发电比例更高达60%;北欧国家水电占90%。</p>
<p>所以，这些国家电网对风电并网容纳能力远高于我国，这是因为燃气、燃油发电和水电的调峰能力比煤电强，在一定范围内能有效减少风电波动对电网的危害。即便如此，美国、丹麦等西方国家也已遭遇大规模风电上网难的制约。</p>
<p>这是比较本质的问题。</p>
<p>电网问题</p>
<p>这是中国大规模风电并网面对的特殊问题，当然，欧洲海上风电以后集中打捆送出也会需要到这个问题，但送出距离比我国近很多。</p>
<p>首先这个大规模并网的可行性需要论证，上千万千瓦级超大型电源建设，涉及电力系统规划的问题十分复杂，仅三峡工程电力输出规划就论证了十多年，因此，千万千瓦级的风电项目大规模送出怎么可能不需要充分论证？</p>
<p>对电网的影响，大概说来，试想下，有几千台甚至上万台风力发电机组在同一接入点接入电网，风电输送线路长度可能达到几百甚至上千公里。风电出力的随机波动导致线路无功的流向和规模频繁变化，只依靠电网进行无功调节是无法满足风电波动对电压的影响的。另外，当风电机组低电压穿越能力不足时，电网一个很小的故障，也可能使风电基地切除，可能造成重大电网事故。</p>
<p>即使论证可行，一般来说，电网的建设是远远滞后于风电建设的，具体实施起来也有很多困难。</p>
<p>抛开规模不谈，欧洲的风电并网的电网适应性还是比较好的。举个例子，在星期六凌晨4点前后风电大发时，丹麦风电出力占负荷需求的比重可达95%以上，此时丹麦向北欧电网输出电力，北欧电网通过跨国/跨区输电网为丹麦电网提供备用，以保证电网安全稳定运行。而在星期六18点前后风速超过25m/s时，风机退出运行，风电场出力急剧下降，此时北欧电网向丹麦输入大量电力，满足负荷需求。</p>
<p>其他问题</p>
<p>风电运行管理水平这块，欧洲水平是很高的，以西班牙和丹麦为代表。他们广泛开展了风电功率预测工作，都实现了风电输出功率的日前预测，西班牙规定风电出力预测误差超过20%时将被罚款，2006年，西班牙绝大多数风电场发电量都销售给了电网企业，只有不到5%的风电由于预测误差超过20%，发电企业不愿交罚金而采取了弃风措施。然后对风电场进行有效调控，如西班牙成立可再生能源电力控制中心(CECRE)，对风电场进行有效监控和有序调控，水平非常高。</p>
<p>我国这方面就差强人意了。</p>
<p>电价等管理政策</p>
<p>这块不太好说，毕竟国家不同。就说德国吧，德国1991年颁布的《电力入网法》强制要求公用电力公司收购可再生能源电力，但1998年后德国电力行业市场化，销售电价整体下降，为了缓解压力，2000年4月德国出台了《可再生能源法》，核心政策调整为可再生能源强制入网，采用固定电价优先购买，并建立了可再生能源电力成本全网分摊制度。2009年1月，针对风电在电源结构中的比例不断提高、对电网安全稳定运行影响日渐突出，又颁布了可再生能源法修正案(EEG2009)，对部分情况下风电可不优先收购进行了规定。</p>
<p>可以看出，非常灵活，我国任重道远。</p>
<p>或许可以期待下储能？呵呵。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新能源并网</title>
    <url>/2023/06/02/%E6%96%B0%E8%83%BD%E6%BA%90%E5%B9%B6%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/19862668">https://zhuanlan.zhihu.com/p/19862668</a></p>
<p>新能源并网，是一个比较敏感的问题，也是一个平时电力系统设计的时候经常遇到的问题，小到一个单体工程的接入系统，大到一个区域的新能源的电网消纳，都是有很多注意的地方。</p>
<p>现在从事新能源的也越来越多了，这里只是总结和电力系统关联的并网部分，新能源本体部分涉及的比较少。</p>
<p>一、新能源并网对电网的影响</p>
<p>新能源其实是包含很多东西的，这里主要讨论风电、光伏和分布式电源，当然分布式电源可能有些包含小型光伏等，理解意思即可。</p>
<p>涉及对电网的影响，其实主要分为两块，一是风电这种接入主网的新能源，二是分布式电源这种接入配网的新能源，两者的影响内容是不一样的。</p>
<p>1）接入主网的新能源，以风电为例，主要有以下影响：</p>
<p>增大调峰、调频难度：风电随机性强、间歇性明显。波动幅度大，波动频率无规律性。风电的反调峰特性增加了电网调峰的难度。 据东北、蒙西和吉林电网统计结果，风电反调峰概率分别为60%、57%和56%。吉林电网由于风电接入，一年期间峰谷差变大的时间达到210天。由于调峰容量不足，吉林、蒙西电网都出现了低负荷时段弃风的情况。 下图为风电出力与电网负荷表现出较强的反调节特性。（华北电网张家口地区）</p>
<p>加大电网电压控制难度：风电场运行过度依赖系统无功补偿，限制了电网运行的灵活性。据统计，受风电影响： 蒙西电网锡盟灰腾梁风电基地沿线变电站220千伏母线电压全年维持在额定电压的1.1倍；蒙西塔拉地区500千伏无功补偿设备停运时，220千伏系统电压最高升至257千伏。</p>
<p>局部电网接入能力不足 ：风电场大多处于电网末梢，大规模接入后，风电大发期大量上网，电网输送潮流加大，重载运行线路增多，热稳定问题逐渐突出。 甘肃酒泉地区2007年以来风电、小水电快速发展，送出矛盾加剧，尽管采用过负荷切机以及变电站分裂运行等措施来提高输送能力，但风场弃风问题仍然长期存在。<br>增加电网稳定风险：风电的间歇性，随机性增加了电网稳定运行的潜在风险。 一是风电引发的潮流多变，增加了有稳定限制的送电断面的运行控制难度； 二是风电发电成分增加，导致在相同的负荷水平下，系统的惯量下降，影响电网动态稳定； 三是风电机组在系统故障后可能无法重新建立机端电压，失去稳定，从而引起地区电网的电压稳定破坏。<br>2）接入配网的新能源，以分布式电源为例，主要有以下影响：</p>
<p>保护问题：潮流的改变，一会导致本线路保护的灵敏度降低及拒动； 二会导致本线路保护误动； 三会导致相邻线路的瞬时速断保护误动并失去选择性； 四回导致重合闸不成功。<br>应对措施<br>：一是限制分布式电源的并网容量； 二是增加分布式电源隔离变压器阻抗； 三是分布式电源出口增设方向功率保护；其中最关键一点在于分布式电源并网之前，要在充分调查发电设备阻抗的基础上，计算分布式电源可能带来的短路电流的增加，以确定分布式电源的并网容量。</p>
<p>电压问题：一是分布式电源启停的影响 ，二是分布式电源供电间歇性的影响。<br>应对措施：一是从电压支撑角度，分布式电源有明显积极作用。这取决合理选择接入地点、合理选取容量并适当调度； 二是正常情况下，分布式电源应多发有功少发无功，保持高功率因素运行；减少线路电压对分布式发电依赖； 三是在分布式电源接入地点，应安装适当无功电压支撑设备，在分布式电源退出运行时投运。</p>
<p>电能质量问题：分布式发电通过电力电子逆变器并网，易产生谐波、三相电压/电流不平衡；输出功率随机性易造成电网电压波动、闪变； 分布式电源直接在用户侧接入电网，电能质量问题直接影响用户的电器设备安全。<br>应对措施：一是分布式电源与直流注入问题，并网模式下，通过分布式电源控制功能，较大容量的逆变型分布式电源机组出口处设置隔离变压器。二是电压不平衡问题，对于采用单相并网的分布式电源机组，可以将其接入到带负荷较多的一相，从而减少电压的不平衡度。</p>
<p>接入配网的影响，其实还有很多：短路电流问题，通信计量问题，孤岛问题等，但根本在于：分布式电源接入配网，潮流分布改变，配电系统从放射状变为多电源结构。</p>
<p>二、新能源并网的技术要求</p>
<p>这块的东西比较规程化，对照最新的规程简单的总结一下，内容比较多，只列框架。</p>
<p>1）风电</p>
<p>《风电场接入电力系统技术规定》2012年版。</p>
<p>主要是以下部分：</p>
<p>2）光伏</p>
<p>《光伏电站接入电网技术规定》2011年版</p>
<p>3）分布式电源</p>
<p>《国家电网分布式能源接入系统技术规定》2010年版</p>
<p>其实，里面很多相似的东西，对照规程看几遍就可以了。</p>
<p>三、新能源并网关键问题（摘自我做的PPT）</p>
<p>1）风电</p>
<p>风电接入规模问题</p>
<p>基于大规模风电的电源规划问题</p>
<p>系统友好型风电场</p>
<p>风电与电网协调发展的运行管理策略</p>
<p>2）光伏</p>
<p>并网逆变器控制<br>——最大限度提取电能</p>
<p>接入主网和接入配网<br>——接入电网的安全稳定问题</p>
<p>逆功率问题<br>——自发自用，多余上网</p>
<p>光伏并网检测技术<br>——并网标准和并网技术</p>
<p>3）分布式电源</p>
<p>这块在前面已经提过（接入配网带来的问题里面），都是需要解决的关键问题。</p>
<p>四、大规模新能源消纳能力分析</p>
<p>很多人都知道，新能源消纳能力是影响新能源开发的一个关键制约，所以这里并不想深入的举例分析这种现象，而是总结下消纳能力分析的一些要素，也是实际工程里面用得到的。</p>
<ol>
<li>以风电为例，首先是影响消纳能力的要素：</li>
</ol>
<p>系统调节能力：风能具有问歇性、波动性、随机性的特点。此外，从风电的年出力特性看，中国大部分地区的风电出力呈现春季、冬季较大，夏季、秋季较小的特点;而从日出力特性看，中国风电出力多数是在白天负荷高峰时段较小，后半夜负荷低谷时段较大，呈现明显的反调峰特性。风电的大规模接入给电力系统的调频调峰带来了严峻的挑战。<br>因此，良好的电源结构和充足的备用容量是风电消纳的基础，风电开发客观上需要一定规模的灵活调节电源与之相匹配。欧美等国家在大力发展风电的同时，注重配套抽水蓄能、燃油燃气等灵活调节电源的建设。美国、西班牙、德国灵活调节电源的比例分别达到了48.4%,36.4%以及22. 8%。充足的调节能力是这些国家风电开发和消纳的力保障。调峰能力不足己成为制约中国风电消纳的主要因素之一。</p>
<p>电网输电能力：风电的随机性和问歇性特点使得大规模风电并网后，系统对备用容量的需求大幅增加。通过提高电网输电能力，可以扩大风电平衡区域范围，充分利用系统备用容量，并可根据不同地区负荷峰谷的时间差消除风电出力波动性对系统的影响，提高风电并网消纳规模。<br>中国风电富集的东北、华北、西北等地区，大部分省区系统规模较小，负荷水平较低，网架结构相对薄弱，限制了风电消纳范围。东北电网虽然区域内联系较强，但黑龙江、吉林、辽宁以及蒙东地区均为风能资源丰富地区，风电装机规模较高、电源结构相近、调峰能力不足、区域内相互调剂能力有限，需要进一步扩大消纳范围;处于华北的蒙西电网与相邻的京津唐电网之问仅有4 GW的电力交换能力，且河北北部也是国家规划的千万千瓦级风电基地，在现有通道上加大蒙西电网的风电送出规模会挤占河北风电的消纳空问;西北的甘肃酒泉、新疆哈密是规划的千万千瓦级风电基地，但由于本地负荷小，距离负荷中心较远，即使利用己建成的750 kV输电通道，仍然不能满足千万千瓦级风电基地电力电量消纳的需求。在电源结构、系统调峰能力短期内难以解决的情况下，跨省跨区的电网输电能力，己成为中国风电消纳的最主要制约因素。</p>
<p>风电并网技术性能：能否保证风电大规模接入后不降低系统的安全稳定水平，是影响风电有效消纳的重要因素。为保证系统安全稳定运行，丹麦、德国、爱尔兰、英国等国家在2002年左右就己建立了完备的风电并网标准体系，对风电并网运行提出了详细的技术要求，如有功和无功运行范围、控制能力、低电压穿越能力、信息监控等。德国最新的并网标准更是提出了零电压穿越的要求，要求风电场、光伏电站在电网电压跌落到。的时候，仍能并网运行150 ms。在并网标准约束下，制造企业不断提高风电设备并网运行的技术水平，减少大规模风电对电网的冲击。<br>中国风电发展起步相对较晚，也没有强制性的风电并网技术标准。大部分设备制造企业依靠引进国外设计图纸生产组装风电机组，自主研发能力不足，己并网的风电机组有部分不具备有功、无功调节功能和低电压穿越能力（目前并网的都满足），风电场自动化水平较低，给电力系统安全稳定带来了隐患。甘肃千万千瓦级风电基地一期5GW风电场建成以来，由于不具备低电压穿越能力，多次发生风电大发期间风电场局部故障导致大规模风电机组脱网事故，给电力系统的安全稳定运行带来了严重影响。</p>
<p>风电调度运行水平：做好风电的调度管理，合理安排系统中其他电源的运行模式，是实现风电电量最大化消纳的关键。而建立完善的风电运行监测体系和风电功率预测预报机制，是实现风电优化调度的前提条件。<br>从功率预测系统覆盖范围的角度而言，中国则与国外风电发达国家存在明显差距。一般地，电网调度部门和风电场端都应该安装满足精度要求的风电功率预测系统，中国风资源丰富的省级电网均安装了风电功率预测系统，可根据预测信息进行-定程度上的优化调度。但绝大多数风电场还没有配置风电功率预测系统，也不具备风电发电计划上报和执行功能（目前并网的已做要求），不利于系统的优化调度，也影响了风电的消纳。</p>
<ol start="2">
<li>其次是风电消纳能力的分析方法：</li>
</ol>
<p>在计算风电消纳能力时，需首进行调峰能力计算，得出考虑系统调峰能力约束的风电接纳能力范围；<br>然后计算地区风电场穿透功率极限用以表征风电送出问题；<br>最后对风电场并网后的电网进行稳定性分析。<br>综合以上三方面的分析，得出电网风电接纳能力的，这三点其实也是比较好理解。</p>
<p>调峰能力计算：对于电网而言，风电的出力波动更像一个负的负荷扰动。因此，电网中常规电源不仅需要为负荷波动留出足够备用，当有大量风电注入电网后，还需要考虑为风电场留出一定备用以平衡风电场出力的变化。在风电场出力产生较大波动时，需调度电网内其他电厂改变出力水平以平衡风电出力的变化。特别是在负荷较低时，常规电厂机组已经调到较低出力，如果此时风电场出力大幅增加，那么常规机组能否进一步压出力让风电来带负荷决定了电网接纳风电的能力，也就是说常规机组在低谷负荷时的调峰能力是限制电网接纳风电能力的关键条件。这里面有公式计算，可以找论文细看，很多论文里面都有。</p>
<p>风电场穿透功率极限：风电场穿透功率极限是表征一个给定规模的电网最大可以承受的风电功率。目前，多以风电场穿透功率极限来描述系统风电接入容量极限。关于风电场穿透功率极限的定义有多种形式，但考虑到我国的实际情况，将其定义为系统能够接受的最大风电场装机容量和系统最大负荷的比值。</p>
<p>这个指标和系统的备用容量、风电场的并网性能、电网的短路容量和输送能力、电网调度方式都有关系，一般的计算方法有动态仿真法，数学优化法，频率约束法等。这块一般采用数学优化法比较多。</p>
<p>接入后的稳定分析：风电场在短时间内完全切除是大规模风电接入给电网带来的最严重的扰动，在这种情况下极可能发生系统频率和电压的同时失稳；风速的大幅波动会造成风电场出力的大幅度波动，从而恶化系统的调峰调频性能；线路短路故障会影响风电机组的暂态调节性能，故障切除后风电场的恢复速度影响风电场的出力。为此，工程中多数考虑风电场切机、风电场阵风扰动和线路短路故障下相关母线和电站的暂态稳定性。下图为风场切机后相关电站的频率情况。</p>
<p>总结大概就这么多吧，很多东西新能源专业的人员写可能会更好些。</p>
<p>某些图片和数据来源于网络，若有侵权，请联系删除。带来不便请见谅。</p>
<p>微信公众号：严同笔记 —- 定期写文，供交流讨论</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式能源与微电网、电站的关系</title>
    <url>/2023/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E8%83%BD%E6%BA%90%E4%B8%8E%E5%BE%AE%E7%94%B5%E7%BD%91%E3%80%81%E7%94%B5%E7%AB%99%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电站没什么好说的，就说说分布式能源和微电网的区别吧。</p>
<p>分布式能源（DER）：一般定义为包括分布式发电（DG）、储能装置（ES）和与公共电网相连的系统。其中DG是指满足终端用户的特殊需求，接在用户侧的小型发电系统，主要有内燃机，微型燃气轮机、燃料电池、太阳能、风能等发电系统。</p>
<p>分布式能源有很多优点，比如可实现能源综合梯级利用，弥补大电网稳定性方面不足，环境友好等，但是它的最本质缺点在于不可控和随机波动性，从而造成高渗透率下对电网稳定的负面影响。</p>
<p>所以，分布式能源和微电网的本质区别就在于前者不可控，后者可控。</p>
<p>微电网把分布式发电、储能装置、负荷通过控制系统协调控制，形成单一可控单元，直接接在用户侧，优点是非常明显的。</p>
<p>微电网的控制模式和策略是里面的关键部分，无论是系统级的主从、对等和综合性控制模式，还是逆变器级的P/Q、U/f、下垂控制，乃至和储能相结合的控制方式，都是微电网的核心部分。而这些，在分布式能源系统里面是不会涉及的。</p>
<p>所以说，很多外面在搞的微网项目，特别是中国人在国外援建，都是在混淆概念，没有控制系统，其实只能叫做分布式发电（分布式能源系统都算不上）。</p>
<p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/22515671/answer/35688123">https://www.zhihu.com/question/22515671/answer/35688123</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>作者：林石边<br>链接：<a href="https://www.zhihu.com/question/22515671/answer/35666153">https://www.zhihu.com/question/22515671/answer/35666153</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>1、电站：</p>
<p>传统电网分为发输变配用，或者说（电）源-（电）网-（负）荷。电能是单相流动的，大型的电站发电，长距离电网送电，到用户这里用电。</p>
<p>2、分布式能源：</p>
<p>电网里中一种利用可再生能源的方法，因为风能、太阳能的分布不会像煤矿、天然气那样集中，所以在西北之类风光资源充足的地方修建大型风电场、光伏电站的同时，可以在用户侧接入小型的风机、光伏、储能、燃气轮机等电源设备，省去了在电网中传输的损耗，提高可再生能源的比例。这里风机、官府、燃料电池、微型燃气轮机成为分布式发电（Distributed Generations，DGs），带上储能设备称为分布式电源（Distuibuted Energy Resource，DER）。</p>
<p>3、分布式的问题：</p>
<p>由于用户侧出现了电源，传统源-网-荷的单向能量流变成了双向，导致电网既定的调度、保护策略面临了新考验，加上风、光资源具有波动性和随机性，发电难以控制，分布式电源直接并网最终会导致整个电网络不稳定。随着2012年底国家开放分布式并网政策，2013年国电电网公司规定6MW以下分布式电源免费接入10kv线路，2014年又规定20MW以下光伏电站（实际是分布式电源，所以所分布式电源其实就是小型的电站）可以接入35KV线路售电，部分地区已经出现过因为光伏发电比例过大（渗透率高）导致系统崩溃的事故。于是，为了让分布式电源可控，大约06年开始提出了各种方案，最有前途的是两种，微电网（Mircogrid，MG）和虚拟电厂（Virtual power Plant，VPP）。</p>
<p>4、微电网：</p>
<p>微电网是把分布式电源和它所供能的负荷以及能量转换、保护、监控等装置作为一个系统，形成一个小型的完整电网，以储能设备或者微型燃气轮机这类可控的电源维持系统的稳定，使之可以消纳光伏、风电这些可再生能源，整个微电网与大电网有一个公共连接点（PCC），当微电网电源功能不足时可以通过大电网补充缺额，发电量大时可以将多余电网馈送回大电网。分布式电源以微电网方式并网和直接并网的却别主要是两点：a、微电网可以通过控制策略决定并网点的功率流向，比如发电多时用储能存储，负荷大时储能放电；b、标准意义上的微电网可以和大电网断开，从并网模式切换成孤岛运行模式，两种模式能否实现无缝切换是微电网成功的标志。从这个意义上说，目前全世界范围内文献可知的微电网不到500个，大部分不能实现真正的无缝切换，当然有些是无电地区纯孤岛运行的微电网，对大电网没影响。所以有分布式电源和负荷通过PCC点并网，但做不到孤岛的，还应该认为是分布式电源直接并网。</p>
<p>5、虚拟电厂：</p>
<p>微电网要求网内的设备在地理上是集中的，电源、负荷都相互靠近，网内设备都可控（比如最简单的孤岛控制策略：高频减载、低频减源），对于大电网来说化整为零，系统内会出现多个自治的小系统。和微电网的思路相反，虚拟电厂的思路是化零为整，把一定范围内所有分布式电源看做一个电厂来管理，可以通过中央控制器的方式集中控制每个电源，实现协调控制，也可以通过需求响应等手段，调控各个独立控制的分布式电源。</p>
<p>6、主动配电网：</p>
<p>由于国内之前把需求侧管理的能效电厂概念和虚拟电厂概念不加区分，所以国内的虚拟电厂会特指通过工商业用户的节能改造带来的能源节约，把省的电等效成一个虚拟的电厂多发了这些电，这一纯粹蒙事骗补贴的概念（以上文字三观不正确）。所以近年来又出现了主动配电网（Acvtie Distuibtion Network，ADN）的概念，这个概念也被翻译成有源配电网，因为电专业里active通常翻译成有源，比如有源元件、有源滤波器等，这甚至导致国内各门派为争论那种译法科学而水了不少文章。简单来说所有含分布式电源并网的配电网络都是ADN，以为配电网也有电源了，但是为了强调配电网由受转攻，额，我说的是由受电端变成供电端，所以称之为主动，好似翻身农奴做主人，从此配电不在受输电鄙视，从此站了起来。其本质还是虚拟电厂的思想，强调对整个配电网范围内的分布式电源实现协调控制。相比于微电网，它的优势是控制的分布式电源规模可以更大，范围更广。缺点是现在也就是个概念，用于各种水论文，申基金申项目。主要问题在于：a、想调动分布式电源或者你拥有控制权或者你可以利益驱动用户按你的期望调度，前者的通信控制问题目前配电网范围似乎还没谁真做出实际系统来，不是仿真算例就是控制规模只能算微电网，后者因为电价掌握在发改委手里，通过能源管理合同之类的激励方式获取控制权就把问题变成了前者。所以主动配电网也算是今后水文章的一大方向，短期内实践无望。</p>
<p>转自<br><a href="https://www.zhihu.com/question/22515671/answer/35688123">https://www.zhihu.com/question/22515671/answer/35688123</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>微网运行与控制</title>
    <url>/2023/05/31/%E5%BE%AE%E7%BD%91%E8%BF%90%E8%A1%8C%E4%B8%8E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/19896961">https://zhuanlan.zhihu.com/p/19896961</a></p>
<p>微电网，现在无疑是比较前沿的内容，国内这块与国外相比有一些差距。参与做过一些微电网规划，比如三沙岛的，也参观过一些实验室的微电网模型，许继的示范项目，试着总结一二。</p>
<p>一、微电网概述</p>
<p>首先说说分布式能源和微电网的区别吧。</p>
<p>分布式能源（DER）：一般定义为包括分布式发电（DG）、储能装置（ES）和与公共电网相连的系统。其中DG是指满足终端用户的特殊需求，接在用户侧的小型发电系统，主要有内燃机，微型燃气轮机、燃料电池、太阳能、风能等发电系统。</p>
<p>分布式能源有很多优点，比如可实现能源综合梯级利用，弥补大电网稳定性方面不足，环境友好等，但是它的最本质缺点在于不可控和随机波动性，从而造成高渗透率下对电网稳定的负面影响。</p>
<p>所以，分布式能源和微电网的本质区别就在于前者不可控，后者可控。</p>
<p>微电网（MG）把分布式发电、储能装置、负荷通过控制系统协调控制，形成单一可控单元，直接接在用户侧，优点是非常明显的。</p>
<p>微电网的控制模式和策略是里面的关键部分，无论是系统级的主从、对等和综合性控制模式，还是逆变器级的P/Q、U/f、下垂控制，乃至和储能相结合的控制方式，都是微电网的核心部分。而这些，在分布式能源系统里面是不会涉及的。</p>
<p>所以说，很多外面在搞的微网项目，特别是中国人在国外援建，都是在混淆概念，没有控制系统，其实只能叫做分布式发电（分布式能源系统都算不上）。</p>
<p>所以说微电网的核心在于“自治独立，协调互济”，自治独立指的是微电网具备阻断电网故障影响的能力，使微电网的孤网运行具有不失负荷或者少失负荷；协调互济指的是微电网和主网可以建立互相支援的关系。</p>
<p>国外这块，美国，欧盟和日本研究和应用较为领先，三者之间对于微电网的定义略有区别但不大，国内这块，学校里面天大好像还可以，示范工程许继有两个。</p>
<p>二、微电网的架构</p>
<p>微电网的体系结构一般采用国际上比较成熟的三层结构（许继的示范工程也是如此）：配电网调度层、微电网集中控制层、分布式电源和负荷就地控制层。</p>
<p>这块就不多展开了，比较直白。</p>
<p>三、微电网控制策略</p>
<p>控制策略是微电网的核心关键部分。</p>
<p>微电网的运行分为并网运行和离网运行（孤岛运行），控制策略也是围绕这两种状态和切换过程进行。微电网控制体系主要如下图所示：</p>
<p>第一层为逆变型电源的逆变器级控制<br>这一层的控制模式主要分为：恒功率控制(PQ控制)、恒压/恒频控制(V/f控制)和下垂控制(Droop控制)。</p>
<p>恒功率控制(PQ控制)：顾名思义，就是实现有功和无功的控制=参考值。当光伏、风机等分布式发电系统采用最大功率追踪控制时，属于恒功率控制。微电网并网运行时，由电网提供电压和频率参考，各分布式电源一般采用恒功率控制。当然，部分可控型分布式电源也可采用f-P 和V-Q 下垂控制方法，在电网电压幅值和频率降低时，能够支撑电网电压和频率。</p>
<p>恒压/恒频控制(V/f控制)和下垂控制(Droop控制)：</p>
<p>恒压/恒频控制，即控制电压和频率。</p>
<p>下垂控制，则比较重要且复杂些，即选择与传统发电机相似的频率一次下垂特性曲线（Droop Character）作为控制方式，即分别通过P/f下垂控制和Q/V下垂控制来获取稳定的频率和电压，这种控制方法对微网中的微源输出的有功功率和无功功率分别进行控制，无需机组间的通信协调，实现了微源即插即用和对等控制的目标。</p>
<p>微电网孤立运行时，需由微电网内主电源建立电压和频率参考，该层控制可分为主从控制模式和对等控制模式。</p>
<p>在主从控制模式中，微电网内的一个分布式电源(或储能设备)采取V/f 控制，为微电网提供电压和频率参考，而其他分布式电源则采用PQ 控制。</p>
<p>在对等控制模式中，微电网中参与电压、频率调节和控制的多个可控型分布式电源(或储能设备)在控制上都具有同等的地位，通常选择P-f 和Q-V 下垂控制方法，根据分布式电源接入点就地信息进行控制。</p>
<p>与主从控制模式相比，在对等控制模式中采用下垂控制的分布式电源可以自动参与输出功率的分配，易于实现分布式电源的即插即用。</p>
<p>所以一般来说，下垂控制核心在于负荷功率变化时，不同分布式电源的功率自动通信和共享，P/Q控制核心在于根据实际运行情况，对分布式电源有功和无功指定控制。</p>
<p>两者区别已经很清楚了，直观的说一个主要对外，一个主要对内。PQ控制对外用于并网，被处理为一个恒定的功率输出；下垂控制用于孤岛，没有公网的电压频率支撑，要自治地负责系统的电压频率的调节满足要求。</p>
<p>第二层控制<br>微电网并网运行时，第二层控制的主要目标为降低微电网内可再生能源与负荷的波动对主网的影响，使微电网作为一个友好、可控的负荷接入主网。</p>
<p>通过微电网中心控制器(MGCC)对各分布式电源下发合理的功率指令，通过联络线功率控制可实现这一点。微电网孤立运行时，采用主从控制模式能维持微电网电压和频率恒定，负荷的变化主要由主电源跟随，需要通过MGCC 实现各分布式电源间的功率合理分配。采用对等控制模式时，能同时解决电压频率稳定控制和输出功率合理分配，但这是一种有差控制，负载变化前后系统的稳态电压和频率会有所变化。此时，该层控制的目标主要是恢复微电网电压和频率。</p>
<p>微电网运行模式无缝切换控制也在第二层控制中实现，该部分应具备电网故障检测、微电网与电网同步等功能，并对微电网并网静态开关和主电源控制模式切换进行协调控制。</p>
<p>第三层控制<br>该层主要为微电网能量管理系统层，通过相应能量优化算法：①确定微电网并网运行时，与大电网之间联络线输出功率参考值(作为微电网第二层控制目标参考值);②在微电网孤立运行时，调整各分布式电源输出功率参考值或下垂曲线稳态参考点和分配比例系数设定等信息，实现微电网经济运行等功能。</p>
<p>这里其实只是简单总结了下微电网的控制模式，在实际运行中和储能模块相结合这块还是非常复杂的，特别是离网控制，涉及稳态，动态和暂态的三态控制，并网控制稍微简单些，只需考虑稳态控制即可。</p>
<p>四、微电网规划</p>
<p>微电网规划这块国内目前也还是慢慢开始做，并不是很成熟。</p>
<p>里面具体的可以看一些文献和资料，定容、储能、协调控制，优化算法结合在一起，还是比较复杂的。</p>
<p>用的软件主要是HOMER软件，软件本身还是比较强大的，我没有用过就不多说了，以后想抽空学下。</p>
<p>五、微电网保护</p>
<p>微电网保护问题根源在于分布式电源使得配电系统从单电源辐射式网络变为“潮流双向性网络”，主要是三个问题：1）分布式电源与原有配电网保护的配合问题 2）分布式电源对线路重合闸的影响 3）孤岛监测和反孤岛措施。</p>
<p>传统配电网典型保护设计方案通常是主馈线采用电流速断保护和过流保护组成的两段式保护，并配置三相一次重合闸装置。电流速断按照线路末端故障有灵敏度的方法整定，过流保护按保护线路全长加时限整定。</p>
<p>1）分布式电源与原有配电网保护的配合问题</p>
<p>如图所示。</p>
<p>一是导致本线路部分保护灵敏度降低及拒动，部分保护的灵敏度增加。如图，当K3发生接地故障时，由于MG的分流作用，使B3感受到的故障电流减小，B3的灵敏度降低：当K2点发生接地故障，B4将流过MG提供的故障电流，使保护B4的灵敏度增加。</p>
<p>二是导致本线路保护误动。当母线处或K1发生接地故障时，B3流过MG提供的反方向短路电流，当MG馈入电网的功率足够大时，将使B3误动。</p>
<p>三是导致相邻线路保护误动，失去选择性。当K4发生接地故障，B1流过MG提供的短路电流，如果MG的容量足够大，那么B1的保护范围将可能延伸到下一段线路，使保护失去选择性。</p>
<p>2）分布式电源对线路重合闸的影响</p>
<p>依旧如图。</p>
<p>K3发生接地故障，保护B3的电流速断保护立即动作断开故障线路，但MG的PCC从检测外部故障到SS断开MG需要一段时间，期间MG和B3所在的馈线构成孤岛运行，如果此时保护B3的前加速动作，可能会造成非同期合闸。同时，MG继续向故障点提供电路电流，可能使故障点电弧重燃，扩大事故。</p>
<p>保护B3的前加速必须与PCC处的静态开关SS动作时间配合。所以，必须限制MG提供的短路电流，以公共配电网电流速断或定时限过流保护的定值为约束条件，以减轻MG接入对重合闸前加速，后加速的影响。</p>
<p>3）防孤岛保护</p>
<p>孤岛效应当主电网由于故障或检修而停止对部分负荷供电时,用户侧的分布式电源可能与负 荷构成一个可独立运行的孤网系统,从而脱离电网调度系统的控制,如果不能明确地 给出孤网系统与主电网的断开点,则可能引发一系列人身和运行隐患。</p>
<p>这块内容涉及到一些孤岛监测方法，可以结合IEEE 1547 孤岛检测标准看看。</p>
<p>4）微电网保护措施</p>
<p>一是微电网系统级保护。关键是其与公共配电网的连接点PCC，可知，微电网并网运行对配电网继电保护的影响因素主要取决于两个因素：注入配电网的短路电流大小和持续时间。当公共电网发生永久性故障或微电网的运行状态不符合标准时，要求微电网进入孤网运行，PCC的迅速动作能减轻微电网对公共配电网继电保护的不利影响。所以，PCC安装的控制与保护装置必需能够检测并准确判断电网的各种故障情况，迅速做出响应，决定微电网是否进入孤网运行。</p>
<p>二是微电网单元级保护。当公共电网发生故障或电能质量下降，如过电压，电压偏低等，对于敏感负荷，需要微点网快速断开与公共电网的连接，微电网进入孤网运行模式。微电网单元及保护主要是应对微电网内部发生的各种故障所配置的保护。</p>
<p>具体来说比如限制DG的容量与接入位置，配电网故障时，DG立即退出，引入故障电流限制手段如故障限流器等。</p>
<p>保护这块确实不擅长，也就随便总结一些。</p>
<p>六、微电网工程实例</p>
<p>许继河南分布式光伏发电及微电网运行控制试点工程是国内首个包含光伏发电、电力储能，并具有微电网特性的试点工程，是国家电网公司唯一的微电网试点项目。该项目以河南财政税务高等专科学校屋顶380 kW光伏项目为依托，由380 kW光伏电源、2 组100 kW/100 kWh 储能系统、约34 路用电负荷、相关控制单元和保护单元构成光储联合微电网系统，可以实现微电网并网到离网，离网到并网的平滑过渡。</p>
<p>图 中的负荷回路和光伏发电回路实际上对应有多路负荷回路和光伏回路。本示范工程将离网状态定义为：1DL 和2DL 均跳开，即孤岛状态。并网状态定义为：1DL 和2DL有一个合上。</p>
<p>正常运行时，1DL 及分段3DL 合上，2DL 断开，微电网为并网运行。系统和光伏电源同时给用电负载供电。</p>
<p>如果系统故障，导致1DL 断开，微电网进入离网运行，光伏发电、储能系统和用电负荷构成微电网的计划孤岛运行模式，持续供电。当系统电源恢复，则合上1DL 或2DL 开关，微电网由离网运行转入并网运行。</p>
<p>此项目的保护与控制装置有：光伏逆变器，储能变流器，微电网系统控制器，负荷控制器，馈线保护控制器。除了以上保护控制器外，还有一套后台集中控制中心完成系统的集中控制和管理。</p>
<p>微电网的并网、离网过程中，系统控制流程如图所示。</p>
<p>本项目中所有光伏逆变器在这整个过程中均作P/Q 控制。在并网状态，按最大出力发电，在离网状态，由后台集中控制中心根据需要控制出力。在整个过程中，光伏回路可以认为是功率为负值的负载回路。</p>
<p>储能回路二配置的2#储能变流器在这整个过程中均作P/Q 控制，由后台集中控制中心根据需要进行充放电控制。在过程中，储能回路可认为是功率可调节的负载回路。</p>
<p>储能回路一配置的1#储能变流器在并网状态作P/Q 控制，由后台集中控制中心根据需要进行充放电控制。在离网状态作V/f 控制，稳定系统的电压和频率，作为微电网的主电源，其他光伏回路和储能回路根据此电压和频率作P/Q 控制，共同维持系统的稳定运行。</p>
<p>负荷控制器主要完成离网后的快速负荷切除功能，馈线保护控制器完成馈线的保护控制功能。</p>
<p>某些图片和数据来源于网络，若有侵权，请联系删除。带来不便请见谅。</p>
<p>微信公众号：严同笔记 —- 定期写文，供交流讨论</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>能源互联网</title>
    <url>/2023/05/30/%E8%83%BD%E6%BA%90%E4%BA%92%E8%81%94%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/25562450/answer/40681458">https://www.zhihu.com/question/25562450/answer/40681458</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>好像最近一两年，互联网公司似乎突然一下找到了杀进传统能源产业的入口，苹果、google、微软大力投资新能源，苹果在做电动汽车icar？<br>而一直在岸边游泳的传统行业公司似乎一下子学会了给自己打上互联网标签，如华为，远景能源等。</p>
<p>能源和互联网结合的话题似乎很热。</p>
<h1 id="1、通俗的解释能源互联网"><a href="#1、通俗的解释能源互联网" class="headerlink" title="1、通俗的解释能源互联网"></a>1、通俗的解释能源互联网</h1><p>试想下未来，人们的电动汽车、家用电器、屋顶光伏、电脑手机等等都变成互相联网的一分子，每个人的能源消耗、碳排放指标和生活需求都能够被打通变成数字化坐标，如果未来生活的每一秒钟各种需求都能被积聚起来被导向最有效的生产供给，会是什么样？</p>
<p>比如下面的场景：</p>
<p>如果你拖欠电费，那么你的的门口不会被贴上一张纸催费，而是响起一记手机提醒：亲，你忘记了交电费了列，记得时刻给自己充电，让自己电力十足哦。。随便给我个好评吧；<br>你在平板电脑上手指轻划，把自家屋顶多余的光伏发电通过微信卖给附近准备给电动汽车停车充电的陌生人；<br>你可以对每一个家用电器会根据能耗曲线设置最佳的开关时间并随时远程遥控，建筑物的能耗控制随时依据会议活动类型人数和实时电价进行动态调整；<br>城市的整体能源消耗和二氧化碳排放随时依据天气和事件变化进行需求侧编排以实现最优；<br>沙漠和大海里安装的各种新能源发电设备可以通过程序由各国人民竞拍投资自由交易；</p>
<p>是不是很cool？</p>
<p>所以，所谓能源互联网，简单而言，就是类似信息互联网，所有的能量信息（分布式的产生、供应、消耗），都可以通过网络互联，得到及时的反馈，并根据需求予以选择控制。</p>
<h1 id="2、能源互联网和智能电网的区别"><a href="#2、能源互联网和智能电网的区别" class="headerlink" title="2、能源互联网和智能电网的区别"></a>2、能源互联网和智能电网的区别</h1><p>能源互联网究竟和智能电网有什么区别?</p>
<p>电网层面，所谓能源互联网的这些特点，在原来的智能电网理论中都讲过了，只是之前智能电网没有过多的关注新能源的占比和影响，所以这个层面，能源互联网和智能电网的些许区分就在于是当可再生能源占到80%甚至更高时，那个时候，我们的电力系统和电网怎么去支撑这个环境?</p>
<p>但是上升到能源层面，似乎能源互联网，Internet of Energy，包含的东西要更多，呈现的都是一种试图把各种能源形式组合成一个超级网络的大开大合。其似乎包含了智能通信、智能电网、智能交通等等众多智能与绿色概念。</p>
<h1 id="3、国内外的能源互联网"><a href="#3、国内外的能源互联网" class="headerlink" title="3、国内外的能源互联网"></a>3、国内外的能源互联网</h1><p>目前，美国虽然尚未明确提出能源互联网，但其提出的智能电网却与能源互联网的内涵有诸多相似之处。德国于2008年在智能电网的基础上选择了6个试点地区进行为期4年的E-Energy技术创新促进计划，成为实践能源互联网最早的国家。</p>
<p>目前市面上呈现出三种对能源互联网的理解版本：从通信的角度强调各种设备的互联，以华为等通信公司为代表;从软件的角度强调第三方数据的优化管理，以美国Opower等公司为代表;以及从国与国之间的角度强调跨区域电网的互联，以国家电网为代表。</p>
<p>国网刘BOSS提出的”全球能源互联网“就更加高大上了，之前我也回答过类似问题，并不是能源互联网不好，而是无限地扩大能源互联区域，不太合理和可行。</p>
<h1 id="4、能源互联网的关键环节"><a href="#4、能源互联网的关键环节" class="headerlink" title="4、能源互联网的关键环节"></a>4、能源互联网的关键环节</h1><h2 id="1）可再生能源作为主要能源廉价供应，并合理联网调度、利用"><a href="#1）可再生能源作为主要能源廉价供应，并合理联网调度、利用" class="headerlink" title="1）可再生能源作为主要能源廉价供应，并合理联网调度、利用"></a>1）可再生能源作为主要能源廉价供应，并合理联网调度、利用</h2><p>以数据形式存在于信息互联网上的信息，其实是非常廉价且可以挖掘的，但是，能源互联网的主要载荷–能量，却只能从自然界中开采。而且还存在着成本高(相比信息而言)等等问题。所以要满足互联网的特点，要保障精心构建的“能源互联网”有米下锅，必须让它能消化基本“无穷尽”供应的风能、太阳能等。但由于这些渠道的能量供应有非常强的随机性、间断性和模糊性。目前将它们成功的并入电网，或用其他形式高效利用起来，还是一件很困难的事情。</p>
<p>当然这更是环境保护、节能减排方面的需要。</p>
<h2 id="2）支持超大规模分布式发电、储能及其他能源终端的接入平台"><a href="#2）支持超大规模分布式发电、储能及其他能源终端的接入平台" class="headerlink" title="2）支持超大规模分布式发电、储能及其他能源终端的接入平台"></a>2）支持超大规模分布式发电、储能及其他能源终端的接入平台</h2><p>依靠PC、智能移动设备的等个人接入者，在信息互联网接入者的数量上占绝大多数；IT业者用几十年时间构建了一套由通讯协议、路由器、交换机、数据库、服务器等等一系列软硬件设施组成的庞大系统，是人类文明迄今为止最伟大的成就之一。</p>
<p>能源互联网想要达到这样的运转效率，需要的技术准备只多不少：比如需要一个极强的信息流处理能力，用来预测和监视消费者的需求变化、极端不稳定的能量生产供应变化；同时它还要指挥相应的能量调配部门完成上载与下载能源的分流与整合等等。数据和习惯都是超大规模的。</p>
<p>然后，还需要一个极强的能量流处理能力。以智能电网为例，设想中，它需要7X24小时完成功率以亿千瓦计的电流变、输、配调节，而且还必须满足实时的供需平衡(由电能特性决定)。还要再引入分布式清洁能源和市场竞争两个超复杂的变量。</p>
<h2 id="3）类似互联网技术的能源共享实现"><a href="#3）类似互联网技术的能源共享实现" class="headerlink" title="3）类似互联网技术的能源共享实现"></a>3）类似互联网技术的能源共享实现</h2><p>信息互联网的一大魅力就在于它能够打破地域的限制，因为信息传输的门槛和成本都相对较低。</p>
<p>但当我们开始依靠现有的技术输送能量的时候，损耗问题就相当严重了。于是人们不得不考虑手段来降低损耗，这些方法要么单位成本极高(如直接运输，这个过程本身就要消耗大量的燃料)，要么建设成本和科研成本极高(如特高压输电技术)。</p>
<p>相对于信息的传播，能量成本还是高了太多。在能源领域内，油气管道、运煤交通线、特高压输电等话题永远不会离开话题榜的前几名。这样的设施建设往往伴随着庞大的资金规模，数年的建设周期，艰难的科研攻关。</p>
<h2 id="4-能源的移动互联实现"><a href="#4-能源的移动互联实现" class="headerlink" title="4)能源的移动互联实现"></a>4)能源的移动互联实现</h2><p>移动互联是目前互联网产业的一个重要趋势，但是类比到能量上，就完全是另一回事了。</p>
<p>可以便携的能量转换装置，要么效率太低(如内燃机)，要么太贵且用起来麻烦(如燃气机)，要么就是我们“喂不饱”(如电机);</p>
<p>储能问题是老生常谈的老大难;</p>
<p>无线充电技术虽然在已经能够给很多小的智能设备充电了，但是大规模应用上仍然问题多多，最简单的一问：那么多电磁能量散播到空间里，辐射谁受得了?</p>
<p>电动汽车，它的航程、方便性和可靠性等等，真能和同价位传统的汽油车一比了么?</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>大规模储能系统现状及未来</title>
    <url>/2023/05/29/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%82%A8%E8%83%BD%E7%B3%BB%E7%BB%9F%E7%8E%B0%E7%8A%B6%E5%8F%8A%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/20530503/answer/41904894">https://www.zhihu.com/question/20530503/answer/41904894</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="现有的储能系统及其不足之处"><a href="#现有的储能系统及其不足之处" class="headerlink" title="现有的储能系统及其不足之处"></a>现有的储能系统及其不足之处</h1><p>现有的储能系统主要分为五类：机械储能、电气储能、电化学储能、热储能和化学储能。目前世界占比最高的是抽水蓄能，其总装机容量规模达到了127GW，占总储能容量的99%，其次是压缩空气储能，总装机容量为440MW，排名第三的是钠硫电池，总容量规模为316MW。</p>
<h2 id="1）机械储能"><a href="#1）机械储能" class="headerlink" title="1）机械储能"></a>1）机械储能</h2><p>机械储能主要包括抽水蓄能、压缩空气储能和飞轮储能等。</p>
<ul>
<li>抽水蓄能</li>
</ul>
<p>将电网低谷时利用过剩电力作为液态能量媒体的水从地势低的水库抽到地势高的水库，电网峰荷时高地势水库中的水回流到下水库推动水轮机发电机发电，效率一般为75%左右，俗称进4出3，具有日调节能力，用于调峰和备用。</p>
<p>不足之处：选址困难，及其依赖地势；投资周期较大，损耗较高，包括抽蓄损耗+线路损耗；现阶段也受中国电价政策的制约，去年中国80%以上的抽蓄都晒太阳，去年八月发改委出了个关于抽蓄电价的政策，以后可能会好些，但肯定不是储能的发展趋势。</p>
<ul>
<li>压缩空气储能（CAES）</li>
</ul>
<p>压缩空气蓄能是利用电力系统负荷低谷时的剩余电量，由电动机带动空气压缩机，将空气压入作为储气室的密闭大容量地下洞穴，当系统发电量不足时，将压缩空气经换热器与油或天然气混合燃烧，导入燃气轮机作功发电。国外研究较多，技术成熟，我国开始稍晚，好像卢强院士对这方面研究比较多，什么冷电联产之类的。</p>
<p>压缩空气储也有调峰功能，适合用于大规模风场，因为风能产生的机械功可以直接驱动压缩机旋转，减少了中间转换成电的环节，从而提高效率。</p>
<p>不足之处：一大缺陷在于效率较低。原因在于空气受到压缩时温度会升高，空气释放膨胀的过程中温度会降低。在压缩空气过程中一部分能量以热能的形式散失，在膨胀之前就必须要重新加热。通常以天然气作为加热空气的热源，这就导致蓄能效率降低。还有可以想到的不足就是需要大型储气装置、一定的地质条件和依赖燃烧化石燃料。</p>
<ul>
<li>飞轮储能</li>
</ul>
<p>是利用高速旋转的飞轮将能量以动能的形式储存起来。需要能量时，飞轮减速运行，将存储的能量释放出来。飞轮储能其中的单项技术国内基本都有了(但和国外差距在10年以上)，难点在于根据不同的用途开发不同功能的新产品，因此飞轮储能电源是一种高技术产品但原始创新性并不足，这使得它较难获得国家的科研经费支持。</p>
<p>不足之处：能量密度不够高、自放电率高，如停止充电，能量在几到几十个小时内就会自行耗尽。只适合于一些细分市场，比如高品质不间断电源等。</p>
<h2 id="2）电气储能"><a href="#2）电气储能" class="headerlink" title="2）电气储能"></a>2）电气储能</h2><ul>
<li>超级电容器储能</li>
</ul>
<p>用活性炭多孔电极和电解质组成的双电层结构获得超大的电容量。与利用化学反应的蓄电池不同，超级电容器的充放电过程始终是物理过程。充电时间短、使用寿命长、温度特性好、节约能源和绿色环保。超级电容没有太复杂的东西，就是电容充电，其余就是材料的问题，目前研究的方向是能否做到面积很小，电容更大。超级电容器的发展还是很快的，目前石墨烯材料为基础的新型超级电容器，非常火。</p>
<p>Tesla首席执行官Elon Musk 早在2011年就表示，传统电动汽车的电池已经过时，未来以超级电容器为动力系统的新型汽车将取而代之。</p>
<p>不足之处：和电池相比，其能量密度导致同等重量下储能量相对较低，直接导致的就是续航能力差，依赖于新材料的诞生，比如石墨烯。</p>
<ul>
<li>超导储能（SMES）</li>
</ul>
<p>利用超导体的电阻为零特性制成的储存电能的装置。超导储能系统大致包括超导线圈、低温系统、功率调节系统和监控系统4大部分。超导材料技术开发是超导储能技术的重中之重。超导材料大致可分为低温超导材料、高温超导材料和室温超导材料。</p>
<p>不足之处：超导储能的成本很高（材料和低温制冷系统），使得它的应用受到很大限制。可靠性和经济性的制约，商业化应用还比较远。</p>
<h2 id="3）电化学储能"><a href="#3）电化学储能" class="headerlink" title="3）电化学储能"></a>3）电化学储能</h2><ul>
<li>铅酸电池</li>
</ul>
<p>是一种电极主要由铅及其氧化物制成，电解液是硫酸溶液的蓄电池。目前在世界上应用广泛，循环寿命可达1000次左右，效率能达到80%-90%，性价比高，常用于电力系统的事故电源或备用电源。</p>
<p>不足之处：如果深度、快速大功率放电时，可用容量会下降。其特点是能量密度低，寿命短。铅酸电池今年通过将具有超级活性的炭材料添加到铅酸电池的负极板上，将其循环寿命提高很多。</p>
<ul>
<li>锂离子电池</li>
</ul>
<p>是一类由锂金属或锂合金为负极材料、使用非水电解质溶液的电池。主要应用于便携式的移动设备中，其效率可达95%以上，放电时间可达数小时，循环次数可达5000次或更多，响应快速，是电池中能量最高的实用性电池，目前来说用的最多。近年来技术也在不断进行升级，正负极材料也有多种应用。</p>
<p>市场上主流的动力锂电池分为三大类：钴酸锂电池、锰酸锂电池和磷酸铁锂电池。前者能量密度高，但是安全性稍差，后者相反，国内电动汽车比如比亚迪，目前大多采用磷酸铁锂电池。但是好像老外都在玩三元锂电池和磷酸铁锂电池？</p>
<ul>
<li>锂硫电池</li>
</ul>
<p>锂硫电池也很火，是以硫元素作为正极、金属锂作为负极的一种电池，其理论比能量密度可达2600wh/kg，实际能量密度可达450wh/kg。但如何大幅提高该电池的充放电循环寿命、使用安全性也是很大的问题。</p>
<p>不足之处：存在价格高（4 元/wh）、过充导致发热、燃烧等安全性问题，需要进行充电保护。</p>
<ul>
<li>钠硫电池</li>
</ul>
<p>是一种以金属钠为负极、硫为正极、陶瓷管为电解质隔膜的二次电池。循环周期可达到4500次，放电时间6-7小时，周期往返效率75%，能量密度高，响应时间快。目前在日本、德国、法国、美国等地已建有200多处此类储能电站，主要用于负荷调平，移峰和改善电能质量。</p>
<p>不足之处：因为使用液态钠，运行于高温下，容易燃烧。而且万一电网没电了，还需要柴油发电机帮助维持高温，或者帮助满足电池降温的条件。</p>
<ul>
<li>液流电池</li>
</ul>
<p>利用正负极电解液分开，各自循环的一种高性能蓄电池。电池的功率和能量是不相关的，储存的能量取决于储存罐的大小，因而可以储存长达数小时至数天的能量，容量可达MW级。这个电池有多个体系，如铁铬体系，锌溴体系、多硫化钠溴体系以及全钒体系，其中钒电池最火吧。</p>
<p>不足之处：电池体积太大；电池对环境温度要求太高；价格贵（这个可能是短期现象吧）；系统复杂（又是泵又是管路什么的，这不像锂电等非液流电池那么简单）。</p>
<p>电池储能都存在或多或少的环保问题。</p>
<h2 id="4）热储能热储能："><a href="#4）热储能热储能：" class="headerlink" title="4）热储能热储能："></a>4）热储能热储能：</h2><p>热储能系统中，热能被储存在隔热容器的媒介中，需要的时候转化回电能，也可直接利用而不再转化回电能。热储能又分为显热储能和潜热储能。热储能储存的热量可以很大，所以可利用在可再生能源发电上。</p>
<p>不足之处：热储能要各种高温化学热工质，用用场合比较受限。</p>
<h2 id="5）化学类储能"><a href="#5）化学类储能" class="headerlink" title="5）化学类储能"></a>5）化学类储能</h2><p>化学类储能：利用氢或合成天然气作为二次能源的载体，利用多余的电制氢，可以直接用氢作为能量的载体，也可以将其与二氧化碳反应成为合成天然气（甲烷），氢或者合成天然气除了可用于发电外，还有其他利用方式如交通等。德国热衷于推动此技术，并有示范项目投入运行。</p>
<p>不足之处：全周期效率较低，制氢效率仅 40%，合 成天然气的效率不到 35%。引用个前人的总结：</p>
<p>总体来说，目前研究发展主要还是集中于超级电容和电池（锂电池、液流电池）上。材料领域的突破才是关键。</p>
<h1 id="可靠储能后的电网会是什么样"><a href="#可靠储能后的电网会是什么样" class="headerlink" title="可靠储能后的电网会是什么样"></a>可靠储能后的电网会是什么样</h1><p>1）支撑实现能源互联网，智能电网。储能是智能电网实现能量双向互动的重要设备。没有储能，完整的智能电网无从谈起。</p>
<p>2）利用储能技术面对新能源考验主要就是平抑、稳定风能、太阳能等间歇式可再生能源发电的输出功率，提高电网接纳间歇式可再生能源能力。</p>
<p>3）减小峰谷差，提高设备利用率电网企业在调峰和供电压力得到缓解的同时，可获取更多的高峰负荷收益。</p>
<p>4）提高电网安全可靠性和电能质量提供应急电源;减少因各种暂态电能质量问题造成的损失。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>充电站规划</title>
    <url>/2023/05/28/%E5%85%85%E7%94%B5%E7%AB%99%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/27582791/answer/41934204">https://www.zhihu.com/question/27582791/answer/41934204</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>从2014年6月开始，按照国务院的分工，国家能源局已经开始制定《电动汽车充电基础设施建设规划》，2014年年底前已经完成了第一稿，未来与《规划》同时出台还有《充电基础设施建设指导意见》。同时，全国多个城市陆续推出大规模建设充电设施的发展规划。</p>
<h1 id="充电设施的布局规划"><a href="#充电设施的布局规划" class="headerlink" title="充电设施的布局规划"></a>充电设施的布局规划</h1><p>1）发展现状和规划思路</p>
<p>美国充电站发展规划</p>
<p>两年翻十倍，可以说，发展速度相当快，如果仅仅是数量多，也不足为奇。以ChargPoint为例，它不仅仅是一个简单的充电网络，它还可以向电动车车主、经销商及制造商提供大量云服务，比如电动汽车使用车可以通过手机下载充电服务公司的App，来寻找就近的空闲充电桩，并可直接导航至充电桩所在地。</p>
<p>我国充电站发展规划</p>
<p>2011年时，国家电网提出“换电为主、插充为辅、集中充电、统一配送”，这是基于当时情况的考虑。</p>
<p>现在，特斯拉18650电池等等成功应用，使得快速充电成为可能，国内厂家的水平也不断提高，14年国网就变了，变成“主导快充、兼顾慢充、引导换电、经济实用”的思路，并引入社会资金和力量参与充电设施建设。</p>
<p>截至目前，我国建成的电动汽车充电桩达到了2.6万个（国家电网数据），但从数量来看已经很多了，不过根据国内多家媒体的调查，充电桩投入使用的比例十分低。此外，我国各地的直流充电接口与通讯协议标准至今尚未统一，电动汽车地方目录（本质是地方保护主义）尽管被宣布取消，实际上却依然存在。</p>
<p>好在不久前，能源局制定的《电动汽车充电基础设施建设觃划》草稿已经完成，乐观预计到2020年，新能源汽车累计产销量将超过500万辆。按照一辆车对应1个慢充、0.2个快充计算，预计至2020年将会催生500万个慢充和100万个快充的市场需。随着充电桩建设加速，充电设备未来投资额将会超过850亿元。</p>
<p>北京：北京市将在中心城区打造服务半径平均为5公里的充电圈，逐步建成公用领域充电设施网络服务体系。与自用充电桩主要采取交流慢充不同，公用充电桩主要采用直流快充模式，半小时充电就能支撑普通新能源汽车续航100公里。</p>
<p>下为2015年北京市电动车公用充电设施分布图。电动车车主可通过网站、手机APP、微信等方式查找附近的充电设施。</p>
<p>上海：2015年充电桩布局将超6000个。此外，为了进一步保障新能源汽车的使用，上海将在中心城区和示范区优先建设公共快充网络，一辆车只需20分钟就可充80%的电。</p>
<p>天津：2015年将建66个充换电站，6700个充电桩。其中，公交、出租、邮政、快递、环卫等领域将优先选择用户现有场地，不足部分由市统一规划供地。<br>等等，可见发展的趋势还是很快的。</p>
<p>2）规划技术层面</p>
<p>目前一般是能源局和电网公司来做规划。</p>
<p>但，目前针对电动汽车应用的充电站建设规划布局理论尚未完整成熟，各地的充电站建设尚处于定点示范建设阶段，没有建立于车辆应用、电网规划、城市规划相结合的充电站布局选址理论。</p>
<p>而且充电站建设的规划与布局面临着供电能力、服务能力与城市用地紧张的矛盾。</p>
<p>就看到过的充电站规划方面的资料答几点技术层面的东西。</p>
<h2 id="首先肯定是容量预测，统计电动汽车的数量及进行预测。"><a href="#首先肯定是容量预测，统计电动汽车的数量及进行预测。" class="headerlink" title="首先肯定是容量预测，统计电动汽车的数量及进行预测。"></a>首先肯定是容量预测，统计电动汽车的数量及进行预测。</h2><h2 id="其次就是充电站布局规划的技术思路。"><a href="#其次就是充电站布局规划的技术思路。" class="headerlink" title="其次就是充电站布局规划的技术思路。"></a>其次就是充电站布局规划的技术思路。</h2><p>电动汽车充电站布局包括“需求”和“可能性”两个因素。衡量充电站需求的主要指标是交通量与服务半径两个要素，决定可能性与否关键在于交通、环保及区域配电能力等外部环境条件与该地区的建设规划和路网规划。</p>
<ul>
<li><p>充电站分布与电动汽车交通密度和充电需求的分布尽可能一致</p>
</li>
<li><p>充电站的布局应符合充电站服务半径要求</p>
</li>
</ul>
<p>电动汽车充电站的分布可以参考建设部《城市道路交通规划设计规范》(1995)中的加油站服务半径规定，结合电动汽车自身的运行特点以及各区域的计算服务半径按实际需要设定。</p>
<p>动力电池的续驶能力是影响充电站服务半径的另一大因素。故充电站的服务半径应以电动汽车单次充电行驶里程100km(甚至更短)计算。只有这样才能有效保障电动汽车的持续行驶能力。</p>
<ul>
<li>充电站的设置应满足城市总体规划和路网规划要求</li>
</ul>
<p>充电站的选址定点应结合地区建设规划和路网规划,以网点总体布局规划为宏观控制依据，经过对布局网点及其周围地区规划选址方案的比较，确定网点设置用地。</p>
<ul>
<li>充电站的设置应充分考虑本区域的输配电网现状</li>
</ul>
<p>电动汽车充电站运营时需要高功率的电力供应支撑,在进行充电站布局规划时，应与电力供应部门协调，将充电站建设规划纳入城市电网规划中。</p>
<ul>
<li>充电规划应充分考虑电动汽车未来发展趋势</li>
</ul>
<h2 id="最后就是具体的选址和现场情况了。"><a href="#最后就是具体的选址和现场情况了。" class="headerlink" title="最后就是具体的选址和现场情况了。"></a>最后就是具体的选址和现场情况了。</h2><h1 id="充电设施的标准"><a href="#充电设施的标准" class="headerlink" title="充电设施的标准"></a>充电设施的标准</h1><p>在电动车实际使用的过程中，充电标准不统一问题非常明显。京沪高速公路充电站全线开通后，有企业派工作小组去做电动车运行试验，结果是在这个充电站这辆车能充电，那辆车不能充电。</p>
<p>原因在于一方面标准还需完善，同时设施和汽车做的接口是否真正符合国标需认证，另一方面，原先国标还没有出来时，各地先行按照自己的想法制定了地方标准，也形成了现在的过渡阶段。</p>
<p>目前，传统的充电方式全球有三个标准：最早出现的美国的SAE标准，日本、韩国也采用SAE标准;其次是欧洲标准;再是中国的标准，介于欧洲标准和美国标准之间。这就形成了三部完全不兼容的标准。</p>
<p>今年国家已经把接口标准纳入新能源汽车购置税减免目录准入条件，下一步还将纳入新能源汽车准入条件，解决标准执行力不强的问题。</p>
<h1 id="充电设施谁来建"><a href="#充电设施谁来建" class="headerlink" title="充电设施谁来建"></a>充电设施谁来建</h1><p>目前看来，统一充电标准先行，同时要解决的核心问题还有商业模式。这都属于充电站长远规划的问题。</p>
<p>充电站的运营管理尚处于起步阶段，尚未对其服务范围进行清晰定义，尚未建立成熟的运营管理模式。建设运营主体不明确已经成为电动汽车商业化应用的瓶颈问题之一。</p>
<p>反正就我所知，国网对这块越来越重视，2016年-2020年，国网建设充电站目标高达10000座，建成完整的“四纵四横”（四纵：沈海、京沪、京台、京港澳，四横：青银、连霍、沪蓉、沪昆）电动汽车充电网络。但是也没有好的盈利模式，都是赔本响应国家号召。</p>
<p>就私有资本来说，也是一样，盈利模式单一，单靠服务费，难以实现长期稳定收益。在目前的情况下，其实有80%的车主都可以通过家庭充电的方式来满足需求，如果要外出充电，更多的也只是补电，收益显然会很低，而且还有特斯拉这种提供免费增值服务的新能源汽车厂家。</p>
<p>商业模式不清晰，也没有国外的经验参考，个人感觉单纯从充电站单方面解决非常困难，因为这些主体的利益是相对的，结合新能源汽车和充电设施，由政府、新能源汽车厂家、充电设施业主一起形成一个商业模式，或许比较靠谱。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>智能充电桩</title>
    <url>/2023/05/27/%E6%99%BA%E8%83%BD%E5%85%85%E7%94%B5%E6%A1%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/28697268/answer/42167808">https://www.zhihu.com/question/28697268/answer/42167808</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>什么叫智能充电桩？</p>
<p>依我看，简单来说，就是必须满足和智能电网的所有互动，属于目前比较火的V2G的范畴，具体一点，至少要像通用的“Watt Station”说的那样，满足两个功能。</p>
<p>第一，获取电力部门实时电价的信息，并根据这一信息帮助电动汽车用户决定在何时以最经济的价格对车辆进行充电。</p>
<p>你只需要在下班回家的时候将电动汽车与充电桩进行连接，这个时候你不必担心电价的高低，因为如果电价高于你的预期，充电桩不会连接电网给电动汽车进行充电。当你已经熟睡后，电价下降到较低水平，充电桩内的智能芯片通过获取信息后便触发充电开关，电动汽车开始充电。</p>
<p>这一点感觉比较容易做到。</p>
<p>第二就比较难了，就是未来，当电力部门出现电力供应紧张时，智能充电桩可以把电动汽车电池内的电反向传输给电网，从而缓解供电压力。用户的输电量则被电网记录，下次可以免费为用户提供数额相等的供电。</p>
<p>当然，还有很多和未来智能电网的互动，非常多。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>电动汽车入网技术（V2G）</title>
    <url>/2023/05/26/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6%E5%85%A5%E7%BD%91%E6%8A%80%E6%9C%AF%EF%BC%88V2G%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/28866374/answer/42464699">https://www.zhihu.com/question/28866374/answer/42464699</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>V2G 是Vehicle-to-grid的简称，它的核心思想在于：电动汽车和电网的互动，利用大量电动汽车的储能源作为电网和可再生能源的的缓冲。</p>
<p>当电网负荷过高时，由电动汽车储能源向电网馈电;而当电网负荷低时，用来存储电网过剩的发电量，避免造成浪费。通过这种方式，电动汽车用户可以在电价低时，从电网买电，电网电价高时向电网售电，从而获得一定的收益。</p>
<h1 id="国内外研究现状"><a href="#国内外研究现状" class="headerlink" title="国内外研究现状"></a>国内外研究现状</h1><p>这块国内外，目前只有少数机构涉足此领域，相关研究与示范大多都在美国，具有代表性的就是美国特拉华大学的Willlett Kempton教授领导的团队，以及日产汽车公司与美国通用电气的联合研究团队。</p>
<p>国内就是国网和学校有一些研究，都还比较皮毛吧。</p>
<p>总的来说，国内外都只是一些初步研究，研究框架是明确的，但离实际应用还很远。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>原理挺简单，就是双向互动，难点还是在电池、电动汽车V侧的控制、以及电网G侧的调度控制。</p>
<h1 id="互动效果"><a href="#互动效果" class="headerlink" title="互动效果"></a>互动效果</h1><ul>
<li><p>用户方面：<br>（1）节省费用：单位电能比单位汽油便宜，行驶相同距离，电动汽车花费少。<br>（2）获得收益：给电网供电时，可获得电价补偿。</p>
</li>
<li><p>电网方面<br>移峰填谷：谷荷充电，峰荷放电。<br>旋转备用：作为分布式储能单元（风电、太阳能发电等)。<br>电压支持：高负荷时放电抑制电压的下降等</p>
</li>
</ul>
<h1 id="目前的研究方向"><a href="#目前的研究方向" class="headerlink" title="目前的研究方向"></a>目前的研究方向</h1><h2 id="充电负荷计算"><a href="#充电负荷计算" class="headerlink" title="充电负荷计算"></a>充电负荷计算</h2><p>充电负荷是研究电动汽车充电问题的基础。</p>
<h2 id="电动汽车规模接入对电网产生的影响"><a href="#电动汽车规模接入对电网产生的影响" class="headerlink" title="电动汽车规模接入对电网产生的影响"></a>电动汽车规模接入对电网产生的影响</h2><p>电动汽车大规模接入配电网，由于其充电时间地点的高度随机性，会对配电网网损，电能质量，可靠性，稳定性等方面产生影响。<br>国内外专家学者在该方面做了大量的研究工作，迄今为止，大部分研究集中在网损和电能质量两方面。</p>
<h2 id="电动汽车有序充电控制"><a href="#电动汽车有序充电控制" class="headerlink" title="电动汽车有序充电控制"></a>电动汽车有序充电控制</h2><p>这个方向比较热门些，大多数此方向的人都在研究这个。电动汽车有序充电控制，可以有效缓解大规模电动汽车接入电网所带来的负面影响。</p>
<h2 id="基于V2G的电网规划调度"><a href="#基于V2G的电网规划调度" class="headerlink" title="基于V2G的电网规划调度"></a>基于V2G的电网规划调度</h2><p>新能源与电动汽车均有高度的随机性特点，研究其联合调度不仅可以降低新能源的随机性对电网的影响，增加新能源消纳，更可以实现电动汽车的清洁化低碳化。</p>
<p>这部分个人感觉挺难的，数量级上去了，对平台和调度策略的要求非常高。其他的还有，比如电池双向传输对电池的要求，电价政策什么的。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>新能源并网</title>
    <url>/2023/05/25/%E6%96%B0%E8%83%BD%E6%BA%90%E5%B9%B6%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：严同<br>链接：<a href="https://www.zhihu.com/question/28984074/answer/44625800">https://www.zhihu.com/question/28984074/answer/44625800</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>新能源并网可分为两类：1）大规模集中式并网  2）分布式并网</p>
<p>大规模集中式并网和分布式并网，在接入电网电压等级，输送容量，对电网的影响等方面，显然是显著不同的，有点类似大超市和小门店的感觉，所以分开来说。</p>
<p>大规模集中式并网存在哪些问题？对此问题的答复，再次厚颜无耻的引用我的这个回答：千万级的大风电并网都存在什么问题？</p>
<p>严同的回答主要是调峰和调度的问题，上述答案里有详情，不表。本答复对大规模并网不感兴趣，主要针对分布式并网的问题。</p>
<p>分布式并网存在哪些问题？我国目前的分布式能源发展非常缓慢，导致很多高渗透率并网才发生的问题一点都没有凸显。当然，和大规模集中式并网类似，调峰和调度问题依然是分布式并网的最主要问题，分布式电源量更多，更细微，更复杂，平台需求更高，对储能的依赖会很高。除此之外，还有以下问题。</p>
<p>1）双向潮流引起的问题</p>
<p>传统配电网是单向电流流动，配电网只接收负荷。大量接入分布式光伏发电后，传统辐射状的无源配电网络将变成一个充满中小型电源的有源网络，潮流开始双向流动，这是最根本的问题。</p>
<p>潮流的变化，对配电网的规划设计、信息采集、运行方式、保护控制等影响很大。就拿保护来说，潮流的改变，一会导致本线路保护的灵敏度降低及拒动(下图2)； 二会导致本线路保护误动； 三会导致相邻线路的保护误动并失去选择性（下图1）； 四会导致重合闸不成功。</p>
<p>再比如说，分布式新能源故障时贡献的短路电流，现在的配电网没有考虑到，相关的规划设计都没有考虑过，现在并网方案一般也不会算这个，但是这个对配电网的设计是有影响的。</p>
<p>当然这里也存在一些争论，国际上很多人认为：拿光伏电源逆变器来说，对短路电流贡献不大。</p>
<p>1999年，IEA-PVPS-Task-5(国际能源署中的光伏技术工作组)在日本曾用4个不同厂家控制电流注入的逆变器连接到一个配电网上的柱式变压器，然后在变压器另一侧进行短路试验。试验表明，短路电流上升不超过故障前的2倍，1-2个周波就隔离了故障。</p>
<p>2003年，美国的NERL(美国可再生能源国家实验室)曾做过关于分布式发电与配电网络之间的交互影响的研究。采用以逆变器方式接入的分布式电源，仿真原型建立在13.2kV的中压配电网络上，分布式电源的容量是5MW，研究重点是熔断保护特性。结果表明，当发生单相和三相故障时，以逆变器方式接入的分布式电源对短路电流的贡献很小，短路电流主要来自主网。</p>
<p>但是这是个规模问题，以后如果分布式新能源的渗透率搞了，这些问题应该会很大，网络的构架上就存在问题。</p>
<p>还有运行控制方面，针对双向潮流引起的复杂的线路保护、有功无功控制，通信等等。</p>
<p>2）无功和电压问题</p>
<p>集中供电的配电网一般呈辐射状。稳态运行状态下，电压沿馈线潮流方向逐渐降低。</p>
<p>接入光伏电源后，由于馈线上的传输功率减少，使沿馈线各负荷节点处的电压被抬高，可能导致一些负荷节点电压偏移超标，其电压被抬高多少与接入光伏电源的位置及总容量大小密切相关。</p>
<p>对于配电网的电压调整，可以想到的，一是在中低压配电网络中设置有载调压变压器和电压调节器等调压设备，将负荷节点的电压偏移控制在符合规定的范围内；二是合理设置光伏电源的运行方式。</p>
<p>试想一下，在午间阳光充足时，光伏电源出力通常较大，若线路轻载，光伏电源将明显抬高接入点的电压。如果接入点是在馈电线路的末端，接入点的电压很可能会越过上限，这时就必须合理设置光伏电源的运行方式。</p>
<p>又比如，由于光伏电源的出力随入射的太阳辐照度而变，可能会造成局部配电线路的电压波动和闪变，若跟负荷改变叠加在一起，将会引起更大的电压波动和闪变。</p>
<p>还是一句话，目前问题没有凸显，但当大量分布式能源并网后，需要通盘考虑这些系统性问题。</p>
<p>3）谐波问题</p>
<p>分布式发电通过电力电子逆变器并网，易产生谐波、三相电压/电流不平衡；输出功率随机性易造成电网电压波动、闪变；分布式电源直接在用户侧接入电网，电能质量问题直接影响用户的电器设备安全。</p>
<p>这里讨论最主要的谐波问题。</p>
<p>谐波问题，目前确实是个比较大的问题，它和诸多因素有关，比如分布式光伏逆变器出厂质量、并网点的短路容量和同一中压升压变下并网的分布式电源总量等等。</p>
<p>但正因为这些因素，都是可以优化完善的，所以在我看来，谐波今后倒不是个十分严重的问题。</p>
<p>有例为证：</p>
<p>1998年，IEA-PVPS-Task-5曾经对丹麦的一个80%家庭都安装有光伏电源的住宅区进行测试，发现光伏电源对当地的谐波贡献有限，还不如家用电器造成的谐波多。</p>
<p>1999年，IEA-PVPS-Task-5曾在日本对多光伏电源接入到同一配电变压器(住宅区柱式变压器)中的谐波进行测试，使用了多个厂家和多个型号的逆变器。测试结果表明，同类型的逆变器(内在电路和控制策略一致)会造成特定次数的谐波叠加，不同类型的逆变器会相互抵消谐波的注入。</p>
<p>英国也在1999年做过类似的测试，测试结果表明：高次谐波衰减很快，低次谐波的变化情况比较复杂。在强网中谐波畸变一般是个常值，而弱网中的谐波畸变一般随接入的光伏电源逆变器个数增加而加重。当馈电线路阻抗值较大时，可使谐波衰减明显。</p>
<p>所以，在今后的实际运行中，谐波问题是相对可控的。</p>
<p>4）孤岛问题</p>
<p>由于线路故障等原因，断路器QF2或QF3跳开，此时分布式电源DG和负载L就构成了一个孤岛系统。在孤岛系统中，DG脱离电网后继续运行，独立地给负载L供电，称为孤岛运行。由于故障跳闸等偶然原因形成的孤岛运行，称为 非计划孤岛运行。</p>
<p>非计划的孤岛运行具有偶然性和不确定性，会对系统、用户和DG本身带来不利影响。目前的做法一般比如，英国电力联合会颁布的G59/1（3）对于容量小于5MW、接入电压等级低于20kV的分布式电源接入电网做了技术规定：对于长期并网运行的分布式电源，大于150kVA的都需要配置反孤岛保护。</p>
<p>这显然是比较简单粗暴的。</p>
<p>对用户来说，供电的中断却给用户带来不便；对发电商来说，利益受到损害；对电网来说，如果分布式电源在孤岛状态下退出，当电网重合成功或故障消除后恢复供电，原来由DG提供电能的用户全部由电网供电，加重了电网的负担，在某些情况下可能造成电网的不稳定。</p>
<p>所以必须发展合理的孤岛运行，以及更为合理的并网、离网协调控制机制。</p>
<p>还有很多其他的次要问题，比如接地、谐振等等，就不多说了。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>发生了人员爬到电塔的情况下，高压电塔能否紧急断电？</title>
    <url>/2023/05/24/%E5%8F%91%E7%94%9F%E4%BA%86%E4%BA%BA%E5%91%98%E7%88%AC%E5%88%B0%E7%94%B5%E5%A1%94%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E9%AB%98%E5%8E%8B%E7%94%B5%E5%A1%94%E8%83%BD%E5%90%A6%E7%B4%A7%E6%80%A5%E6%96%AD%E7%94%B5%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：彭师<br>链接：<a href="https://www.zhihu.com/question/27403155/answer/37453506">https://www.zhihu.com/question/27403155/answer/37453506</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>好激动，知乎首次上百答案，终于有机会划横线了</p>
<hr>
<p>答案不补充了，看很多评论对供电可靠性感兴趣的，就在这里简单介绍下了</p>
<p>电力系统里面有个专业，是搞供电可靠性的，诸如停电范围，停电时间，都是有很多标准和要求的，回到这个问题，停电会不会造成医院抢救的病人没电手术呢？</p>
<p>答案是基本不会。</p>
<p>一般的综合性大型医院，在用电电源上，都是按一级或特级用户供电的，基本要求就是由供电局供电的电源是从两个不同的变电站（不同地理位置）来给的，同时，要求医院内部有自备的发电机及UPS。所以，当有人跳塔时，调度首先时评估，这条线路所供的线路有没有重要用户，如医院/电台/钢铁厂等，如果有，有没有按要求配置双电源，如果有，另一回线路能否保证不间断供电，可以了才能停这一回电的，同时，停电的时候，就要通知医院内部电工，后备电源进行启动切换。对于手术的医生来说，这些都是不知道的，因为所有的切换都是在不停电的前提下进行的。</p>
<p>当然了，什么都有意外，要是这条自杀的线路上重要用户没有按要求进行双电源或者内部的UPS无法切换，调度在下令拉闸停电时，实际上就处在“电车悖论”里，是用一个大概率的可能性停电去救一个小概率不值得救的人，还是用一个小概率的停电导致大概率的大范围停电呢？所以说，调度此刻的心理压力很大的，他下令停电时，甚至都没看到现场。</p>
<hr>
<p>看了新闻，说一下感想：</p>
<p>不作不会死。</p>
<p>当从技术方面分析下，如果不是自杀，而是一个10岁小孩，爬到了铁塔上，他的风险有多大？</p>
<p>1、新闻里是110kV的铁塔，同塔双回，也就是说，塔上有6条线路是带110kV高压电的，而110kV的安全距离是1.5m，也就是说在线路1.5m范围内，都是可能放电的，所以，要穿过那么多的线路不被放电，是非常难和小概率的一件事。</p>
<p>2、保护动作的前提是有短路情况，也就是说，除非已经发生放电、短路，而且要达到一定的限值，才能跳闸的，所以，等保护跳的时候，一般是很惨的接地了，金属都会融化的。</p>
<p>3、作为电力企业，其实首先是保证人的生命安全，不论是电力人员还是非电力的，所以，请不要误解供电企业不停电是怕停电造成的影响，在任何影响前提下，人的生命都是最重要的。</p>
<p>4、一般的110kV线路，在使用中大部分是配网输电用的，也有用于大型企业供电，但大型企业供电的110kV线路，一般都是双回线供电，停一条线路是没问题的，另外一条有充足的余量，如果是重要线路设计时就没考虑停电因素，没考虑备供，那不止要怕人自杀了，还要防止老天打雷不劈这条线。</p>
<p>5、之所以没有现场停电，原因其实很简单，围观和警察都没办法准确描述需要停电的线路，如果现场有一名从事线路运行的电力员工，一个电话给调度，调度是可以准确评估停电影响范围和造成的后果，并在允许的情况下通知停电的，但是，这个时间最快，也要3-5分钟。</p>
<p>电工甲：调度啊，110kV作四线3号铁塔上有人爬上去了，申请紧急停电避险。<br>调度乙：我看看，这条线供城区啊，负荷不重，还有不作线供电，可以停电。<br>调度丙：小丁，有事故，紧急停电作四线。<br>电站戊：老己，调度通知停电，准备操作。<br>电站己：操作完成，可以汇报调度。</p>
<p>至少5个人，时间么，你可以想象。</p>
<p>6、但最关键的还有一点，由于城市空间和建设的原因，上述说的那个保证供电安全的双回线路，很多情况下其实就是同一个铁塔架设的，那么，问题来了，停哪回？</p>
<p>假设新闻中的就是一个电源的两回线：</p>
<p>电工甲：调度啊，110kV作四线3号铁塔上有人爬上去了，申请紧急停电避险。<br>调度乙：不行啊，作四线和不作线都在这个铁塔上，停一回没问题，要是停下来，他一个不小心跑到不作线上，那就全站失压事故了，好几万户居民停电啊，老甲啊，能不能确定停哪回啊？<br>电工甲：刚才在不作这边，现在在作四那边。。。</p>
<p>7、就算停下来了，感应电还是会发生触电的，就算触电没死，但是从高处坠落还是不可避免的，其实铁塔作业，最大的风险还是高度，那么高的地方，铁塔是有晃动的，就算是那个地方来个静电，一样会自由落体，所以，只能说电力员工就算尽力，也不一定能挽救一个爬那么高没安全措施的人。</p>
<p>最后还是做个广告，发现这样的情况，请报警，并打95598给供电部门，告诉你能观察到的情况，最好是有铁塔底座上的编号标识，专业部门会评估电网风险的。不要以为别人作死就觉得是应得的。</p>
<p>希望还是要有的，万一实现了呢，万家灯火。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>紧急断电</tag>
      </tags>
  </entry>
  <entry>
    <title>多能互补</title>
    <url>/2023/05/23/%E5%A4%9A%E8%83%BD%E4%BA%92%E8%A1%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/24610241">https://zhuanlan.zhihu.com/p/24610241</a></p>
<p>今年7月4日，国家发改委、能源局印发了《推进多能互补集成优化示范工程建设的实施意见》，一时间，此类示范工程的申报工作如火如荼，十天之内，地方申报的多能互补集成优化示范工程建设项目已经超过250个（指标为20-30个），热情之高，干劲之足，令人惊叹。</p>
<p>前两天，结果出来了，首批多能互补集成优化示范工程入选项目23个，其中用户侧17个，电源侧6个，前段时间参与了申报工作，这次也入选了，借此，聊聊火热的背后，还有些什么。</p>
<p>一、何谓多能互补？</p>
<p>多能互补，字面理解，多种能源互相补充，综合利用，提高能源输出和利用效率。</p>
<p>常规来讲，我们平时理解的多能互补，就是用户端，特别是工业和产业园区，实施能源综合梯级利用，典型的，如冷热电三联供项目。申报通知中，对此类常规理解作了一定延伸，使得多能互补项目的定义更为完善，申报的示范工程分为两类：</p>
<p>一是面向终端用户电、热、冷、气等多种用能需求，优化布局建设一体化集成供能基础设施，实现多能协同供应和能源综合梯级利用；二是利用大型综合能源基地风能、太阳能、水能、煤炭、天然气等资源组合优势，推进风光水火储多能互补系统建设运行。</p>
<p>第一类工程针对用户侧，主要为天然气分布式能源，主要为常说的（冷）热电三联供，即以天然气为主要燃料带动发电设备运行，产生的电力供应用户，发电后排出的余热通过余热回收利用设备向用户供热、供冷，大大提高整个系统的一次能源利用率，实现了能源的梯级利用。</p>
<p>第二类工程针对电源侧，互补的形式有多种。比如：“风-风互补”，不同风电场之间可能具有互补性，打捆送出可降低出力变化率；“风-光互补”，从负荷去线上看，风光之间没有明显的互补特性，但是在某些特定区域，特别是风电夜晚大发，白天出力时，共用输出通道，可提高线路利用率；“水-光（风）互补”，具有日调节及以上能力的水电站启停快，调整出力能适应新能源的出力变化；“煤电-光（风）互补”，优先次序低于水电调节，目前哈密、酒泉均采用新能源与煤电打捆的方式，但此种方式幅度有限；“抽蓄-光（风）互补”， 利用蓄能电站的储能作用，效果较佳。</p>
<p>二、智慧能源的落脚点</p>
<p>多能互补是能源互联网、智慧能源的落脚点，个人认为，是当前最重要理念和切入点。</p>
<p>一直以来，能源互联网、智慧能源给大众的感觉，非常高大上，难免有些不接地气，确实，概念炒作太多，没有具体落地点，对行业的发展比较不利。</p>
<p>多能互补示范工程来的正是时候。能源互联网核心就是横向互补、纵向优化，提高能源效率。所以，抛开互联等信息技术不谈，多能互补下的综合能源系统，应该是智慧能源在能源专业范畴中的精髓，也是智慧能源的工程具体化。</p>
<p>实际上，多能互补和综合能源系统也不是一个新概念，热电联产和冰蓄冷本质上已经属于局部的多能互补，“楼宇型”和“区域型”天然气分布式能源系统也时常可见，但这些项目无论是实际能效转化，还是和用户侧的互动，总体感觉，和智慧能源的要求存在差距。</p>
<p>所以，本次申报的多能互补项目，作为智慧能源的切入点，除了常规的天然气分布式以外，应该体现智能互联，互动响应等元素。以深圳前海多能互补、协鑫苏州园区项目为例，初步包含了供应侧的冷热电三联供和分布式新能源，传输侧的智能配网，用户侧的智能社区（需求响应等），平台侧的能源管理系统，应该是本次试点的方向。</p>
<p>三、“小系统”与“大系统”</p>
<p>示范项目的分类，对应能源系统发展的两类方向：“小系统”和“大系统”。</p>
<p>用户侧项目（小系统）面向终端，以能源自给自足，合理联络为主；电源侧项目（大系统）面向跨地区配置，以能源输送为主。</p>
<p>诚然，国际上电网和能源系统发展的潮流为“小系统”，区域化、智能化，就地平衡；但目前国内能源资源分布不均，所以“大系统”也将在一定范围内存在，得到一定发展也是理所应当的。</p>
<p>但是，“大系统”的发展，应该得到充分论证，毕竟不远的将来，分布式能源给电力和能源系统带来的影响是巨大的，“大系统”存在但必须结合远景能源系统构成，谨慎决策。毕竟，电源侧打捆送出只是一种模式，不能因为是新能源，而忽略其成本及可靠性的合理范围，盲目支持。</p>
<p>本次示范项目的比例也和上述观点相符，“十三五”期间，国家级终端一体化集成供能示范工程（用户侧项目）20项以上，国家级风光水火储多能互补示范工程（电源侧项目）3项以上。即用户侧小系统平衡为主，电源侧大系统输送为辅，符合能源系统和国际发展趋势。</p>
<p>四、国内的发展&amp;与国外的差距</p>
<p>用户侧多能互补。</p>
<p>国内由于发展天然气分布式能源时间较短，大约十几年，处于起步状态。但自2011年起，中国天然气分布式能源项目装机容量快速增长。2014年底，已建成和建设中项目达到104个，装机容量已达3.8GW。</p>
<p>然而，根据我国制定的天然气分布式建设规划，“十二五”期间要建设1000个左右天然气分布式能源项目，但截止到2015年底，我国建成和在建项目总和约为100个左右，仅完成了十分之一。天然气发电装机占总装机容量仅为3%，而发达国家占比均在25%-35%不等，与它们还存在着相当大的差距。</p>
<p>国外发达国家天然气分布式能源（冷热电三联供）发展的较早，也较为成熟。以美国为例，在天然气供给充足和环境保护的双重推动下，美国的分布式天然气得到了长足的发展，据美国能源部2012年的不完全统计，全美约3500个大学、医院、政府机构、金融中心、工业小区等建立了区域冷热电联供项目，装机总量超过了85GW，占到国总发电量的12%，到2020年，约占总发电装机量的29%。另外，欧洲和日本的发展也十分迅速。</p>
<p>日本东京地区天然气分布式能源</p>
<p>电源侧多能互补。</p>
<p>国内由于“三北”地区新能源富集，近年来新能源基地打捆互补送出一直是研究和实践的热点，当然其中也存在很多问题，火电比例较大的成本问题，故障下的电源和负荷两侧的稳定问题等等，哈密-郑州直流目前的实际输送功率不高也正是因为这些问题。</p>
<p>国外基本没有大电源基地的打捆输送，比较接近电源侧多能互补的，应该是“虚拟电厂”概念。</p>
<p>“虚拟电厂”通过分布式电力管理系统将电网中分布式电源、可控负荷和储能装置聚合成一个虚拟的可控集合体，参与电网的运行和调度。即随着分布式能源比例的不断提高，在原有的大电网中，高效的控制这些分散的小型“电厂”。也算是电源侧多能互补的一种体现，当然，“虚拟电厂”不仅限于电源侧。</p>
<p>例如德国北部港口城市库克斯港市的虚拟电厂项目，系统由风力（600千瓦）发电、太阳能（80千瓦）发电、冷藏仓库（250千瓦和260千瓦）、热电联产系统（460千瓦和5.5千瓦）构成。通过转移冷藏仓库的热需求，来抵消风力发电的变动。通过整合风力发电、太阳能发电及冷藏仓库的电力需求，能够如同一座发电站一样进行电力控制。</p>
<p>个人认为，“虚拟电厂”思路应该也适用于大电源基地的消纳。</p>
<p>多能互补项目的关键</p>
<p>用户侧多能互补，关键在于经济性。只有经济性好，才有产业化的希望。经济性的影响因素，一是实际效率，二是价格，三是智能互联。</p>
<p>实际效率。主要取决于机组/负荷匹配，即针对不同用户的负荷情况，通过分析全年负荷变化情况来选择系统各装置的机组容量，并对选定的机组配置方案进行优化分析，尽量提高其能源利用率。国内现在不少项目，由于电负荷预测不准、机组容量配置不合理，经济性很差，有的已经停运，有的靠着国家补贴存活。</p>
<p>天然气分布式有其适用场景，冷热负荷需要连续且基本稳定，同时原动机所提供的冷热负荷用户能消纳，所发电能或自用或上网。冷热负荷预测和特性分析十分重要，直接决定机组规模。</p>
<p>机组/负荷匹配工作做好不容易，项目自投的还好，否则非常容易夸大负荷，从而造成机组配置冗余，需要既懂负荷，又懂机组，还懂天然气的跨界人才。这方面的具体工作我们一直在做，有时确实感觉从理论到实际还是有差距。</p>
<p>价格。分布式能源系统的经济性与当地的电价、气价有着密切的关系，对应不同的价格体系，分布式能源系统的经济性可能有着根本性的不同。尤其是天然气价格，是整个分布式天然气项目能否存活的关键，燃料成本几乎占到项目总成本的70%-80%，目前的价格机制来看，大多数地区不是很理想，但试点工程背景下，应该会有改善。</p>
<p>智能互联。现在大多数多能互补工程都在独立园区或区域，如何组织这个独立系统，使供应侧、传输侧、需求侧、平台侧各部分都做到智能高效，是目前的重要课题，也是我们一直在具体探索的事情，智能互联这部分和主动配电网关联比较近，网架优化、终端主站建设方案、通信方案、主动控制方案、主动服务方案等等，之前都做过，但需要融入多能互补工程，并扩展延伸至能源系统。</p>
<p>电源侧多能互补，关键在于是否真正互补，即最终的互补效果。比如多种电能混合输送的调度问题，稳定问题，特高压的经济性问题，都值得关注。</p>
<p>多能互补和增量配售电</p>
<p>无需多言，将这两者联系在一起几乎是必然的，配售电对电源和综合能源服务的需求，让这两者天然地结合起来，各种园区就是天然地应用场景，两类试点工程推行时间相隔不长，结合起来，大有文章可做。</p>
<p>你看，试点通知中提到，到2020年，各省（区、市）新建产业园区采用终端一体化集成供能系统的比例达到50%左右，既有产业园区实施能源综合梯级利用改造的比例达到30%左右，市场巨大，很多人都要开始忙碌了。</p>
<p>多能互补相关的，暂时就写这么多吧，后面对应工程中的心得体会，到时再总结，学习之路，漫长而充实。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>电力系统效率</title>
    <url>/2023/05/22/%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/28793570">https://zhuanlan.zhihu.com/p/28793570</a></p>
<p>最近工作上，搞太多增量配网、多能互补、微电网等电改相关的东西了，也不算特别顺利，确实啊，咱中国很多事情，搞到最后就变成关系、资源和政策了，否则很难推动。不说那么多了，回归技术层面，回归本源，说一千道一万，电改的目的不就优化系统效率么，那么就谈谈效率方面的事儿。</p>
<h1 id="何谓电力系统效率"><a href="#何谓电力系统效率" class="headerlink" title="何谓电力系统效率"></a>何谓电力系统效率</h1><p>效率这词很容易明白，电力系统效率也一样。也就是说电力系统不是越可靠越好，要讲究一个性价比和利用效率，冗余多了会造成极大的浪费。</p>
<p>好吧，言归正传，电力系统这个系统比较复杂，说点拗口的专业的描述：</p>
<p>“一个复杂的、形成的具有网络结构特征的，多个参与主体和投资主体相互作用，相互影响以电力和热力为主要产品、以能源生产、和消费为主要功能的投入产出系统。”</p>
<p>是挺复杂的，简单点说，效率主要由发电企业、电网企业和电力用户三个主体自身运行效率以及相互作用决定。</p>
<p>发电企业：主要由发电设备利用效率、原料产出效率、发电经济效率等因素决定。<br>电网企业：主要由电网传输效率、电网结构、电力设备与设施运行效率及损耗等因素决定。<br>电力用户：这方面以往被遗忘，现在越来越被重视，比如节能和能效管理，需求侧管理等等，可以为提高电力系统整体效率做出贡献。</p>
<p>当然，还有些外部因素的影响，比如国家可再生能源政策和环境保护政策，影响系统的效率。</p>
<p>这里面因素太多，我们需要简化下，不然根本说不完。</p>
<p>从发电企业、电网企业和电力用户择取三个指标，分别是：可再生能源利用效率，设备利用效率和需求侧管理效率。个人感觉，这三个指标还是符合趋势和代表性的。</p>
<h1 id="我国电力系统效率"><a href="#我国电力系统效率" class="headerlink" title="我国电力系统效率"></a>我国电力系统效率</h1><p>总体而言，我国电力系统效率显然是不高的，比较冗余，这里面有很多原因，下面再详细说，先说说效率不高的表现，就从三个指标说起。</p>
<h2 id="首先说说，最主要的，设备利用效率。"><a href="#首先说说，最主要的，设备利用效率。" class="headerlink" title="首先说说，最主要的，设备利用效率。"></a>首先说说，最主要的，设备利用效率。</h2><p>这里面应该包括火电设备利用小时，电网负载率，网损率等方面。</p>
<p>火电设备利用小时数，最近经常提到，去年火电设备利用小时进一步降至4165小时，为1964年以来年度最低，火电企业日子相当难过。5100小时左右，应该是盈亏平衡点集中区，目前的火电设备效率堪忧。</p>
<p>电网负载率，以我国最具活力的长三角地区的华东电网为例， 500k V 输电线路轻载情况相对较为严重，大部分线路处于长期轻载的情况，只有相对少数线路负载率超过 50%，其他电压等级也类似。</p>
<p>近年来，由于电力电量的增长速度放缓，冗余程度还在上升。</p>
<p>考虑电网可靠性，相对保守的情况下，输电线路合理平均负载率应位于 40%左右。这样看来我国电网设备的冗余度是非常高的，大马拉小车，设备晒太阳的比例不小。</p>
<p>网损率，我国2013年电网综合线损率为6.67%，居世界同等供电负荷密度条件国家的先进水平，但与网损率最低的国家如日本、德国相比还存在差距。</p>
<h2 id="其次是，可再生能源利用效率。"><a href="#其次是，可再生能源利用效率。" class="headerlink" title="其次是，可再生能源利用效率。"></a>其次是，可再生能源利用效率。</h2><p>这里面应该包括可再生能源装机占比，弃风弃光，新能源最大利用小时数等方面。</p>
<p>可再生能源装机占比我国目前超过30%，绝对量是比较高的，但是占比和发达国家还是有较大差距；弃风弃光就不说了，非常严重的问题；最大利用小时数，国际排名也是很低的。</p>
<h2 id="最后是，需求侧管理效率。"><a href="#最后是，需求侧管理效率。" class="headerlink" title="最后是，需求侧管理效率。"></a>最后是，需求侧管理效率。</h2><p>这里面主要涉及负荷率。</p>
<p>何谓负荷率？是指年平均负荷与年最大负荷的比值。负荷率越小，说明平均负荷与最大负荷之间的差距越大峰谷差异较大，电力系统运行效率与经济性都比较差。</p>
<p>我国要电网负荷率逐年减小，峰谷差越来越大，除华北电网32.5％和西北电网29.4%外均超过35%。全国各主要电网的调峰能力普遍不足。</p>
<p>提高负荷率是一项系统工程，需要在发电企业、电网企业、电力用户联合实施管理措施。尤其是需求侧管理，可以提高负荷率，缩小峰谷差。</p>
<p>所以，不管是从电源侧、电网侧，还是用户侧，咱们国家的电力系统的效率都偏低，不是说不可靠，而是某些方面太可靠，过于冗余了。</p>
<p>这里的国外，肯定是指的发达国家，谨防抠字眼。（说到这个真是来气，今天莫名其妙的，在好久之前的“日本电线杆”问题下被骂了精日，所以用词需谨慎）</p>
<p>上面说国内的时候，其实也附带着提到了国外，可再生能源利用率和需求侧管理效率就不说了，都知道国外电力市场开展的早，这两方面肯定大幅领先国内。</p>
<h1 id="重点说说设备利用层面。"><a href="#重点说说设备利用层面。" class="headerlink" title="重点说说设备利用层面。"></a>重点说说设备利用层面。</h1><p>有些数据，日本、美国的电量线路比分别为 3008 万千瓦时/千米和 1486 万千瓦时/千米，我国是972 万千瓦时/千米。</p>
<p>澳大利亚电网40%的500kV线路的平均负载率超过50%，上面看到的华东电网是8%，多大的冗余和浪费。</p>
<p>又要吐槽特高压了，在这么高的电网冗余程度下，还要上这么惊人投入的特高压？只会继续加大电力系统冗余度，极大降低系统效率，最后这些钱都摊到电价里面，加大群众的用电成本。</p>
<h1 id="差异的原因和建议"><a href="#差异的原因和建议" class="headerlink" title="差异的原因和建议"></a>差异的原因和建议</h1><p>为什么存在这么大的差别？简单概括，一是规划建设思路，二是市场机制发展。</p>
<p>规划建设思路。我们的规划建设，通常都是考虑可靠不出事，容载比高高的，N-1，N-2时刻准备着，基于国情嘛，供电安全问题是最大的问题，帽子问题，而国外都是竞争性盈利企业，肯定是要基于可靠性和经济性的均衡考虑。</p>
<p>这点非常明显，而且，国外电力市发展成熟，可靠性和经济性之间的区别越来越模糊。可靠性问题大都同时是经济性方面的问题，它会影响电力市场的不同参与者采取不同的行为</p>
<p>PJM认为：电力市场调度的输电约束就是经济性约束，只要是在事故之前电力系统经过调整能够维持在可靠性限制之内运行，经济性约束不应该视为违反了可靠性标准。这种观点是合理的，因为提供充足的输电能力以保证所有系统状态条件下市场的有效竞争，代价过于昂贵。</p>
<p>而且国外会定期对电网充裕度进行评估，以指导后续，国内的评估近年来也开始做了，但是还远不如国外的实际和有效。</p>
<p>市场机制发展，这个是显而易见的，新能源发电小时，需求侧管理这些都和电力市场有关，单纯靠政策，效果非常有限，市场机制提高效率，这句话已经被证明了无数次了，就不多说了。</p>
<p>关于建议，除了以上两大点以外，还有些具体的。</p>
<p>比如发电侧的合理控制装机规模，优化调整电源结构，提高火电调峰能力；电网侧的优化网架，合理评估建设需求等；需求侧的完善现行电价政策，充分发挥峰谷分时电价杠杆作用，推广负荷聚合机制等需求侧响应措施等。</p>
<p>所以说，电改只是手段，提高系统效率才是目的，本源更应该被关注。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解虚拟电厂</title>
    <url>/2023/05/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E7%94%B5%E5%8E%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/258942313">https://zhuanlan.zhihu.com/p/258942313</a></p>
<p>虚拟电厂这个概念和业态，近期动作频频，尤其在国内沿海发达地区。</p>
<p>名字听上去比较新奇和前沿，实际是否在炒作概念？工作过程中，接触了一些相关业务和案例，把情况作一些分享交流。</p>
<p>1、概念的通俗解释。</p>
<p>虚拟电厂，顾名思义就是一个虚拟化的电厂，里面的内容不是电厂，但是起到一个电厂的作用。实际上也是如此，就是将相对分散的源、网、荷、储等元素进行集成调控，形成一个黑匣子，对外等效成一个可控的电源。</p>
<p>这个黑匣子，对外既可以作为“正电厂”向系统供电，也可以作为“负电厂”消纳系统的电力，起到灵活的削峰填谷等作用。</p>
<p>以往的电力系统削峰填谷，基本是通过火电厂实现的，根据测算，满足5%的峰值负荷需要投资4000亿的电厂和配套电网；而通过虚拟电厂实现，建设、运营、激励等环节的投资只需要500-800亿元。</p>
<p>既然这么节约，以前为什么没有这么做？因为虚拟电厂这个黑匣子，要实现上述功能，需要有内部可控的资源，比如储能、充电桩等；需要有机制，比如电力市场交易；需要有技术，黑匣子内部资源的控制和调度。</p>
<p>这些，以前都不太具备条件，现在基本具备了，所以沿海进展比较快。</p>
<p>实际上西方国家，在这块已经有不少案例。各国各有特点，日本和德国以储能和分布式电源，作为虚拟电厂的主体，美国则是以可控负荷为主，规模已占尖峰负荷的5%以上。</p>
<p>2、一些容易混淆的东西。</p>
<p>听上去虚拟电厂和需求侧响应，好像比较相似，本质内涵也比较一致。</p>
<p>实际上，广义来讲，虚拟电厂是需求侧响应的延伸版，需求侧响应主要是削峰，主要针对用户负荷；虚拟电厂则是削峰和填谷兼顾，源网荷储都包含在内。</p>
<p>虚拟电厂的响应机制，比起常规的需求侧响应，要灵活迅速，一旦系统发生负荷缺口或者消纳困难，虚拟电厂可以迅速实现削峰填谷，自动响应，要求和常规电厂的效果，基本一样。</p>
<p>需求侧响应的响应要求，相对低一些，做到自动响应的基本没有。</p>
<p>虚拟电厂能够发展，必须具备以下三种资源：分布式电源、储能、可调节负荷。</p>
<p>分布式电源包括小型光伏、风电、生物质、燃机等，当然，调度关系不属于现有公用电网系统。截至2018年底，我国分布式电源装机约为6000万千瓦，其中，分布式光伏约5000万千瓦，分布式天然气发电约为300万千瓦，分散式风电约为400万千瓦。</p>
<p>储能就更好理解了，对冷热电等能源进行存储、释放，虚拟电厂天然的可调节资源。</p>
<p>截至2019年12月，全球已投运电化学储能累计装机为809万千瓦，我国171万千瓦，初步形成电源侧、电网侧、用户侧“三足鼎立”格局。</p>
<p>可调节负荷主要是一些工业、交通和空调负荷，需要考虑用户中断负荷的意愿、中断量和补贴价格。据国网统计，夏季空调负荷占最大负荷约30%，其中华北、华东、华中部分省市占比达40%-50%。空调负荷已经成为拉大用电峰谷差、加剧电网高峰运行压力的重要因素。</p>
<p>3、有没有落地的案例？</p>
<p>国内最近就有几个，基于空调负荷的，国网营销部牵头，选择了一些省份落地。</p>
<p>2020年，上海黄浦区虚拟电厂项目。迄今最大规模的一次试运行，参与楼宇超过50栋，释放负荷约1万千瓦。</p>
<p>怎么实现的？在用电高峰时段，系统对虚拟电厂区域内，相关建筑中央空调的温度、风量、转速等多个特征参数，进行自动调节，且对用户体验影响不大。</p>
<p>技术层面是有一些工作量的，包括控制、计量、调度、交易等等，以往的能源调控颗粒度比较大，虚拟电厂针对的是设备级，而且要求自动响应的话，复杂程度就很高了。</p>
<p>国网在这块，以前没做过，也是一步步研究探索，参与过里面一些项目，还是有点启发。开发的系统叫CPS系统，基于一套“云管边端”体系。</p>
<p>这里面，不同的空调，比如中央空调，VRV空调、分散式空调，他们的控制策略和实现，都不一样，现在的成果也都需要根据项目实践，进一步完善。</p>
<p>那么，用户怎么参与虚拟电厂项目，实现收益？以上海项目为例，还是在系统平台上，负荷集成商进行竞价。三级的架构，平台、负荷集成商、用户。</p>
<p>补贴价格根据响应时间，也是有区分。用户在30分钟之内进行削峰，给你的补贴就是3倍的价格（有一个基准值），30分钟到2小时之间是2倍，时间更长就更低。</p>
<p>补贴的来源，目前主要是来源于各省的跨省区可再生能源电力现货交易购电差价的盈余部分，所以还是有一些制约，很多省份还没有开始现货交易。</p>
<p>国外的典型虚拟电厂，德国Next Kraftwerke公司的项目，实现了对4000多个分布式发电设备的管理，也包括一部分可调节负荷，2019年底已经实现对跨5个国家7000多个分布式能源和可调负荷的管理，总规模接近300万千瓦。</p>
<p>2009年成立的Next Kraftwerke公司员工总数不超过200人，销售收入4亿欧元左右，交易电量140GWh，业绩非常突出。</p>
<p>主要通过几方面获得效益，一是光伏、风电等边际成本较低的电源，参与市场化交易获利，二是生物质、燃机等调节性能较好的电源，参与调频获利，三是调节分布式电源和可控负荷，利用峰谷差在电力市场获利。</p>
<p>这样的案例，对于资源协调和聚集能力，要求是非常高的。源网荷储资源的特征，如何与电力市场的商务模式衔接，怎么及时响应，高效控制，都是很大的课题。</p>
<p>4、国内发展的大致判断。</p>
<p>是个大趋势，是个好东西，但是能不能推广，还是要看几方面。</p>
<p>一是盈利模式。跨省区可再生能源现货交易购电差价盈余作为资金池，只是当前权宜之计，还是要形成商业模式，且不是那种被动的补贴模式：虚拟电厂使得电网、电厂投资减少了，就去找他们出钱。</p>
<p>这种模式很难推广，不好核定，没人愿意出钱，需要形成市场化行为，电力市场里面，有人愿意买单，自然不愁没人主动去做。</p>
<p>二是场景延伸。例如充电桩站用这样的元素，能否充分融合进来，充电桩可调节性能很强，对时间和舒适度要求不高，发展体量很大，需要统筹规划。</p>
<p>现在很多案例，都是以空调负荷为主，受到到很多制约，单个楼宇空调需求响应项目改造投资较大，但可调负荷有限，性价比不高，难以回收投资。</p>
<p>三是成本问题。目前虚拟电厂平台、终端成本还是很高的，自控、信息设备都很花钱，如何优化成本，对于案例的市场化复制，也是至关重要的。</p>
<p>以上，感谢阅读。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>电力系统规划</title>
    <url>/2023/05/20/%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/264898348">https://zhuanlan.zhihu.com/p/264898348</a></p>
<p>电力系统规划，算是比较传统的专业，里面的知识体系，包括相关工程实践，其实也比较固化。</p>
<p>里面少有的有意思的，其实就是，关于国内外的对比，会带来一些新鲜感，然后发现一些电力系统本质的东西。</p>
<p>1、整体直观的感觉。</p>
<p>之前工作中，接触过一些国外知名的，做电力规划的咨询机构，比如Parsons Brinckerhoff （柏诚）、Tractebel Engineering（特克贝尔）、london Power Associates等等。</p>
<p>听过他们的汇报，分析过他们的成果，也沟通交流过，整体感觉差异还是存在的。</p>
<p>首先，一些底层的专业原理，还是共通的。比如N-1，网架结构，短路校验，稳定校验这些，框架和具体内容都基本一致。</p>
<p>底层原理之上，一些具体实施环节，包括有些关键指标、分析过程、计算方法，还是存在差异。</p>
<p>美国CAISO输电网发展规划编制流程图<br>你翻一本国外的电力规划报告，对比国内的，内容安排和风格，差别非常大。我也看过一些日本做的亚行项目规划报告，相比之下，和我们国内的比较接近，和西方的也不是一样东西。</p>
<p>欧美的规划报告，模板是互通的，包括印度的，英语母语的天然优势，接轨的挺快，但是印度人做的东西，比较偷工减料。</p>
<p>所以，还是强调一下，本文里提的老外，主要是欧美的专业同行。</p>
<p>老外做电力系统规划的套路和流程纯熟，工作量不小，效率也很高。</p>
<p>上面提到的那些公司，很多都是大的工程咨询公司，除了电力还涉足其他领域，所以有些通用套路，显得比较规范。</p>
<p>表现在PPT展示里面，就会比较明显，我们的基本都是干货，一份材料。他们就是不同的人上去讲，每个人都是一个独立的题目，电力需求分析、电源规划、网架规划、可靠性分析等等</p>
<p>每份PPT里面，都是旁征博引，信息量很大，但是其实实用的也不算多，但给人感觉很专业。</p>
<p>所以他们的工作量，其实很大，和我对他们的固有影响，闲散的做做电力咨询，完全不一样。</p>
<p>因为他们的规划内容，实际上比国内的要细致，计算分析过程也相对繁琐，展现形式要求也很高，加上专业上也比较较真，所以真的也不容易。</p>
<p>以上是一些宽泛的印象，具体的专业内容，下面探讨。</p>
<p>2、专业原则上的一些差异。</p>
<p>首先是对可靠性的理解，电力系统核心问题。</p>
<p>北美《NERC输电规划标准》里面定义可靠性，包含两方面：充裕度和安全性。</p>
<p>充裕度又称静态可靠性，是指系统维持给用户供电的能力，主要是对装机容量充裕性的考虑；安全性也称动态可靠性，是指系统发生故障时稳定运行的能力。</p>
<p>评估可靠性时，有确定性和概率性两种原则。打个比方，确定性原则不允许出现N-1故障下的负荷损失，概率性原则却可以，特别是一些小概率故障，或者应付这些小故障投资过高。概率性原则更考虑经济性。</p>
<p>在这点上，国内基本全部采用确定性原则，老外则是确定性、概率性兼顾。</p>
<p>那是不是说，老外电网企业没有担当，只考虑经济利益？</p>
<p>其实也不是，老外很精明，他们在骨干电网安全的关键环节：主网规划里一直提概率性原则，但是从来没有写到规划标准里，都还是执行N-1确定性校核。而配网规划、电源规划里面，概率性原则就用的比较多了。</p>
<p>以英国配网《供电安全导则》ER P2/6 流程为例，里面大量的故障概率、可靠性分析和成本效益分析，并得到了广泛应用。</p>
<p>电源规划也如此，老外通常采用概率性原则，如LOLF(电力不足概率)或者LOLE(电力不足期望值)来评估。国内则是确定性原则，来确定装机规模，其中粗略的，就是备用容量为系统最大发电负荷的20%～30%。</p>
<p>概率性原则，只是老外对经济性重视的一方面，电力规划中还有很多环节，都在强调经济性。</p>
<p>重视经济性，不是坏事，也不代表不安全、不可靠。国网和南网，可靠性方面做得很好，确实体现了社会担当，但是运营效率和效益上，还是有很多提升空间。</p>
<p>比如说提高可靠性，不一定非要建设满足最大负荷的电气设施，可以通过转供实现，可以通过需求侧管理实现，等等。</p>
<p>毕竟，现在国内变压器和线路的平均负载率，还是比较低的，设备冗余比较大。</p>
<p>法国配变负载率控制在80%-90%之间，过小是不经济的，因铁损成本高于铜损成本；当负载率超过90%时纳入黄色警示监测，达到95%后纳入改切或换大。所有的公用配变下均有轮子，便于抽出更换。</p>
<p>当然，电力系统效率，涉及很多方面，电力体制、电力市场、电价机制等等，但是技术、经济均衡考虑，这个方向，应该是没有问题的。</p>
<p>3、具体做法上的异同。</p>
<p>先说说网架规划，这方面国内外的差别，主要体现在理念上。</p>
<p>主网大家基本一致，比如北京、东京、巴黎等，都在外围形成了高压环网，并向内供电，进一步形成市中心的低一级高压环网。</p>
<p>配网网架理念差别，主要体现在两方面。</p>
<p>一是复杂和简化。以法国ERDF配网为例，极为推崇简洁可靠的网架结构，他们推荐的单环网、单层级模式，与国内目前大力推广的是双环网多层级模式差异较大。</p>
<p>这是有道理的，复杂网架运维难度成倍增加，受限于设备本身可靠性，对电网可靠性提升，往往无法达到预期效果，而且自动化策略因为电网结构的复杂，实际上不利于自愈功能的发挥。</p>
<p>国内现在很多同行，现在也意识到这个问题，简单配电网的说法也时而听到。</p>
<p>二是模块化。国内主要还是关注网架，而国外更关注供电模型。</p>
<p>供电模型能够使网架清晰化、标准化。因为供电模型里面，不仅包括网架接线，还有负荷密度、供电能力、转供联络等因素。</p>
<p>负荷不断增加，供电模型可不断延展，相当于一个模块化设计的思路，不同模块之间也有联络，典型的就是巴黎的三环网和新加坡的花瓣式中压配网。</p>
<p>其次是电气计算，这块也是系统规划的干货，老外和我们同样存在差异。</p>
<p>计算内容的话，大家基本一致，潮流计算（Load flow）、短路计算（Short circuit）、稳定计算（Transient stability），有时候还要加上电磁暂态（electromagnetic transient），差异主要在计算过程和计算工具上。</p>
<p>计算模型上，老外的比较细致，国内稍微粗略，等效的比较多。</p>
<p>老外的计算过程，比国内相对详细，相对清晰。以稳态部分的潮流计算为例，一般为单线图（Single Line Diagram），相对国内的节点示意图来说，表达的信息更加全面细致，更能反映电网结构和特性，当然对于初期建模的要求也更高。</p>
<p>暂态部分就详细的更多了，国内算的比较粗略。国外报告里面暂态部分，一般都包括三块：暂态安全评估、暂态稳定评估和小信号稳定评估，篇幅很大。</p>
<p>暂态安全评估是研究突发事件时的暂态电压，突出电容/电抗器和静止无功补偿（SVC）的需求；</p>
<p>暂态稳定评估，是指在计算故障时，系统的稳定情况以及各要素的临界切除时间（critical clearing time , CCT）。CCT的计算，老外算的比较多。</p>
<p>故障临界切除事件计算表<br>小信号稳定评估和国内对比，结果显示上更加直观些，对于每种振荡模式，都给出了左右特征向量，从而可以计算出每个变量的参与系数及其振型。</p>
<p>区域内机组振荡模式示意图<br>具体做法上，其实还有很多差异，篇幅原因，后面抽空再探讨。</p>
<p>4、孰优孰劣。</p>
<p>这个其实不好说，国外电力系统规划做的细致，展现出来比较高端，国内做的比较实用，效率比较高，各有所长。</p>
<p>说到底还是个话语权的问题，不管是东南亚还是非洲拉美，已经习惯了，西方那些著名电力咨询公司的做法，我们的做法，就显得不接轨了。</p>
<p>不管是标准、内容、方法、展现形式，都存在接受度问题，很多东西，我们国内业内人士看没有问题，老外觉得就不行，除非是那种对底层原理，非常了解的老外。</p>
<p>这种老外，我也碰到过，和他解释一本规划报告，从N-1这种共同的基础认知开始，逐步解释每一个环节的由来，有些东西为什么可以不算，解释了一下午。</p>
<p>这种老外毕竟很少，而且只适用于主网规划，配网规划很难解释的通，国内外差异更大，建议直接用国外公司规划模板，套用一下，不是很难。</p>
<p>所以，想参与国际电力咨询业务，在底层原理差异不大的情况下，在内容、过程、展现上，向国际通用模板靠拢，是有必要的。</p>
<p>何况，老外的这些东西，确实经得住推敲。</p>
<p>以上，感谢阅读。</p>
<p>（某些图片和数据来源于网络，若有侵权，请联系删除）</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>电力仿真软件</title>
    <url>/2023/05/19/%E7%94%B5%E5%8A%9B%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自<br><a href="https://zhuanlan.zhihu.com/p/286645843">https://zhuanlan.zhihu.com/p/286645843</a></p>
<p>工欲善其事，必先利其器。电力系统分析工作中，软件应用是回避不了的一个环节。</p>
<p>什么时候用什么软件，哪种软件更适合，还是有些差异，故形成下文，供参考。</p>
<p>1、什么时候需要用系统仿真软件？</p>
<p>总体上来讲，涉及到系统层面的，排除系统规模特别小的，计算基本只能依靠软件，这是由电力计算的专业特性决定的。</p>
<p>当然，仿真计算得出的只是数据和曲线，是原料，需要分析、加工，从而得出结论。</p>
<p>电网规划，肯定需要进行软件仿真的。网架规划后的电气校核，属于全面性的计算，工作量比较大，软件仿真不可或缺。</p>
<p>电网规划的范围很广，核心内容是网架规划，需要校核很多东西，线路过载？短路超标？稳定与否？无功欠缺？等等。</p>
<p>专项仿真计算，除了电网规划以外的概括。比如说电能质量计算、过电压计算、直流系统仿真、保护计算等等。</p>
<p>这方面的仿真计算，领域更加细化，深度要求也更高一些。</p>
<p>电力系统仿真也分两类，稳态和暂态。暂态又分为机电暂态和电磁暂态，大致对应于下图中的有效值范畴、瞬时值范畴。</p>
<p>机电暂态和电磁暂态，通俗的讲，主要是针对不同时间颗粒度的电气过程，采取不同样的计算模型。电磁暂态的时间颗粒度更短，计算模型精度更高。</p>
<p>所以仿真软件里面，用于稳态和机电暂态的是一类，用于电磁暂态的是另一类。</p>
<p>2、稳态和机电暂态仿真软件。</p>
<p>国内的有两个，BPA和PSASP，都是电力规划工程师日常打交道的东西，计算潮流、短路、稳定这些常规的数据。</p>
<p>BPA。严格意义上，其实也不算国内的，它是上世纪60年代由美国邦纳维尔电力局开发的，1996年终止了开发和维护，现在是中国电科院系统所在维护升级。</p>
<p>BPA还是挺不错的，用的熟练了对系统架构，各项参数取值，稳定分析都会有较深的认识。</p>
<p>唯一的不好之处，在于这个软件很难找到破解版，是需要软件狗的，即使有破解版，估计计算的节点也受限制。</p>
<p>PSASP。和BPA类似，功能基本差不多，也是用来搭网架、算潮流、算短路、算稳定的。</p>
<p>但这软件有点不好的，界面式操作，有点不方便，设置参数一个个的弄，很费时间。</p>
<p>BPA是代码式的，就比较好，EXCEL整理数据，一起复制就可以了，而且对参数的熟悉比PSASP要高的多，天天操作代码必然会了解参数。</p>
<p>这软件也有比BPA好的，即BPA不支持用户自定义，学生做课题可能不太适合，而PSASP有，这个软件也要软件狗。</p>
<p>PSS/E。西门子旗下的NB软件，比较贵，每年都要交钱，国外通常只认这个。</p>
<p>PSS/E能处理潮流计算、故障分析、网络等值、动态仿真和安全运行优化等问题。输入输出可根据用户要求进行设计，它要求使用者有一定的编程基础。</p>
<p>实际上，PSS/E只是西门子系统仿真软件的输变电包，配网包是PSS/SINCAL。SINCAL主要也是国外在用。</p>
<p>PSS/E这软件也是很难上手的，但是上手了，功能相当强大，还是比上两个软件严谨些。</p>
<p>特别在一些模型的考虑上，比如输电系统塔型都要自己设置，还有比如负荷模型也很灵活。</p>
<p>软件的潮流输出图形，非常漂亮，包含所有电气元件的接线图，网络结构和潮流参数，一目了然，而BPA和PSASP通常只是节点图，简洁，但是应的东西不是很全面，各有各的好处。</p>
<p>Digsilent。也是一个综合性的电力系统仿真软件。大家知道他，是因为它在仿真微电网、新能源发电、配电网可靠性方面的强大表现。</p>
<p>软件本身，对于新能源、配电网、电能质量等用户侧相关的元素和模型，确实考虑的比较多一些，所以这些领域的应用比较广。</p>
<p>当然，它本身还是一个侧重电网侧的仿真软件，如果需要对新能源里面，一些控制系统和策略进行建模仿真，可以联合MATLAB一起做，也比较常见。</p>
<p>ETAP。也是个比较综合性的软件，是一个美国软件。功能上个人感觉和Digsilent差距不大，最近国内也有一些推广。</p>
<p>这个软件在短路和保护计算上，还是有他的特点，特别是在一些工业企业的相对独立的配电系统中，感觉应用比较多。</p>
<p>3、电磁暂态仿真软件。</p>
<p>主要有两个，都是国外的：EMTP/ATP和PSCAD。</p>
<p>EMTP/ATP的功能非常强大，也比较权威，侧重的是系统的运行情况而不是个别开关的细节，很多论坛上也有破解版。</p>
<p>让大家比较熟知的，就是用于过电压分析。</p>
<p>这块软件还是比较难上手的，就过电压计算来说，因为既涉及过电压系统的理论知识，里面的模型设定和参数整定又需要经验积累，更需要一些工程实践经验。当初我们学这个软件，也异常艰难。</p>
<p>下图为算感应电压前需要搭的一个简单的输电系统。ATP理论多看看ATP-theory book中文版，实践就多看看用户手册。</p>
<p>PSCAD全称PSCAD/EMTDC，EMTDC是其仿真计算核心，PSCAD为EMTDC提供图形操作界面。</p>
<p>它和EMTP基本类似，原理相同，模型库相似。图形化界面，更容易上手，但是感觉在工程中用的极少，一般都是学校科研项目。</p>
<p>原因主要在于，EMTP擅长保护和过电压仿真，PSACD擅长交直流仿真，而实际工程里面前者比较多。</p>
<p>PSCAD的界面看的比较舒服，系统仿真软件里的一股清流。在仿真的同时，可以改变控制参数，从而直观地看到各种测量结果和参数曲线，模型库也比较全，也可以自定义。</p>
<p>学校里面如果有RTDS（实时数模仿真），配合起来用还是不错的。几年前和高校合作过一个科研项目，轻型直流输电方面的，效果还可以。</p>
<p>4、软件和自行分析计算的关系。</p>
<p>这两者应该是相对独立的，该软件去做的事情，就应该应用软件；该掌握原理，自行分析的，就应该自行去分析。</p>
<p>实际上，工程里面，需要用软件的场合，都是手算不了的地方。比如说潮流计算，3000个节点，你给我手算一个，显然不现实。</p>
<p>软件包含的底层原理，大致了解一下，基本就可以了。</p>
<p>电力系统相关的知识面太广，网架规划、短路分析、无功、稳定、过电压、电能质量等等，光一个稳定，要研究透估计就得花个几年时间。</p>
<p>所以很多时候，只需要掌握清楚核心原理，其他的交给工具书，交给软件，这样你的专业知识体系，才会更清晰，更有条理。</p>
<p>以上，感谢阅读。</p>
<p>PS1：某些图片和数据来源于网络，若有侵权，请联系删除</p>
<p>PS2：微信公众号：严同笔记。继续行业分享，欢迎关注。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>电力</tag>
      </tags>
  </entry>
  <entry>
    <title>碳计量碳监测全方位解读</title>
    <url>/2023/05/18/%E7%A2%B3%E8%AE%A1%E9%87%8F%E7%A2%B3%E7%9B%91%E6%B5%8B%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文对碳计量、碳监测进行了全方位梳理解读，包括概念范畴、政策标准、技术发展现状趋势等。</p>
<h1 id="一、概念范畴"><a href="#一、概念范畴" class="headerlink" title="一、概念范畴"></a>一、概念范畴</h1><p>碳计量也称编制温室气体排放或碳盘查，碳监测是一种碳计量技术。碳中和的目的是平衡温室气体排放和吸收，碳计量、碳监测是实现碳中和碳达峰的重要手段。碳排放量的核算主要有两大类方式，即碳计量和实测法。</p>
<p>碳计量又可以分为排放因子法和质量平衡法，二者的区别在于排放因子法适用于较为宏观层面的碳核算，质量平衡法更为灵活，可以根据每年用于国家生产生活的新化学物质和设备，计算为满足新设备能力或替换去除气体而消耗的新化学物质份额。</p>
<p>排放因子法目前仍是我国主要使用的碳核算方法。在制定碳核算方法时，我国主要参考联合国政府间气候变化专门委员会（IPCC）的相关指南。《IPCC指南》主要面向国家和区域层面的温室气体清单编制工作，其中所采用的排放因子以及活动数据属于国家以及区域层面的数据。</p>
<p>碳监测有物料核算法，即根据化石燃料消耗量等推测碳排放；以及现场检测法，通过CEMS对气态污染物和颗粒物进行浓度和排放总量的连续监测和实时传输。</p>
<p>展望未来，根据《建立健全碳达峰碳中和标准计量体系实施方案》的部署，碳达峰碳中和标准计量体系的建设主要分为三个阶段：2025年，碳达峰碳中和标准计量体系基本建立（重点排放单位碳排放测量能力基本具备，主要行业碳核算核查标准实现全覆盖）；2030年，碳达峰碳中和标准计量体系更加健全；2060年，引领国际的碳中和标准计量体系全面建成。</p>
<h1 id="二、政策梳理"><a href="#二、政策梳理" class="headerlink" title="二、政策梳理"></a>二、政策梳理</h1><h2 id="1、国家层面："><a href="#1、国家层面：" class="headerlink" title="1、国家层面："></a>1、国家层面：</h2><p>2023年2月6日，国务院印发《质量强国建设纲要》提出，建立健全碳达峰、碳中和标准计量体系，推动建立国际互认的碳计量基标准、碳监测及效果评估机制。（<a href="http://www.gov.cn/zhengce/2023-02/06/content_5740407.htm%EF%BC%89">http://www.gov.cn/zhengce/2023-02/06/content_5740407.htm）</a></p>
<p>2023年02月08日，国家市场监管总局国家工业和信息化部印发《关于促进企业计量能力提升的指导意见》指出，推动企业建立健全碳计量体系，研究建立重点排放单位碳计量审查制度，为企业碳排放“可测量、可报告、可核查”提供计量支撑，服务国家碳排放统计核算体系的建立和完善。（<a href="https://gkml.samr.gov.cn/nsjg/jls/202302/t20230208_353180.html%EF%BC%89">https://gkml.samr.gov.cn/nsjg/jls/202302/t20230208_353180.html）</a></p>
<p>2022年6月23日，国务院发布《关于加强数字政府建设的指导意见》明确指出，“要加快构建碳排放智能监测和动态核算体系，服务保障碳达峰、碳中和目标顺利实现。”（<a href="http://www.gov.cn/zhengce/content/2022-06/23/content_5697299.htm%EF%BC%89">http://www.gov.cn/zhengce/content/2022-06/23/content_5697299.htm）</a></p>
<p>2022年1月21日，生态环境部印发的《“十四五”生态环境监测规划》要求，支撑低碳发展，加快开展碳监测评估。推进碳监测评估试点。补齐碳监测技术短板。加快推动大气碳监测相关卫星 研制发射，统筹运用现有遥感监测资源，提高天空地海一体化 碳监测水平。</p>
<p>2021年9月23日，生态环境部发布《碳监测评估试点工作方案》，选取唐山、太原、上海等16个城市以及火电、钢铁、石油天然气开采等五个重点行业，开展温室气体试点监测、推进减污和降碳协同增效。</p>
<h2 id="2、地方层面"><a href="#2、地方层面" class="headerlink" title="2、地方层面"></a>2、地方层面</h2><p>12省份推出了各自的碳监测相关政策，其中，</p>
<p>安徽、河北、湖北、吉林、宁夏、山东、重庆发布了相应的《“十四五”生态环境监测规划》；</p>
<p>山西、黑龙江发布了相应的《关于组织开展“十四五”全省细颗粒物与臭氧协同控制监测工作的通知》；</p>
<p>江苏发布《江苏省生态环境监测条例》；</p>
<p>陕西发布《关于推进陕西省生态环境监测体系与监测能力现代化的实施意见》；</p>
<p>湖南发布《关于深化生态环境监测改革推进生态环境监测现代化的实施意见》。</p>
<h1 id="三、标准"><a href="#三、标准" class="headerlink" title="三、标准"></a>三、标准</h1><p>碳计量方面，现行标准主要针对植物树种生物量的碳计量。</p>
<p>碳监测方面，现行标准有以下几个：</p>
<ul>
<li><p>泰州市《DB3212T 1125—2023 碳排放在线监测系统建设规范》<br>碳排放监测领域国内首个市级地方标准，规定了碳排放在线监测系统的建设原则、组成结构、技术要求、性能指标、站房设置、安装及评估的要求。</p>
</li>
<li><p>《TCAEPI 48—2022固定污染源二氧化碳排放连续监测技术规范-中国环境保护产业协会》<br>规定了固定污染源二氧化碳排放连续监测系统的组成和功能、监测站房、安装、技术性能指标调试检测、技术验收、日常运行维护、质量保证和质量控制以及数据审核和处理等有关要求。</p>
</li>
<li><p>《T∕CECA-G 0146-2021 发电行业温室气体排放监测技术规范-中国节能协会》<br>规定了发电行业温室气体排放参数监测的技术方法和监测要求，包括温室气体排放监测的一般要求、基于核算和连续监测的监测方法及技术质量要求。</p>
</li>
<li><p>《TLCAA01—2020发电行业温室气体排放监测技术规范-北京低碳农业协会》<br>规定了发电行业温室气体排放参数监测的技术方法和监测要求，包括温室气体排放监测的一般要求、基于核算和连续监测的监测方法及技术质量要求。</p>
</li>
<li><p>《TLCAA 02—2020水泥行业温室气体排放监测技术规范-北京低碳农业协会》<br>规定了水泥行业温室气体排放参数监测的技术方法和监测要求，包括温室气体排放监测的一般要求、基于核算和连续监测的监测方法及技术质量要求。</p>
</li>
<li><p>《TLCAA 003—2020种植企业（组织）温室气体排放监测 技术规范-北京低碳农业协会》<br>规定了种植企业（组织）温室气体排放监测的监测范围、监测方法的要求、监测计划的制定、温室气体排放核算参数的监测方法以及数据质量控制。</p>
</li>
<li><p>《DL／T 2376—2021 火电厂烟气二氧化碳排放连续监测技术规范-国家能源局》<br>规定了火电厂烟气二氧化碳排放连续监测系统的组成和功能、技术性能、监测站房、安装、调试检测、技术验收、运行管理及数据审核和处理的有关要求。</p>
</li>
<li><p>《TCAS 454-2020 火力发电企业二氧化碳排放在线监测技术要求-中国标准化协会》<br>规定了火力发电企业烟气二氧化碳排放在线监测系统（简称CDEMS）中的主要监测项目、性能指标、安装要求、数据采集处理方式、数据记录格式以及质量保证。</p>
</li>
<li><p>《CCAEPI-RG-Y-066-2022二氧化碳排放连续监测系统》<br>规定了二氧化碳排放连续监测系统的适用范围、认证模式、认证环节、认证要求、认证标志使用及收费等内容。</p>
</li>
<li><p>《固定污染源碳排放（CO2、CO、CH4）在线自动监测技术要求-山西省环境保护产业协会》<br>规定了固定污染源烟气（CO2、CO、CH4）在线自动监测的组成结构、技术要求、性能指标和检测方法。</p>
</li>
<li><p>《T/SXAEPI 12—2022工业排放源 碳（CO2、CO、CH4）连续监测系统技术要求》–山西省环境保护产业协会》<br>规定了工业排放源 碳（CO2、CO、CH4）连续监测系统的组成结构、技术要求、性能指标、检测方法、质量保证和检测项目。</p>
</li>
<li><p>《T/CI 090—2022卫星对地观测下的森林碳指标监测体系-中国国际科技促进会》<br>规定了卫星对地观测下的碳指标分级体系、碳指标遥感监测产品体系和碳指标监测技术体系框架等。</p>
</li>
<li><p>《T/CI 001—2022《卫星对地观测下的碳指标监测体系》-中国国际科技促进会》<br>规定了卫星对地观测下的碳指标分级体系、碳指标遥感监测产品体系和碳指标监测技术体系框架等，适用于采用卫星对地观测技术进行双碳相关遥感信息产品的业务化反演生产和双碳监测技术系统的建设。</p>
</li>
</ul>
<h1 id="四、技术现状"><a href="#四、技术现状" class="headerlink" title="四、技术现状"></a>四、技术现状</h1><p>在进行碳监测时，我国主要采用物料核算法，即根据化石燃料消耗量等推测碳排放；而欧美发达国家采用现场检测法较多，通过CEMS对气态污染物和颗粒物进行浓度和排放总量的连续监测和实时传输。</p>
<p>进行物料核算的主要弊端在于测量误差大、排放系统变化时难以应对、易于造假。因此从大趋势来看，一方面我国将继续完善碳计量基准、计量标准能力；另一方面将加强关键计量技术研究，在碳排放量在线监测等方面攻坚克难，建立国际互认的碳监测及效果评估机制。</p>
<p>目前来看，我国的碳监测技术存在许多难点，比如排放源复杂；精确度要求非常高，可以说是所有环境监测项目中最高的一个；等等。</p>
<p>这些问题目前的解决方案是卫星遥感技术，2022年10月13日，我国环境监测“天眼”—生态环境卫星在太原卫星发射中心发射成功，可实现1~4ppm的二氧化碳探测和20ppb的甲烷探测，让碳排放无所遁形。</p>
<p>从近年来碳监测领域的招投标信息来看，多是基于卫星遥感和碳通量监测，碳通量监测多是采购相关设备，当前碳通量监测设备有无人机、土壤呼吸检测仪等。</p>
<p>最后特别提一下碳汇计量，碳汇计量监测是CDM的重要内容，2012年-2017年CCER允许受理，这个期间的林业碳汇计量监测体系建设有了一定规模，但随着经济技术发展，有些碳汇计量方式需要更新，比如可以使用雷达遥感等新技术代替传统人工测量方式，重建树高、胸径的测量方程式，降低调查监测的难度和成本等。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是碳监测？应用领域有哪些？</title>
    <url>/2023/05/17/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A2%B3%E7%9B%91%E6%B5%8B%EF%BC%9F%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>碳监测是指对人类活动和自然系统中的碳排放、吸收和储存进行监测和评估的过程。随着全球气候变化问题的日益严峻，碳监测成为了关注的焦点。本文将从定义、技术手段、应用领域等方面对碳监测进行详细介绍。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>碳监测是指对人类活动和自然系统中的碳排放、吸收和储存进行监测和评估的过程。目的是为了了解碳排放情况，制定合理的碳减排策略，促进低碳经济发展，减缓全球气候变化的影响。</p>
<h1 id="技术手段"><a href="#技术手段" class="headerlink" title="技术手段"></a>技术手段</h1><p>碳监测主要依靠以下技术手段：</p>
<h2 id="1-遥感技术"><a href="#1-遥感技术" class="headerlink" title="1.遥感技术"></a>1.遥感技术</h2><p>遥感技术是通过卫星等遥感数据获取平台对地球表面进行监测。通过遥感技术可以获取大范围、高精度的地表覆盖类型和植被生长信息，为碳监测提供了重要的数据基础。</p>
<h2 id="2-碳通量测量技术"><a href="#2-碳通量测量技术" class="headerlink" title="2.碳通量测量技术"></a>2.碳通量测量技术</h2><p>碳通量测量技术是指对生态系统中的碳排放、吸收和转化过程进行直接测量的技术。如对森林和草地中的碳通量进行测量，可以了解生态系统中的碳循环和碳储量情况，为制定碳减排策略提供依据。</p>
<h2 id="3-碳排放核算技术"><a href="#3-碳排放核算技术" class="headerlink" title="3.碳排放核算技术"></a>3.碳排放核算技术</h2><p>碳排放核算技术是指对人类活动中的碳排放量进行计算和评估的技术。如对能源消耗、工业生产、交通运输等领域的碳排放量进行核算，为制定碳减排政策提供依据。</p>
<h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h1><p>碳监测广泛应用于以下领域：</p>
<h2 id="1-碳交易市场"><a href="#1-碳交易市场" class="headerlink" title="1.碳交易市场"></a>1.碳交易市场</h2><p>碳交易市场是指通过买卖碳排放权来实现碳减排的市场。碳监测为碳交易市场提供了数据基础，同时也为制定碳交易政策提供了依据。</p>
<h2 id="2-碳减排政策"><a href="#2-碳减排政策" class="headerlink" title="2.碳减排政策"></a>2.碳减排政策</h2><p>碳监测为制定碳减排政策提供了依据和支持。通过对碳排放和吸收情况进行监测和评估，制定合理的碳减排政策，促进低碳经济的发展，达到减缓气候变化的目的。</p>
<h2 id="3-碳足迹评估"><a href="#3-碳足迹评估" class="headerlink" title="3.碳足迹评估"></a>3.碳足迹评估</h2><p>碳足迹是指某一产品或服务的生命周期内排放的温室气体总量，是评估产品或服务的环境影响的重要指标。碳监测为碳足迹评估提供了数据支持，有助于企业和个人评估和改善自己的碳排放情况，降低对气候变化的负面影响。</p>
<h2 id="4-气候科学研究"><a href="#4-气候科学研究" class="headerlink" title="4.气候科学研究"></a>4.气候科学研究</h2><p>碳监测对于气候科学研究也有着重要的意义。通过对大气中温室气体的监测和分析，可以了解气候变化的原因和规律，为气候预测和应对气候变化提供数据支持。</p>
<h2 id="5-能源管理"><a href="#5-能源管理" class="headerlink" title="5.能源管理"></a>5.能源管理</h2><p>碳监测也可以用于能源管理。通过对能源使用情况进行监测和分析，可以发现能源浪费的问题，并采取相应的节能措施，降低碳排放量。</p>
<p>总之，碳监测在各个领域都有着广泛的应用和重要意义。随着全球气候变化问题的日益突出，碳监测的重要性也日益凸显，未来碳监测行业有望进一步发展壮大。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>空天遥感精准碳索，点亮碳汇监测之眼</title>
    <url>/2023/05/16/%E7%A9%BA%E5%A4%A9%E9%81%A5%E6%84%9F%E7%B2%BE%E5%87%86%E7%A2%B3%E7%B4%A2%EF%BC%8C%E7%82%B9%E4%BA%AE%E7%A2%B3%E6%B1%87%E7%9B%91%E6%B5%8B%E4%B9%8B%E7%9C%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不久前，中国科学院空天信息创新研究院所属中国遥感卫星地面站，按计划成功跟踪、接收到陆地生态系统碳监测卫星“句芒号”观测数据，并第一时间发送至数据处理系统。</p>
<p>中国科学院空天信息创新研究院国家遥感应用工程技术研究中心（以下简称“工程中心”）将卫星遥感对地观测技术应用于碳监测和碳捕捉，是我国碳监测领域一项新的技术探索。这项技术具有什么样的优势，会对我国“双碳”目标的实现起到怎样的推动作用，未来还需要在哪些方面进一步寻求突破？带着这一系列问题，中国经济信息社分析师探访国家遥感应用工程技术研究中心，为大家揭秘天空中的“碳”索之眼。</p>
<h1 id="碳监测和碳捕捉的重要技术探索"><a href="#碳监测和碳捕捉的重要技术探索" class="headerlink" title="碳监测和碳捕捉的重要技术探索"></a>碳监测和碳捕捉的重要技术探索</h1><p>卫星遥感对地观测技术能够定量化监测跟踪、精细化核查评估碳排放与吸收的过程、影响范围和异常情况，是实现碳监测并逐步建立系统的碳收支监测、计量、报告、检验标准体系的重要技术手段。</p>
<p>传统方式碳源监测受观测网点数量的限制导致获得的数据量较少，且相关监测方法受监测设备、监测尺度、人员经验等多种因素制约，存在较大不确定性。而卫星遥感监测可以获得温室气体和陆地碳汇分布，具有稳定、长时间序列、广空间区域等优点，弥补现有地面监测和核查方法的不足，可大幅提高监测效率，降低监测成本，有助于提高对碳源汇和气候变化的认识。</p>
<h1 id="“绿色大脑”将实现精准监测与管理"><a href="#“绿色大脑”将实现精准监测与管理" class="headerlink" title="“绿色大脑”将实现精准监测与管理"></a>“绿色大脑”将实现精准监测与管理</h1><p>实现“双碳”目标和碳交易的第一步是如何对我国碳源汇进行全天候、立体化、长时间序列的精准、客观摸底，摒弃人为主观因素的不确定性和单点性。7月30日，空天地一体化碳源碳汇综合监测管理治理平台“绿色大脑”在京发布。国家遥感应用工程技术研究中心协同中国国际科技促进会碳中和工作委员会等30多家单位，利用数字化技术搭建了空天地一体化碳源汇监测管理平台，集成了卫星遥感监测系统、飞艇遥感监测系统、无人机监测系统和地面综合能碳应用管理平台及相关数字化智能化治理系统体系，同时将城市工业、能源、建筑、交通、农业及居民等碳排放主体全面接入地面综合能碳应用管理平台，城市管理者即可全方位实现对各类碳排放主体的实时监测和管理。</p>
<h1 id="团体标准提出森林碳汇估算技术方法"><a href="#团体标准提出森林碳汇估算技术方法" class="headerlink" title="团体标准提出森林碳汇估算技术方法"></a>团体标准提出森林碳汇估算技术方法</h1><p>国家遥感应用工程技术研究中心背靠中国科学院空天信息创新研究院，在池天河院士带领下，于2022年4月发布了卫星对地观测下的森林碳指标监测团体标准。这一标准隶属于工程中心发布的《卫星对地观测下的碳指标监测体系》系列团体标准。为了使标准更好地适应我国地形和气候现状，工程中心在全国范围内选择东（江苏）、西（新疆）、南（福建）、北（北京）、中（黄河流域）五个典型区域进行实地验证。目前南北区域已验证完毕，效果达到预期。该标准提出利用卫星+无人机雷达遥感监测手段，实现森林碳汇估算的技术方法，从而弥补现有方法学的不足。</p>
<h1 id="试点城市先行推进技术成果产业化落地"><a href="#试点城市先行推进技术成果产业化落地" class="headerlink" title="试点城市先行推进技术成果产业化落地"></a>试点城市先行推进技术成果产业化落地</h1><p>工程中心围绕碳源和碳汇监测已经实现了数字化平台的搭建、卫星对地观测下的碳指标监测等团体标准发布，并在京津冀、福建等地开展了示范应用。在碳源二氧化碳、甲烷等温室气体的监测上可以达到高精度监测水平。为了打通卫星遥感技术在碳交易上的技术壁垒，工程中心还与厦门产权交易中心、海峡股权交易中心、中国林业科学研究院、中国农业科学院等达成战略合作，推进技术成果的产业化落地。（刘之微、李昕）</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>碳监测</title>
    <url>/2023/05/15/%E7%A2%B3%E7%9B%91%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>碳监测是一种衡量各种活动中产生的碳排放情况的方法。这种活动包括人类的活动，如燃烧化石燃料，以及自然活动，如植物以及有机物的腐烂。碳监测通常通过分析大气碳水汽、土壤碳汇等各种物质的浓度来实施。</p>
<p>碳监测的目的是帮助我们了解全球碳排放的总量和来源等细节。先进的碳监测工具能够显示每个小区每个季节中碳排放量的变化，而大型的碳监测工具则可以帮助研究人员了解全球碳排放量的整体图景。</p>
<p>碳监测也有助于减少温室气体排放，并促进可持续发展原则的实施。碳监测可以帮助研究人员更好地理解碳排放的影响，并有助于为控制全球变暖和气候变化制定有效的应对措施。人类碳排放越多，碳保存方案就越有必要。</p>
<p>政府机构比较喜欢使用碳监测，因为它们可以更有效地对碳排放的来源、变化和影响进行监督和评估。例如，碳监测可以帮助政府机构评估能源公司的碳排放量，以及它们采取的节能措施是否有效。</p>
<p>碳监测的最终目标是使我们能够更好地知道地球上发生的活动如何影响它的未来环境。它也有助于政府政策制定者捕捉，识别和监控碳排放会产生的长期影响及其影响的程度，以及它们将如何处置减排策略。这些过程可能从政府碳减排目标到市场二氧化碳排放交易，从气候服务到微型碳累积信贷，都会影响着我们的未来。因此，碳监测在保护环境的现状和改变未来的关键时刻发挥着不可或缺的作用。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>城市碳监测如何从0到1</title>
    <url>/2023/05/14/%E5%9F%8E%E5%B8%82%E7%A2%B3%E7%9B%91%E6%B5%8B%E5%A6%82%E4%BD%95%E4%BB%8E0%E5%88%B01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一座城市的温室气体排放情况怎么测?在哪儿测?测什么?济南正在尝试给出答案。</p>
<p>2021年9月，生态环境部启动碳监测评估试点工作，济南是全国16个试点城市之一，也是山东唯一开展城市碳监测评估试点工作的城市。近日，伴随济南新旧动能转换起步区温室气体高精度监测站点的联网试运行，济南完成“天空地”一体化立体监测网络体系搭建。未来，在海量监测数据的基础上，济南将计算出城市的碳排放家底，画出城市的碳排放“画像”。</p>
<p>“双碳”目标下，企业、行业、城市相关的碳排放数据不断涌现。这些数据多经“推算”而来，即通过企业消耗的燃煤，推算出产生多少碳排放。“真正从监测端直接着手的碳监测评估工作，全国各地都处于起步阶段。在技术路线设计、实施方案制订等方面都是全新领域，没有可以参考借鉴的现成经验。”山东省济南生态环境监测中心(以下简称省济南监测中心)主任潘光说。</p>
<p>试点工作的一个难题是监测点位的选择。“如果把点位选在市中心，就可能面对热岛效应等带来的监测数据不准确，如果选在远郊，有可能会使得数据没有代表性。”省济南监测中心综合室主任王兆军说。最终，济南在综合城市布局、产业结构、排放源分布、地形地貌、主导风向等因素的基础上，在全市设置了历下太平庄、章丘绣惠沙埠、槐荫黄河河务局等9个温室气体高精度监测点位，20个二氧化碳中精度监测点位和35个甲烷中精度监测点位。“高精度、中精度监测点位互为补充，再与卫星遥感、地基遥感、无人机、移动走航车等多种方式相配合，济南被划分为若干片区、点位，二氧化碳、甲烷等温室气体的浓度被实时监测。”王兆军说。</p>
<p>布好点位后，如何监测?“在这些点位的高处，我们会安装温室气体采样头，减少低层气流的扰动。比如现在这个点位，我们在通信铁塔离地50米处安装了温室气体采样头，采集到的气体沿着管线传到铁塔下的设备间里，机器设备在这里对采集到的气体进行检测，得出实时数据。”在高精度温室气体自动监测网的黄河河务局点位，省济南监测中心预报室副主任付华轩向记者展示了碳监测数据的获取过程，“再将各个站点的监测数据汇总，哪个地方温室气体浓度高、哪个地方低，浓度变化有什么特点和规律等等，经过计算，整个城市的碳排放情况就有了答案。”</p>
<p>相对于常规污染物监测，碳监测对监测数据的准确度要求非常高。“符合要求的温室气体高精度监测设备精度能到0.05%，是二氧化硫等常规空气污染物监测设备精度(5%左右)的近百倍。这就意味着，碳监测对监测设备的性能提出了新要求。”付华轩说。</p>
<p>“济南作为试点城市之一，主要目标就是探索自上而下的碳排放量核算方法，初步形成技术指南，做好可推广、可应用、可示范的技术储备。”省济南监测中心副主任张战朝表示。当前，济南的温室气体监测网络已经在稳定运转，城市碳排放数据稳定输出。省济南监测中心正联合中科院大气物理研究所等科研机构对监测数据进行分析研究，探索建立碳监测反演模型。预计明年将形成相对可靠的济南碳排放数据清单，为城市的碳减排工作提供数据支撑。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>碳监测为什么是锁碳的关键一步</title>
    <url>/2023/05/13/%E7%A2%B3%E7%9B%91%E6%B5%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%A2%B3%E7%9A%84%E5%85%B3%E9%94%AE%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如今，大部分国家都在努力解决全球范围内二氧化碳浓度过高的问题，而从能源发展到材料创新，不同的发展方向也都将目标指向了“碳中和”“碳达峰”。不过当我们的目光都聚焦在那些新能源新技术的时候，回头看看或许还有许多其他只能我们关心的关键技术对碳治理起到了重要的帮助。</p>
<p>前面也提到了，碳治理的背景是二氧化碳浓度过高，因此对于碳治理这项工作来说，了解碳浓度状况以及明确二氧化碳的产生原因便有了重要的意义，这也就使得摸清“碳”家底成为了碳治理工作的关键一步。</p>
<p>那么如何摸清呢？这就涉及到了区域检测和宏观监测两个方面了。区域检测并不是什么难事，如今大大小小二氧化碳浓度测定仪非常多，之后只要建立相关的信息网络就可以得到不同地区的二氧化碳浓度情况。难点在于宏观监控，虽然可以通过区域数据得出宏观的二氧化碳分布情况，但是如果想要进一步获得更加全面的数据，那么就需要解决大面积监控的难题。</p>
<p>这个难题解决了吗？答案是正在解决，得益于航天事业的发展以及卫星遥感技术的成熟，伴随着大气环境监测卫星的顺利升空入轨，我国拥有了能够监测全球大气环境的“天眼”，也标志着大气卫星监测网络部署工作正在不断开展。</p>
<p>说道这里，或许有人会有疑问，为什么要执着于碳监测呢？既然要解决碳浓度过高，直接进入治理的环节不是更好吗？其中缘由其实并不复杂。二氧化碳的产生和人类活动有种密切的联系，而目前影响经济建设和社会发展的重点产业都和高碳排有所关联。像是我们生活离不开的电能以及经济建设离不开的工业占据了国内碳排比重的前两位，此外，与出行有密切联系的交通也占据了非常大的比重。</p>
<p>而这些产业现在短时间内完成低碳转型几乎是不可能的，因此只能一边控制，一边改变。而想要做到这一点就需要对不同地区的二氧化碳状况有一个详细的了解，以便于制定详细的治理方案，并且在方案是时候需要长期的监测来确保方案的实施情况，也就侧面体现了碳监测的重要性。</p>
<p>此外碳排放从现有的技术来说是不可能避免的，即便是“碳中和”目标也只是让碳排放与碳转化实现正负抵消，达到相对“零排放”。因此，要解决碳浓度过高，碳监测环节必不可少。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>碳路者-杨东旭：碳监测背后硬科技中国碳卫星为碳排称重</title>
    <url>/2023/05/12/%E7%A2%B3%E8%B7%AF%E8%80%85-%E6%9D%A8%E4%B8%9C%E6%97%AD%EF%BC%9A%E7%A2%B3%E7%9B%91%E6%B5%8B%E8%83%8C%E5%90%8E%E7%A1%AC%E7%A7%91%E6%8A%80%E4%B8%AD%E5%9B%BD%E7%A2%B3%E5%8D%AB%E6%98%9F%E4%B8%BA%E7%A2%B3%E6%8E%92%E7%A7%B0%E9%87%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年5月份，地球大气中的二氧化碳月平均浓度为419ppm，也就是0.0419%，这是人类有记录以来的二氧化碳浓度最高值。虽然二氧化碳在大气中的占比很少，但随着它们的浓度越来越高，已经造成了显著的全球变暖效应，二氧化碳浓度的日常监测至关重要。</p>
<p>2016年12月22日凌晨3时22分，随着一颗卫星发射升空，我国二氧化碳的监测视角，从地面升高至地球上空700公里。这是我国首颗全球二氧化碳监测科学实验卫星（简称“中国碳卫星”），也是全球第三颗碳卫星，它实现了我国空间温室气体高精度监测的从无到有，为应对全球气候变化贡献了“中国力量”。碳卫星是多部门百余名专家共同潜心科研多年的成果，而中科院大气物理研究所副研究员杨东旭便是这百余名专家中的一员。</p>
<h1 id="攻克碳卫星核心技术，自主研发反演系统"><a href="#攻克碳卫星核心技术，自主研发反演系统" class="headerlink" title="攻克碳卫星核心技术，自主研发反演系统"></a>攻克碳卫星核心技术，自主研发反演系统</h1><p>碳排放的计算主要依赖于清单方法，政府间气候变化专门委员会（IPCC）制定了《2006年IPCC国家温室气体清单指南》（下称《指南》），要求各国清单须按照《指南》的方法编制。即便如此，国际上很多声音提出，不同行政区域之间上报标准不一致导致的偏差问题、统计管理上相互不透明等问题无法避免，利用碳监测卫星，通过大气反演的方法，进行全球人为排放的监测方式更优成为共识。</p>
<p>发射碳卫星，各国都在努力。2009年，美国率先发射碳卫星，但因发射失败而坠入南极附近海域；同年，日本成功发射了国际上第一颗温室气体专用探测卫星GOSAT；美国OCO-2紧随其后，于2014年发射升空。据杨东旭介绍，“碳卫星虽然没有完全解决掉国别间偏差和不透明等问题，但是向着国际间碳监测的‘公平公正、查漏补缺’迈出了一大步。”</p>
<p>2007年，杨东旭在中科院读研究生时，开始接触碳卫星科研领域，从此参与研发碳卫星成了他毕生的事业。2009年，国家遥感中心组织专家组开始碳卫星项目的前期战略研究工作；2011年，在863计划的支持下，“全球二氧化碳监测科学实验卫星与应用示范”重大项目（中国碳卫星）正式由科技部立项，彼时临近博士毕业的杨东旭正式参与其中。</p>
<p>“几乎是摸着石头过河，困难在于这个项目在我国属于‘前无古人’——没有基础，没有借鉴，一切从零开始。”回忆起刚立项时的情景，杨东旭十分感慨，“为了争分夺秒研发碳卫星的算法，我当时几度办了延期毕业，也放弃了一些国外研究所和学校的机会，在攻克碳卫星面前，一切都得让路。”</p>
<p>碳卫星需要什么，杨东旭就研究什么。从科学问题倒推碳卫星需要什么样的核心指标，为实现做好碳卫星的目标，杨东旭自主研发了温室气体卫星反演系统——中国科学院大气物理研究所碳反演系统（IAPCAS），助力实现了国产卫星的高精度全球碳监测，在我国温室气体高精度遥感反演方面突破了“卡脖子”的技术瓶颈和欧美国家的技术封锁。据介绍，IAPCAS高精度模拟了太阳辐射在大气中的传输过程，充分优化气溶胶光学性质随波长的变化以及卷云的连续吸收等特征，显著降低了误差，提高了反演精度，大幅提高了计算效率。</p>
<h1 id="四年突破“不可能”，碳卫星及观测数据被世界认可"><a href="#四年突破“不可能”，碳卫星及观测数据被世界认可" class="headerlink" title="四年突破“不可能”，碳卫星及观测数据被世界认可"></a>四年突破“不可能”，碳卫星及观测数据被世界认可</h1><p>据杨东旭回忆，2012年在国际会议上谈到要研制自己的碳卫星，国际同行觉得不可思议，觉得我们没有任何基础，甚至公开说“不可能”。</p>
<p>然而，从“不可能”到“能”，中国只用了4年。这四年里的艰辛，只有像杨东旭这样的一线科研专家们才知道。从无到有，实现技术突破；又后发赶上，比肩国际领先水平。“我们现在碳卫星的整体水平已经赶超日本，比肩美国了。”杨东旭说。</p>
<p>二氧化碳在大气中的浓度本就非常低。数据质量特别是观测精度，是制约卫星数据有效应用的瓶颈，CO2的卫星监测精度需求高于0.5%，这在卫星大气成分遥感领域中是非常高的要求。</p>
<p>杨东旭介绍，最开始我们对观测精度定的目标很高，日本GOSAT初级数据产品的精度将近20ppm（单位意义：体积混合比百万分之一）,当时我们的目标底线是4ppm，也就是说最差也要达到日本数据误差的20%左右。</p>
<p>为什么定这么高呢？“我们认为，只有到达了这个精度以后，数据才能真正地发挥科学上的应用价值。”杨东旭解释，我们不仅要从“不可能”做到“可能”，还要从“可能”做到“更好”。</p>
<p>“现在我们的碳卫星观测精度优于了1.3ppm，跻身于全球先进地位。”杨东旭补充，中欧开展了针对中国碳卫星全球碳监测的相关合作研究，中国碳卫星加入欧洲空间局（ESA）第三方卫星计划，我国碳卫星及其观测数据逐渐被世界认可。</p>
<p>“2019年，我在另外一个国际大会上见到当年说‘不可能’的国际同行，对我们非常礼貌，说中国碳卫星已经做成全球品牌了。现在只要说到卫星碳监测，大家都会提到中国的碳卫星。”杨东旭骄傲地说，“如今在全球温室气体监测大会上，大会前几个的口头报告里总会有留给中国碳卫星的一席之地。”</p>
<h1 id="下一代碳卫星研制已经启动"><a href="#下一代碳卫星研制已经启动" class="headerlink" title="下一代碳卫星研制已经启动"></a>下一代碳卫星研制已经启动</h1><p>尽管1.3ppm的观测精度已经让中国碳卫星跻身于全球领先地位，但是杨东旭认为还可以更好。“我们正在设计下一代碳卫星。”杨东旭说，“靠一颗卫星解决不了所有问题。”</p>
<p>对于碳监测的未来，专家团队有更宏大的设想。杨东旭介绍，对于传统的碳排核算方法来说，碳卫星其实是一个补充的独立手段，从整体来看，更希望最终会建成一整套卫星体系，“我们正在设计的下一代卫星系统将做到更高精度，超越现有的1.3ppm达到1ppm以内，去做更深入的工作；除了精度以外，还要解决幅宽较窄的问题，未来下一代碳卫星的幅宽更宽，甚至做到全球覆盖；达到全球覆盖以后，一天覆盖一次可能也不够，会再考虑一天覆盖几次，以应对大气的快速变化；解决天上卫星的问题以后，我们地面的反演、同化等系统也要跟上，同时天地一体化的协同观测也非常重要，从而形成碳的监测体系，要将更高科技的技术应用到产品中去，用更新的方法去做更新的事情。”</p>
<p>据悉，我国下一代碳卫星（TanSat-2）的论证设计工作已经开始，卫星的研制工作也即将启动。新一代卫星将在第一代卫星所具有的技术优势基础上，进一步提升探测能力，并以应用需求与科学需求为出发点。目标测量将以人为排放、全球碳汇等为重点，以高定量、高时频、高分辨探测，来提高排放量和碳汇的计算精度。</p>
<p>正如杨东旭所介绍，下一代碳卫星将是一个天基系统，希望每天可多次覆盖一个城市或点源，同时将具备协同大气污染物的观测能力，更好地用于对人为碳排放量进行独立测算。</p>
<p>对于普通民众如何参与到碳减排工作中，杨东旭谈到：“双碳是个大概念，包括了我们未来生活、生产和发展形势与机遇；双碳工作和目标门槛高，因此可持续发展需要硬核的科技力量做强有力的支撑；把最前沿的科学变成大众的认知，把最先进的技术应用于发展建设，将有助于全社会真正走向低碳、可持续、高质量发展。”</p>
<p>新京报零碳研究院研究员 陶野</p>
<p>编辑 曲筱艺 李铮</p>
<p>校对 薛京宁</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>碳排放监测</tag>
      </tags>
  </entry>
  <entry>
    <title>能碳管理平台4</title>
    <url>/2023/05/11/%E8%83%BD%E7%A2%B3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ie-Cloud企业智慧能碳管理平台——让企业双碳管理更高效</p>
<p>作者:上海方融科技有限责任公司|发布时间: 2022-07-17|2095 次浏览</p>
<p>传统能耗企业没有完善的数据采集收集系统，自我研发成本贵且耗时；同时对耗能主体的数据进行实时高效的采集和处理，需要专业人才，人工成本相对较高。<br>2020年9月22日，习近平总书记在第七十五届联合国大会上宣布，中国将采取更加有力的政策和措施，二氧化碳排放力争于2030年前达到峰值，努力争取2060年前实现碳中和。</p>
<p>在此大背景下，实行能源消费强度和总量双控既是落实生态文明建设要求，促进节能降耗、推动高质量发展的一项重要制度性安排，也是党中央、国务院作出的重大决策部署，是推进实现碳达峰、碳中和的重要抓手。</p>
<p>但传统能耗企业没有完善的数据采集收集系统，自我研发成本贵且耗时；同时对耗能主体的数据进行实时高效的采集和处理，需要专业人才，人工成本相对较高。</p>
<p>于是， ie-Cloud企业智慧能碳管理平台因此也应运而生。</p>
<h1 id="1-平台概述"><a href="#1-平台概述" class="headerlink" title="1 平台概述"></a>1 平台概述</h1><p>ie-Cloud企业智慧能碳管理平台，是依托云计算、大数据、物联网、移动互联网、人工智能等前沿技术，面向能源服务行业研发并运营的大型分布式开放能源服务平台，平台围绕着冷、热、水、电、气及光储充多能源实时监测、分析、预警，为工业企业、商业建筑等不同行业的客户提供一站式智慧能源解决方案，帮助用户“看清楚、想明白、节更多”。</p>
<h1 id="2-应用领域"><a href="#2-应用领域" class="headerlink" title="2 应用领域"></a>2 应用领域</h1><p>钢铁、石化、冶金、有色金属、采矿、医药、水泥、煤炭、物流、铁路、航空工业、木材、化学原料以及机电设备、电器产品、工器具制造等。</p>
<h1 id="3-核心技术"><a href="#3-核心技术" class="headerlink" title="3 核心技术"></a>3 核心技术</h1><p>目前非化石能源种类繁多，含风能、太阳能、水能等可再生能源及核能。如何解决多样性的非化石能源的电力管理成为众多电力企业痛点。为解决这一难题，方融科技打造了智能微网双碳大脑技术，基于e-CIM构建的全景能源网信息模型，利用“云大物移智”相关先进技术，构建去中心化的分布式架构体系，已经形成的ie-Cloud智慧能源云服务平台，可以支撑多源、异构、多样、海量非化石能源的智慧管理。</p>
<p>1）“云-边-端”多级能源分布式碳汇体系基于云边协同大数据平台及边缘计算的弹性分布式多级数据汇集与计算支撑体系，多场景数模算力承载力，实现对各类场景应用的分权分级自主管理、全网协同，减轻云中心集中处理压力，确保微网能源就地自主运行和全网可靠、轻便、高效调度。</p>
<p>2）五维时空分布式双碳数据库利用e-CIM扩展对综合能源和碳排放数据描述，融合实时、历史、图形、拓扑和关系五维数据库技术，实现能源和碳数据的统一建模与多维度分析，从而打破孤岛，形成双碳大脑元数据支撑标准体系，实现毫秒级完成设备属性、空间信息、网络拓扑、实时数据、历史数据库等多个维度信息查询和搜索。</p>
<p>3）AI双碳数孪引擎基于能流计算的能效-碳足迹协同数字孪生，首创AI使能、自学习、自演进的“能-碳协同”管控核芯，研发AI双碳引擎，实时更新系统的碳足迹与能效的时空域分布特性，为多维感知、趋势预测、双碳路径、碳排优化等各类应用，提供数据、算法与AI能力。</p>
<h1 id="4-功能展示"><a href="#4-功能展示" class="headerlink" title="4 功能展示"></a>4 功能展示</h1><p>1）运行总览</p>
<p>根据企业不同需求定制专属于企业的驾驶舱；在能源看板中，呈现工厂全部能源消耗情况，以及配电、光伏、储能等各类能源设施的运行状况；根据产品类型、产线结构展示单产能耗</p>
<p>2）能源监控</p>
<p>水/废水/蒸汽/天然气监测</p>
<p>配电监控</p>
<p>空调监控</p>
<p>分布式新能源</p>
<p>3）能耗分析</p>
<p>综合能耗分析</p>
<p>桑基能量平衡图</p>
<p>产线能效分析</p>
<p>能耗排行</p>
<p>4）能耗预警</p>
<p>根据国家节能减排要求，分解能耗指标，落实到产线、设备；手动设置能耗基准值，根据实际用能分级报警。</p>
<p>5）运行报表</p>
<p>平台提供多种统计报表：定制化能效报表、峰谷电量报表、运行参数报表、运行月报等，满足客户的数据统计、图表呈现、及运行分析的管理需求。</p>
<p>6）需量管控</p>
<p>需量管控，用于专变用户的需量管理，平台提供了需量的全流程管控功能，包括：需量预测、需量申报、需量跟踪、需量预警、需量预案，避免需量超标罚款。</p>
<p>6）智能运维</p>
<p>资料管理</p>
<p>值班管理</p>
<p>巡检管理</p>
<p>试验管理</p>
<p>两票管理</p>
<p>7）基础支撑</p>
<p>数据管理</p>
<p>能源建模</p>
<p>权限体系</p>
<h1 id="5-服务案例"><a href="#5-服务案例" class="headerlink" title="5 服务案例"></a>5 服务案例</h1><p>1）项目背景<br>山西华翔集团股份有限公司，是一家拥有4000余名员工的大型装备制造高耗能企业，生产能源主要包括：电、水、天然气等。其中电力消耗高达4亿度电。存在高耗能设备多，能耗总量大，能效水平低，被能源局归入重点管控单位。供电设备分散，发生问题恢复供电时间长，停电损失大。</p>
<p>2）解决方案<br>通过建设一套工厂综合能源管理系统，并为其提供综合管控和智慧能效服务，实现：</p>
<p>Ø灵活的能源管理架构，覆盖了工厂-车间-产线-设备的4级能源架构，管理层级清晰；<br>Ø全面的能耗自动抄表，600个能耗计量数据自动上传，不仅节省人力，而且确保数据一致性；<br>Ø7×24小时的远程监控，结合供电监测，隐患报警，故障追溯，在安全方面，多次提前发现供电隐患，避免了生产停产，间接收益上百万元；<br>Ø产量能耗的归一化处理，基于能源架构的单产能耗分析，节能对标更科学，能效提升5%。</p>
<h1 id="6-结束语"><a href="#6-结束语" class="headerlink" title="6 结束语"></a>6 结束语</h1><p>方融科技团队在电网领域已有二十余年的积累，更是在全球范围内创造性地提出e-CIM全景能源模型体系。在此基础上，方融科技对能源应用的全场景进行解决方案的开发，目前积累了城市、园区、企业、能源集团、电站运维五大应用场景的七大解决方案，分别是ie-Cloud企业智慧能碳管理平台、ie-Cloud城市双碳管理平台、ie-Cloud城市智慧能源管控平台、ie-Cloud政府产业园区双碳管理平台、ie-Cloud企业园区零碳管理平台、ie-Cloud能源集团大数据管理平台、ie-Cloud配电智能运维管理平台。</p>
<p>方融科技始终致力于通过我们的标准化的产品和独一无二的技术支持，助力我们的合作伙伴和客户一起成为双碳微能源网时代的弄潮儿。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>能碳管理平台3</title>
    <url>/2023/05/10/%E8%83%BD%E7%A2%B3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2020年9月中国在联合国大会上宣布将在2060年前实现碳中和，从此，碳中和正式成为未来数十年各行各业共同努力实现的国家目标。</p>
<p>碳中和：通过新能源替代化石能源、植树造林+碳回收技术、节能减排的三种方式做到吸收的二氧化碳和排放的二氧化碳抵消，达到相对的“零排放”。</p>
<p>联合国环境规划署发布的《2020年排放差距报告》数据显示，2019年碳排放较大的四个部门是以发电为主要消耗的部门：能源、工业、交通、农业。</p>
<p>以上碳排放行业尤其是碳排放企业须以自己的实际行动彰显对中国社会可持续发展的责任和担当。而这一目标的达成，离不开数字化创新技术的成功应用。</p>
<ul>
<li>碳中和，智能化转型</li>
</ul>
<p>数字化转型，简单来说就是从端到端的价值链重新整合，通过打造一个信息实时共享的端到端体系，尽可能多的连接工厂的人、机、料、法、环。</p>
<p>这些要素一旦拥有了数字通信能力，那么大量的智能信息就是准备就绪的状态，随时可以被采集、上下文关联、聚合、分析、建立事件的因果联系，从而转化为人的洞察力，帮助企业制定正确的行动计划，使运营决策变得更有效率。</p>
<p>制造业深度脱碳，关键在于建立起制造企业自己的能源管理手段，通过数字化等技术建立智慧能源管理系统，实现降本增效、吸引投资、改善资产配置，提高企业ESG指数评级。（E：environmental 环境；S：social 社会；G：governance 公司治理）。</p>
<h1 id="格创东智碳中和解决方案"><a href="#格创东智碳中和解决方案" class="headerlink" title="格创东智碳中和解决方案"></a>格创东智碳中和解决方案</h1><p>制造企业常见的能源管理痛点包括数据不全面、工具不完善、场景碎片化、数据孤岛化等。</p>
<p>格创东智从用户侧视角，基于云大物移等技术，以东智智慧能源管理系统EMS为基础，通过三大业务途径助力企业构建能源管理系统，迎接碳中和时代的到来。</p>
<h2 id="01-能源管理咨询诊断"><a href="#01-能源管理咨询诊断" class="headerlink" title="01 能源管理咨询诊断"></a>01 能源管理咨询诊断</h2><p>通过专家团队，格创东智为企业提供顶层设计和视角，从长远角度为企业能源流向（从计量分析到应用环节，再到发现问题，找出损耗）制定相应的优化方案，为实现节能优化、持续改进的闭环提供整体性的诊断和把控。</p>
<h2 id="02-能源管理系统平台"><a href="#02-能源管理系统平台" class="headerlink" title="02 能源管理系统平台"></a>02 能源管理系统平台</h2><p>格创东智能源管理系统平台有九大功能模块，主要管理两个维度，一是能源类（水电冷热气五种常见能源），二是设备类（包括公共辅助设备如空压机等，以及工艺生产设备如真空泵等），基本涵盖了工厂所有用能终端。</p>
<p>以上两个维度的终端用能数据，通过边缘计算、通用化网关等硬件采集到东智IoT平台上；随后在东智数据平台上进行数据分析、数据治理、算法分析、设备诊断等服务；最终将分析结果呈现到面向终端的能源管理平台上，供企业管理人员实时监控，并针对各类能耗设备，提供不同场景下持续优化的管理方案。</p>
<p>此外，格创东智能源管理系统平台还具有很强的拓展性，不仅能进行能源管控，还能够拓展至光伏储能、楼宇自控、视频安防等领域，形成整体化管控平台。</p>
<h2 id="03-企业碳中和方案"><a href="#03-企业碳中和方案" class="headerlink" title="03 企业碳中和方案"></a>03 企业碳中和方案</h2><p>完成能源管理咨询诊断，搭建能源管理系统平台后，企业用能分析便有了大数据量、细颗粒度，以及全面的用能画像，此时碳追踪、碳剂量、碳管理，以及碳中和便有了强大的数据和技术支撑，不再是“无米之炊”。</p>
<h1 id="格创东智碳中和成果"><a href="#格创东智碳中和成果" class="headerlink" title="格创东智碳中和成果"></a>格创东智碳中和成果</h1><p>格创东智碳中和解决方案目前已在能源、制造行业中实践落地，并带来显著成效，例如：</p>
<h2 id="01-助力制造业数字化节能减排"><a href="#01-助力制造业数字化节能减排" class="headerlink" title="01 助力制造业数字化节能减排"></a>01 助力制造业数字化节能减排</h2><p>在碳排放部门第二的工业领域，尽管在碳排放总量上排在发电行业之后，但是从增加值上看，制造业发展和应用节能减排技术已经成为全国制造企业必须面对的问题。</p>
<p>中国制造业不要只是把碳中和看成是任务、投资。从制造业，从研发、供应链、生产、物流到销售、管理等每个环节，制造业各个环节都是碳排放“大户”，尤其是生产环节，占到了制造业企业90%以上的能源消耗。</p>
<p>实际上能源费用降低，可以节省不少支出，尤其是制造类的大企业集团，可以增强企业竞争力。</p>
<ul>
<li>半导体制造企业节能减排案例说明</li>
</ul>
<p>在某半导体制造企业里上线了能源消耗可视、能源消耗可知、能源使用可控的智能化能源管理系统；建立了能源体系行业标准，实现6个厂区厂务能耗数据的采集、存储、统计分析、节能诊断、优化控制和综合管理，在各系统稳定运行的前提下，减少能源消耗，提高能源利用率。2020年该企业实现能耗降低1%，降本增效收益达上千万元。</p>
<ul>
<li>电子制造企业节能减排案例说明</li>
</ul>
<p>某家电制造企业的三个生产厂区，年产值100亿+，2020年能源能耗费用达到4000万左右。接入格创东智智慧能源管理系统后，实现了海量数据实时采集，为大数据分析节能增效提供了支撑数据；通过对设备数据采集和监控分析，及时发现和反馈异常监控，降低异常发生频率和损失10%以上；预期每年降本收益达上百万元。</p>
<h2 id="02-助力光伏产业迈入数字化时代"><a href="#02-助力光伏产业迈入数字化时代" class="headerlink" title="02 助力光伏产业迈入数字化时代"></a>02 助力光伏产业迈入数字化时代</h2><p>能源行业是碳中和主战场，以清洁能源替代燃料能源的使用是大势所趋。</p>
<p>从能源使用上看，电能、热能、燃料是三种最重要的能源终端形式，电力是比较好的方式，而光伏正是清洁发电中的佼佼者。这为光伏产业带来了发展机遇，同时也提出了更高要求。</p>
<p>如何强化光伏供应链管理、化解产能与需求错配的矛盾，重视光伏产业链各生产环节的品质、提高全产业链的资源调整和优化能力，数字化解决方案都在其中发挥重要作用。</p>
<ul>
<li>光伏电站智能监控运维案例说明</li>
</ul>
<p>某光伏发电厂拥有相当规模的分布式光伏电站，如何做好电站的规范化管理，提高发电品质，提升资源调用能力，是发电厂迫切需要解决的痛点。格创东智为其搭建的智能化光伏电站监控运维平台，提供采集、监控、运维、统计、分析、结算等全方位服务，全面提升电站的规模化监控及生产运维能力，有效解决以上痛点，使光伏发电厂向智能化、数字化、可交易的能源资产转变。</p>
<p>做碳中和的数字化赋能者</p>
<h1 id="格创东智在行动"><a href="#格创东智在行动" class="headerlink" title="格创东智在行动"></a>格创东智在行动</h1><p>格创东智始终致力于发展有助于提升企业运营水平的数字化创新技术，以信息数字化能力的培植带动企业数据的增值，陆续转化为企业的资源调整配置能力。</p>
<p>在碳中和领域，利用数字化转型促进碳中和的目标和做法，和先进技术发展、产业发展的方向是一致的。格创东智将坚定不移地推动碳中和数字化解决方案，为中国制造业转型升级做好数字化赋能。</p>
]]></content>
  </entry>
  <entry>
    <title>能碳管理平台2</title>
    <url>/2023/05/09/%E8%83%BD%E7%A2%B3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>远景科技助力打造能碳“双控”发展新模式发布者：wwh | 来源：能见 | 0评论 | 783查看 | 2022-06-07 11:16:33    </p>
<p>尽早实现能耗“双控”向碳排放总量和强度“双控”转变，已经成为新的共识和政策要求。</p>
<p>但是如何实现能碳“双控”，对于政府和企业界而言，无论是碳监测还是碳管理、碳治理，都是一个重大难题。</p>
<p>为了破解这一难题，去年4月22日世界地球日，远景科技集团发布了一款针对于企业、园区、政府能碳管理的超级应用——远景方舟能碳管理系统，开创了国内人工智能物联网(AIoT)手段进行碳管理的先河，用人工智能+物联网+大数据技术相结合的方式，提供实时碳足迹监测，自动生成碳排放报告，同时模拟及优化减排路径，对接外部绿色权益交易市场，一站式实现碳中和闭环。</p>
<p>近日，由远景支持建设的全国首个省级开发区能碳双控管理平台在无锡江阴临港经济开发区上线运行，能碳“双控”的发展模式，有了可借鉴、可复制的样板，实现向政府和企业“授之以渔”的赋能转变。</p>
<p>在江阴临港打造零碳示范区样板</p>
<p>今年一季度经济运行情况显示，长三角地区以占比不到4%的国土面积，集中了全国约25%的经济总量和25%以上的工业增加值，创造出全国经济总量近1/4的规模。这样高度集中的发展特点，使得长三角地区碳排放占到全国碳排放的20%左右。</p>
<p>持续增加的能源消费总量、难以精准统计的碳排和能耗、无法形成碳减排、碳中和闭环等问题成为长三角地区转型的压力。</p>
<p>以无锡江阴临港经济开发区为例，其2020年规模以上工业总产值达到1328亿元，占江阴全市的25.4%，规模以上工业增加值达到282亿元，经济总量连续9年位于江苏省省级开发区第一。但是高能耗和高碳排放也因此成了临港开发区转型的痛点。如何破解这一难题?</p>
<p>从去年10月开始，远景与无锡江阴临港经济开发区政府携手共建“能碳双控”管理平台，具备能碳核算、能碳分析、目标管理、区域环境权益交易、碳普惠系统、碳资产管理等功能板块，以“平台+系统解决方案+零碳示范工程”模式，探索建设零碳开发区，建设无锡江阴市乃至江苏省的碳中和管理先行实践示范区，碳中和技术创新应用区，全面赋能本地绿色低碳产业和分布式能源体系。</p>
<p>目前，该平台已接入30多家规模以上重点能耗工业企业，未来几个月将逐步覆盖辖区内全部规模以上工业企业300余家。平台支持当地政府形成了开发区、下辖街镇和产业园以及辖区内规模以上工业企业三级能碳管理体系，应用AIoT智能物联、云计算、大数据等先进技术，建立碳排放管理与碳资产管理两大管理体系。</p>
<p>远景智能副总裁、远景碳管理业务总经理孙捷向「能见」介绍： “江阴临港能碳双控管理平台一方面可以实现能碳双控指标的实时监测、综合分析、目标管理与及时预警。另一方面通过开发区、远景与上海环境能源交易所三方形成战略合作，积极探索搭建区域性碳普惠减排量交易机制和系统，大幅度降低企业参与碳资产开发与交易的经济成本，政府也可以通过平台明晰企业降碳的绩效表现，避免‘一刀切’，用市场化手段激励，使更多企业加速零碳转型进程。”</p>
<p>“同时，远景方舟能碳管理系统还将应用于开发区内的企业侧，帮助企业对日常碳数据进行跟踪盘查、量化项目带来的经济价值及减碳效果。企业还可以通过方舟系统直接购买可追溯、可核查的绿色权益，以最优的成本去进行碳抵消，实现碳中和闭环。”孙捷强调。</p>
<p>对于政府来说，能耗管理是抓手，减排降碳是最终目标。</p>
<p>这一平台将成为开发区政府治理能碳问题、推进产业转型、提升城市竞争力的指挥运营中心，在远景零碳技术和专家赋能下，临港开发区已形成本地化的碳管理、碳治理的专业运营队伍，实现从“授之以鱼”到“授之以渔”的转变。</p>
<p>此外，在“平台+系统解决方案+零碳示范工程”的思路指导下，远景还将帮助临港经济开发区积极打造零碳产业园、零碳综保区、零碳港口、零碳学校、近零碳政府、零碳综合体和低碳工业转型7大应用场景的技术解决方案，构建风光储充一体化、节能降耗技术综合应用、绿证交易和碳交易创新试点，制定减排“路径图”，并通过能碳管理平台持续追踪节能减排绩效。</p>
<p>例如在开发区政府和远景的支持下，江阴港口集团已累计投入上亿元建设风光互补供电系统、光伏发电系统、内燃轮胎吊油改电、堆场作业设备油改气等多个节能减排项目，被评为江苏省五星级绿色港口，该集团将进一步借助远景的方舟能碳管理系统以及风光储充技术打造零碳港口。</p>
<p>算好经济、环境两笔账</p>
<p>江阴工业发展起步早，工业产值多依赖于重工业。数据显示，在临港经济开发区2020年288家规模工业企业中，涉及纳入全国碳市场八大重点控排行业中的七大行业(除航空外)，控排行业企业共72家。</p>
<p>钢铁、化工、石化、水泥、电厂等高耗能产业，给临港经济开发区带来巨大的经济效益，也面临着巨大的“能耗双控”压力，临港经济开发区正在低碳、零碳转型的路上积极探索。</p>
<p>城市做零碳转型需要大量资金投入，这笔投入能带来什么效益?临港经济开发区的经济账要如何算?</p>
<p>需要注意的是，一方面，2021年9月中旬起，浙江、江苏、广东、山东、辽宁、吉林、湖南等十多个省份陆续出现电力短缺、限电停产等情况。大规模拉闸限电为地方经济发展敲响警钟，各地政府“一刀切”看似遏制高耗能、高排放项目，实则直接影响着工业生产，影响着经济正常运行。</p>
<p>另一方面，企业还面临着国际上碳关税的威胁。据欧洲议会最新的法案文本来看，2026年1月1日起，欧盟将正式开征碳关税，首先覆盖的将是铝、水泥、化肥、钢铁、电力、有机化工、塑料和氢这8个行业。</p>
<p>也就是说，一旦欧盟碳关税确定实施，将会削弱我国相关产品在国际贸易中的竞争力，对涉及行业出口造成一定冲击，碳管理已是箭在弦上。</p>
<p>“在过去一年里，远景碳管理业务服务了大量的世界500强企业，如微软、苹果等科技企业，宜家、星巴克、耐克等零售业巨头，丰田、沃尔沃等汽车行业领军企业，这些企业都是最早开始觉醒意识到碳管理的意义和价值。近日，我们联合了联合利华、元気森林、立讯精密、钛和认证等权威企业和机构打造全球首个零碳工厂标准。”孙捷表示。</p>
<p>“方舟”能碳管理系统发布一年来，目前已经为全球超过300家客户提供端到端的数字化碳管理服务，协助减排和管理的二氧化碳总量超过10亿吨。</p>
<p>而在产业园区层面的零碳方案，远景从去年开始在鄂尔多斯打造“远景鄂尔多斯零碳产业园”已于今年4月正式投产，远景位于江阴的智慧能源产业园也将于2022年底实现碳中和。</p>
<p>因此，城市做零碳转型投入大量资金不仅将解决上述难题，从市场化的角度来讲，随着碳中和与碳普惠的推进，市场将赋予碳管理先进企业和地方更多的经济利益。</p>
<p>孙捷认为，“很多企业在节能降碳的过程中，可以省出来一些配额。但这些配额需要有相关的交易机制和交易中心去承载，从而激励企业更有动力去做碳管理。当碳普惠这样一个交易机制形成后，省出来的碳额度就可以交易给有需求的企业。这其实是通过正向的市场激励手段，推动区域性节能降碳。”</p>
<p>当前，在远景的技术支持下，开发区正与上海环境能源交易所积极探索建立分布式光伏和节能技改项目的碳普惠减排量核算方法学，并通过构建数字化赋能的碳普惠减排项目审定、签发和管理流程，实现碳普惠减排量的自动签发、管理和交易，大幅降低碳普惠项目申请和管理的边际成本。</p>
<p>以江阴临港经济开发区重点能耗企业西城钢铁为例，远景为西城钢铁定制数字化赋能的零碳技术解决方案，应用远景方舟能碳管理系统实现厂区能耗碳排的实时监测与分析，投资开发厂区屋顶光伏资源，帮助西城钢铁使用绿电并实现降本，同时西城钢铁正深度应用油车转电、油炉转电等技术措施，进一步节能降碳。随着碳普惠机制的成熟，西城钢铁将能够把节能降碳取得的成效转化为碳普惠减排量，获得更多碳收益。</p>
<p>从企业到园区，到地方政府，未来，“方舟”平台将继续以数字化手段助力中国“双碳”转型，实现经济效益和环境效益的双赢。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>能碳管理平台1</title>
    <url>/2023/05/08/%E8%83%BD%E7%A2%B3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自主研发Linking OS能碳管理平台 实现碳达峰碳中和<br>2022-09-06 09:58</p>
<p>8月31日，2022年中国国际服务贸易交易会（简称“服贸会”）在京正式拉开帷幕，为了能更加充分发挥“服贸会”作为国家级展会平台在绿色转型过程中的促进作用，本次服贸会新增设了环境服务专题展区，以“双碳赋能·焕发创新动力”为主题，共设置五大专区，重点展示生态环保、绿色节能新技术、新应用，助力实现“双碳”目标。</p>
<p>参加本次环境服务专题展的企业来自不同的领域，但都围绕着绿色节能、生态环保、“双碳”目标，都带来了自己不同的技术、产品及解决方案。谷腾环保网作为本次服贸会的特约媒体，对参展企业进行了跟踪报道。以下是我们采访京能远景领金智汇（北京）科技有限公司总经理祁一峰的主要内容。</p>
<p>LinKing OS能碳管理平台，自主研发，唯一一家AIOT管控平台</p>
<p>新能源、清洁能源已经成为能源发展的趋势，也是降碳的重要手段。一些城市的厂房、商业综合体已经安装了光伏板，但由于光伏的特殊性，只有白天可以发电，这就需要通过储能技术，把白天发的多余的电储存起来，在需要的时候再释放出来加以利用。</p>
<p>由于光伏能源的分布式和分散性，如何有效的统一管理和配送，这就需要一个基于数字化的微电网，把这些能源全部串联，然后再结合服务用能的业态，进行数字化的源网合处的微调，把它们有效的循环利用、高效衔接。同时再把既有的配电设施、用能设备进行数字化，用物联网的方式把它们进行串联，从而与能源达到万物互联。通过数字化、物联网使能源和设备物跟物、人跟物能互相感知、互联互通，最后形成了一个新的网—智能微网， LinkingOS能碳管理平台系统就起到了这个作用。</p>
<p>LinKing OS能碳管理平台，可在业态里实现零碳、低碳</p>
<p>LinKing OS能碳管理平台，支持海量设备的接入，支持高度的智能化，基于AI、数字孪生，在新的能源形势下，高效的把它们进行串联，按照数字学习、云边协同，高效的把能源数字化、把碳数字化，以达到在整个设施中、在整个业态里就可达到零碳、低碳的运行，从而形成了一个有效的聚合载体。</p>
<p>从发电侧来说，由于新能源的发电形式入网不稳定，这就需要结合当地的区域、天气，再结合电网的出力，要做出精准的预测和管理。它支持区域新能源的协同和管理，包括了能源设备的优化、功率预测等。</p>
<p>针对于终端用户，LinKing OS相当于是为商业综合体这种大型的建筑、商业综合体商务楼宇提供了一个基于能碳的Windows操作系统，在操作系统里把用能设施、用能设备、新的能源全部连接起来，然后基于操作系统进行更加智能、优化的来运营。</p>
<p>专业化能碳管家服务，累计和盘查碳排放和碳足迹，进行碳交易，达到碳中和</p>
<p>作为专业的能碳管家服务提供商，京能领金可以帮助客户：第一，提供数字化的、专业性的能源运营托管服务；第二，帮助用户累计和盘查企业的碳排放和碳足迹；第三：帮助用户进行交易绿电，因为LinKing OS系统里接入了大量的绿电；第四，帮用户进行碳交易，最终帮助用户达到碳中和；第五，还可以帮助用户提供一系列后端的全链条服务。</p>
<p>京能领金提供给客户的不仅仅是一个软件，更多的是提供了软件背后一个专业化的能碳服务。比如在城市端，现在超一线城市其实就是最大的能耗和碳排的主体，以北京为例，其实就是大型的商业综合体，针对超一线城市的这种大型商业综合体，如果把它的能源、碳排建成一个统一的体系，帮助它高效的运转，进行综合改善，达到碳达峰、碳中和的程度将会达到50%、60%，乃至70%。</p>
<p>大型城市及商业综合体的碳排放碳中和解决方案</p>
<p>基于新的后地产时代，讲究高效、运营的品质，尤其大型城市、超一线城市、大型商业综合体已经成了主要的碳排放载体。对于降碳，首先要通过电气化改造、新能源的应用，包括屋顶光伏、储能，有条件的可以增加分布式风电；第二，进行热源改造，比如利用有机相变蓄热，然后再通过LinKing OS平台进行一些绿电交易，通过绿电来供应场景内的电器设施，基本上就可以达到把最主要的碳排放进行中和。</p>
<p>对于以上三类碳排的其它方面，比如厨卫方面，可以把原来的燃气灶改换成使用电能的，排烟系统加上烟气处理装置，用电能替代之前的集中式供冷、供热等，都是达到碳中和以及低碳化的有效手段。</p>
<p>当然，以上的实现都是基于LinKing OS平台，通过对用户环境的考量来加权预算最后产生的，因为LinKing OS平台有一个基于碳中和的进程表，是根据用户的碳评计、当前的检查进度、后端是否能进行碳交易等，在碳交易达到中和之后会给用户颁发一个CCER碳中和证书，这样一系列的过程是京能领金提供给用户的全链条服务。</p>
<p>建设智慧能源管理平台协同用户侧综合能源项目</p>
<p>京能领金依托京能集团能源领域雄厚的投资建设能力和远景集团国内领先的数字化技术，建设具有自主知识产权的智慧能源管理平台协同用户侧综合能源项目，形成数字化转型解决方案、产品及交付能力，赋能城市侧高端商务楼宇(园区)、商业综合体、能源企业、医院，打造引领智慧城市数字能源技术创新发展的能源互联网企业。</p>
<p>京能远景领金智汇（北京）科技有限公司总经理 祁一峰先生</p>
<p>LinkingOS能碳管理平台是唯一一家集风、光、储、充、智慧配电、智慧冷热、碳交易、售电和虚拟电厂一体的AIOT管控平台。</p>
<p>对于未来公司业务发展目标，京能远景领金智汇（北京）科技有限公司总经理祁一峰表示：公司将通过建设具有自主知识产权的智慧能源管理平台协同楼宇侧综合能源项目以及智慧园区、智慧城市物联网设备，赋能城市侧高端商务楼宇、商业综合体，助力楼宇、园区、城市智慧大脑建设，将领金公司打造成拥有自主知识产权及可交付能力的能源科技企业。</p>
<p>文章来源于：谷腾环保网</p>
<p>声明：转载此文是出于传递更多信息之目的。若有来源标注错误或侵犯了您的合法权益，请作者持权属证明与本网联系，我们将及时更正、删除，谢谢。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据中心让电网能说会算：助力能耗双控提升能效管理</title>
    <url>/2023/05/07/%E6%8F%90%E5%8D%87%E8%83%BD%E6%95%88%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日前，浙江展邦电子科技有限公司工作人员主动联系瓯海供电分局，为供电公司主动向其提供智慧效能服务方案，为企业出谋划策的举措点赞。随着能耗“双控”工作的持续推进，电力部门接获的企业自发节能减排的诉求日益增多。其背后，由国网温州供电公司开发运营的温州能源大数据中心，为帮助企业落实能耗“双控”提供了坚实的数据支撑。</p>
<p>在温州市能源大数据中心，记者看到，实时更新的数字化大屏让全市各地企业、产业及产业链的用能状况及能效水平直观呈现。“透过这些数据，我们可以清楚知道哪个区域的用能超标，哪个产业的单位增加值能耗偏高，哪家企业的用能异常”，国网温州供电公司相关负责人介绍，目前，温州市能源大数据中心已接入全市7246家企业，其中规上企业6641家，实现了规上企业的全覆盖，是全省企业覆盖面最广的地市级能源大数据中心。</p>
<p>通过对能源大数据的分析，国网温州供电公司建立了企业用能自动诊断分析模型，可为企业提供最优用能解决方案。永嘉县纽顿流体科技有限公司便收到过这样的一份用能方案，在报告中，该企业的“电税比”、“产值能耗比”各项能耗数据及评估分析均一目了然。依据报告，该公司对加工中心等进行了改造升级，所更新的设备不仅低碳环保，还让生产效率提升了30%。</p>
<p>通过能效监测，展邦电子也找到了提升“单位能均产值”的突破口。“以往我们每月使用150万度电，生产5万多平方米线路板，如今同样的产值，每个月却能节省电量17.5万度，一年下来，企业能节省电费315万元。”展邦电子负责人黄海告诉记者。</p>
<p>实际上，能源数据发挥的作用远不仅限于此。利用电力大数据，能源大数据中心不仅可以精准分析企业的能耗情况，还可全面掌握全市企业开复工状况、行业景气指数、上下游产业分布情况等。如能源大数据中心推出单位增加值能耗分析，以指数形式展现行业产业以及区域的产能效率；研发产业链预警应用，通过产业上下游用能分析，以数字化赋能工业企业发展；开发“碳画像五色图”，对企业碳排状况进行线上分析，支撑政府对不同画像等级的企业精准施策。从宏观中观微观层级，立体式助力社会经济精准治理。</p>
<p>下一步，温州市能源大数据中心还将推进煤、油、气等能源领域大数据集成融合，对能源生产、传输、存储、消费和能源市场交易全环节全链条数据汇聚接入、安全存储和统筹管理，打造共建、创新、开放、协作、共享的温州能源大数据生态，充分释放能源数字经济潜力。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>工业园区综合能源服务的四种商业模式分析</title>
    <url>/2023/05/06/%E5%B7%A5%E4%B8%9A%E5%9B%AD%E5%8C%BA%E7%BB%BC%E5%90%88%E8%83%BD%E6%BA%90%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工业园区具有经济基础好、能源消耗大、产业集聚等特点，是构建灵活多样、低碳高效的综合能源服务体系的 “理想试验田”。</p>
<p>本文从促进清洁能源消纳、能源需求优化、能源效率提升以及市场效益挖掘4个方面探讨了适合园区开展的综合能源服务商业模式，并从推动市场公平竞争、开放共享发展的角度提出了相关政策建议, 为探索建立园区综合能源服务商业模式提供参考。</p>
<h1 id="1、工业园区能源消费分析"><a href="#1、工业园区能源消费分析" class="headerlink" title="1、工业园区能源消费分析"></a>1、工业园区能源消费分析</h1><p>工业园区按其主导产业类型可分为综合类、行业类和静脉产业类园区。综合类工业园区产业集群程度较高，行业类别较多，资源消耗种类也繁多复杂；行业类工业园区一般以某一类行业及其衍生行业为核心，资源消耗种类相对简单，静脉产业类园区主要从事再生资源回收、加工和利用，其用能类型也相对简单，以电等二次能源为主。</p>
<p>除生产用能以外，工业园区内的商业、居民建筑、园区交通等，也是园区用能的重要组成。</p>
<p>目前工业园区能源消费面临着诸多问题，如：<br>能源消耗总量大，温室气体排放量大；<br>园区内电、水、热等能源的耦合利用不足，各类企业资源回收、余能利用不足，能源综合利用率不高；<br>因本地资源禀赋、能源网络调度技术等因素的限制，导致清洁能源应用比重不高等。</p>
<p>随着中央提出“四个革命、一个合作”能源战略思想，能源生产和消费转型成为我国可持续发展的重要命题。工业园区能源系统的低碳、高效、多能、智能发展已成为必然的发展方向。</p>
<h1 id="2、工业园区综合能源系统架构"><a href="#2、工业园区综合能源系统架构" class="headerlink" title="2、工业园区综合能源系统架构"></a>2、工业园区综合能源系统架构</h1><p>园区综合能源系统架构包含物理层、信息层和服务层。<br>物理层是物质基础，实现能源生产、传输、供应等功能；<br>信息层是数据与控制中心，利用能源数据与信息通信技术，进行数据的交互与共享、智慧用能控制、数据价值挖掘等；<br>服务层是管理枢纽，基于综合能源系统物理架构及数据、信息技术的支撑,在清洁能源消纳、能源效率提升、能源智慧管理等方面提供综合能源的整体解决方案。<br>园区综合能源服务的商业模式是基于上述3个层次进行规划、设计与实施。</p>
<h2 id="2-1物理层"><a href="#2-1物理层" class="headerlink" title="2.1物理层"></a>2.1物理层</h2><p>以石油、电力、天然气等多种能源资源为供应侧，构建分布式和集中式能源协调互补的供应方式，促进电网、石油管网、天然气网、供热网等多种资源管网耦合集成，运用多种仓储设施及储备方法满足电力负荷、热负荷、冷负荷等消费侧能源需求，实现终端用户的用能优化。</p>
<h2 id="2-2信息层"><a href="#2-2信息层" class="headerlink" title="2.2信息层"></a>2.2信息层</h2><p>针对各能源子系统建立动态数据中心，实现用户侧的能源生产、传输、存储、共享等各环节的数据监测、分析、挖掘，提供能源智慧管理策略；基于能源数据与信息通信技术实现对能源枢纽站、源网荷储协调、虚拟电厂、负荷侧虚拟同步等的控制；构建微功率无线通信、电力线通信、泛在智能无线专网等通信网络；在数据、控制、通信耦合集成基础上开发云平台技术服务模块、综合能源服务互动平台。</p>
<h2 id="2-3服务层"><a href="#2-3服务层" class="headerlink" title="2.3服务层"></a>2.3服务层</h2><p>提供多元化的综合能源服务，实现清洁能源有效利用，提升能源利用整体效率，如：分布式能源、储能及电动汽车充电站的建设与运营；构建区域能源市场，形成公平、开放的准入机制，开展能源零售与能源交易；针对用户侧海量能源数据进行分类与挖掘，分析用户个性化需求，开展综合能源套餐定制等增值服务。</p>
<h1 id="3、工业园区综合能源服务商业模式研究"><a href="#3、工业园区综合能源服务商业模式研究" class="headerlink" title="3、工业园区综合能源服务商业模式研究"></a>3、工业园区综合能源服务商业模式研究</h1><p>在国家发布的“能源十三五规划”及“互联网智慧能源”发展指导意见的推动下，园区综合能源系统建设及综合能源服务业态发展得到了有力的推动，改变了传统能源系统互相独立的产供消方式，构建“电、热、冷、气”横向多能耦合、“源-网-荷-储”纵向多能协同、以及能源生产、传输、存储、消费都灵活高效的综合能源系统。</p>
<p>这也改变了传统能源系统“条块分割”的情况,有利于培育新的市场主体。</p>
<p>下面将从促进清洁能源消纳、能源需求优化、能源效率提升以及能源市场交易4个方面展开对综合能源服务商业模式的探讨。</p>
<h2 id="3-1促进清洁能源消纳"><a href="#3-1促进清洁能源消纳" class="headerlink" title="3.1促进清洁能源消纳"></a>3.1促进清洁能源消纳</h2><p>充分了解园区产业结构、用能需求特征和综合能源服务资源禀赋，建设分布式与集中式供应相结合的综合能源系统，开展针对传统能源利用方面的项目规划建设与投资运营。通过降低能源消费成本、提升能源利用效率获得收益，同时对优化能源需求、降低终端能耗、减少气体排放有积极影响。</p>
<h3 id="3-1-1分布式能源系统建设"><a href="#3-1-1分布式能源系统建设" class="headerlink" title="3.1.1分布式能源系统建设"></a>3.1.1分布式能源系统建设</h3><p>分布式能源具有灵活性高、排放低、就地利用等优势，是园区能源利用的主要方式。分布式能源系统建设的业务方向包括：<br>①基础设施服务，即能源基础设施的建设、运行和维护，微能网的规划、建设及运营，以及存量配电网向智能电网发展的改造等；<br>②区域性分布式发电厂的建设运营，如：园区大规模屋顶光伏和立面光伏系统的建设；<br>③虚拟电厂的建设，如：利用先进的通信及控制技术,整合不同类型分布式能源，有机结合储能侧和需求侧的可用负荷,实现对发售电侧的协调运行；<br>④发电与其他行业的耦合，如:参与制氢、制甲烷等能源转换过程。</p>
<h3 id="3-1-2能源社区运营"><a href="#3-1-2能源社区运营" class="headerlink" title="3.1.2能源社区运营"></a>3.1.2能源社区运营</h3><p>综合能源系统中，终端用户除了是能源消费者外，也可以通过建设分布式能源系统成为能源供应者，但光伏、风电系统的建设对一般用户来说存在技术壁垒、供应安全、能源管理、投资风险等诸多方面的困难，能源社区的运营模式则可以解决上述问题。</p>
<p>能源社区是由运营商、工业用户、商业用户及个人用户等组成的集合体，社区中的风、光、储等设备可以由用户自建或由社区运营商提供，用户在满足自身用能需求的基础上，可以选择存储多余的能源或供给社区网络。运营商拥有社区能源网络及相应公共设施资产，可为社区用户供能，或在需要时有偿供应给外部公共网络。</p>
<p>能源社区中所有的能源交换均通过数字化的智能系统准确记录和计算，运营商及用户均可通过能源供应等活动获得收益。<br>能源社区在国外已有一些实践案例，澳大利亚维多利亚州推出了家庭屋顶光伏与储能系统项目，在降低初始投入成本的基础上，提供每月固定价格的用电套餐，可为每个家庭节省上千澳元的电费支出。</p>
<p>项目运营商一方面通过用能系统的销售与运维获取收益，另一方面对这些系统进行统一管理,可在需要时为电网提供相应服务。</p>
<h2 id="3-2能源需求优化"><a href="#3-2能源需求优化" class="headerlink" title="3.2能源需求优化"></a>3.2能源需求优化</h2><p>通过政策约束、价格激励等方式引导客户参与到园区的负荷调控，推动分布式和集中式能源供应的共同发展，优化能源消费结构，增强系统运行的灵活性，提高能源利用率，实现园区内能源网络的经济、高效和稳定运行。</p>
<h3 id="3-2-1需求响应"><a href="#3-2-1需求响应" class="headerlink" title="3.2.1需求响应"></a>3.2.1需求响应</h3><p>需求响应主要是指通过政策或经济手段挖掘用户的响应潜力，促进各方互动以达到削峰填谷、缓解电力缺额等调控目标。<br>对于电网侧来说，网络运营商可与客户或负荷聚合商签订合作协议或形成标准化服务模式，在电网有平衡需求时发出信号，由用户侧调节柔性负荷来增减产量及能源的消耗量，从而调节电网稳定性,用户则可获得相应的补偿。</p>
<p>对于用户侧来说，需求响应可提高用户用电的经济性。</p>
<p>企业可根据可再生能源的资源情况调整生产计划，当可再生能源资源充足时，实时电价相对较低，在资源欠缺时则相反，企业可据此调节其生产计划，以降低用能成本，提高其生产经济效益。</p>
<h3 id="3-2-2供热、供冷项目的建设与运营"><a href="#3-2-2供热、供冷项目的建设与运营" class="headerlink" title="3.2.2供热、供冷项目的建设与运营"></a>3.2.2供热、供冷项目的建设与运营</h3><p>项目为客户提供供热、供冷项目的规划设计、建设、运营等服务，并提供专家服务以实现客户项目实施过程中的成本控制，在此过程中，客户能够专注于其专业领域内，而将能源相关的技术问题交给专业人员处理，为其实现降低用能成本、能源高效利用的目的。</p>
<p>服务内容包括但不限于：</p>
<p>①能源传输、基础设施分析、需求优化等方面的咨询和规划；<br>②供热、供冷设备设施的建设及后续运营、维护和故障处理；<br>③冷、热管网的建设与运维管理；<br>④能源审计服务等。其主要的服务模式包括2种：合同能源管理与集中式供能。</p>
<p>合同能源管理的重点是高效用能，承包商需利用最先进的技术为客户提供高效用能服务；集中式供能的重点则是高效的能源分配和利用，以最大限度地减少能源消耗、降低成本，服务对象越多则分摊成本越低，提高整体运营效率。</p>
<h2 id="3-3能源效率提升"><a href="#3-3能源效率提升" class="headerlink" title="3.3能源效率提升"></a>3.3能源效率提升</h2><p>针对园区内高能耗、粗放型的能源消费方式，有必要促进其能源精细管理和循环利用，提高资源配置效率，形成节约高效的能源消费体系。</p>
<h3 id="3-3-1能源管理服务"><a href="#3-3-1能源管理服务" class="headerlink" title="3.3.1能源管理服务"></a>3.3.1能源管理服务</h3><p>能源管理服务主要是指在企业的能源采购、资源管理、生产计划、设备维护等生产全周期内，提供能耗监测、能源消费分析、能源效率咨询以及能源管理系统等服务，发现企业级、部门级以及特定环节中的能耗问题,发掘企业节能降耗的潜力，从而实现提高能源效率、降低用能成本的目的。</p>
<p>通常的实施步骤为：<br>①对能源供应、负荷曲线、能量平衡、投资收益等进行协同分析；<br>②针对具体的问题提出管理措施，制定解决方案；<br>③制定关键绩效指标，管控能源管理方案的实施过程；<br>④分析能源系统整体运行情况,优化能源采购、系统运营等管理方式，不断降低用户整体成本。</p>
<h3 id="3-3-2充电设施的建设与运营"><a href="#3-3-2充电设施的建设与运营" class="headerlink" title="3.3.2充电设施的建设与运营"></a>3.3.2充电设施的建设与运营</h3><p>在政府的大力推动以及各项优惠政策的扶持下，我国已逐渐发展成为全球最大的新能源汽车消费国。与我国新能源汽车的发展严重不匹配的是充电基础设施的建设严重滞后，而针对充电设施的建设与运营模式的探索也将成为推动新能源汽车发展的动力之一。</p>
<p>充电站的建设服务包括：初期的规划设计、土木工程和电网接入、硬件设施的安装与调试、电量电费的计量核算等。</p>
<p>除了常规的建设运营服务之外，通过应用软件提供附加服务也将成为一个重要的价值创造方向。针对充电站的运营商开发能源管理智能平台软件，提供运行监测、数据管理、需求分析与预测等服务；针对车主提供用户版的智能充电管理软件，提供附近站点忙闲信息、车辆充电数据、充电需求预判与站点推荐等服务。</p>
<p>在充电站建设与运营服务中，提供软硬件结合的综合服务，以硬件设施的规划建设质量为基本，以软件服务的智能性与灵活性为增值。</p>
<h2 id="3-4能源市场交易"><a href="#3-4能源市场交易" class="headerlink" title="3.4能源市场交易"></a>3.4能源市场交易</h2><p>在当前能源市场蓬勃发展的形势下，能源的生产、传输、转化、存储、消费等各个环节逐渐被打通，能源市场将变得更加公平、开放、透明，能源的商品属性越发清晰，市场将催生新的商业模式，并挖掘出新的效益增长点。</p>
<h3 id="3-4-1能源零售交易"><a href="#3-4-1能源零售交易" class="headerlink" title="3.4.1能源零售交易"></a>3.4.1能源零售交易</h3><p>在园区内，能源零售商可以根据不同用户的用能特性和利益诉求，考虑其用能质量要求、用能时间段、用能需求量等，制定涵盖不同价格机制的个性化综合能源零售套餐。</p>
<p>在用能侧，运营商为用户提供灵活、经济的用能套餐，根据实际需求调整能源配比、用能时间、价格机制等，满足用户多样化的需求；同时通过对不同用户的能源需求进行合理分配及预测，实现整体用能效率的优化。</p>
<p>在产能侧，运营商可以与不同的能源供应商或上下游相关企业进行业务合作,通过联合采购保障能源成本，通过提高能源利用率降低运营成本,通过联合管理降低人力成本，提高管理效率。</p>
<p>小型的能源运营商可以通过这种业务合作产生的协同效应保障其能源零售服务的品质，利用其服务的灵活性和定制化,吸引对用能服务有更多需求的客户，从而与传统能源企业共同竞争。</p>
<h3 id="3-4-2能源批发交易"><a href="#3-4-2能源批发交易" class="headerlink" title="3.4.2能源批发交易"></a>3.4.2能源批发交易</h3><p>园区的综合能源服务商可以为区域内的分布式能源和终端用户提供能源批发市场的代理服务：</p>
<p>①为各类服务对象建立标准化市场交易流程，提供能源产品评价、交易政策制定与市场分析等服务；<br>②针对能源交易需求较小的“小微用户”，通过项目组合管理的方式集成多个用户的用能负荷，使原本不满足市场交易条件的用户也能享受优惠的市场价格；<br>③对于自身能源需求较大的用户，基于市场风险管控手段提供价格稳定、用能可靠的交易服务。<br>此外，未来能源交易平台将朝着独立、开放、多元的新型交易平台发展，这也将催生以信息技术、数据服务以及安全服务为主的能源信息服务市场,使能源交易的开展更加轻松便捷。</p>
<h1 id="4、政策建议"><a href="#4、政策建议" class="headerlink" title="4、政策建议"></a>4、政策建议</h1><p>园区的综合能源服务商业模式的构建在于针对园区及行业用户的实际情况和发展阶段特征，研究推出高效率、低成本、具有清晰盈利模式和丰富社会价值的综合能源服务解决方案。</p>
<p>一个成熟的商业模式需要在市场环境中接受检验并进行实践,这既需要各类市场相关方不断创新创造，也需要政府部门通过政策进行引导与约束，保障用户及各市场主体的基本权益，培育新的利益相关方，促进综合能源市场开放竞争、健康良好地发展。</p>
<p>（1）消除行政壁垒，能源配置由行政化转向市场化。<br>推进能源资源领域的供给侧结构性改革，加快油气、热力、电力等领域体制改革，破除行业壁垒，强化市场竞争；促进能源流、信息流的自由流动，完善制度体系保障各种能源实现横向多能互补、纵向梯级利用。</p>
<p>（2）按照市场化改革方向，推行有利于提高系统效率的价格机制。<br>实施峰谷价格、季节价格两部制价格等科学价格制度，推广落实气、电价格联动等价格机制，引导电力、天然气用户主动参与需求侧管理。</p>
<p>（3）鼓励创立专业化信息和技术服务提供商，提供跨行业、跨领域的科技、政策、管理等专业信息，扩充市场参与者信息获取渠道，提高市场信息公开透明度，消减信息不对称，降低交易成本，推广技术升级，提高智慧能源体系效率，降低生产成本。</p>
<p>（4）发挥市场在资源配置中的决定性作用，推动建立公平竞争、开放有序的能源市场交易体系。建立健全能源市场的准入制度，鼓励第三方资本、小微型企业等新兴市场主体参与市场，促进各类所有制企业的平等、协同发展。加快电力、油气行业市场体系建设，建立市场化交易机制和价格形成机制，有效引导供需。允许市场主体自主协商或通过交易平台集中竞价等多种方式开展能源商品及灵活性资源等能源衍生品的服务交易，最大限度地激发市场活力。</p>
<p>（5）鼓励互联网企业和能源企业合作，实现能源大数据的集成、共享和交易，促进应用创新，加强安全监管。</p>
<p>工业园区在发展综合能源服务方面具有天然的优势,随着我国能源变革进程的不断推进，可以想见，未来园区的综合能源服务市场将成为各类市场参与主体开展竞争的重要领域。</p>
<p>来源：《电力需求侧管理》南度度<br>作者：朱君、孙强、冯蒙霜、苏慧玲、朱婵霞、孙志凰、蔡晖、韩超</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>园区级智慧能源如何提供智慧服务</title>
    <url>/2023/05/05/%E5%9B%AD%E5%8C%BA%E7%BA%A7%E6%99%BA%E6%85%A7%E8%83%BD%E6%BA%90%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%99%BA%E6%85%A7%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发布者：xylona | 来源：中国能源新闻网 | 0评论 | 418查看 | 2023-05-31 16:48:20  </p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>智慧能源是以电力系统为核心，充分利用互联网思维和物联网技术，通过信息系统与能源系统深度耦合，覆盖能源生产、加工转化、传输配送、存储、终端消费、回收利用各环节的系统管理和优化运行，以促进能源安全、高效、低碳发展的全新能源生产和利用方式。</p>
<p>园区级智慧能源产业是智慧能源落地的典型场景。园区负荷相对集中且多元，具有多能互补的天然优势。以园区为落地载体，积极推广清洁能源、电动汽车、绿色建筑、需求响应，是实践智慧能源系统落地实践的有效途径，为智慧能源系统的规模化建设和健康发展积累实践经验。</p>
<p>目前园区级智慧能源服务有两层含义：一是智慧能源，涵盖多种能源，包括电力、燃气和冷热等；二是智慧服务，包括工程服务、投资服务和运营服务。智慧能源服务本质上是由新技术革命、绿色发展、新能源崛起引发的能源产业结构重塑，从而推动的新兴业态、商业模式、服务方式不断创新。</p>
<h1 id="园区级智慧能源发展问题分析"><a href="#园区级智慧能源发展问题分析" class="headerlink" title="园区级智慧能源发展问题分析"></a>园区级智慧能源发展问题分析</h1><h2 id="市场盈利模式仍待探索。"><a href="#市场盈利模式仍待探索。" class="headerlink" title="市场盈利模式仍待探索。"></a>市场盈利模式仍待探索。</h2><p>一是用户数据分析能力薄弱。能源行业强调以生产为导向，缺乏对用户信息和数据的解析能力，对用户行为捕捉和需求感知力度较弱，导致综合能源服务同质化程度高、交易成功率低、用户参与意愿不足、服务推广和项目落地困难等问题。与传统能源相比，综合智慧能源所涉及的用户数据更为复杂多样，分析难度更大。二是新能源送出的系统经济性难以保障。发电企业更注重电量上网的利益，造成新能源发电机组仍不能承担其应有的责任。经过10多年的技术进步，新能源发电机组发电效率大幅提升，但涉网性能并没有得到同步提升，电压支撑能力、功率控制水平远不能与常规机组相比。在系统成本增加方面，随着高比例新能源接入，消纳一个单位的新能源电力边际成本呈几何级数增加，调节电源的经济性难以保障；在电网侧成本增加方面，大规模新能源接网和输电工程利用率偏低，即使纳入输配电价仍难以取得合理回报。</p>
<h2 id="核心技术尚需创新和突破。"><a href="#核心技术尚需创新和突破。" class="headerlink" title="核心技术尚需创新和突破。"></a>核心技术尚需创新和突破。</h2><p>一是储能关键技术有待突破。目前储能系统集成设计，EMS、BMS、日常管理技术等尚不成熟，相关技术标准缺失，并网验收标准不够完善。其中，使用范围最为广泛的电化学储能，在安全性、使用寿命、回收再生、关键设备的国产化、降低成本等方面还有较大提升空间。二是数据壁垒有待解决。智慧能源行业通信协议标准依然缺乏，终端能源设备的接口、协议不统一，单一能源系统数字化水平高、能源数据孤岛林立、不同品种能源数据壁垒难以破除，缺少将行业内部和跨行业的横向和纵向数据整合而成的智慧能源一体化大平台。新技术自主化及深度融合欠缺。大数据、云计算、人工智能、区块链等技术在能源系统的应用仍处于起步阶段，关键设备与技术的自主可控使用、相关技术标准制定、安全防护措施、其与能源系统的深度融合应用等问题亟待解决。</p>
<h2 id="顶层设计和统筹规划能力不足。"><a href="#顶层设计和统筹规划能力不足。" class="headerlink" title="顶层设计和统筹规划能力不足。"></a>顶层设计和统筹规划能力不足。</h2><p>一是综合智慧能源市场广阔，但用户需求定制化、个性化特征明显，传统的产品化、流程化、大规模批量复制模式难以开展。针对新兴产业和市场细分，综合智慧能源服务商缺少商业模式的顶层设计和创新机制。在园区智慧化升级和智能化探索过程中，企业缺乏系统性规划，各智能化系统相对独立，各自完成自己的业务功能，虽有硬件层面的协同联动，但各智能化系统仍是信息孤岛，形成“伪智慧园”。二是园区级智慧能源项目在建设过程中涉及部门较多，电网公司在筛选合作商、增选服务等过程中，合作商很难完全配合，再加上目前南网在线客户数不多，电网话语权不高，供应商不愿意合作，统筹协调存在一定的难度。目前各类能源品种在规划、建设、运行和管理层面都相互独立，能源网、信息网的协同和统一调度存在障碍，缺少能够协调管理的综合部门。为统筹园区各参与主体的需求，统筹资金投入、技术能力等因素，同时横向整合电网公司发电、储能、充电桩等业务服务，需要通过制定科学合理的顶层规划方案，有步骤有计划地整体推动园区项目实施落地。</p>
<h1 id="园区级智慧能源商业模式选择"><a href="#园区级智慧能源商业模式选择" class="headerlink" title="园区级智慧能源商业模式选择"></a>园区级智慧能源商业模式选择</h1><p>电网公司可以将园区智慧能源服务看作是一种能源托管模式。在售电侧和配电网同时放开的情况下，同时拥有配售电业务，并且能为园区内电力用户提供增值能源服务。以用电数据为基础，为用户提供能效监控、运维托管、抢修检修和节能改造等综合用电服务可有效提高用户的用电质量，并增强客户黏性，同时从盈利能力更强的服务类业务中获得更多利润。<br>可以说，“配售一体化+能源综合服务”的模式为电网公司进入园区综合能源服务的优选盈利模式。同时，电网公司可以衍生出如下关键业务：</p>
<h2 id="一是咨询服务业务。"><a href="#一是咨询服务业务。" class="headerlink" title="一是咨询服务业务。"></a>一是咨询服务业务。</h2><p>园区智慧能源建设以产业发展为规划核心，以先进的IT信息技术和知识综合应用为规划手段，采用自上而下的顶层规划、业务专项规划、底层应用规划相结合的高效率、多专业、多元化、大集成的规划模式，贯穿园区项目始终的咨询服务是园区智慧能源业务的重要组成部分。</p>
<h2 id="二是基础设施智能化配套业务。"><a href="#二是基础设施智能化配套业务。" class="headerlink" title="二是基础设施智能化配套业务。"></a>二是基础设施智能化配套业务。</h2><p>在园区建设初级阶段，电网公司可以配合园区一级开发企业，做好水、电、气、热、路、通信等公共基础设施中智能化相关部分的布局、规划和施工，有效避免初期遗漏而导致后期建设中的无效劳动和重复工作，这部分工作需要与基础设施设计单位和施工单位紧密合作，共同完成，为园区二级开发的相关业务做好准备。</p>
<h2 id="三是标准化园区管理服务平台业务。"><a href="#三是标准化园区管理服务平台业务。" class="headerlink" title="三是标准化园区管理服务平台业务。"></a>三是标准化园区管理服务平台业务。</h2><p>在园区建设中级阶段，电网公司可以配合园区级开发企业，提供诸如智慧安保、智慧停车、智慧环保等功能模块化、标准化的园区管理服务平台。这些标准模块服务平台具有通用性、普适性的特点，为大多数智慧园区所必备。电网公司既可以提供一揽子服务，为园区提供标准化的整体解决方案，也可以由园区业主从诸多标准模块中选择所需内容，为其提供标准化的平台产品。</p>
<h2 id="四是定制化园区管理服务平台业务。"><a href="#四是定制化园区管理服务平台业务。" class="headerlink" title="四是定制化园区管理服务平台业务。"></a>四是定制化园区管理服务平台业务。</h2><p>在园区二级开发完成后，园区进入大规模招商引资阶段。在此阶段，电网公司可以结合园区的产业特点和现实需求，为园区运营管理者以及入驻园区的企业提供智慧金融、智慧物流、智慧政务等定制化的业务服务，满足智慧园区管理平台所服务对象的私人化、个性化需求。</p>
<h2 id="五是园区智慧能源平台业务。"><a href="#五是园区智慧能源平台业务。" class="headerlink" title="五是园区智慧能源平台业务。"></a>五是园区智慧能源平台业务。</h2><p>在自营标准化、定制化的智慧园区管理服务平台之外，还可以为诸如外卖订餐、票务服务等外部智慧园区解决方案提供商预留平台接口，提供一个开放式的管理平台。将各种各样有益园区智慧发展的功能产品，吸纳、融入到大的智慧平台中来，集众家智慧，丰富平台的应用产品功能，推动园区智慧化不断向前发展。（文章来源：中国能源新闻网 作者：南方电网能源发展研究院有限责任公司 蔡文静 令文君 李三 邹儒懿）</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>geographiclib极简入门</title>
    <url>/2023/05/04/GeographicLib%20%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-文档"><a href="#1-文档" class="headerlink" title="1. 文档"></a>1. 文档</h1><p>GeographicLib - 官方文档<br>GeographicLib::LocalCartesian - 官方文档</p>
<h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>克隆源码并编译安装 GeographicLib 。 (码云镜像更快，已有较多人转储，不用自己导入，如需自己导入，参考gitee文档)。</p>
<pre><code>git clone https://gitee.com/masonqin/geographiclib.git
cd geographiclib
mkdir build &amp;&amp; cd build
cmake .. #无报错
make #无报错
sudo make install #无报错
</code></pre>
<h1 id="3-项目集成"><a href="#3-项目集成" class="headerlink" title="3. 项目集成"></a>3. 项目集成</h1><ul>
<li><p>编写 CMakeLists.txt，非常简单的老三句。</p>
<p>  find_package (GeographicLib REQUIRED)<br>  include_directories(${GeographicLib_INCLUDE_DIRS})<br>  target_link_libraries(&lt;可执行程序&gt; ${GeographicLib_LIBRARIES})</p>
</li>
<li><p>代码集成，最常用的功能，使用局部坐标系转换，从 经纬高 到 ENU 。</p>
<p>  #include &lt;GeographicLib/LocalCartesian.hpp&gt; //包含头文件<br>  //经纬度原点初始化<br>  GeographicLib::LocalCartesian geo_converter;<br>  geo_converter.Reset(latitude, longitude, altitude);<br>  //经纬度转ENU<br>  geo_converter.Forward(latitude, longitude, altitude, local_E, local_N, local_U);</p>
</li>
</ul>
<p>初始化原点用了 Reset 函数，Forward 用于将经纬高转换成米制坐标[E,N,U] 。俩函数都是调用 geo_converter 对象的成员函数，geo_converter 就是 GeographicLib::LocalCartesian 的实例。</p>
<ul>
<li>GeographicLib::LocalCartesian 简介，官方文档</li>
</ul>
<p>功能就是把椭球体下的地理坐标系坐标转为ENU局部系下的坐标。<br>Reset 函数的作用是重置原点，LocalCartesian构造函数是默认在(0,0,0)也就是地心。<br>Forward (lat, lon, alt, x, y, z)函数就是把经纬高转换为ENU，前三个传入，后三个传出。</p>
<h1 id="4-极简的例子"><a href="#4-极简的例子" class="headerlink" title="4. 极简的例子"></a>4. 极简的例子</h1><ul>
<li><p>新建 geographiclib_demo 文件夹，在里面新建 CMakeLists.txt 和 main.cpp。</p>
</li>
<li><p>main.cpp ，经纬度数据转ENU米制坐标，数据文件为lonlat.csv，格式为**[纬度，经度，高度]**。</p>
<p>  #include <iostream><br>  #include <vector><br>  #include <string><br>  #include <fstream><br>  #include <sstream><br>  #include &lt;GeographicLib/LocalCartesian.hpp&gt; //header file</sstream></fstream></string></vector></iostream></p>
<p>  typedef std::vector&lt;std::vector<double>&gt; dataMat_NxN;</double></p>
<p>  void ReadCSV(std::string str_csv_file, dataMat_NxN &amp;data_NxN)<br>  {</p>
<pre><code>  std::ifstream in_file(str_csv_file, std::ios::in);
  std::string std_line;
  while (getline(in_file, std_line))
  &#123;
      std::stringstream ss(std_line);
      std::string data_each;
      std::vector&lt;double&gt; data_array;
      while (getline(ss, data_each, &#39;,&#39;))
      &#123;
          data_array.push_back(atof(data_each.c_str()));
      &#125;
      data_NxN.push_back(data_array);
  &#125;
</code></pre>
<p>  }</p>
<p>  void WriteDat(std::string str_dat_file, dataMat_NxN &amp;data_NxN)<br>  {</p>
<pre><code>  std::ofstream out_file(str_dat_file, std::ios::out);
  for (int i = 0; i &lt; data_NxN.size(); ++i)
  &#123;
      for (int j = 0; j &lt; data_NxN[i].size(); ++j)
      &#123;
          out_file &lt;&lt; data_NxN[i][j]&lt;&lt;&quot; &quot;;
      &#125;
      out_file &lt;&lt; &quot;\n&quot;;
  &#125;
</code></pre>
<p>  }</p>
<p>  int main()<br>  {</p>
<pre><code>  std::cout &lt;&lt; &quot;Demo program of GeographicLib.&quot; &lt;&lt; std::endl;
  // geo origin init
  GeographicLib::LocalCartesian geo_converter;
  // data structure define
  dataMat_NxN geo_data;
  dataMat_NxN ENU_data;
  // read data from file
  std::string str_geo_data = &quot;../lonlat.csv&quot;;//lat,lon,h
  ReadCSV(str_geo_data, geo_data);
  if (geo_data.size() &gt; 0)
  &#123;
      if (geo_data[0].size() == 3)
      &#123;
          geo_converter.Reset(geo_data[0][0], geo_data[0][1], geo_data[0][2]);
          for (int i = 0; i &lt; geo_data.size(); ++i)
          &#123;
              double local_E, local_N, local_U;
              // convert[lat,lon,hgt] to ENU
              geo_converter.Forward(geo_data[i][0], geo_data[i][1], geo_data[i][2], local_E, local_N, local_U);
              std::vector&lt;double&gt; data_each;
              data_each.emplace_back(local_E);
              data_each.emplace_back(local_N);
              data_each.emplace_back(local_U);
              ENU_data.emplace_back(data_each);
              std::cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; std::endl;
          &#125;
      &#125;
  &#125;
  std::string str_ENU_data = &quot;../enu.dat&quot;;//e,n,u
  WriteDat(str_ENU_data, ENU_data);
  return 0;
</code></pre>
<p>  }</p>
</li>
</ul>
<p>CMakeLists.txt 文件</p>
<pre><code>cmake_minimum_required(VERSION 3.10)
project(geographiclib_demo)

set(CMAKE_CXX_STANDARD 14)

find_package (GeographicLib REQUIRED)
include_directories($&#123;GeographicLib_INCLUDE_DIRS&#125;)

add_executable(geographiclib_demo main.cpp)
target_link_libraries(geographiclib_demo $&#123;GeographicLib_LIBRARIES&#125;)
</code></pre>
<p>编译 &amp; 执行</p>
<pre><code>git clone https://gitee.com/jqf64078/geographiclib_demo.git
cd geographiclib_demo
mkdir build &amp;&amp; cd build
cmake ..
make
./geographiclib_demo
</code></pre>
<p>转换ENU米制坐标结果绘制，matlab 绘制。</p>
<pre><code>enu_data = load(&#39;enu.dat&#39;);
plot(enu_data(:,1),enu_data(:,2));grid on;xlabel(&#39;East&#39;),ylabel(&#39;North&#39;);
</code></pre>
<p>csv 文件格式，程序只是简单地定义 [纬度，经度，高度] 如下所示的格式进行读取。</p>
<pre><code>lat, lon, h,
lat, lon, h,
lat, lon, h,
…
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「银时大魔王」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sinat_25923849/article/details/115625911">https://blog.csdn.net/sinat_25923849/article/details/115625911</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>geographiclib</tag>
      </tags>
  </entry>
  <entry>
    <title>快速下载notepad++</title>
    <url>/2023/05/03/%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDnotepad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Notepad+官网难进入，下载速度慢。最新版简体中文的GitHub下载地址。<br>建议迅雷下载，其他下载貌似速度很慢。</p>
<p>可以在<a href="https://github.com中,检索notepad-plus-plus./">https://github.com中，检索notepad-plus-plus。</a></p>
<p>也可以直接使用下面方法下载：</p>
<p>以64位为例：</p>
<p>64位：<a href="https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.4.x/npp.8.4.x.Installer.x64.exe">https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.4.x/npp.8.4.x.Installer.x64.exe</a>  【将x换成版本号】</p>
<p>可以参考如下信息修改下载地址：<br>全系列版本：<a href="https://github.com/notepad-plus-plus/notepad-plus-plus/releases">https://github.com/notepad-plus-plus/notepad-plus-plus/releases</a><br>版本：Notepad++ 8.4.8<br>发布时间: 2022-12-25</p>
<p>官方下载地址：<a href="https://github.com/notepad-plus-plus/notepad-plus-plus">https://github.com/notepad-plus-plus/notepad-plus-plus</a><br>32位：<a href="https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.4.8/npp.8.4.8.Installer.exe">https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.4.8/npp.8.4.8.Installer.exe</a><br>64位：<a href="https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.4.8/npp.8.4.8.Installer.x64.exe">https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.4.8/npp.8.4.8.Installer.x64.exe</a><br>其他系列下载地址：<a href="https://notepad-plus-plus.org/news/v848-released/">https://notepad-plus-plus.org/news/v848-released/</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「笑春风oO」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qcmyqcmy/article/details/128899474">https://blog.csdn.net/qcmyqcmy/article/details/128899474</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>gSOAP</tag>
      </tags>
  </entry>
  <entry>
    <title>gSOAP的工具用法说明</title>
    <url>/2023/05/02/gSoap%E7%9A%84%E5%B7%A5%E5%85%B7%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>gSOAP是一个绑定SOAP/XML到C/C++语言的工具，使用它可以简单快速地开发出SOAP/XML的服务器端和客户端。由于 gSOAP具 有相当不错的兼容性，通过gSOAP，我们就可以调用由Java, .Net, Delhpi, PHP等语言开发的SOAP服务，或者向它们提供SOAP服务。</p>
<p>gSOAP的主页是:</p>
<p><a href="http://sourceforge.net/projects/gsoap2">http://sourceforge.net/projects/gsoap2</a></p>
<p>下载解压后，可以在gsoap\bin\win32里 找到wsdl2h.exe和soapcpp2.exe（另外还有linux和mac版本）。</p>
<p>wsdl2h.exe的作用是根据WSDL生成C/C++风格的头文件<br>soapcpp2.exe的作用是根据头文件自动生成调用远程SOAP服务的客户端代码（称为存根:Stub）和提供SOAP服务的框架代码（称为框架：Skeleton），另外它也能从头文件生成WSDL文件。<br>gsoap\stdsoap2.cpp则是gSOAP的核心代码，要使用gSOAP只要在项目里包含这个文件以及由soapcpp2.exe生成的代码即可。另外还有个stdsoap2.c，内容与stdsoap2.cpp一模一样，用于纯C项目。</p>
<p>gSOAP两大工具的用法</p>
<p>从WSDL中产生头文件<br>用法：</p>
<p>wsdl2h -o 头文件名 WSDL文件名或URL<br>wsdl2h常用选项</p>
<p>-o 文件名，指定输出头文件<br>-n 名空间前缀 代替默认的ns<br>-c 产生纯C代码，否则是C++代码<br>-s 不要使用STL代码<br>-t 文件名，指定type map文件，默认为typemap.dat<br>-e 禁止为enum成员加上名空间前缀<br>type map文件用于指定SOAP/XML中的类型与C/C++之间的转换规则，比如在wsmap.dat里写</p>
<p>xsd__string = | std::wstring | wchar_t*<br>那么SOAP/XML中的string将转换成std::wstring或wchar_t*，这样能更好地支持中文。</p>
<p>例:</p>
<p>wsdl2h -o ayandy.h <br> -n ay -t wsmap.dat <br> <a href="http://www.ayandy.com/Service.asmx?WSDL">http://www.ayandy.com/Service.asmx?WSDL</a></p>
<p>从<a href="http://www.ayandy.com/Service.asmx?WSDL">http://www.ayandy.com/Service.asmx?WSDL</a> 生成ayandy.h文件，名空间为ay，使用wsmap.dat指定的转换规则。</p>
<p>wsdl2h生成的头文件里的变量、类型等名称的前面都会加上名空间前缀，以两个下划线分隔。如上面的命令生成的头文件，有这样的定义：</p>
<p>class ay1__ArrayOfString;<br>enum ay1__theDayFlagEnum<br>{<br> ay1__theDayFlagEnum__Today,<br> ay1__theDayFlagEnum__Tomorrow,<br> ay1__theDayFlagEnum__theDayafterTomorrow,<br>};<br>前面的ayandy1__的是名空间前缀，用以防止名称冲突。 wsdl2h的-n选项可以改变这个名空间前缀(默认为ns)。对于枚举ay1__theDayFlagEnum内的成员，如果嫌它太长的话，可以用-e命令选项禁止加入名空间前缀。</p>
<p>从头文件生成存根(stub)和框架(Skeleton)源文件<br>编写SOAP程序除了头文件是不够的，还要有连接、通信、XML解析、序列/反序列化等工作。gSOAP提供的socapcpp2.exe就是用于从头文件中生成这些代码的，我们只要关心真正的业务逻辑就行了。</p>
<p>用法</p>
<p>soapcpp2 头文件<br>例:</p>
<p>soapcpp2 ayandy.h<br>将生成下面这些文件</p>
<p>soapStub.h    // soap的存根文件，定义了ayandy.h里对应的远程调用模型<br>soapC.c soapH.h  // soap的序列和反序列代码，它已经包含了soapStub.h，服务器端与客户端都要包含它<br>soapClient.c soapClientLib.c // 客户端代码，soapClientLib.c文件则只是简单地包含soapClient.c和soapC.c<br>soapServer.c soapServerLib.c // 服务器端代码,soapServerLib.c文件则只是简单地包含soapServer.c和soapC.c<br>ServiceSoap.nsmap ServiceSoap12.nsmap // 名空间定义，服务器端与客户端都要包含它<br>soapServiceSoapProxy.h soapServiceSoap12Proxy.h // 客户端的C++简单包装(如果头文件是纯C代码，这两个文件就不会生成)</p>
<p>综上所述</p>
<p>如果编写服务器端，项目里应该加入soapServerLib.c，代码里包含头文件soapH.h<br>如果编写客户端，项目里应该加入soapClientLib.c，代码里包含头文件SoapH.h（或xxxxProxy.h）<br>当然，还要加入gsoap库里的stdsoap2.cpp文件（如果是写C代码，则加入stdsoap2.c）<br>如果看到soapcpp2提示:”Critical error: #import: Cannot open file “stlvector.h” for reading.“， 那是因为我们的头文件使用了STL(wsdl2h 没用-s选项)，这时要使用-I选项指定gSOAP的 import文件路径，这个路径是”$gsoap\gsoap\import”:</p>
<p>soapcpp2 ayandy.h -I D:\gsoap-2.7\gsoap\import<br>soapcpp2常用选项</p>
<p>-C 仅生成客户端代码<br>-S 仅生成服务器端代码<br>-L 不要产生soapClientLib.c和soapServerLib.c文件<br>-c 产生纯C代码，否则是C++代码(与头文件有关)<br>-I 指定import路径（见上文）<br>-x 不要产生XML示例文件<br>-i 生成C++包装，客户端为xxxxProxy.h(.cpp)，服务器端为xxxxService.h(.cpp)。<br>转自：<a href="https://www.oschina.net/question/10320_7573">https://www.oschina.net/question/10320_7573</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>gSOAP</tag>
      </tags>
  </entry>
  <entry>
    <title>vcpkg使用说明</title>
    <url>/2023/05/01/vcpkg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><p>去GitHub上下载源码，然后点击安装脚本就可以了。</p>
<ul>
<li><p>先决条件：</p>
<p>  Windows 7 或更高版本<br>  用于 Windows 的 Git</p>
</li>
<li><p>安装过程：</p>
<p>  vcpkg的GitHub主页在这里：<a href="https://github.com/microsoft/vcpkg">https://github.com/microsoft/vcpkg</a><br>  Visual Studio 2015 更新 3 或更高版本（带英文语言包）</p>
</li>
</ul>
<p>在“命令提示符”窗口中，为 vcpkg 的克隆实例创建目录。 如果打算为不同的生成目标安装库，最好在目录名称中包含目标。 建议使用短路径名称（不含空格）（如 C:\src\win32\ 或 C:\dev\iot\），否则，某些端口生成系统可能会出现路径问题 。 在命令窗口中，切换到刚刚创建的目录。</p>
<p>从 GitHub 克隆 vcpkg 存储库：<a href="https://github.com/Microsoft/vcpkg%E3%80%82">https://github.com/Microsoft/vcpkg。</a></p>
<pre><code>git clone https://github.com/microsoft/vcpkg
</code></pre>
<p>此命令在 vcpkg 子目录中创建存储库的本地副本。 此位置是此 vcpkg 克隆的 vcpkg 根目录。</p>
<p>下载完成后，在“命令提示符”窗口切换到 vcpkg 目录。</p>
<p>在 vcpkg 根目录下，运行 vcpkg 引导程序命令：</p>
<pre><code>bootstrap-vcpkg.bat
</code></pre>
<p>引导程序将使用 Microsoft C/C++ 工具、库和 Windows SDK 的位置配置 vcpkg。</p>
<ul>
<li>更新 vcpkg</li>
</ul>
<p>vcpkg 包管理器在 GitHub 上定期更新。 若要将 vcpkg 的克隆更新到最新版本，请从 vcpkg 根目录运行 git pull。 此命令会将 vcpkg 的副本与 GitHub 上的版本同步。 下载完成后，再次运行引导程序。 引导程序会重新生成 vcpkg 程序，但保留已安装的库。</p>
<ul>
<li>卸载 vcpkg</li>
</ul>
<p>若要卸载 vcpkg，只需删除 vcpkg 目录。 删除此目录会卸载 vcpkg 分发以及 vcpkg 已安装的所有库。</p>
<p>但是，如果已执行 vcpkg integrate install，则应执行 vcpkg integrate remove 来确保在删除文件夹之前已清理集成 。</p>
<ol start="2">
<li>使用</li>
</ol>
<ul>
<li><p>命令</p>
<p>  Command    描述<br>  vcpkg search [pat]    搜索可安装的包<br>  vcpkg install <pkg>…    安装包<br>  vcpkg remove <pkg>…    卸载包<br>  vcpkg remove –outdated    卸载所有过期包<br>  vcpkg list    列出已安装的包<br>  vcpkg update    显示用于更新的包列表<br>  vcpkg upgrade    重新生成所有过期包<br>  vcpkg hash <file> [alg]    通过特定算法对文件执行哈希操作，默认为 SHA512<br>  vcpkg integrate install    使已安装包在用户范围内可用。 首次使用时需要管理权限<br>  vcpkg integrate remove    删除用户范围的集成<br>  vcpkg integrate project    为使用单个 VS 项目生成引用 NuGet 包<br>  vcpkg export <pkg>… [opt]…    导出包<br>  vcpkg edit <pkg>    打开端口进行编辑（使用 %EDITOR%，默认为“code”）<br>  vcpkg create <pkg> <url> [archivename]    创建新程序包<br>  vcpkg cache    列出缓存的已编译包<br>  vcpkg version    显示版本信息<br>  vcpkg contact –survey    显示联系信息，以便发送反馈。</url></pkg></pkg></pkg></file></pkg></pkg></p>
</li>
<li><p>选项</p>
</li>
</ul>
<p>选项    描述<br>–triplet <t>    指定目标体系结构三元组。 （默认：%VCPKG_DEFAULT_TRIPLET%，另请参阅 vcpkg help triplet）<br>–vcpkg-root <path></path>    指定 vcpkg 根目录（默认：%VCPKG_ROOT%）</t></p>
<h1 id="3-集成vcpkg"><a href="#3-集成vcpkg" class="headerlink" title="3. 集成vcpkg"></a>3. 集成vcpkg</h1><ul>
<li>Windows 上的 Visual Studio 集成</li>
</ul>
<p>从 vcpkg 根目录，运行 vcpkg integrate install来配置 Visual Studio，以便按用户找到所有 vcpkg 头文件和二进制文件。 无需在 Visual Studio 中编辑 VC + + 目录路径。 如果有多个 vcpkg 克隆，则你从中运行此命令的克隆将成为新的默认位置。<br>现在，只需键入文件夹/标头名称即可轻松加入标头，并且自动完成功能将帮助你完成这一切。 无需执行任何额外的步骤即可链接到库或添加项目引用。 下图演示了 Visual Studio 查找 azure-storage-cpp 标头的方法。 Vcpkg 将其标头置于 /installed 子文件夹中，由目标平台予以分区。 下图显示库的 /was 子文件夹中包含文件的列表：</p>
<ul>
<li>Linux 或 macOS 上的 Visual Studio Code 集成</li>
</ul>
<p>在 shell 或“终端”窗口中，将目录更改为 vcpkg 根目录。 然后运行./vcpkg integrate install，在 Linux 或 macOS 上配置 Visual Studio Code。 此命令将设置 vcpkg 工具和库的位置，并对源文件启用 IntelliSense。</p>
<ul>
<li><p>删除 vcpkg 集成<br>如果已使用 integrate 选项，则应在删除 vcpkg 实例之前删除该集成。 若要删除和清理该集成，请将目录更改为 vcpkg 根目录。</p>
<p>  在 Windows 上，运行vcpkg integrate remove，确保清除该集成。<br>  在 Linux 或 macOS 上，运行./vcpkg integrate remove 命令。</p>
</li>
<li><p>使用举例<br>我现在的场景是我需要 libpng 来进行开发，输入命令：vcpkg install libpng来安装，可以看到他在开始自动下载。</p>
</li>
</ul>
<p>注意我们可以使用.\vcpkg help triplet来看库支持的模式。</p>
<h1 id="4-详细介绍"><a href="#4-详细介绍" class="headerlink" title="4. 详细介绍"></a>4. 详细介绍</h1><ul>
<li>4.1 新增库</li>
</ul>
<p>使用指令：vcpkg help triplet可以看到都支持什么平台。</p>
<p>下载某一个平台的包：.\vcpkg.exe install jsoncpp:x64-windows</p>
<pre><code>(base) PS C:\Users\cds&gt; vcpkg help triplet
Available architecture triplets
VCPKG built-in triplets:
  arm-uwp
  arm64-windows
  x64-linux
  x64-osx
  x64-uwp
  x64-windows-static
  x64-windows
  x86-windows

VCPKG community triplets:
  arm-ios
  arm-linux
  arm-mingw-dynamic
  arm-mingw-static
  arm-windows
  arm64-ios
  arm64-linux
  arm64-mingw-dynamic
  arm64-mingw-static
  arm64-osx
  arm64-uwp
  arm64-windows-static-md
  arm64-windows-static
  ppc64le-linux
  s390x-linux
  wasm32-emscripten
  x64-ios
  x64-mingw-dynamic
  x64-mingw-static
  x64-openbsd
  x64-osx-dynamic
  x64-windows-static-md
  x86-freebsd
  x86-ios
  x86-mingw-dynamic
  x86-mingw-static
  x86-uwp
  x86-windows-static-md
  x86-windows-static
  x86-windows-v120
</code></pre>
<ul>
<li><p>4.2 删除库</p>
<p>  .\vcpkg.exe remove jsoncpp</p>
</li>
</ul>
<p>注意：</p>
<p>这个时候只是移除了默认的x86-winodws版本的文件，如果有其他平台的版本需要移除，需要制定相应的triplet。<br>移除也只是移除了二进制程序库而已，源码包和解压缩的源码并没有删除。</p>
<ul>
<li><p>4.3 查看已经安装的列表</p>
<p>  .\vcpkg.exe list</p>
</li>
<li><p>4.4 更新已经安装的开源库</p>
</li>
</ul>
<p>一般有两种更新方式。一个是update指令，可以显示可以升级的开源库的列表。另一个是upgrade的指令，会重新编译所有需要更新的包。<br>————————————————<br>版权声明：本文为CSDN博主「早睡的叶子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sexyluna/article/details/115285405">https://blog.csdn.net/sexyluna/article/details/115285405</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>vcpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>httpbin</title>
    <url>/2023/04/30/httpbin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>httpbin 是一个使用 Python + Flask 编写的 HTTP HTTP Request &amp; Response Service。该服务主要用于测试 HTTP 库。<br>你可以向他发送请求，然后他会按照指定的规则将你的请求返回。这个类似于echo服务器，但是功能又比它要更强大一些。 httpbin支持HTTP/HTTPS，支持所有的HTTP动词，能模拟302跳转乃至302跳转的次数，还可以返回一个HTML文件或一个XML文件或一个图片文件（还支持指定返回图片的格式）。实在是请求调试中居家必备的良器！</p>
<p><a href="http://httpbin.org/">http://httpbin.org/</a></p>
<h1 id="相同推荐"><a href="#相同推荐" class="headerlink" title="相同推荐"></a>相同推荐</h1><p>类似这种能够很方便调试接口的还有很多，但是无疑还是httpbin最好用。</p>
<p>requestb<br>putsreq<br>ttpresponder<br>runscope</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>使用你擅长的语言，与它的接口互动。</p>
<h1 id="接口列表"><a href="#接口列表" class="headerlink" title="接口列表"></a>接口列表</h1><pre><code>Endpoint***************Description

/************************This page.

/ip**********************Returns Origin IP.

/user-agent*************Returns user-agent.

/headers*****************Returns header dict.

/get******************Returns GET data.

/post*****************Returns POST data.

/patch*************Returns PATCH data.

/put*******************Returns PUT data.

/delete****************Returns DELETE data

/gzip********************Returns gzip-encoded data.

/deflate*****************Returns deflate-encoded data.

/status/:code****************Returns given HTTP Status code.

/response-headers******************Returns given response headers.

/redirect/:n***************************302 Redirects n times.

/redirect-to?url=foo**********************302 Redirects to the foo URL.

/relative-redirect/:n****************302 Relative redirects n times.

/cookies*******************Returns cookie data.

/cookies/set?name=value**********************Sets one or more simple cookies.

/cookies/delete?name*********************Deletes one or more simple cookies.

/basic-auth/:user/:passwd****************Challenges HTTPBasic Auth.

/hidden-basic-auth/:user/:passwd*************404&#39;d BasicAuth.

/digest-auth/:qop/:user/:passwd***********Challenges HTTP Digest Auth.

/stream/:n***************Streams n – 100 lines.

/delay/:n****************Delays responding for n – 10 seconds.

/drip*************Drips data over a duration after an optional initial delay, then (optionally) returns with the given status code.

/range/:n************************Streams n bytes, and allows specifying a Range header to select a subset of the data. Accepts a chunk_size and request durationparameter.

/html****************Renders an HTML Page.

/robots.txt******************Returns some robots.txt rules.

/deny*******************Denied by robots.txt file.

/cache********************Returns 200 unless an If-Modified-Since or If-None-Match header is provided, when it returns a 304.

/cache/:n*********Sets a Cache-Control header for n seconds.

/bytes/:n****************Generates n random bytes of binary data, accepts optional seedinteger parameter.

/stream-bytes/:n*******************Streams n random bytes of binary data, accepts optional seed and chunk_size integer parameters.

/links/:n*****************Returns page containing n HTML links.

/forms/post*************HTML form that submits to /post

/xml*******************Returns some XML

/encoding/utf8**************Returns page containing UTF-8 data.
</code></pre>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>httpbin</tag>
      </tags>
  </entry>
  <entry>
    <title>微电网到底是什么，为什么早些年无法普及？</title>
    <url>/2023/04/29/%E5%BE%AE%E7%94%B5%E7%BD%91%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A9%E4%BA%9B%E5%B9%B4%E6%97%A0%E6%B3%95%E6%99%AE%E5%8F%8A%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>微电网的官方定义<br>由分布式电源、用电负荷、配电设施、监控和保护装置等组成的小型发配用电系统</p>
<p>（发改能源〔2017〕1339号《推进并网型微电网建设试行办法》）。</p>
<p>解读：微电网是包含源、网、荷、储（这四个字是不是超级常见）的小型发配用电系统，配置完备的控制保护系统，具有以下四个特征。</p>
<p>微型：主要体现在微电网接入到配网侧，电压等级低且容量小，一般在 35 千伏及以下且系统容量（最大用电负荷）原则上不大于 20 兆瓦。<br>清洁：“源”以光伏、风电、潮汐能等可再生能源为主，或以天然气多联供（CHP）等能源综合利用为目标的发电形式，清洁环保。<br>自治：微电网内部基本实现电力供需自平衡，且可独立运行。<br>友好：通过源、荷、储的协调控制，实现与电网之间的交换功率可控可调，可减少大规模分布式电源接入对电网造成的冲击。</p>
<p>是不是没啥感觉，看看这些项目的内容，找找感觉</p>
<p>微电网性价比主要表现在10KV及以上的工商业用户！</p>
<p>为什么现在才强调微电网？</p>
<p>新能源后时代，1光伏、2储能、3充电桩等硬件普及以及盈利模式明确，4 电力市场交易规则加速完善，多方面因素驱动企业微电网能效管理系统配置意愿增强。</p>
<p>1、2022年全国新增并网容量87.4GW，其中集中式36.29GW，分布式总计51.11GW，户用分布式25.25GW；截至2022年底累计并网容量共392GW，其中集中式234.44GW，分布式157.62GW。</p>
<p>2、工商业储能主要负荷是满足工商业自身内部的电力需求，实现光伏发电最大化自发自用，或者通过峰谷价差套利和需求侧响应实现投资回报。</p>
<p>3、充电桩普及程度渐高，保有量持续提升。充电桩是保障电动汽车用户出行的基础设施，是推动汽车电动化的最基础抓手。根据中国充电联盟的数据如下。</p>
<p>4、电力市场交易制度加速完善</p>
<p>微电网能效管理系统可以实现平台一体化管理和协调</p>
<p>三方面因素驱动企业配置微电网</p>
<p>（1）可靠用电安全可靠用电是电力用户的刚性需求。近两年，国际形势紧张，部分国家地区能源安全问题突出。国内“双碳”背景下，企业能耗双控力度偏大，较多高能耗企业面临拉闸限电问题。同时，国内用电需求持续高企，电力供需日益偏紧，2022年6月以来，国内部分流域来水偏少，水电紧缺，国内多次出现电 力紧张局面。企业铺设分布式能源及微电网调度系统，可以独立于主电网，主干网可靠性减弱的情况下，微电网可以快速解耦，实现电力自给自足，减少停电损失，保障经营。</p>
<p>（2）节能降本电价上行，峰谷价差拉大，同时部分省市实行尖峰电价。电力成本是工商业企业的重要成本之一，峰谷价差拉大，企业能耗精细化管理意愿渐强，微电网可以按照峰谷电价、实时电价，为企业做优化策略，帮助企业排工派单，对源荷进行柔性控制，实现节能降本。除电力成本外，微电网平台还可以综合电、气、水等多样能源数据，并进行分析，帮助企业梳理能源账单，避免能源浪费。</p>
<p>（3）参与电力市场交易，提升经济性电力市场改革力度加大，企业装机新能源比例逐步上升，电价交易机制完善，虚拟电厂建设加速，工商业用户可参与电力现货市场交易。企业微电网实现打破与主干网之间的“屏障”，与外部电网互联互通，辅助企业形成“自发自用-外网取电-余电上网”的运行模式，动态优化用电策略、 赚取电费收益，微电网经济性进一步提升。微电网是虚拟电厂的关键一环。虚拟电厂管控平台向可调节资源下达调控 指令，用户侧需根据自身情况对各类设备进行功率控制，同时虚拟电厂管控平 台与用户侧需进行实时信息交互。随着电力市场交易机制完善、控制/通信等 关键技术的升级，虚拟电厂建设加速，而企业微电网作为围墙内和围墙外的有效连接，也将发挥重要作用。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>微电网用途</title>
    <url>/2023/04/28/%E5%BE%AE%E7%94%B5%E7%BD%91%E7%94%A8%E9%80%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：浙江电网信息<br>链接：<a href="https://www.zhihu.com/question/558702432/answer/2711099433">https://www.zhihu.com/question/558702432/answer/2711099433</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>01.微电网的定义</p>
<p>微电网(Micro-Grid)是由分布式电源、负荷、储能、变配电和控制系统构成的小型电力系统。<br>微电网是一个能够实现自我控制、保护和管理的自治电力系统，既可以与外部电网并网运行，也可以孤网运行。<br>微电网是相对传统大电网的一个概念，发展微电网能够充分促进分布式可再生能源的大规模接入。微电网与大电网是相辅相成的，尤其在大电网没有覆盖的地区可以发挥更大的作用，以弥补大电网的不足。</p>
<p>02.微电网的划分</p>
<p>按照运行方式划分：并网型、孤网型(独立型)<br>按照电网类型划分：交流微电网、直流微电网、混合型<br>按照电压等级划分：低压(400V-1kV)、中压(1-35kV)、高压(35kV以上)<br>按照规模划分：小型(电网容量&lt;500kVA)、中型(500kVA&lt;=电网容量&lt;6MVA)、大型(电网容量&gt;6MVA)</p>
<p>03.微电网的应用</p>
<p>独立型微电网</p>
<p>独立型微电网：不依赖于外部电网，可以通过分布式电源、储能系统独立、稳定、长期地给负荷供电。<br>可分为直流型、交流型、交直流混合型三种。</p>
<p>为什么要发展独立型微电网系统?<br>(1)在现阶段，在大电网覆盖的经济发达地区，微电网的供电成本远高于大电网，缺乏经济性;<br>(2)尤其是并网型微电网，易被大电网替代，缺乏竞争力;<br>(3)但在大电网没有覆盖的地方，例如岛屿、偏远地区、城市周边、旅游景点等，微电网反而具有优势，因此迫切需要发展独立型微电网。</p>
<p>01.分布式电源</p>
<p>(1)独立型微电网相关的分布式电源<br>光伏发电<br>风力发电<br>燃气发电(天然气、沼气)<br>生物质发电<br>海洋能发电<br>小水电<br>柴油发电</p>
<p>(2)分布式发电的优缺点</p>
<p>优点：可利用丰富的清洁和可再生能源。<br>缺点：一些可再生能源具有间歇性和随机性。</p>
<p>(3)独立型微电网相关的分布式电源</p>
<p>其中分布式光伏是最有潜力的可再生能源，适应面广，受限制少，技术进步快和成本下降迅速，最有应用前景。</p>
<p>现阶段发展分布式光伏的困难与对策：<br>困难：地难找，电难接，补贴慢，用电需求不稳定;<br>对策：可以采用独立型微电网方式，不依赖于电网;寻求适合的用电需求，真正实现自发自用。</p>
<p>02.储能系统<br>独立型微电网相关的储能系统：</p>
<p>化学储能<br>铅酸电池、铅酸胶休电池、铅碳电池、铅品电池<br>锂电池：磷酸铁悝、锰酸锂、三元、钛酸悝，<br>液流电池：全钒液流、锌溴，镍氢电池、钠硫电池、锌空、锂空</p>
<p>物理储能<br>抽水蓄能、压缩空气、飞轮、相变储能、超级电容器、超导储能、蓄热蓄冷</p>
<p>储能系统是独立型微电网不可或缺的组成部分，也是造成微电网系统成本高的主要原因。<br>需要找到大幅降低储能成木的方式方法：<br>a. 技术进步<br>b. 商业模式创新<br>(结合电动汽车充放电、退役电池梯级利用)</p>
<p>03.推广应用<br>典型推广应用方向：</p>
<p>独立光伏电动汽车充换电站<br>独立光伏水泵灌溉系统<br>独立光伏制氢系统<br>独立风光储村庄供电系统<br>独立风光柴储岛屿供电系统<br>独立风电海水淡化系统</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式EMS：流水线生产微电网</title>
    <url>/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8FEMS%EF%BC%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%94%9F%E4%BA%A7%E5%BE%AE%E7%94%B5%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：极简物控<br>链接：<a href="https://www.zhihu.com/question/372948858/answer/2990066810">https://www.zhihu.com/question/372948858/answer/2990066810</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>嵌入式EMS也已经有了实践答案。极简物控应用嵌入式EMS在杭州某区域打造了集化工、印染、轻加工等在内的8类用能企业、52家用户的智慧协同微网群示范。我们了解到，区域超90%能源依赖于外部输入，具有典型大受端城市工业园区特征，以化纤纺织业、化学原料和化学制品制造业、化学纤维制造业、金属制品业、通用设备制造业、汽车制造业六大行业为主，属于高负荷密度区域，未来区域也仍以工业负荷为主，负荷发展相对稳定。我们选择其中1个供电单元为微电网群示范建设区域，该供电单元由4个10kV标准单环网组成，因此我们划分为4个微电网群，示范区的电压等级在10千伏及以下，单个微电网群容量小于12兆瓦。微电网群区域已建光伏12户（6649kWp）、储能1户（300kW/600kWh）。未来拟新建光伏14户（15110kWp）、储能7户（3000kW/6000kWh）、可调节负荷21户（9950kW），在3个企业中拟新建一体化充电设施，每套设备可同时服务停车场内40辆新能源车。</p>
<p>示范区微电网群拓扑示意图传统微电网群协同控制通常采用集中式架构，但是随着微电网数量不断增多，系统计算负担增大、处理效力降低，同时，由于集中式系统过于庞大，存在某一节点失灵可能影响全局的风险，系统可靠性较差，扩展灵活性不足。在这样的场景下，分布式控制架构或许是更优的选择！然而，哪怕采用分布式控制架构，每一层级的微电网分布式协同控制都需要服务器、控制器、物联网关等多个硬件支撑，结构笨重，而且需要针对不同应用场景逐一开发系统平台，通用性较差。嵌入式EMS让微电网的分层分区（分布式）协同控制更加简单！极简物控的嵌入式EMS是目前市面上核心的微电网能量管理产品化方案之一。嵌入式EMS软硬件高度集成，相当于１个嵌入式EMS＝数据网关＋微网控制器＋能量管理服务器，即１个用户仅需安装１个嵌入式EMS即可打造微网智能控制平台。</p>
<p>嵌入式EMS软硬件高度集成分层分区协同控制可分为“微电网层”、“协同控制层”、“系统平台层”。</p>
<p>基于嵌入式EMS的微电网分层协同控制架构在微电网层中，通过1个嵌入式EMS实现对1个微电网优化调控，包括内部源网荷的直接控制、微电网运行模式切换、微网稳定运行以及与外部电网的能量交互，满足微网自治优化运行需求。一方面，微电网层上送关键的基础数据，包括设备的状态、需求响应潜力评估和策略执行反馈等，共协同控制层决策参考。另一方面，微电网层接受上级下发的分解指令，包括调度策略、响应顺序和设备状态调节指令等，根据微电网自身状态，管理微电网内部源荷储资源，保障微网内部的功率平衡，有效保障系统的稳定性和经济性。在协同控制层中，由嵌入式EMS和可视化平台构成，是架构中的中间层，是上下层数据和指令交互媒介，具备边缘计算、边缘互联、云边协同能力。一方面，协同控制层接收系统平台层下发的调控指令和下层微网群上发数据信息，制定考虑多目标约束的微网群优化调控策略，并下发控制指令下发给微电网层，实现微网群互联互济、协同运行。另一方面，将微网群执行情况，响应能力等信息反馈至系统平台层，辅助电网调度策略制定。在系统平台层中，主要是电网调度中心与能源大数据中心，是区域的能源智能大脑。一方面，根据所辖区域内的能源消费特征以及微电网群的状态，制定区域调度策略，并下发至协同控制层。另一方面，接受系统控制层上报的执行情况、响应能力等数据，以此为重要的数据参考制定下阶段的调度策略。</p>
<p>操作面板在这样的系统架构下，单个微电网能够实现“最大功率输出模式、可调度模式、孤岛运行模式”及其他控制模式之间的切换，并且根据用户计划调度以及故障场景可以在并网和离网状态之间进行无缝切换，在孤岛模式下实现微电网自供电，依靠分布式电源和储能为电网用户供电。同时，微电网与微电网群之间进行能源、信息的交互互动，微电网与大电网实现电能的灵活互济，实现“企业收益最大、电网稳定运行、碳排总量最小”等多方面平衡，满足政府、用户、电网多方利益诉求，实现共建共享共赢。在经济效益方面，微电网控制系统的建设成本下降超60%以上，系统运维由需要2个及以上专业编程人员降至1个兼职巡检人员。随着微电网数量地不断增多，系统建设边际成本将会进一步下降。在系统运营期间，光伏预期发电量（现有+新建）2700万度电/年，按照“80%自发自用，20%余量上网”的原则，预计可节约电费约2000万元／年，储能（现有+新建）通过“低充高放”等方式盈利约420万元／年，通过参与电网日前削峰响应获得补贴约380万元／年（按浙江省需求响应按照4元/千瓦时的上限标准进行补偿）。在安全运行方面，微电网具备自平衡、自管理、自调节能力，独立运行时能保障内部负荷连续供电不低于2小时，微电网群的电量交换率接近50%，外部电网输入功率峰谷差下降比例超过25%，帮助实现日前削峰填谷20MW/次，每次大约为1.8小时，帮助电网稳定运行，极端事故条件下，配合需求响应和储能，内部非可调负荷可短时孤岛运行。此外，采取分层分区协同控制架构后，有效提高了系统的运行可靠性，不仅降低电网调度中心的调节负担。在低碳发展方面，光伏发电占总用电比例高于100%的有9家，50%-100%之间7家，微电网群的光伏发电占总用电整体比例超过50%，新能源消纳率达100%，平均每年减少二氧化碳13500吨。</p>
<p>屋顶光伏受益于嵌入式EMS是产品化的解决方案，微电网群的建设边际成本会进一步降低，并为微电网群提供了一个“交流沟通”的平台，邀请微电网们“加入群聊”，实现微电网群分层分区的协调控制。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>智能微电网优点</title>
    <url>/2023/04/26/%E6%99%BA%E8%83%BD%E5%BE%AE%E7%94%B5%E7%BD%91%E4%BC%98%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：汉碳云<br>链接：<a href="https://www.zhihu.com/question/372948858/answer/3030184012">https://www.zhihu.com/question/372948858/answer/3030184012</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>随着环保意识日益增强，越来越多的国家和地区开始重视碳中和，加快绿色经济和可持续发展的步伐。而智能微电网作为一种新兴的电力供应方式，在实现碳中和方面有着重要的意义，本文将从以下几个方面进行探讨。</p>
<ul>
<li>促进清洁能源发展：</li>
</ul>
<p>智能微电网是一种小型、灵活、可靠的电力供应系统，它具备能源的自治管理和分配功能，可以灵活应对不同的需求，使清洁能源更容易被广泛使用。在智能微电网的支持下，太阳能、风能等新能源可以更加广泛的应用，而传统的化石燃料可以得到替代。这有助于实现碳中和的目标，减少二氧化碳的排放，推动清洁能源的发展。</p>
<ul>
<li>提高能源供应效率：</li>
</ul>
<p>智能微电网是一种灵活的能量供应方式，能够将化繁为简，优化能源管理，减少能源浪费，从而实现更高效的能源利用，降低能源成本。随着技术和管理能力的不断提升，智能微电网能够更好地分配和管理能源，使其更加合理、高效地使用，从而有助于减少碳排放，实现碳中和。</p>
<ul>
<li>提高电网稳定性：</li>
</ul>
<p>智能微电网是一种小型的分布式电力系统，分布式能源的优越性在于可以充分利用地方资源，降低长距离输电功率损耗和线路故障的风险。而且智能微电网可以对接到传统的电力系统，通过智能化的控制，调节电量、提高电网的稳定性和可靠性，减少电网对环境的影响，从而更加适合碳中和的发展需求。</p>
<ul>
<li>促进能源去中心化：</li>
</ul>
<p>智能微电网的自治化管理可以将较小的电力系统转化为具有独立运行能力的电力区域。这些电力区域可以充分利用当地的可再生能源资源，减轻对集中供电系统的依赖，降低对化石燃料的需求，从而实现碳中和的目标。此外，去中心化还可以加强能源系统的安全性和独立性，使其免受对中央能源控制的可能性和黑客攻击的威胁。</p>
<p>综上所述，汉碳云智能微电网不仅有助于碳中和的实现，还可以提高能源利用效率，降低污染排放，促进能源去中心化等。它是一种前景广阔的电力供应方式，相信随着技术和经验的不断积累，将会在未来得到更广泛的应用。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>新型电力系统下的微电网应用及市场有何变化？</title>
    <url>/2023/04/25/%E6%96%B0%E5%9E%8B%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E5%BE%AE%E7%94%B5%E7%BD%91%E5%BA%94%E7%94%A8%E5%8F%8A%E5%B8%82%E5%9C%BA%E6%9C%89%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>微电网能够实现自我运行控制、保护和管理，既可以与公网并网运行，也能以孤立电网形式独立运行。微电网可以与现有电力系统结合形成高效灵活的新系统。</p>
<h1 id="什么是微电网？"><a href="#什么是微电网？" class="headerlink" title="什么是微电网？"></a>什么是微电网？</h1><p>微电网是指由分布式电源、储能装置、能量转换装置、配用电设施、负荷、监控和保护装置等组成的小型发配用电系统，也称微网。微电网既可以与公网并网运行，也可以独立运行，是能够实现自我运行控制、保护和管理的自治系统。微电网内部分布式电源以清洁能源为主，或采取以能源综合利用为目标的发电形式。</p>
<p>微电网包括五类装置。其中，能量提供装置包括分布式光伏、风能、生物质、地热、波浪、燃油、燃气等发电微电源和电能转换并网装置，用能装置包括用电负荷、冷负荷、热负荷等，储能装置包括多种分布式储能本体、并网装置和电池管理系统等，控制保护装置包括中央控制器、控制主站、并网开关、断路器等，通信监测装置包括通信、传感和能量管理系统等。</p>
<p>优点体现为：可减少大规模分布式电源接入对电网造成的冲击，可以为用户提供优质可靠的电力，能实现并网/离网模式的平滑切换，能够很好地协调大电网与分布式电源的技术矛盾。</p>
<p>具有一定的局限性：微电网以分布式电源就地利用为主要控制目标，受到地理区域的限制，对多区域、大规模分布式电源的有效利用及在电力市场中的规模化效益具有一定的局限性。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>我国按照微电网的运行应用场景，将微电网主要分为城市片区微电网、农村微电网、企业微电网、海岛微电网等。</p>
<ul>
<li>城市片区微电网。</li>
</ul>
<p>城市片区微电网将在我国经济较发达的城市首先发展，按居民小区、宾馆、医院、商场、办公楼等进行建设。</p>
<ul>
<li>农村微电网。</li>
</ul>
<p>尽可能利用农村、边远地区的资源禀赋，通过不同形式的微电源、储能满足负荷要求，可独立运行解决边远地区供电的问题，也可与公网并网运行。该类微电网一般接在400伏低压配电网中，容量在数千瓦至数百千瓦。</p>
<ul>
<li>企业微电网。</li>
</ul>
<p>一般接在10千伏中压配电网甚至更高电压等级的配电网中，容量在数百千瓦至10兆瓦，多利用传统电源满足企业内部的用电需求，常见于石化、钢铁等大型企业，为企业降低成本、提高效益。</p>
<ul>
<li>海岛微电网。</li>
</ul>
<p>清洁能源在海岛上的综合应用拥有广阔前景。国内海岛微电网的建设集中在东南沿海地区，微电源的主要形式以风、光、柴、储为主。</p>
<h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>微电网有两种典型运行模式，并网运行模式和孤网运行（独立运行）模式。并网运行模式为正常情况下微电网与公网相连，微电网与公网进行电能交换，微电网内的新能源系统可在并网运行时发电，储能系统也可在并网运行时进行充电和放电。</p>
<p>微电网独立运行时，应能满足其内部负荷的有功功率和无功功率需求，必要时可采取投入备用分布式电源、切负荷等措施，以保证内部重要负荷的供电可靠性。微电网应具备黑启动能力。</p>
<ul>
<li>浙江宁波慈溪微电网示范工程</li>
</ul>
<p>2022年12月，浙江宁波慈溪氢电耦合直流微电网示范工程正式完工。该工程是2020年国家重点研发计划专项“可离网型风/光/氢燃料电池直流互联与稳定控制技术”的配套示范工程，也是浙江省“十四五”新型电力系统建设试点示范工程。</p>
<p>示范工程建设规模包含4兆瓦光伏、0.2兆瓦风电、3兆瓦/6兆瓦时电化学储能、240千瓦燃料电池，支撑400千瓦制氢机、10台60千瓦直流充电机、示范工程楼宇用电运行。示范工程以综合能量管理系统总体监测、调度控制各系统运行，以智能直流变流器核心控制设备调节各子系统运行参数，构建风光储氢充一体化可离网微电网系统。</p>
<p>示范工程自主研发了高效电解制氢系统、燃料电池热电联供系统、氢能与电池混合储能、多端口直流换流器等核心装备，实现氢电耦合核心设备100%国产化。每年可产氢超过60万标准立方米，消纳新能源超400万千瓦时。通过可再生能源“绿电”制“绿氢”，能有效减低氢能制备成本，助力氢能终端应用，加速消费侧脱碳，为实现碳达峰碳中和目标提供宁波经验。</p>
<ul>
<li>福建台区组共享储能型微电网</li>
</ul>
<p>4月12日14时，福建泉州供电公司电力调度控制中心的大屏幕上显示，位于翔云镇的福建省首个台区组共享储能型微电网的光伏发电出力达到当天的出力峰值1120千瓦，光伏发电就地完成消纳。</p>
<p>台区组共享储能型微电网是国网福建省电力有限公司探索新型电力系统建设的示范工程之一。翔云镇是典型的高比例分布式光伏电源接入乡镇，截至2022年年底，该镇超过三分之二的公用变压器台区接入了分布式光伏电源。分布式光伏发电并网容量持续增长，对电网安全稳定运行的影响有所增加。</p>
<p>针对这一问题，2022年6月，国网福建电力在翔云镇翔云村、金安村试点建设台区组共享储能型微电网，为翔云台区5号、6号配电变压器和金安台区2号、4号配电变压器配置了一套储能供电系统和电池管理系统装置。</p>
<p>台区组共享储能型微电网运行以来，试点区域的分布式光伏发电实现100%就地消纳。台区组共享储能型微电网解决了山区乡村的分布式光伏发电就地消纳难问题，为分布式光伏发电高效、灵活消纳提供了样板。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>微电网是什么</title>
    <url>/2023/04/24/%E5%BE%AE%E7%94%B5%E7%BD%91%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>微电网是什么</p>
<p>微电网（Micro-Grid）也译为微网，是指由分布式电源、储能装置、能量转换装置、负荷、监控和保护装置等组成的小型发配电系统。</p>
<p>微电网的提出旨在实现分布式电源的灵活、高效应用，解决数量庞大、形式多样的分布式电源并网问题。 开发和延伸微电网能够充分促进分布式电源与可再生能源的大规模接入，实现对负荷多种能源形式的高可靠供给，是实现主动式配电网的一种有效方式，使传统电网向智能电网过渡。</p>
<p>微电网是指由多个可分割的分布式电源、电池储能、能量管理系统和智能电网控制设备等构成的一种小型的、自治的电力供应系统。微电网可以独立运行，也可与主电网进行联网运行，其在电能供应、能源管理和电网稳定等方面都具有一定的优势。</p>
<p>微电网在一定范围内可以平衡供需，降低能源供应和传输的代价，提高电力供应的可靠性和安全性，并实现了低碳环保和节约能源的目的。微电网可以应用于城镇社区、商业区、工业园区、农村偏远地区、战略设施等多种场合，为能源需求提供一个高度自主的解决方案，同时也为主电网的网络优化、调峰和配电等方面带来了积极的作用。</p>
<p>微电网主要由以下几个组成部分构成：</p>
<ol>
<li><p>可再生能源发电设备：包括太阳能、风力发电、生物质发电等，可实现对区域内能源的自产自用和清洁生产。</p>
</li>
<li><p>储能设备：包括超级电容、电池、储热系统等，用于应对天气变化和停电期间保障可靠能源供应。</p>
</li>
<li><p>智能电网管理设备：包括负荷预测、控制器、能量管理等系统，可以实现微电网内的能量平衡和优化控制。</p>
</li>
<li><p>接口设备：实现微电网与主电网之间的互动和动态平衡。</p>
</li>
</ol>
<p>微电网的运行模式一般有独立运行和联网运行两种方式，独立运行即指在无法接入主电网的场合下独立运行，联网运行则指在宏观控制下接入主电网，建立起一种分布式的、灵活的低压直流微电网。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>微型电网</title>
    <url>/2023/04/23/%E5%BE%AE%E5%9E%8B%E7%94%B5%E7%BD%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="微网"><a href="#微网" class="headerlink" title="微网"></a>微网</h1><p>微型电网(微电网)有时简称微网:是相对传统大电网的一个概念，是指多个分布式电源及其相关负载按照一定的拓扑结构组成的网络，并通过静态开关关联至常规电网。</p>
<p>微电网(micro-grid，microgrid)，是指由分布式电源、储能装置、能量转换装置、相关负荷和监控、保护装置汇集而成的小型发配电系统，是一个能够实现自我控制、保护和管理的自治系统，既可以与外部电网并网运行，也可以孤立运行。是智能电网的重要组成部分。</p>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li><p>中文名称<br>微网(微型电网、微电网)</p>
</li>
<li><p>外文名称<br>micro-grid，microgrid</p>
</li>
<li><p>结构<br>拓扑结构组成的网络</p>
</li>
<li><p>连接方式<br>通过静态开关关联至常规电网</p>
</li>
<li><p>别名<br>微电网</p>
</li>
<li><p>组成部分<br>分布式电源、储能装置等</p>
</li>
<li><p>含义<br>近距离网络接触的代名词</p>
</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>美国电气可靠性技术解决方案联合会( CERTS-Consortium for Electric Reliability Technology Solutions)给出的定义为:微电网是一种由负荷和微型电源共同组成系统，它可同时提供电能和热量;微电网内部的电源主要由电力电子器件负责能量的转换，并提供必需的控制;微电网相对于外部大电网表现为单一的受控单元，并可同时满足用户对电能质量和供电安全等的要求。</p>
<p>欧盟微电网项目(European Commission Project Micro-grids)给出的定义是:利用一次能源;使用微型电源，分为不可控、部分可控和全控三种，并可冷、热、电三联供;配有储能装置;使用电力电子装置进行能量的调节。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在过去的几十年，电网规模不断扩大，已逐步发展成集中发电、远距离输电的超大互联网络系统。但远距离输电的不断增大、使得受端电网对外来电力的依赖程度不断提高，电网运行的稳定性和安全性趋于下降，而且难于满足多样化供电需求。另一方面，对全球常规能源的逐渐枯竭、环境污染等问题的担忧却日益突显。鉴于此，环保、高效和灵活的分布式发电广受青睐。</p>
<p>分布式发电一般是指将相对小型的发电装置(一般50 MW以下)分散布置在用户/负荷现场、或邻近地点，从而实现发电供能的方式。分布式发电具有位置灵活、分散的特点，极好地适应了分散电力需求和资源分布，延缓了输配电网升级换代所需的巨额投资;与大电网互为备用，也使供电可靠性得以改善;一般还具有污染少、能源利用效率高的优势。</p>
<p>尽管优点突出，但分布式发电也存在诸多问题:分布式电源单机接入成本高，控制困难等;分布式电源相对大电网来说是一个不可控源，大系统往往采取限制、隔离的方式来处置分布式电源，以减小其对大电网的冲击。当电力系统发生故障时，分布式电源往往都须在第一时间退出运行，这就大大限制了分布式发电效能的充分发挥。为协调大电网与分布式电源间的矛盾，充分挖掘分布式电源为电网和用户带来的价值和效益，提出并不断发展了微电网(Microgrid)的概念。</p>
<p>根据Navigant Research第九版微电网部署报告显示，全球已经公布的微电网项目累计达到1437个，装机容量超过13吉瓦，其中超半数属于远程微电网。</p>
<p>报告中指出，微电网已经成为全球现象。已经超过100个国家都在部署微电网项目，累计装机容量超过13吉瓦，其中，俄罗斯北极圈附近的微电网项目累计约816兆瓦。</p>
<p>从国家来看，无论是微电网装机容量还是项目数量，美国都位居第一，其中，纽约州就有83个微电网项目。</p>
<p>从区域来看，亚太地区和北美地区是微电网最大的两个区域市场，市场占有率均为42%。</p>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势:"></a>优势:</h1><p>微电网，也被称为分布式能源孤岛系统，将发电机、负荷、储能装置及控制装置等系统地结合在一起，形成一个单一可控的单元，同时向用户供给电能和热能。微电网中的电源多为微电源，亦即含有电力电子界面的小型机组(小于100kW)，包括微型燃气轮机，燃料电池、光伏电池以及超级电容、飞轮、蓄电池等储能装置。微电网接在用户侧，具有低成本、低电压、低污染等特点。微电网既可与大电网联网运行，也可在电网故障或需要时与主网断开单独运行。</p>
<p>微网具有双重角色。对于电网，微电网作为一个大小可以改变的智能负载，为本地电力系统提供了可调度负荷，可以在数秒内做出响应以满足系统需要，适时向大电网提供有力支撑;可以在维修系统同时不影响客户的负荷;可以减轻(延长)配电网更新换代，采用IEEE1547.4标准，指导分布式电源孤岛运行，能够消除某些特殊操作要求产生的技术阻碍。对于用户，微电网作为一个可定制的电源，可以满足用户多样化的需求，例如，增强局部供电可靠性，降低馈电损耗，支持当地电压，通过利用废热提高效率，提供电压下陷的校正，或作为不可中断电源服务等。</p>
<p>此外，紧紧围绕全系统能量需求的设计理念和向用户提供多样化电能质量的供电理念，是微电网的2个重要特征。在接入问题上，微电网的并网标准只针对微电网与大电网的公共连接点(PCC)，而不针对各个具体的微电源。微电网不仅解决了分布式电源的大规模接入问题，充分发挥了分布式电源的各项优势，还为用户带来了其他多方面的效益。微网将从根本上改变传统的应对负荷增长的方式，在降低能耗、提高电力系统可靠性和灵活性等方面具有巨大潜力。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>微型电网</tag>
      </tags>
  </entry>
  <entry>
    <title>新能源消纳能力要跟上</title>
    <url>/2023/04/22/%E6%96%B0%E8%83%BD%E6%BA%90%E6%B6%88%E7%BA%B3%E8%83%BD%E5%8A%9B%E8%A6%81%E8%B7%9F%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发布时间：2022-06-10 来源：经济日报 大中小</p>
<p>　　今年以来，我国新能源装机出现大幅增长，但是在局部地区也同时出现了弃风弃光率提升的现象。</p>
<p>　　弃风弃光现象曾是制约我国新能源产业高质量发展的重要因素。有人形象地比喻，风电光电就像地头的农特产品，随着种植规模扩大，当地老百姓吃不完，深加工能力跟不上，外送物流渠道又不畅通，只能将一部分白白扔掉。由此可见，弃风弃光的根源，是一定区域内的新能源电源建设速度超出消纳能力，从而造成能源的规模化发展和高效消纳利用之间的矛盾。</p>
<p>　　近年来，我国以风电、光伏发电为代表的新能源装机规模稳居全球首位，发电量占比稳步提升，成本快速下降，已基本进入平价无补贴发展的新阶段。在“双碳”目标下，我国已明确到2030年，风电和太阳能发电总装机容量达到12亿千瓦以上。从国家规划、能源消费的低碳化趋势和新能源装备技术等各个层面，都释放出了新能源进一步大规模开发利用的利好信号。</p>
<p>　　但要引起警惕的是，如果忽视电力系统对大规模高比例新能源接网和消纳的适应性不足等制约因素，那么新能源的开发利用还有可能重演大规模弃风弃电的困境。因此，我国新能源发展面临着既要大规模开发、又要高水平消纳、更要保障电力安全可靠供应等多重挑战。</p>
<p>　　日前公布的《“十四五”可再生能源发展规划》中指出，我国可再生能源将进入高质量跃升发展新阶段。在这一判断中，“高质量”不难理解，所谓“跃升”，既是装机规模的跨越式发展，也是可再生能源在电力消费中的占比快速提升，更是发展模式由政策驱动向市场驱动的新转变。以风电、光电为代表的新能源作为可再生能源的主力军，将在未来清洁低碳、安全高效的能源体系中起到“挑大梁”的作用。因此，必须坚持先立后破、通盘谋划和系统观念，有效化解新能源发展面临的各种挑战。当务之急是要统筹解决好新能源大规模开发和高水平消纳，以及保障电力安全可靠供应之间的关系，协同推进新能源的规模、效益和安全。</p>
<p>　　一方面，要挖掘新能源就地消纳的潜力。从利用方式看，新能源就地消纳是最经济的方式。提高新能源就地消纳水平，需要进一步挖掘潜力空间，鼓励引导全社会消费新能源等绿色电力，推动绿色电力在交易组织、电网调度、价格形成机制等方面体现优先地位，为市场主体提供功能健全、友好易用的绿色电力交易服务。同时，在具备条件的工业企业、工业园区，加快发展分布式光伏、分散式风电等新能源项目，提高终端用能的新能源电力比重。</p>
<p>　　另一方面，要加快外送通道建设。特高压输电线路就像电力“高速公路”，在新能源就地消纳能力有限的情况下，通过外送通道将新能源电力输送至用电负荷较高的发达地区，既能满足产业聚集地区用电需求，也能实现新能源电力的有效利用。从长远看，提高新能源消纳水平，需要加快构建新型电力系统，突破省际壁垒，从电网技术、交易机制、基础设施等多方面发力，实现新能源电力在全国范围内的合理配置。</p>
<p>　　此外，还需要探索多渠道储能路径。近年来，不少新能源富集地区实施了抽水蓄能、绿电制氢等储能项目，一定程度上提高了新能源的利用水平。通过将暂时富余的风电、光电转化成其他形式的能源，在用电高峰时再次转化成电能输出，可以有效实现新能源电力的“错峰上市”。（陈发明）</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>新能源</tag>
      </tags>
  </entry>
  <entry>
    <title>下载《算法秘籍》和《刷题笔记》</title>
    <url>/2023/04/21/%E4%B8%8B%E8%BD%BD%E3%80%8A%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8D%E3%80%8B%E5%92%8C%E3%80%8A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此链接可下载《算法秘籍》和《刷题笔记》两本 PDF 以及 Chrome 插件的离线安装程序：</p>
<p>链接：<a href="https://pan.baidu.com/s/1PoG0Zxy7H64aXUM-Gj0UuA?pwd=541i">https://pan.baidu.com/s/1PoG0Zxy7H64aXUM-Gj0UuA?pwd=541i</a> 提取码：541i</p>
<p>另外，该链接会持续更新本链接中的插件和 PDF 的版本，你从上面链接中下载到的都将是最新版本。请直接下载，不要转存，因为转存后不会同步更新最新内容。</p>
<p>刷题全家桶的安装使用手册点这里：<br><a href="https://mp.weixin.qq.com/s/M5Ud_RCzIe9pNl1cLSDPRQ">https://mp.weixin.qq.com/s/M5Ud_RCzIe9pNl1cLSDPRQ</a></p>
<p>或长按识别对应的二维码查看（如果二维码过多无法识别，可以放大图片再长按识别对应的二维码）。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>算法秘籍</tag>
        <tag>刷题笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Accept-Encoding</title>
    <url>/2023/04/20/Accept-Encoding/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、项目经历"><a href="#一、项目经历" class="headerlink" title="一、项目经历"></a>一、项目经历</h1><p>碰到个奇葩的服务，请求头加了Accept-Encoding，但凡结果不为空的，就报异常，结果为空的就给放行说成功。</p>
<h1 id="二、同行遭遇"><a href="#二、同行遭遇" class="headerlink" title="二、同行遭遇"></a>二、同行遭遇</h1><h2 id="1、请求头设置-Accept-Encoding"><a href="#1、请求头设置-Accept-Encoding" class="headerlink" title="1、请求头设置 Accept-Encoding"></a>1、请求头设置 Accept-Encoding</h2><pre><code>&quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;
</code></pre>
<p>返回的数据是乱码，无论设置utf-8、gbk、gb2312都无法解码</p>
<p>一个奇怪的现象是本地测试可以正常解码，代码在服务器上运行就无法解码，最终将该请求头去除就正常了。</p>
<p>在使用okhttp请求服务器数据的时候，发现返回的数据一直都是乱码，但是使用fiddler抓包，decode后，可以正常显示。刚开始一直怀疑是编码的问题，后来对比了hex的数据和程序中乱码的二进制，发现不一样。fiddler可以自动处理，说明不是密钥加密。经过不断的尝试发现时Accept-Encoding设置的问题，下面就一一详细介绍一下</p>
<h2 id="2、设置Accept-Encoding为gzip-deflate，返回的网页是乱码"><a href="#2、设置Accept-Encoding为gzip-deflate，返回的网页是乱码" class="headerlink" title="2、设置Accept-Encoding为gzip,deflate，返回的网页是乱码"></a>2、设置Accept-Encoding为gzip,deflate，返回的网页是乱码</h2><ul>
<li>HTTP 内容协商</li>
</ul>
<p>要了解 Vary 的作用，先得了解 HTTP 的内容协商机制。有时候，同一个 URL 可以提供多份不同的文档，这就要求服务端和客户端之间有一个选择最合适版本的机制，这就是内容协商。</p>
<ul>
<li>协商方式有两种</li>
</ul>
<p>一种是服务端把文档可用版本列表发给客户端让用户选，这可以使用 300 Multiple Choices 状态码来实现。这种方案有不少问题，首先多一次网络往返；其次服务端同一文档的某些版本可能是为拥有某些技术特征的客户端准备的，而普通用户不一定了解这些细节。举个例子，服务端通常可以将静态资源输出为压缩和未压缩两个版本，压缩版显然是为支持压缩的客户端而准备的，但如果让普通用户选，很可能选择错误的版本。</p>
<p>另外一种方案：服务端根据客户端发送的请求头中某些字段自动发送最合适的版本。可以用于这个机制的请求头字段又分两种：内容协商专用字段（Accept 字段）、其他字段。HTTP 的内容协商通常使用这个方案</p>
<pre><code>请求头字段    说明    响应头字段
Accept    告知服务器发送何种媒体类型    Content-Type
Accept-Language    告知服务器发送何种语言    Content-Language
Accept-Charset    告知服务器发送何种字符集    Content-Type
Accept-Encoding    告知服务器采用何种压缩方式    Content-Encoding
</code></pre>
<p>例如客户端发送以下请求头：</p>
<pre><code>Accept:*/*
Accept-Encoding:gzip,deflate,sdch
Accept-Language:zh-CN,en-US;q=0.8,en;q=0.6
</code></pre>
<p>表示它可以接受任何 MIME 类型的资源；支持采用 gzip、deflate 或 sdch 压缩过的资源；可以接受 zh-CN、en-US 和 en 三种语言，并且 zh-CN 的权重最高（q 取值 0 - 1，最高为 1，最低为 0，默认为 1），服务端应该优先返回语言等于 zh-CN 的版本。</p>
<p>浏览器的响应头可能是这样的：</p>
<pre><code>Content-Type: text/javascript
Content-Encoding: gzip
</code></pre>
<p>表示这个文档确切的 MIME 类型是 text/javascript；文档内容进行了 gzip 压缩；响应头没有 Content-Language 字段，通常说明返回版本的语言正好是请求头 Accept-Language 中权重最高的那个。</p>
<p>有时候，上面四个 Accept 字段并不够用，例如要针对特定浏览器如 IE6 输出不一样的内容，就需要用到请求头中的 User-Agent 字段。类似的，请求头中的 Cookie 也可能被服务端用做输出差异化内容的依据。</p>
<p>由于客户端和服务端之间可能存在一个或多个中间实体（如缓存服务器），而缓存服务最基本的要求是给用户返回正确的文档。如果服务端根据不同 User-Agent 返回不同内容，而缓存服务器把 IE6 用户的响应缓存下来，并返回给使用其他浏览器的用户，肯定会出问题 。</p>
<p>所以 HTTP 协议规定，如果服务端提供的内容取决于 User-Agent 这样「常规 Accept 协商字段之外」的请求头字段，那么响应头中必须包含 Vary 字段，且 Vary 的内容必须包含 User-Agent。同理，如果服务端同时使用请求头中 User-Agent 和 Cookie 这两个字段来生成内容，那么响应中的 Vary 字段看上去应该是这样的：</p>
<pre><code>Vary: User-Agent, Cookie
</code></pre>
<p>也就是说 Vary 字段用于列出一个响应字段列表，告诉缓存服务器遇到同一个 URL 对应着不同版本文档的情况时，如何缓存和筛选合适的版本。</p>
<ul>
<li><p>在Okhttp中的解决方法<br>上面返回乱码的原因就是没有正确解压Gzip的数据，</p>
</li>
<li><p>分析：<br>在 Okhttp 中，如果在请求头添加addHeader(“Accept-Encoding”, “gzip, deflate”)，Okhttp 不会帮你处理Gzip的解压，需要你自己去处理。</p>
</li>
</ul>
<p>部分源码如下：</p>
<pre><code>boolean transparentGzip = false;
if (userRequest.header(&quot;Accept-Encoding&quot;) == null)
&#123;
  transparentGzip = true;
  requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);
&#125;

if (transparentGzip &amp;&amp;
 &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))
    &amp;&amp; HttpHeaders.hasBody(networkResponse))
&#123;
  GzipSource responseBody = new GzipSource(networkResponse.body().source());
  Headers strippedHeaders = networkResponse.headers().newBuilder()
      .removeAll(&quot;Content-Encoding&quot;)
      .removeAll(&quot;Content-Length&quot;)
      .build();
  responseBuilder.headers(strippedHeaders);
  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
&#125;
</code></pre>
<ul>
<li>解决方法：<br>把Request的header中去掉header(“Accept-Encoding”)就行了</li>
</ul>
<p>通过Request.Builder.tag(“url”)来打tag，然后通过下述代码即可做到cancel某一个Request的功能，你需要做的只是返回url就行了。</p>
<pre><code>public static void cancelCallWithTag(String tag) &#123;
    for (Call call : RequestApi2.getInstance().getOkHttpClient().dispatcher().queuedCalls()) &#123;
        if (call.request().tag().equals(tag))
            call.cancel();
    &#125;
    for (Call call : RequestApi2.getInstance().getOkHttpClient().dispatcher().runningCalls()) &#123;
        if (call.request().tag().equals(tag))
            call.cancel();
    &#125;
&#125;
</code></pre>
<p>有朋友可能想到，如果在header添加”Accept-Encoding”, “gzip, deflate”，返回的是gzip压缩的数据，自己解压可不可以？<br>使用其他的http库，可以拿到最原始的http数据，是可以的。但使用okhttp，返回的字符串是经过编码的，此时已经不是gzip数据格式了，所以没法解压。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Axure RP下载及汉化</title>
    <url>/2023/04/19/Axure%E4%B8%8B%E8%BD%BD%E5%8F%8A%E6%B1%89%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Axure-RP"><a href="#Axure-RP" class="headerlink" title="Axure RP"></a>Axure RP</h1><p>Axure RP 是一款专业的快速原型设计工具。Axure（发音：Ack-sure），代表美国Axure公司；RP则是Rapid Prototyping（快速原型）的缩写。<br>Axure RP 是美国Axure Software Solution 公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或Web网站的线框图、流程图、原型和规格说明文档。</p>
<p>作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。<br>Axure RP 的使用者主要包括商业分析师、信息架构师、产品经理、IT咨询师、用户体验设计师、交互设计师、UI设计师等，另外，架构师、程序员也在使用Axure。</p>
<h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><p><a href="https://www.axure.com/release-history">https://www.axure.com/release-history</a><br><a href="https://www.axure.com/release-history/rp8">https://www.axure.com/release-history/rp8</a><br><a href="https://www.axure.com/release-history/rp9">https://www.axure.com/release-history/rp9</a><br><a href="https://www.axure.com/release-history/rp7">https://www.axure.com/release-history/rp7</a></p>
<h1 id="汉化资源"><a href="#汉化资源" class="headerlink" title="汉化资源"></a>汉化资源</h1><p>Axure中文网<br><a href="https://www.axure.com.cn/78629">https://www.axure.com.cn/78629</a><br><a href="https://www.axure.com.cn/84384">https://www.axure.com.cn/84384</a></p>
<p>汉化资源使用方法，以 Axure RP 9 为例：</p>
<ul>
<li><p>【使用方法】<br>1、将汉化压缩包解压缩。<br>2、将解压缩后的【lang文件夹】复制粘贴到软件安装根目录下。</p>
</li>
<li><p>【Windows系统汉化路径】<br>以Win7-64位系统为例：C:\Program Files (x86)\Axure\Axure RP 9</p>
</li>
<li><p>【Mac系统汉化路径】<br>以中文版为例：前往–应用程序–右键点击程序图标–显示包内容，依次打开文件夹：Contents&gt;Resources&gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>Axure RP</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构浅谈（一）</title>
    <url>/2023/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构主要描述数据之间的关系，每一个数据可以称之为数据元素，一般以结构体或类来描述。</p>
<p>数据元素的内部组成，一般基础数据类型或复合数据类型。<br>基础数据类型大体可以分为：数值型,字符串型和日期时间型。复合数据类型又分为结构体、联合体。</p>
<p>数据元素之间的关系，从表现形式来看，可以分为四种：离散结构、线性结构、树形结构、图形结构。从组织方式来看，可以分为两种：数组和链表。</p>
<p>一般研究讨论的都是线性结构、树形结构、图形结构。<br>1、线性结构：元素之间是“一对一”的关系，典型有：队列、栈。<br>2、树形结构：元素之间是“一对多”的关系，典型有：树，堆。<br>3、图形结构：元素之间是“多对多”的关系。</p>
<p>数组是申请连续的数据块，查找快捷。链表则是离散数据块，元素之间要记录相互关系，增删方便，</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL性能优化</title>
    <url>/2023/04/17/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h1><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有:<br>select_type : 查询类型，有简单查询、联合查询、子查询等<br>key : 使用的索引<br>rows : 扫描的行数</p>
<h1 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h1><h2 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h2><p>只返回必要的列: 最好不要使用 SELECT * 语句。<br>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。<br>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</p>
<h2 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h2><p>最有效的方式是使用索引来覆盖查询。</p>
<h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><ul>
<li><ol>
<li>切分大查询</li>
</ol>
</li>
</ul>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<pre><code>DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);

rows_affected = 0
do &#123;
    rows_affected = do_query(
    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)
&#125; while rows_affected &gt; 0
</code></pre>
<ul>
<li><ol start="2">
<li>分解大连接查询</li>
</ol>
</li>
</ul>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。减少锁竞争；在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</p>
<pre><code>SELECT * FROM tab
    JOIN tag_post ON tag_post.tag_id=tag.id
    JOIN post ON tag_post.post_id=post.id
    WHERE tag.tag=&#39;mysql&#39;;

SELECT * FROM tag WHERE tag=&#39;mysql&#39;;
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
</code></pre>
<hr>
<p>著作权归@pdai所有<br>原文链接：<a href="https://pdai.tech/md/db/sql-mysql/sql-mysql-performance.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-performance.html</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle性能分析总结（转载）</title>
    <url>/2023/04/16/Oracle%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于Oracle的性能调整，一般包括两个方面。</p>
<p>一是指Oracle数据库本身的调整，比如SGA、PGA的优化设置，</p>
<p>二是连接Oracle的应用程序以及SQL语句的优化。</p>
<p>做好这两个方面的优化，就可以使一套完整的Oracle应用系统处于良好的运行状态。</p>
<p>本文主要是把一些OracleTuning的文章作了一个简单的总结，力求以实际可操作为目的，配合讲解部分理论知识，使大部分具有一般Oracle知识的使用者能够对Oracle Tuning有所了解，并且能够根据实际情况对某些参数进行调整。关于更加详细的知识，请参见本文结束部分所提及的推荐书籍，同时由于该话题内容太多且复杂，本文必定有失之偏颇甚至错误的地方，请不吝赐教，并共同进步。</p>
<ol>
<li> SGA的设置<br>在OracleTuning中，对SGA的设置是关键。SGA，是指Shared Global Area , 或者是System Global Area , 称为共享全局区或者系统全局区，结构如下图所示。</li>
</ol>
<p>对于SGA区域内的内存来说，是共享的、全局的，在UNIX 上，必须为oracle 设置共享内存段（可以是一个或者多个），因为oracle 在UNIX上是多进程；而在WINDOWS上oracle是单进程（多个线程），所以不用设置共享内存段。</p>
<p>1.1  SGA的各个组成部分<br>下面用 sqlplus 查询举例看一下 SGA 各个组成部分的情况：</p>
<pre><code>SQL&gt; select * from v$sga;
NAME                     VALUE
--------------------             ----------
FixedSize                  104936
VariableSize             823164928
Database Buffers         1073741824
RedoBuffers                172032
</code></pre>
<p>或者</p>
<pre><code>SQL&gt; show sga
Total System Global Area   1897183720 bytes
FixedSize                  104936 bytes
VariableSize             823164928 bytes
Database Buffers         1073741824 bytes
RedoBuffers                172032 bytes
</code></pre>
<p>Fixed Size</p>
<p>oracle 的不同平台和不同版本下可能不一样，但对于确定环境是一个固定的值，里面存储了SGA 各部分组件的信息，可以看作引导建立SGA的区域。</p>
<p>Variable Size</p>
<p>包含了shared_pool_size、java_pool_size、large_pool_size 等内存设置</p>
<p>Database Buffers</p>
<p>指数据缓冲区，在8i 中包含db_block_buffer*db_block_size、buffer_pool_keep、buffer_pool_recycle 三部分内存。在9i 中包含db_cache_size、db_keep_cache_size、db_recycle_cache_size、db_nk_cache_size。</p>
<p>Redo Buffers</p>
<p>指日志缓冲区，log_buffer。在这里要额外说明一点的是，对于v$parameter、v$sgastat、v$sga查询值可能不一样。v$ parameter 里面的值，是指用户在初始化参数文件里面设置的值，v$sgastat是oracle 实际分配的日志缓冲区大小（因为缓冲区的分配值实际上是离散的，也不是以block 为最小单位进行分配的），v$sga 里面查询的值，是在oracle 分配了日志缓冲区后，为了保护日志缓冲区，设置了一些保护页，通常我们会发现保护页大小是8k(不同环境可能不一样)。参考如下内容</p>
<pre><code>SQL&gt; select substr(name,1,10) name,substr(value,1,10) value
       2 from v$parameter where name =&#39;log_buffer&#39;;
NAME                VALUE
--------------------  --------------------
log_buffer             163840

SQL&gt; select * from v$sgastat where pool is null;

POOL       NAME                      BYTES
-------------------------------------               ----------
           fixed_sga                     104936
           db_block_buffers           1073741824
           log_buffer                    163840

SQL&gt; select * from v$sga;

NAME                     VALUE
--------------------             ----------
FixedSize                  104936
VariableSize              823164928
Database Buffers          1073741824
RedoBuffers                172032
</code></pre>
<p>172032 – 163840 = 8192</p>
<p>（以上试验数据是在 HPB.11.11 + Oracle 8.1.7.4 环境下得到的）</p>
<p>1.2  SGA的大小设置</p>
<p>在对SGA的结构进行简单分析以后，下面是关于如何根据系统的情况正确设置SGA大小的问题。<br>SGA是一块内存区域，占用的是系统物理内存，因此对于一个Oracle应用系统来说，SGA决不是越大越好，这就需要寻找一个系统优化的平衡点。</p>
<p>1.2.1  设置参数前的准备<br>在设置SGA的内存参数之前，我们首先要问自己几个问题<br>一：物理内存多大<br>二：操作系统估计需要使用多少内存<br>三：数据库是使用文件系统还是裸设备<br>四：有多少并发连接<br>五：应用是OLTP 类型还是OLAP 类型</p>
<p>根据这几个问题的答案，我们可以粗略地为系统估计一下内存设置。那我们现在来逐个问题地讨论，首先物理内存多大是最容易回答的一个问题，然后操作系统估计使用多少内存呢？从经验上看，不会太多，通常应该在200M 以内（不包含大量进程PCB）。<br>接下来我们要探讨一个重要的问题，那就是关于文件系统和裸设备的问题，这往往容易被我们所忽略。操作系统对于文件系统，使用了大量的buffer 来缓存操作系统块。这样当数据库获取数据块的时候，虽然SGA 中没有命中，但却实际上可能是从操作系统的文件缓存中获取的。而假如数据库和操作系统支持异步IO，则实际上当数据库写进程DBWR写磁盘时，操作系统在文件缓存中标记该块为延迟写，等到真正地写入磁盘之后，操作系统才通知DBWR写磁盘完成。对于这部分文件缓存，所需要的内存可能比较大，作为保守的估计，我们应该考虑在 0.2——0.3 倍内存大小。但是如果我们使用的是裸设备，则不考虑这部分缓存的问题。这样的情况下SGA就有调大的机会。<br>关于数据库有多少并发连接，这实际上关系到PGA 的大小（MTS 下还有large_pool_size）。事实上这个问题应该说还跟OLTP 类型或者OLAP 类型相关。对于OLTP类型oracle 倾向于可使用MTS,对于OLAP 类型使用独立模式，同时OLAP 还可能涉及到大量的排序操作的查询，这些都影响到我们内存的使用。那么所有的问题综合起来，实际上主要反映在UGA的大小上。UGA主要包含以下部分内存设置</p>
<pre><code>SQL&gt; show parameters area_size

NAME                                TYPE    VALUE
------------------------------------              -------     --------
bitmap_merge_area_size                  integer    1048576
create_bitmap_area_size                  integer    8388608
hash_area_size                          integer     131072
sort_area_size                           integer     65536
SQL&gt;
</code></pre>
<p>在这部分内存中我们最关注的通常是sort_area_size，这是当查询需要排序的时候，数据库会话将使用这部分内存进行排序，当内存大小不足的时候，使用临时表空间进行磁盘排序。由于磁盘排序效率和内存排序效率相差好几个数量级，所以这个参数的设置很重要。<br>当出现大量排序时的磁盘I/O操作时，可以考虑增加sort_area_size的值。sort_area_size是Oracle用于一次排序所需的最大内存数，在排序结束但是结果列返回之前，Oracle会释放sort_area_size大小的内存，但是会保留 sort_area_retained_size大小的内存，知道最后一行结果列返回以后，才释放所有的内存。<br>会导致排序的语句有 SELECT DISTINCT , MINUS , INTERSECT , UNION 和 min()、max()、count() 操作；而不会导致排序的语句有 UPDATE , 带BETWEEN子句的SELECT 等等。<br>这四个参数都是针对会话进行设置的，是单个会话使用的内存的大小，而不是整个数据库使用的。偶尔会看见有人误解了这个参数以为是整个数据库使用的大小，这是极其严重的错误。假如设置了MTS，则UGA被分配在large_pool_size，也就是说放在了共享内存里面，不同进程（线程）之间可以共享这部分内存。在这个基础上，我们假设数据库存在并发执行server process 为100 个，根据上面我们4 个参数在oracle8.1.7 下的默认值，我们来计算独立模式下PGA 的大致大小。由于会话并不会经常使用create_bitmap_area_size、bitmap_merge_area_size，所以我们通常不对四个参数求和。在考虑到除这四个参数外会话所保存的变量、堆栈等信息，我们估计为 2M，则200 个进程最大可能使用200M 的PGA。</p>
<p>1.2.2  一个经验公式</p>
<p>现在，根据上面这些假定，我们来看SGA 实际能达到多少内存。在1G 的内存的服务器上，我们能分配给SGA 的内存大约为400—500M。若是2G 的内存，大约可以分到1G的内存给SGA，8G 的内存可以分到5G的内存给SGA。当然我们这里是以默认的排序部分内存sort_area_size=64k进行衡量的，假如我们需要调大该参数和 hash_area_size等参数，然后我们应该根据并发的进程的数量，来衡量考虑这个问题。</p>
<p>事实上，通常我们更习惯通过直观的公式化来表达这样的问题：<br>OS 使用内存+SGA+并发执行进程数*(sort_area_size+hash_ara_size+2M)&lt; 0.7*总内存</p>
<p>(公式是死的，系统是活的，实际应用的调整不必框公式，这不过是一个参考建议)</p>
<p>在我们的实际应用中，假如采用的是裸设备，我们可适当的增大SGA(如果需要的话)。由于目前几乎所有的操作系统都使用虚拟缓存，所以实际上如果就算SGA 设置的比较大也不会导致错误，而是可能出现频繁的内存页的换入与换出(page in/out)。在操作系统一级如果观察到这个现象，那么我们就需要调整内存的设置。</p>
<p>1.2.3  各个参数的设置<br>那么SGA中的各个参数具体应该按照什么样的原则来设置呢，下面进行讨论：<br>log_buffer<br>对于日志缓冲区的大小设置，通常我觉得没有过多的建议，因为参考LGWR写的触发条件之后，我们会发现通常超过3M意义不是很大。作为一个正式系统，可能考虑先设置这部分为log_buffer=1—3M 大小，然后针对具体情况再调整。<br>large_pool_size<br>对于大缓冲池的设置，假如不使用MTS，建议在20—30M 足够了。这部分主要用来保存并行查询时候的一些信息，还有就是RMAN 在备份的时候可能会使用到。如果设置了MTS，则由于UGA部分要移入这里，则需要具体根据session最大数量和 sort_ares_size 等相关会话内存参数的设置来综合考虑这部分大小的设置，一般可以考虑为session * (sort_area_size + 2M)。这里要提醒一点，不是必须使用MTS，我们都不主张使用MTS，尤其同时在线用户数小于500的情况下。。<br>java_pool_size<br>假如数据库没有使用JAVA，我们通常认为保留10—20M大小足够了。事实上可以更少，甚至最少只需要32k，但具体跟安装数据库的时候的组件相关(比如http server)。<br>shared_pool_size<br>这是迄今为止最具有争议的一部分内存设置。按照很多文档的描述，这部分内容应该几乎和数据缓冲区差不多大小。但实际上情况却不是这样的。首先我们要考究一个问题，那就是这部分内存的作用，是为了缓存已经被解析过的SQL，而使其能被重用，不再解析。这样做的原因是因为，对于一个新的SQL （shared_pool 里面不存在已经解析的可用的相同的SQL），数据库将执行硬解析，这是一个很消耗资源的过程。而若已经存在，则进行的仅仅是软分析（在共享池中寻找相同 SQL），这样消耗的资源大大减少。所以我们期望能多共享一些SQL，并且如果该参数设置不够大，经常会出现ora-04031错误，表示为了解析新的 SQL，没有可用的足够大的连续空闲空间，这样自然我们期望该参数能大一些。但是该参数的增大，却也有负面的影响，因为需要维护共享的结构，内存的增大也会使得SQL 的老化的代价更高，带来大量的管理的开销，所有这些可能会导致CPU 的严重问题。</p>
<p>在一个充分使用绑定变量的比较大的系统中，shared_pool_size的开销通常应该维持在300M 以内。除非系统使用了大量的存储过程、函数、包，比如oracleerp 这样的应用，可能会达到500M甚至更高。于是我们假定一个1G内存的系统，可能考虑设置该参数为100M，2G 的系统考虑设置为150M,8G 的系统可以考虑设置为200—300M。<br>对于一个没有充分使用或者没有使用绑定变量系统，这可能给我们带来一个严重的问题。所谓没有使用bind var 的SQL，我们称为Literal SQL。也就是比如这样的两句SQL我们认为是不同的SQL,需要进行2 次硬解析：<br>select * from EMP where name = ‘TOM’;<br>select * from EMP where name = ‘JERRY’;<br>假如把 ’TOM’ 和 ’JERRY’ 换做变量V，那就是使用了bind var，我们可以认为是同样的SQL 从而能很好地共享。共享SQL 本来就是shared_pool_size 这部分内存存在的本意，oracle的目的也在于此，而我们不使用bind var 就是违背了oracle 的初衷，这样将给我们的系统带来严重的问题。当然，如果通过在操作系统监控，没有发现严重的cpu问题，我们如果发现该共享池命中率不高可以适当的增加shred_pool_size。但是通常我们不主张这部分内存超过800M（特殊情况下可以更大）。<br>事实上，可能的话我们甚至要想办法避免软分析，这在不同的程序语言中实现方式有差异。我们也可能通过设置session_cached_cursors 参数来获得帮助（这将增大PGA）<br>关于使用绑定变量的话题，在下面的应用优化中继续讨论。</p>
<p>Data buffer<br>现在我们来谈数据缓冲区，在确定了SGA 的大小并分配完了前面部分的内存后，其余的，都分配给这部分内存。通常，在允许的情况下，我们都尝试使得这部分内存更大。这部分内存的作用主要是缓存 DB BLOCK，减少甚至避免从磁盘上获取数据，在8i中通常是由db_block_buffers*db_block_size 来决定大小的。如果我们设置了buffer_pool_keep 和buffer_pool_recycle，则应该加上后面这两部分内存的大小。</p>
<p>可以看出，设置SGA时基本上应该掌握的原则是：<br>  data buffer 一般可以尽可能的大<br>  shared_pool_size 应该适度<br>  log buffer 在 1MB 以内就可以了</p>
<p>假定oracle是 32 bit ,服务器RAM大于2G ，注意你的PGA的情况，,则建议<br>shared_pool_size + data buffer +large_pool_size + java_pool_size &lt; 1.6G</p>
<p>再具体化，如果512M RAM<br>建议 shared_pool_size = 50M, data buffer = 200M</p>
<p>如果1G RAM<br>shared_pool_size = 100M , data buffer = 500M</p>
<p>如果2G RAM<br>shared_pool_size = 150M ,data buffer = 1.2G</p>
<p>物理内存再大已经跟参数没有关系了</p>
<p>假定64 bit ORACLE<br>内存4G<br>shared_pool_size = 200M , data buffer = 2.5G</p>
<p>内存8G<br>shared_pool_size = 300M , data buffer = 5G</p>
<p>内存 12G<br>shared_pool_size = 300M—–800M , data buffer = 8G</p>
<p>1.3  32bit 与 64bit 对SGA的影响<br>为什么在上面SGA大小设置的经验规则中要分 32bit Oracle 和 64bit Oracle 呢，是因为这关系到SGA大小的上限问题。在32bit的数据库下，通常oracle只能使用不超过1.7G的内存，即使我们拥有12G的内存，但是我们却只能使用1.7G，这是一个莫大的遗憾。假如我们安装64bit的数据库,我们就可以使用很大的内存，几乎不可能达到上限。但是64bit的数据库必须安装在64bit 的操作系统上，可惜目前windows上只能安装32bit的数据库，我们通过下面的方式可以查看数据库是32bit 还是 64bit ：</p>
<pre><code>SQL&gt; select * from v$version;
BANNER
----------------------------------------------------------------
Oracle8i Enterprise Edition Release 8.1.7.0.0 - Production
PL/SQL Release 8.1.7.0.0 - Production
CORE 8.1.7.0.0 Production
TNS for 32-bit Windows: Version 8.1.7.0.0 - Production
NLSRTL Version 3.4.1.0.0 – Production
</code></pre>
<p>在UNIX平台下的显示有所不同，明显可以看出是 64bit Oracle ，比如在HP-UX平台上：</p>
<pre><code>SQL&gt; select * from v$version;

BANNER
----------------------------------------------------------------
Oracle8i Enterprise Edition Release 8.1.7.4.0 - 64bit Production
PL/SQL Release 8.1.7.4.0 - Production
CORE    8.1.7.0.0       Production
TNS for HPUX: Version 8.1.7.4.0 - Production
NLSRTL Version 3.4.1.0.0 – Production
</code></pre>
<p>32bit的oracle无论跑在32bit或者64bit的平台都有SGA的限制的，而对于32bit的平台只能跑32bit的oracle，但是在特定的操作系统下，可能提供了一定的手段，使得我们可以使用超过1.7G 的内存，达到2G 以上甚至更多。由于我们现在一般都使用64bit Oracle，因此关于如何在32bit平台上扩展SGA大小的问题不再赘述。</p>
<p>1.4  9i中相关参数的变化<br>oracle的版本的更新，总是伴随着参数的变化，并且越来越趋向于使得参数的设置更简单，因为复杂的参数设置使得DBA们经常焦头烂额。关于内存这部分的变化，我们可以考察下面的参数。事实上在9i中数据库本身可以给出一组适合当前运行系统的SGA相关部分的参数调整值（参考V$ DB_CACHE_ADVICE、V$SHARED_POOL_ADVICE），关于PGA也有相关视图V$PGA_TARGET_ADVICE 等。</p>
<p>Data buffer<br>9i 中保留了8i中的参数，如设置了新的参数，则忽略旧的参数。9i中用db_cache_size来取代db_block_buffers ， 用db_keep_cache_size 取代buffer_pool_keep,用db_recycle_cache_size 取代buffer_pool_recycle；这里要注意9i 中设置的是实际的缓存大小而不再是块的数量。另外9i新增加了db_nk_cache_size，这是为了支持在同一个数据库中使用不同的块大小而设置的。对于不同的表空间，可以定义不同的数据块的大小，而缓冲区的定义则依靠该参数的支持。其中n 可以为2、4、6、8、16 等不同的值。在这里顺便提及的一个参数就是db_block_lru_latches，该参数在9i中已经成为了保留参数，不推荐手工设置。</p>
<p>PGA<br>在9i 里面这部分也有了很大的变化。在独立模式下，9i已经不再主张使用原来的UGA相关的参数设置，而代之以新的参数。假如workarea_size_policy=AUTO（缺省），则所有的会话的UGA 共用一大块内存，该内存由 pga_aggregate_target 设置。在我们根据前面介绍的方法评估了所有进程可能使用的最大PGA 内存之后，我们可以通过在初始化参数中设置这个参数，从而不再关心其他”*_area_size” 参数。</p>
<p>SGA_MAX_SIZE<br>在9i中若设置了SGA_MAX_SIZE，则在总和小于等于这个值内，可以动态的调整数据缓冲区和共享池的大小</p>
<pre><code>SQL&gt; show parameters sga_max_size
NAME      TYPE            VALUE
---------------- -------------------- ------- -------------
sga_max_size  unknown        193752940
SQL&gt;
SQL&gt; alter system set db_cache_size = 30000000;
System altered.
SQL&gt; alter system set shared_pool_size = 20480000;
System altered.
</code></pre>
<p>1.5  lock_sga = true 的问题<br>由于几乎所有的操作系统都支持虚拟内存，所以即使我们使用的内存小于物理内存，也不能避免操作系统将SGA 换到虚拟内存（SWAP）。所以我们可以尝试使得SGA 锁定在物理内存中不被换到虚拟内存中，这样减少页面的换入和换出，从而提高性能。但在这里遗憾的是，windows 是无法避免这种情况的。下面我们来参考在不同的几个系统下怎么实现lock_sga</p>
<pre><code>AIX 5L（AIX 4.3.3 以上）
logon aix as root
cd /usr/samples/kernel
./vmtune (信息如下) v_pingshm已经是1
./vmtune -S 1
</code></pre>
<p>然后oracle用户修改initSID.ora 中 lock_sga = true<br>重新启动数据库</p>
<pre><code>HP UNIX
Root身份登陆
Create the file &quot;/etc/privgroup&quot;: vi /etc/privgroup
Add line &quot;dba MLOCK&quot; to file
As root, run the command &quot;/etc/setprivgrp -f /etc/privgroup&quot;:
$/etc/setprivgrp -f /etc/privgroup
oracle用户修改initSID.ora中lock_sga=true
</code></pre>
<p>重新启动数据库</p>
<p>SOLARIS (solaris2.6以上)<br>8i版本以上数据库默认使用隐藏参数 use_ism = true ，自动锁定SGA于内存中,不用设置lock_sga, 如果设置 lock_sga =true 使用非 root 用户启动数据库将返回错误。</p>
<p>WINDOWS<br>不能设置lock_sga=true,可以通过设置pre_page_sga=true,使得数据库启动的时候就把所有内存页装载，这样可能起到一定的作用。</p>
<ol start="2">
<li> 应用优化<br>下面我们从技术的角度入手，来探讨数据库优化方面的问题。通常作为优化Oracle系统的人，或者是DBA，其实很多时候对应用并不很了解甚至可以说是完全不了解，更不要说对应用程序代码的了解。事实上呢，一个系统运行的快或者慢相信大家都明白，第一重要的是数据库的设计，然后是应用的设计， SQL语句的编写，最后才是数据库参数的调整和硬件、网络的问题，等等。所以在我们不了解一个系统的时候来优化数据库应用不是一个轻松的容易的事情。那么我们第一步应该怎么做呢？<br>通常有两类方法：<br>其中一个方法就是我们常用的，使用statspack来进行诊断系统的瓶颈所在。在statspack中oracle给出了几乎涵盖oracle大部分重要内容的信息。<br>另外一种方式，就是trace session。假如某个session运行很慢或者某个用户的某个查询很慢，那么这个时候我们可以通过trace session的方式来诊断到底是慢在哪里，看究竟执行计划是怎样的，然后在user_dump_dest下根据该session的进程号或者线程号可以找到一个产生的trace文件。通过使用tkprof格式化文件之后我们就可以看见很多的统计信息，这里包括了执行计划、parse/fetch等步骤消耗cpu的时间。通常我们是观察query模式下的consistent gets来首先看sql是否使用了索引，然后看执行计划是不是正常，是不是有调整的余地。当然如果您没有实际做过的话，这些内容说起来很抽象。这是在不了解应用和程序下针对特定session的诊断和调整过程。<br>trace session的方式是一种自下而上的方法，从sql入手；而statspack是自顶向下的方法，也就是从宏观上先诊断数据库的瓶颈在哪里，然后从瓶颈入手来做调整，这个习惯上又可以称为通过等待事件（wait event）入手的方法。</li>
</ol>
<p>2.1  使用statspack<br>statspack是一个性能诊断工具，首先发布于Oracle8.1.6版本，在8.1.7版本中功能得到加强。Statspack除了查找实例中的性能问题外，还可以查找应用程序中高负荷的SQL语句，很容易确定Oracle 数据库的瓶颈所在，并且记录数据库性能状态。<br>在数据库中Statspack 的脚本位于$ORACLE_HOME/RDBMS/ADMIN 目录下，对于ORACLE8.1.6,是一组以stat 开头的文件；对于ORACLE8.1.7,是一组以sp 开头的文件。<br>在Statspack 发布之前，我们通常能够使用诊断数据库的工具是两个脚本UTLBSTAT.SQL和UTLESTAT.SQL，BSTAT/ESTAT 是一个非常简单的性能诊断工具。UTLBSTAT 获得开始时很多V$视图的快照，UTLESTAT 通过先前的快照和当前视图生成一个报表。<br>该报表实际上相当于statspack 中的两个采样点。<br>Statspack 通过连续的采样，能够给我们提供至关重要的趋势分析数据。这是一个巨大的进步。能够使用Statspack 的环境我们就尽量不要使用BSTAT/ESTAT 的方式来诊断数据库问题。</p>
<p>2.1.1  安装statapack<br>§ 步骤一：<br>为了能够顺利安装和运行Statspack ，首先需要设置以下两个系统参数：</p>
<ol>
<li><p>job_queue_processes<br>为了能够建立自动任务，执行数据收集，该参数需要大于0。你可以在初试化参数文件中修改该参数(使该参数在重起后以然有效)。<br>该参数可以在系统级动态修改(重起后失效)。</p>
<p> SQL&gt; alter system setjob_queue_processes = 6;<br> System altered</p>
</li>
</ol>
<p>在Oracle9i 当中，可以指定范围，如 both,这样该修改在当前及之后保持有效(仅当你使用spfile 时，如果在9i 中仍然使用pfile，那么更改方法同8i 相同):</p>
<pre><code>SQL&gt; alter system setjob_queue_processes = 6 scope=both;
System altered
</code></pre>
<ol start="2">
<li><p>timed_statistics<br>收集操作系统的计时信息，这些信息可被用来显示时间等统计信息、优化数据库和 SQL 语句。要防止因从操作系统请求时间而引起的开销，请将该值设置为False。<br>使用statspack 收集统计信息时建议将该值设置为 TRUE，否则收集的统计信息大约只能起到10%的作用，将timed_statistics 设置为True 所带来的性能影响与好处相比是微不足道的。<br>该参数使收集的时间信息存储在在V$SESSTATS 和V$SYSSTATS 等动态性能视图中。<br>timed_statistics 参数也可以在实例级进行更改</p>
<p> SQL&gt; alter system settimed_statistics = true;<br> System altered</p>
</li>
</ol>
<p>如果你担心一直启用timed_statistics 对于性能的影响，你可以在使用statspack 之前在system 更改，采样过后把该参数动态修改成false。</p>
<p>§ 步骤二：<br>需要单独为statspack创建一个存储数据的表空间，如果采样间隔较短，周期较长，打算长期使用，那么可能需要一个大一点的表空间，如果每个半个小时采样一次，连续采样一周，数据量是很大的。下面的例子中创建了一个500M 的测试表空间。<br>注意: 这里创建的表空间不能太小，如果太小的话创建对象会失败，建议至少建立100M 表空间。</p>
<pre><code>SQL&gt; create tablespace perfstat
2 datafile &#39;/oracle/oradata/oradata/res/perfstat.dbf&#39;
3 size 500M;
Tablespace created。
</code></pre>
<p>§ 步骤三：<br>在 sqlplus 中用internal 身份登陆，或者拥有SYSDBA(connect / as sysdba)权限的用户登陆。<br>注: 在Oracle9i 中，不存在internal 用户，可以使用sys 用户以sysdba 身份连接。<br>先转到$ORACLE_HOME/RDBMS/ADMIN 目录，检查安装脚本是否存在，同时我们执行脚本也可以方便些。</p>
<pre><code>$ cd $ORACLE_HOME/rdbms/admin
$ ls -l sp*.sql
-rw-r--r--   1 oracle  other       1774 Feb 18  2000 spauto.sql
-rw-r--r--   1 oracle   other     62545 Jun 15  2000 spcpkg.sql
-rw-r--r--   1 oracle  other        877 Feb 18  2000spcreate.sql
-rw-r--r--   1 oracle   other     31193 Jun 15  2000 spctab.sql
-rw-r--r--   1 oracle  other       6414 Jun 15  2000 spcusr.sql
-rw-r--r--   1 oracle  other        758 Jun 15  2000spdrop.sql
-rw-r--r--   1 oracle  other       3615 Jun 15  2000 spdtab.sql
-rw-r--r--   1 oracle  other       1274 Jun 15  2000 spdusr.sql
-rw-r--r--   1 oracle  other       6760 Jun 15  2000 sppurge.sql
-rw-r--r--   1 oracle   other     71034 Jul 12  2000 spreport.sql
-rw-r--r--   1 oracle  other       2191 Jun 15  2000 sptrunc.sql
-rw-r--r--   1 oracle   other     30133 Jun 15  2000 spup816.sql
$
</code></pre>
<p>接下来我们就可以开始安装Statspack 了。在Oracle8.1.6 版本中运行statscre.sql; 在Oracle8.1.7 版本中运行spcreate.sql。<br>这期间会提示你输入缺省表空间和临时表空间的位置,输入我们为 perfstat 用户创建的表空间和你的临时表空间。安装脚本会自动创建perfstat 用户。</p>
<pre><code>$ sqlplus

SQL*Plus: Release 8.1.7.0.0 - Productionon Sat Jul 26 16:27:31 2003

(c) Copyright 2000 OracleCorporation.  All rights reserved.

Enter user-name: internal

Connected to:
Oracle8i Enterprise Edition Release 8.1.7.0.0 - Production
With the Partitioning option
JServer Release 8.1.7.0.0 - Production

SQL&gt;
SQL&gt; @spcreate
... Installing Required Packages

Package created.

Grant succeeded.

View created.

Package body created.

Package created.

Synonym dropped.

Synonym created.
……

Specify PERFSTAT user&#39;sdefault   tablespace
Enter value for default_tablespace: perfstat
Using perfstat for the default tablespace

User altered.

User altered.

Specify PERFSTAT user&#39;s temporarytablespace
Enter value for temporary_tablespace: temp
Using temp for the temporary tablespace

User altered.

NOTE:
SPCUSR complete. Please check spcusr.lis for any errors.

……
</code></pre>
<p>如果安装成功，你可以接着看到如下的输出信息：</p>
<pre><code>….
Creating Package STATSPACK...

Package created.

No errors.
Creating Package Body STATSPACK...

Package body created.

No errors.

NOTE:
SPCPKG complete. Please check spcpkg.lis for any errors.
</code></pre>
<p>可以查看.lis 文件查看安装时的错误信息。</p>
<p>§ 步骤四：<br>如果安装过程中出现错误，那么可以运行spdrop.sql 脚本来删除这些安装脚本建立的对象。然后重新运行spcreate.sql来创建这些对象。</p>
<pre><code>SQL&gt; @spdrop
Dropping old versions (if any)

Synonym dropped.

Sequence dropped.

Synonym dropped.

Table dropped.

Synonym dropped.

View dropped.
……
NOTE:
SPDUSR complete. Please check spdusr.lis for any errors.
</code></pre>
<p>（以上的安装过程描述是在 HP 11.11 + Oracle8.1.7 平台上得到的）</p>
<p>2.1.2  测试statspack<br>运行statspack.snap 可以产生系统快照，运行两次，然后执行spreport.sql就可以生成一个基于两个时间点的报告。<br>如果一切正常，说明安装成功。</p>
<pre><code>SQL&gt;execute statspack.snap
PL/SQL procedure successfully completed.
SQL&gt;execute statspack.snap
PL/SQL procedure successfully completed.
SQL&gt;@spreport.sql
</code></pre>
<p>可是有可能你会得到以下错误：</p>
<pre><code>SQL&gt; exec statspack.snap;
BEGIN statspack.snap; END;
*
ERROR at line 1:
ORA-01401: inserted value too large for column
ORA-06512: at &quot;PERFSTAT.STATSPACK&quot;, line 978
ORA-06512: at &quot;PERFSTAT.STATSPACK&quot;, line 1612
ORA-06512: at &quot;PERFSTAT.STATSPACK&quot;, line 71
ORA-06512: at line 1
</code></pre>
<p>这是Oracle 的一个Bug，Bug 号1940915。<br>该Bug 自8.1.7.3 后修正。<br>这个问题只会出现在多位的字符集, 需要修改spcpkg.sql 脚本，$ORACLE_HOME/rdbms/admin/spcpkg.sql，将”substr” 修改为”substrb”，然后重新运行该脚本。<br>该脚本错误部分：<br>select l_snap_id<br>, p_dbid<br>, p_instance_number<br>, substr(sql_text,1,31)<br>．．．．．．．．．．．<br>substr 会将多位的字符, 当作一个byte.substrb 则会当作多个byte。在收集数据时， statpack 会将 top10 的 sql 前 31 个字节 存入数据表中,若在SQL 的前31 个字有中文，就会出现此错误。<br>注意：运行 spcpkg.sql 也需要以 internal 用户登录 sqlplus</p>
<p>2.1.3  生成statspack报告<br>调用spreport.sql 可以生成分析报告：<br>当调用spreprot.sql 时，系统首先会查询快照列表，然后要求你选择生成报告的开始快照ID(begin_snap)和结束快照ID(end_snap),生成一个报告.<br>为了生成一个report,我们至少需要两次采样:</p>
<pre><code>SQL&gt; @spreport 

   DB Id    DBName      Inst Num Instance
-----------   ------------      -------- ------------
  2749170756RES             1      res

Completed Snapshots

                          Snap                   Snap
Instance     DBName         Id   SnapStarted    Level Comment
------------ ------------ ----- ----------------- ----- ----------------------
res         RES             1 26 Jul 2003 16:36     5
                             2 26 Jul 2003 16:37     5
                             3 26 Jul 2003 17:03     5

Specify the Begin and End Snapshot Ids
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter value for begin_snap:2</span><br><span class="line">Begin Snapshot Id specified: 2</span><br><span class="line"></span><br><span class="line">Enter value for end_snap: 3</span><br><span class="line">End   Snapshot Id specified: 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Specify the Report Name</span><br></pre></td></tr></table></figure>
The default report file name is sp_2_3.  To use this name,
press to continue, otherwise enter an alternative.
Enter value for report_name: rep0726.txt 

 ……

 Endof Report
</code></pre>
<p>在运行 spreport.sql 生成 statspack 报告的过程中，会有三个地方提示用户输入：<br>1、 开始快照ID；<br>2、 结束快照ID；<br>3、 输出报告文件的文件名，缺省的文件名是sp__<br>上面输入的开始快照ID是2，开始快照ID是3，输出报告文件的文件名是rep0726.txt<br>成功运行一次 statspack.snap 就会产生一个 snapshot ，在生成 statspack 报告的时候就可以看到这个 snap id 和 snap 运行的时间。运行 statspack.snap ，就是上面所说的采样，statspack 报告是分析两个采样点之间各种情况。</p>
<p>2.1.4  删除历史快照数据<br>前面讲过，成功运行一次 statspack.snap 就会产生一个 snapshot ，这个 snapshot 的基本信息是存放在 PERFSTAT.stats$snapshot 表中的，生成 statspack报告时会查询该表的数据，供用户选择准备分析的snapshot 。如果运行 statspack.snap 次数多了以后，该表的数据也会增加，历史数据会影响正常运行的效果，因此需要定时清理一下历史快照数据。<br>删除stats$snapshot 数据表中的相应数据，其他表中的数据会相应的级连删除：</p>
<pre><code>SQL&gt; select max(snap_id) fromstats$snapshot;
MAX(SNAP_ID)
------------
166

SQL&gt; delete from stats$snapshot wheresnap_id &lt; = 166;
143 rows deleted
</code></pre>
<p>你可以更改snap_id 的范围以保留你需要的数据。<br>在以上删除过程中，你可以看到所有相关的表都被锁定。</p>
<pre><code>SQL&gt; select a.object_id,a.oracle_username ,b.object_name
from v$locked_object a,dba_objects b
where a.object_id = b.object_id
/
OBJECT_ID ORACLE_USERNAME OBJECT_NAME
---------------------------------------------------------------------------------------------------------------------
156 PERFSTAT SNAP$
39700 PERFSTAT STATS$LIBRARYCACHE
39706 PERFSTAT STATS$ROLLSTAT
39712 PERFSTAT STATS$SGA
39754 PERFSTAT STATS$PARAMETER
39745 PERFSTAT STATS$SQL_STATISTICS
39739 PERFSTAT STATS$SQL_SUMMARY
39736 PERFSTAT STATS$ENQUEUESTAT
39733 PERFSTAT STATS$WAITSTAT
39730 PERFSTAT STATS$BG_EVENT_SUMMARY
39724 PERFSTAT STATS$SYSTEM_EVENT
39718 PERFSTAT STATS$SYSSTAT
39715 PERFSTAT STATS$SGASTAT
39709 PERFSTAT STATS$ROWCACHE_SUMMARY
39703 PERFSTAT STATS$BUFFER_POOL_STATISTICS
39697 PERFSTAT STATS$LATCH_MISSES_SUMMARY
39679 PERFSTAT STATS$SNAPSHOT
39682 PERFSTAT STATS$FILESTATXS
39688 PERFSTAT STATS$LATCH
174 PERFSTAT JOB$
20 rows selected
</code></pre>
<p>Oracle 还提供了系统脚本用于Truncate这些统计信息表，这个脚本名字是: sptrunc.sql (8i、9i 都相同)<br>该脚本主要内容如下，里面看到的就是statspack 相关的所有系统表：</p>
<pre><code>truncate table STATS$FILESTATXS;
truncate table STATS$LATCH;
truncate table STATS$LATCH_CHILDREN;
truncate table STATS$LATCH_MISSES_SUMMARY;
truncate table STATS$LATCH_PARENT;
truncate table STATS$LIBRARYCACHE;
truncate table STATS$BUFFER_POOL_STATISTICS;
truncate table STATS$ROLLSTAT;
truncate table STATS$ROWCACHE_SUMMARY;
truncate table STATS$SGA;
truncate table STATS$SGASTAT;
truncate table STATS$SYSSTAT;
truncate table STATS$SESSTAT;
truncate table STATS$SYSTEM_EVENT;
truncate table STATS$SESSION_EVENT;
truncate table STATS$BG_EVENT_SUMMARY;
truncate table STATS$WAITSTAT;
truncate table STATS$ENQUEUESTAT;
truncate table STATS$SQL_SUMMARY;
truncate table STATS$SQL_STATISTICS;
truncate table STATS$SQLTEXT;
truncate table STATS$PARAMETER;
delete from STATS$SNAPSHOT;
delete from STATS$DATABASE_INSTANCE;
commit;
</code></pre>
<p>2.1.5  一些重要脚本<br>1．通过导出保存及共享数据<br>在诊断系统问题时，可能需要向专业人士提供原始数据，这时我们可以导出Statspack 表数据，<br>其中我们可能用到：spuexp.par<br>其内容主要为：<br>file=spuexp.dmp log=spuexp.log compress=y grants=y indexes=y rows=yconstraints=y owner=PERFSTAT consistent=y<br>我们可以导出如下：<br>exp userid=perfstat/my_perfstat_password parfile=spuexp.par</p>
<p>2．删除数据<br>spdrop.sql 在执行时主要调用两个脚本: spdtab.sql 、spdusr.sql<br>前者删除表及同义词等数据，后者删除用户</p>
<p>3．Oracle92中新增加的脚本<br>1） 用于升级statspack 对象的脚本,这些脚本需要以具有SYSDBA 权限的用户运行, 升级前请先<br>备份存在的Schema 数据:<br>spup90.sql: 用于升级9.0 版本的模式至9.2 版本。<br>spup817.sql: 如果从Statspack 8.1.7 升级,需要运行这个脚本<br>spup816.sql: 从Statspack 8.1.6 升级,需要运行这个脚本，然后运行spup817.sql<br>2） sprepsql.sql 用于根据给定的SQL Hash 值生成SQL 报告</p>
<p>2.1.6  调整statspack的收集门限<br>Statspack 有两种类型的收集选项：</p>
<p>1．级别（level）：控制收集数据的类型<br>Statspack 共有三种快照级别，默认值是5<br>a. level 0: 一般性能统计。包括等待事件、系统事件、系统统计、回滚段统计、行缓存、SGA、会话、锁、缓冲池统计等等。<br>b. level 5: 增加SQL 语句。除了包括level0 的所有内容，还包括SQL 语句的收集，收集结果记录在stats$sql_summary 中。<br>c. level 10: 增加子锁存统计。包括level5 的所有内容。并且还会将附加的子锁存存入stats$lathc_children中。在使用这个级别时需要慎重，建议在Oracle support 的指导下进行。<br>可以通过statspack 包修改缺省的级别设置<br>SQL&gt;executestatspack.snap(i_snap_level=&gt;0,i_modify_parameter=&gt;’true’);<br>通过这样的设置，以后的收集级别都将是0 级。<br>如果你只是想本次改变收集级别，可以忽略i_modify_parameter 参数。<br>SQL&gt;execute statspack.snap(i_snap_level=&gt;10);</p>
<p>2．快照门限：设置收集的数据的阈值。<br>快照门限只应用于stats$sql_summary 表中获取的SQL 语句。<br>因为每一个快照都会收集很多数据，每一行都代表获取快照时数据库中的一个SQL 语句，所以stats$sql_summary 很快就会成为Statspack 中最大的表。<br>门限存储在stats$statspack_parameter 表中。让我们了结一下各种门限：<br>a. executions_th 这是SQL 语句执行的数量(默认值是100)<br>b. disk_reads_tn 这是SQL 语句执行的磁盘读入数量（默认值是1000）<br>c. parse_calls_th 这是SQL 语句执行的解析调用的数量（默认值是1000）<br>d. buffer_gets_th 这是SQL 语句执行的缓冲区获取的数量（默认值是10000）<br>任何一个门限值超过以上参数就会产生一条记录。<br>通过调用statspack.modify_statspack_parameter 函数我们可以改变门限的默认值。<br>例如：<br>SQL&gt;executestatspack.modify_statspack_parameter(i_buffer_gets_th=&gt;100000,i_disk_reads_th=&gt;100000;</p>
<p>2.2  对statspack报告的分析<br>从上面的描述可以看出，产生一个statspack报告是比较简单的，但是如何读懂statspack报告却不是那么容易，需要对Oracle的体系架构、内存结构、等待事件以及应用系统有充分的了解，加上不断的实践，才能基本读懂statspack报告并且从报告中找到调整优化Oracle的途径。<br>下面接合一个实际的statspack报告，大致分析一下。</p>
<p>2.2.1  基本信息分析</p>
<pre><code>DB Name         DB Id   Instance     Inst Num Release     OPSHost
------------ ----------- --------------------          --------------      ---------  ---
RES           2749170756res                1  8.1.7.0.0   NO  res

               Snap Id     Snap Time     Sessions
               ------- ------------------ --------
 Begin Snap:          226-Jul-03 16:37:08       38
   End Snap:          326-Jul-03 17:03:23       38
   Elapsed:                 26.25 (mins)
</code></pre>
<p>Statspack报告首先描述了数据库的基本情况，比如数据库名、实例名、实例个数、oracle版本号等等；然后是该报告的开始快照和结束快照的信息，包括 snapid , snap time 等等；最后是该报告经过的时间跨度，单位是分钟(mins)。</p>
<p>Cache Sizes</p>
<p>~~~~~~~~~~~<br>db_block_buffers:     61440         log_buffer:     163840<br>db_block_size:        8192     shared_pool_size:   52428800</p>
<p>然后描述了Oracle内存结构中几个重要的参数。</p>
<p>2.2.2  内存信息分析</p>
<pre><code>Load Profile
~~~~~~~~~~~~                      Per Second       Per Transaction
                                  ---------------       ---------------
             Redosize:             4,834.87            11,116.67
          Logicalreads:               405.53               932.43
          Blockchanges:                60.03               138.02
          Physicalreads:               138.63               318.75
          Physicalwrites:                54.27               124.79
          Usercalls:                    62.69               144.13
         Parses:                       19.14                44.00
          Hardparses:                   2.26                 5.20
                 Sorts:                 1.83                 4.20
                Logons:                 0.21                 0.47
              Executes:                21.10                48.50
           Transactions:                 0.43

  % Blocks changed perRead:   14.80    Recursive Call %:   34.45
 Rollback per transaction %:   0.00       Rows per Sort:   20.57
</code></pre>
<p>Redo size: 是日志的生成量，分为每秒和每事务所产生的，通常在很繁忙的系统中日志生成量可能达到上百k，甚至几百k；</p>
<p>Logical reads: 逻辑读实际上就是logical IO=buffer gets表示的含义，我们可以这样认为，block在内存中，我们每一次读一块内存，就相当于一次逻辑读；</p>
<p>Parses 和 Hardparses:  Parse 和 hard parse通常是很容易出问题的部分，80%的系统的慢都是由于这个原因所导致的。<br>所谓parse分soft parse 和hard parse，soft parse是当一条sql传进来后，需要在shared pool中找是否有相同的sql，如果找到了，那就是soft parse，如果没有找着，那就开始hard parse，实际上hard parse主要是检查该sql所涉及到的所有的对象是否有效以及权限等关系，hardparse之后才根据rule/cost模式生成执行计划，再执行sql。<br>而hard parse的根源，基本都是由于不使用bind var所导致的，不使用bind var违背了oracle的shared pool的设计的原则，违背了这个设计用来共享的思想，这样导致shared_pool_size里面命中率下降。因此不使用bind var，将导致cpu使用率的问题，极有使得性能急剧下降。<br>还有就是为了维护internal structure，需要使用latch，latch是一种Oracle低级结构,用于保护内存资源，是一种内部生命周期很短的lock，大量使用latch将消耗大量的cpu资源。</p>
<p>Sorts: 表示排序的数量；</p>
<p>Executes: 表示执行次数；</p>
<p>Transactions: 表示事务数量；</p>
<p>Rollback per transaction %: 表示数据库中事务的回退率。如果不是因为业务本身的原因，通常应该小于10%为好，回退是一个很消耗资源的操作。</p>
<pre><code>Instance Efficiency Percentages (Target 100%)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           Buffer Nowait%:  100.00       Redo NoWait %:  99.98
           Buffer Hit   %:   65.82    In-memory Sort%:   99.65
           LibraryHit   %:   91.32       Soft Parse %:   88.18
         Execute to Parse%:    9.28         LatchHit %:   99.99
Parse CPU to Parse Elapsd %:   94.61     %Non-Parse CPU:   99.90
</code></pre>
<p>Buffer Hit %: 数据缓冲区命中率，通常应该大于90%；</p>
<p>Library Hit %: libaray cache的命中率，通常应该大于98%；</p>
<p>In-memory Sort %: 排序在内存的比例，如果这个比例过小，可以考虑增大sort_area_size，使得排序在内存中进行而不是在temp表空间中进行；</p>
<p>Soft Parse %: 软解析的百分比，这个百分比也应该很大才好，因为我们要尽量减少hard parse。 soft parse 百分比=soft/(soft+hard)；</p>
<p>Execute to Parse %: 这个数字也应该是越大越好，接近100%最好。有些报告中这个值是负的，看上去很奇怪。事实上这表示一个问题，sql如果被age out的话就可能出现这种情况，也就是sql老化，或执行alter system flush shared_pool等。</p>
<pre><code>Shared Pool Statistics         Begin   End
                            ------   ------
         Memory Usage%:    90.63   87.19
   % SQL with executions&gt;1:   71.53   75.39
 % Memory for SQL w/exec&gt;1:  59.45   65.17
</code></pre>
<p>% SQL with executions&gt;1: 这个表示SQL被执行次数多于一次的比率，也应该大为好，小则表示很多sql只被执行了一次，说明没有使用bind var；</p>
<p>2.2.3  等待事件分析<br>接下来，statspack报告中描述的是等待事件（Wait Events），这是Oracle中比较复杂难懂的概念。<br>Oracle 的等待事件是衡量Oracle 运行状况的重要依据及指标。<br>等待事件的概念是在Oracle7.0.1.2 中引入的，大致有100 个等待事件。在Oracle 8.0 中这个数目增加到了大约150 个，在Oracle8i 中大约有200 个事件,在Oracle9i 中大约有360 个等待事件。<br>主要有两种类别的等待事件，即空闲（idle）等待事件和非空闲（non-idle）等待事件。<br>空闲事件指Oracle 正等待某种工作,在诊断和优化数据库的时候,我们不用过多注意这部分事件。<br>常见的空闲事件有:</p>
<pre><code>? dispatcher timer
? lock element cleanup
? Null event
? parallel query dequeue wait
? parallel query idle wait - Slaves
? pipe get
? PL/SQL lock timer
? pmon timer- pmon
? rdbms ipc message
? slave wait
? smon timer
? SQL*Net break/reset to client
? SQL*Net message from client
? SQL*Net message to client
? SQL*Net more data to client
? virtual circuit status
? client message
</code></pre>
<p>非空闲等待事件专门针对Oracle 的活动,指数据库任务或应用运行过程中发生的等待，这些等待事件是我们在调整数据库的时候应该关注与研究的。<br>一些常见的非空闲等待事件有:</p>
<pre><code>? db file scattered read
? db file sequential read
? buffer busy waits
? free buffer waits
? enqueue
? latch free
? log file parallel write
? log file sync
</code></pre>
<p>下面接合statspack中的一些等待事件进行讲述。</p>
<pre><code>Top 5 Wait Events
~~~~~~~~~~~~~~~~~                             Wait     % Total
Event                                   Waits  Time (cs)   Wt Time
--------------------------------------------          ------------ ------------    -------
db file scatteredread                     26,877       12,850   52.94
db file parallelwrite                        472        3,674   15.13
log file parallel write                        975        1,560    6.43
direct pathwrite                          1,571        1,543    6.36
control file parallelwrite                    652        1,290    5.31
         -------------------------------------------------------------
</code></pre>
<p>db file scattered read: DB文件分散读取。这个等待事件很常见，经常在top5中出现，这表示，一次从磁盘读数据进来的时候读了多于一个block的数据，而这些数据又被分散的放在不连续的内存块中，因为一次读进来的是多于一个block的。<br>通常来说我们可以认为是全表扫描类型的读，因为根据索引读表数据的话一次只读一个block，如果这个数字过大，就表明该表找不到索引，或者只能找到有限的索引，可能是全表扫描过多，需要检查sql是否合理的利用了索引，或者是否需要建立合理的索引。<br>当全表扫描被限制在内存时，它们很少会进入连续的缓冲区内，而是分散于整个缓冲存储器中。尽管在特定条件下执行全表扫描可能比索引扫描更有效，但如果出现这种等待时，最好检查一下这些全表扫描是否必要,是否可以通过建立合适的索引来减少对于大表全表扫描所产生的大规模数据读取。<br>对于经常使用的小表，应该尽量把他们pin 在内存中，避免不必要的老化清除及重复读取。</p>
<p>db file sequential read: DB文件连续读取。通常显示单个块的读取(通常指索引读取)，表示的是读进磁盘的block被放在连续的内存块中。<br>事实上大部分基本代表着单个block的读入，可以说象征着 IO 或者说通过索引读入的比较多。因为一次IO若读进多个的block，放入连续的内存块的几率是很小的，分布在不同block的大量记录被读入就会遇到此事件。因为根据索引读数据的话，假设100条记录，根据索引，不算索引本身的读，而根据索引每个值去读一下表数据，理论上最多可能产生100 buffer gets，而如果是full table scan，则100条数据完全可能在一个block里面，则几乎一次就读过这个block了，就会产生这么大的差异。<br>这种等待的数目很多时，可能显示表的连接顺序不佳，或者不加选择地进行索引。<br>对于高级事务处理（high-transaction）、调整良好（welltuned）的系统，这一数值很大是很正常的，但在某些情况下，它可能暗示着系统中存在问题。<br>你应当将这一等待统计量与Statspack 报告中的已知问题（如效率较低的SQL）联系起来。检查索引扫描，以保证每个扫描都是必要的，并检查多表连接的连接顺序。<br>DB_CACHE_SIZE 也是这些等待出现频率的决定因素。有问题的散列区域（Hash-area）连接应当出现在PGA 内存中，但它们也会消耗大量内存，从而在顺序读取时导致大量等待。它们也可能以直接路径读／写等待的形式出现。</p>
<p>Free Buffer Wait: 释放缓冲区。<br>这种等待表明系统正在等待内存中的缓冲，因为内存中已经没有可用的缓冲空间了。如果所有SQL 都得到了调优，这种等待可能表示你需要增大DB_BUFFER_CACHE。释放缓冲区等待也可能表示不加选择的SQL 导致数据溢出了带有索引块的缓冲存储器，没有为等待系统处理的特定语句留有缓冲区。<br>这种情况通常表示正在执行相当多数量的DML（插入／更新／删除），并且可能说明DBWR 写的速度不够快，缓冲存储器可能充满了相同缓冲器的多个版本，从而导致效率非常低。为了解决这个问题，可能需要考虑增加检查点、利用更多的DBWR 进程，或者增加物理磁盘的数量。</p>
<p>Buffer Busy Wait: 缓冲区忙。<br>该等待事件表示正在等待一个以unshareable方式使用的缓冲区，或者表示当前正在被读入buffercache。也就是当进程想获取或者操作某个block的时候却发现被别的进程在使用而出现等待。一般来说BufferBusy Wait不应大于1%。<br>检查缓冲等待统计部分（或V$WAITSTAT），看一下等待是否位于段头。如果是，可以考虑增加自由列表（freelist，对于Oracle8i DMT）或者增加freelist groups.<br>其修改语法为：</p>
<pre><code>SQL&gt; alter table sp_item storage (freelists 2);
Table altered。
</code></pre>
<p>对于Oracle8i而言，增加freelist参数，在很多时候可以明显缓解等待，如果使用LMT，也就是 Local Manangement Tablespace，区段的管理就相对简单还可以考虑修改数据块的pctused\pctfree值，比如增大pctfree可以扩大数据的分布，在某种程度上就可以减少热点块的竞争。</p>
<p>如果这一等待位于undo header，可以通过增加回滚段（rollback segment）来解决缓冲区的问题。<br>如果等待位于undo block上，我们可能需要检查相关应用，适当减少大规模的一致性读取，或者降低一致性读取(consistent read)的表中的数据密度或者增大DB_CACHE_SIZE。<br>如果等待处于data block，可以考虑将频繁并发访问的表或数据移到另一数据块或者进行更大范围的分布（可以增加pctfree 值，扩大数据分布，减少竞争），以避开这个”热点”数据块，或者可以考虑增加表中的自由列表或使用本地化管理的表空间（LocallyManaged Tablespaces）。<br>如果等待处于索引块，应该考虑重建索引、分割索引或使用反向键索引。反向键索引在很多情况下，可以极大地缓解竞争，其原理有点类似于hash分区的功效。反向键索引（reverse key index）常建在一些值是连续增长的列上，例如列中的值是由sequence产生的。</p>
<p>为了防止与数据块相关的缓冲忙等待，也可以使用较小的块：在这种情况下，单个块中的记录就较少，所以这个块就不是那么”繁忙”；或者可以设置更大的pctfree,使数据扩大物理分布，减少记录间的热点竞争。<br>在执行DML (insert/update/ delete)时，Oracle向数据块中写入信息，对于多事务并发访问的数据表，关于ITL的竞争和等待可能出现，为了减少这个等待，可以增加initrans，使用多个ITL槽。<br>以下是一个生产系统v$waitstat 试图所显示的等待信息:</p>
<pre><code>SQL&gt; select * from v$waitstat where count&lt;&gt;0 or time &lt;&gt;0;
CLASS      COUNT TIME
------------------ ---------- ----------
data block       453   6686
undo header      391   1126
undo block      172      3
</code></pre>
<p>latch free: latch释放<br>latch 是一种低级排队机制，用于保护SGA 中共享内存结构。<br>latch就像是一种快速地被获取和释放的内存锁。latch用于防止共享内存结构被多个用户同时访问。如果latch不可用，就会记录latch释放失败(latch free miss)。<br>有两种与闩有关的类型：<br>■ 立刻。<br>■ 可以等待。<br>假如一个进程试图在立刻模式下获得闩，而该闩已经被另外一个进程所持有，如果该闩不能立刻可用的话，那么该进程就不会为获得该闩而等待。它将继续执行另一个操作。<br>大多数latch 问题都与以下操作相关：<br>没有很好的是用绑定变量（library cache latch）、重作生成问题（redoallocation latch）、缓冲存储器竞争问题（cache buffers LRUchain），以及buffer cache中的存在”热点”块（cache buffers chain）。<br>通常我们说，如果想设计一个失败的系统，不考虑绑定变量，这一个条件就够了，对于异构性极强的系统，不使用绑定变量的后果是极其严重的。<br>另外也有一些latch 等待与bug 有关，应当关注Metalink 相关bug 的公布及补丁的发布。<br>当latch miss ratios大于0.5%时，就应当研究这一问题。<br>Oracle 的 latch 机制是竞争，其处理类似于网络里的CSMA/CD，所有用户进程争夺latch，对于愿意等待类型(willing-to-wait)的latch,如果一个进程在第一次尝试中没有获得latch,那么它会等待并且再尝试一次,如果经过_spin_count 次争夺不能获得latch, 然后该进程转入睡眠状态，持续一段指定长度的时间，然后再次醒来，按顺序重复以前的步骤.在8i/9i 中默认值是 _spin_count=2000。<br>如果SQL语句不能调整，在8.1.6版本以上，Oracle提供了一个新的初始化参数: CURSOR_SHARING，可以通过设置CURSOR_SHARING = force 在服务器端强制绑定变量。设置该参数可能会带来一定的副作用，对于Java的程序，有相关的bug，具体应用应该关注Metalink的bug公告。</p>
<p>enqueue<br>enqueue 是一种保护共享资源的锁定机制。该锁定机制保护共享资源，如记录中的数据，以避免两个人在同一时间更新同一数据。enqueue 包括一个排队机制，即FIFO（先进先出）排队机制。<br>Enqueue 等待常见的有ST、HW 、TX 、TM 等<br>ST enqueue 用于空间管理和字典管理的表空间(DMT)的分配。对于支持LMT 的版本，可以考虑使用本地管理表空间，对于Oracle8i，因为相关bug 不要把临时表空间设置为LMT. 或者考虑预分配一定数量的区。<br>HW enqueue 指段的高水位标记相关等待；手动分配适当区段可以避免这一等待。<br>TX 是最常见的enqueue 等待。TX enqueue 等待通常是以下三个问题之一产生的结果。<br>第一个问题是唯一索引中的重复索引，你需要执行提交（commit）/回滚（rollback）操作来释放enqueue。<br>第二个问题是对同一位图索引段的多次更新。因为单个位图段可能包含多个行地址（rowid），所以当多个用户试图更新同一段时，等待出现。直到提交或回滚，enqueue 释放。<br>第三个问题，也是最可能发生的问题是多个用户同时更新同一个块。如果没有自由的ITL 槽，就会发生块级锁定。通过增大initrans 和/或maxtrans 以允许使用多个ITL 槽，或者增大表上的pctfree值，就可以很轻松地避免这种情况。<br>TM enqueue 在DML 期间产生，以避免对受影响的对象使用DDL。如果有外键，一定要对它们进行索引，以避免这种常见的锁定问题。</p>
<p>Log Buffer Space: 日志缓冲空间<br>当你将日志缓冲（log buffer）产生重做日志的速度比LGWR 的写出速度快，或者是当日志转换（log switch）太慢时，就会发生这种等待。为解决这个问题，可以增大日志文件的大小，或者增加日志缓冲器的大小.<br>另外一个可能的原因是磁盘I/O 存在瓶颈，可以考虑使用写入速度更快的磁盘。</p>
<p>log file switch (archiving needed)<br>这个等待事件出现时通常是因为日志组循环写满以后，第一个日志归档尚未完成，出现该等待可能是 IO 存在问题。<br>解决办法：<br>可以考虑增大日志文件和增加日志组<br>移动归档文件到快速磁盘<br>调整log_archive_max_processes .</p>
<p>log file switch (checkpoint incomplete): 日志切换（检查点未完成）<br>当你的日志组都写完以后，LGWR 试图写第一个log file，如果这时数据库没有完成写出记录在第一个log file 中的dirty 块时（例如第一个检查点未完成），该等待事件出现。<br>该等待事件说明你的日志组过少或者日志文件过小。<br>你可能需要增加你的日志组或日志文件大小。</p>
<p>Log File Switch: 日志文件转换<br>所有的提交请求都需要等待”日志文件转换（必要的归档）”或”日志文件转换（chkpt.不完全）”。确保归档磁盘未满，并且速度不太慢。 DBWR可能会因为输入/输出（I／O）操作而变得很慢。你可能需要增加更多或更大的重做日志，而且如果DBWxR是问题症结所在的话，可能需要增加数据库书写器。</p>
<p>log file sync: 日志文件同步<br>当一个用户提交或回滚数据时，LGWR 将session 会话的重做由redo buffer 写入到重做日志中。<br>log file sync 必须等待这一过程成功完成(Oracle 通过写redo log file 保证commit 成功的数据不丢失)，这个事件说明提交可能过于频繁，批量提交可以最大化LGWR 的效率，过分频繁的提交会引起LGWR频繁的激活，扩大了LGWR 的写代价。<br>为了减少这种等待事件，可以尝试每次提交更多的记录。<br>将重做日志置于较快的磁盘上，或者交替使用不同物理磁盘上的重做日志，以降低归档对LGWR的影响。<br>对于软RAID，一般来说不要使用RAID 5，RAID5 对于频繁写入得系统会带来较大的性能损失，可以考虑使用文件系统直接输入/输出，或者使用裸设备（raw device），这样可以获得写入的性能提高。</p>
<p>log file single write<br>该事件仅与写日志文件头块相关，通常发生在增加新的组成员和增进序列号时。头块写单个进行，因为头块的部分信息是文件号，每个文件不同。更新日志文件头这个操作在后台完成，一般很少出现等待，无需太多关注。</p>
<p>log file parallel write<br>从log buffer 写redo 记录到redo log 文件，主要指常规写操作(相对于log file sync)。<br>如果你的Log group 存在多个组成员，当flush log buffer 时，写操作是并行的，这时候此等待事件可能出现。<br>尽管这个写操作并行处理，直到所有I/O 操作完成该写操作才会完成(如果你的磁盘支持异步IO或者使用IO SLAVE，那么即使只有一个redo log file member,也有可能出现此等待)。<br>这个参数和log file sync 时间相比较可以用来衡量log file 的写入成本。通常称为同步成本率。</p>
<p>control file parallel write: 控制文件并行写<br>当server 进程更新所有控制文件时，这个事件可能出现。<br>如果等待很短，可以不用考虑。如果等待时间较长，检查存放控制文件的物理磁盘I/O 是否存在瓶颈。<br>多个控制文件是完全相同的拷贝，用于镜像以提高安全性。对于业务系统，多个控制文件应该存放在不同的磁盘上，一般来说三个是足够的，如果只有两个物理硬盘，那么两个控制文件也是可以接受的。在同一个磁盘上保存多个控制文件是不具备实际意义的。<br>减少这个等待，可以考虑如下方法：<br>减少控制文件的个数(在确保安全的前提下)<br>如果系统支持，使用异步IO<br>转移控制文件到IO 负担轻的物理磁盘</p>
<p>control file sequential read/ control file single write<br>控制文件连续读/控制文件单个写<br>对单个控制文件I/O 存在问题时，这两个事件会出现。<br>如果等待比较明显，检查单个控制文件，看存放位置是否存在I/O 瓶颈。<br>使用查询获得控制文件访问状态：<br>select P1 from V$SESSION_WAIT<br>where EVENT like ‘control file%’ and STATE=’WAITING’;<br>解决办法：<br>移动有问题的控制文件到快速磁盘<br>如果系统支持，启用异步I/O</p>
<p>direct path write: 直接路径写<br>该等待发生在，等待确认所有未完成的异步I/O 都已写入磁盘。<br>你应该找到I/O 操作频繁的数据文件，调整其性能。<br>也有可能存在较多的磁盘排序，临时表空间操作频繁，可以考虑使用Local 管理表空间，分成多个小文件，写入不同磁盘或者裸设备。</p>
<p>SQL*Net message from dblink<br>该等待通常指与分布式处理（从其他数据库中SELECT）有关的等待。<br>这个事件在通过DBLINKS 联机访问其他数据库时产生。如果查找的数据多数是静态的，可以考虑移动这些数据到本地表并根据需要刷新，通过快照或者物化视图来减少跨数据库的访问，会在性能上得到很大的提高。</p>
<p>slave wait: 从属进程等<br>Slave Wait 是Slave I/O 进程等待请求，是一个空闲参数，一般不说明问题。</p>
<p>2.2.4  High Load SQL 分析<br>对于一个特定的应用程序或者系统来讲，要调整优化其性能，最好的方法是检查程序的代码和用户使用的SQL语句。<br>如果使用了 level 5 级别的 snapshot ，那么statspack生成的报告中就会显示系统中高负荷SQL语句（High Load SQL）的信息，而其详细信息可以在 stats$sql_summary 表中查到。缺省情况下 snapshot 的级别是 level 5。<br>按照 buffer gets, physical reads, executions, memory usage andversion count 等参数的降序排列顺序，把SQL语句分为几个部分罗列在报告中。</p>
<p>2.2.5  报告的其他部分<br>statspack报告的其他部分包括了 Instance Activity Stats，TablespaceIO Stats，Buffer Pool Statistics，Bufferwait Statistics，Rollback Segment Stats，LatchActivity，Dictionary Cache Stats，LibraryCache Activity，SGA breakdown difference 以及init.ora 参数，等等。目前本文不对这些内容进行详细讨论，请参加其他详细文档。</p>
<p>2.3 trace session  （……）</p>
<p>2.4 基于成本的优化器技术内幕<br>Oracle基于成本的优化器（Oracle’s cost-based SQL optimizer ，简称CBO)，是Oracle里面非常复杂的一个部分, 它决定了Oracle里面每个SQL的执行路径。CBO是一项评价SQL语句和产生最好执行计划的具有挑战性的工作，所以也使它成Oracle最复杂的软件组成部分。<br>众所周知，SQL的执行计划，几乎是Oracle性能调整最重要的方面了。所以想要学会如何调整Oracle数据库的性能，就要学会如何对SQL进行调整，就需要深入透彻理解CBO。<br>CBO的执行路径，取决于一些外部因素，内部的Oracle统计数据，以及数据是如何分布的。<br>我们将要讨论下面的话题：<br>CBO的参数：我们从基本的优化器参数开始学习，然后学习每个优化器参数是如何影响Oracle的优化器的执行的。</p>
<p>CBO的统计：这里我们将讨论，使用Analyze或者DBMS_STATS来收集正确的统计数据，对Oracle 优化器而言，是多么的重要。我们还将学习如何把优化器的统计数据，从一个系统拷贝到另外一个系统，这样可以确保开发环境和产品数据库环境下，SQL的执行路径不会变化。</p>
<p>下面我们开始讨论CBO优化模式以及影响CBO的Oracle参数</p>
<p>2.4.1  CBO的参数<br>CBO受一些重要参数的影响，修改这些参数后可以看到CBO性能上戏剧性的变化。首先从设置CBO的optimizer_mode参数开始，然后讨论其他重要参数的设置。</p>
<p>在 Oracle 9i 中，optimizer_mode 参数有四种取值，决定了四种优化模式：rule, choose, all_rows, 和 first_rows，其中 rule 和 choose 两种模式表示目前已经过时的基于规则的优化器模式（rule-based optimizer，简称RBO），所以我们在此着重讨论后两种CBO模式。</p>
<p>优化模式的设置可以在系统级进行，也可以对某个会话（session）进行设置，或者对某个SQL语句进行设置。对应的语句如下：<br>alter system set optimizer_mode=first_rows_10;<br>alter session set optimizer_goal = all_rows;<br>select /*+ first_rows(100) */ from student;</p>
<p>我们首先需要知道对一个SQL语句来说，什么是最好的执行计划（the best execution plan）？是使SQL语句返回结果的速度最快，还是使SQL语句占用系统资源最少？显然，这个答案取决于数据库的处理方式。</p>
<p>举一个简单的例子，比如有下列SQL语句：<br>select customer_name<br>from<br>   customer<br>where<br>   region = ‘south’<br>order by<br>   customer_name;</p>
<p>如果最好的执行计划是返回结果的速度最快，那么就需要使用region 列和 customer_name 列上的索引，从 customer 表中按照正确的顺序快速读取所有的列，而不用管是否从物理上读取了很多不连续的数据块导致的大量IO操作。（见下图）</p>
<p>假设这个执行计划从开始到返回结果耗时0.0001 秒，同时产生了 10000 个 db_block_gets ，但是如果你的目标是计算资源的最小化呢？如果这个SQL语句是在一个批处理程序中执行，也许对返回结果的速度要求就不那么重要了，而另一个执行计划则可能耗费更少的系统资源。<br>在下图所示的例子中，并行的全表扫描由于不需要按照排序重新读取数据块，所以耗系统资源较少，并且IO操作也不多。当然，由于SQL语句执行过程中没有排序，得到预期结果的时间就长了，而资源耗费少了。假设这个执行计划从开始到返回结果耗时 10 秒，同时产生了 5000 个 db_block_gets</p>
<p>Oracle提供了几个optimizer_mode 的设置参数，使你能够得到想要的最好的执行计划。</p>
<p>optimizer_mode = first_rows<br>设置为这种CBO模式以后，SQL语句返回结果的速度会尽可能的快，而不管系统全部的查询是否会耗时较长或者耗系统资源过多。由于利用索引会使查询速度加快，所以 first_rows 优化模式会在全表扫描上进行索引扫描。这种优化模式一般适合于一些OLTP系统，满足用户能够在较短时间内看到较小查询结果集的要求。</p>
<p>optimizer_mode = all_rows<br>设置为这种CBO模式以后，将保证消耗的所有计算资源最小，尽管有时查询结束以后没有结果返回。all_rows 的优化模式更倾向于全表扫描，而不是全索引扫描和利用索引排序，因此这种优化模式适合于数据查看实时性不是那么强的数据仓库、决策支持系统和面向批处理的数据库（batch-oriented databases）等。</p>
<p>optimizer_mode = first_rows_n<br>Oracle 9i 对一些预期返回结果集的数据量小的SQL语句优化模式进行了加强，增加了四个参数值：first_rows_1、first_rows_10、 first_rows_100、first_rows_1000。CBO通过 first_rows_n 中的 n 值，决定了返回结果集数量的基数，我们可能仅仅需要查询结果集中的一部分，CBO就根据这样的 n 值来决定是否使用索引扫描。</p>
<p>optimizer_mode = rule<br>基于规则的优化器模式，RBO，是早期Oracle版本使用过的一种优化模式。由于RBO不支持自1994年Oracle版本的新特性，如 bitmap indexes，table partitions，function-based indexes等，所以在以后Oracle版本中已经不再更新RBO，并且也不推荐用户使用RBO这种优化模式了。</p>
<p>从上面的讨论可以看出，optimizer_mode 参数的设置对CBO是非常重要的，决定了CBO的基本模式，同时还有一些其他的参数也对CBO有着极大的影响。由于CBO的重要性，Oracle提供了一些系统级的参数来调整CBO的全局性能，这些调整参数包括索引扫描与全部扫描的选择、表连接方式的选择，等等。下面简单讨论一下。</p>
<p>optimizer_index_cost_adj<br>这个参数用于调整使用索引的访问路径的成本算法，参数值越小，索引访问的成本就越低。</p>
<p>optimizer_index_caching<br>这个参数告诉Oracle在内存缓冲区中索引的数量。该参数的设置会影响CBO如何决定使用表连接（嵌套循环）的索引还是使用全表扫描。</p>
<p>db_file_multiblock_read_count<br>这个参数的值被设置较大的时候，CBO就会认为离散的、多数据块的读取会比顺序读取的代价更低，使得CBO更倾向于全表扫描。</p>
<p>parallel_automatic_tuning<br>这个参数值被设置为 on 的时候，表示使用并行的全表扫描，由于并行的全表扫描比较快，所以CBO认为索引的访问是高成本的，同时就更倾向于全表扫描。</p>
<p>hash_area_size<br>如果不使用 pga_aggregate_target 参数的话，该参数有效。该参数的设置大小决定CBO是否更加倾向于 hash joins ，而不是嵌套循环和表连接的索引合并。</p>
<p>sort_area_size<br>如果不使用 pga_aggregate_target 参数的话，该参数有效。该参数的设置大小影响CBO决定是否进行索引访问和结果集的排序，参数值越大，在内存中排序的可能性就越大，CBO也就更加倾向于排序。</p>
<p>由于对这些参数值的修改会影响到系统中成千上万的SQL语句的执行计划，所以Oracle并不推荐修改这些参数的缺省值。</p>
<p>在对CBO的参数有了大致的了解以后，下面讨论如何根据提供给CBO的数据帮助CBO制定出一个好的执行计划。</p>
<p>2.4.2  CBO的统计<br>对于CBO来说，最重要的是定义和管理好你的统计数据，为了使CBO能够为你的SQL语句产生一个最好的执行计划，必须要有与SQL语句相关的表和索引统计数据。只有当CBO知道了相关的信息，如表的大小、分布、基数以及列值的可选性等，才能对SQL语句作出正确的判断，从而得到最好的执行计划。</p>
<p>下面讨论一下如何获得高质量的CBO统计数据，如何为你的数据库系统创建一个适当的CBO环境。</p>
<p>CBO产生最好执行计划的能力来自于统计数据的有效性，获得统计数据的比较过时的方法是 analyze table 和 dbms_utility ，这两种方法对SQL语句的性能有一些危害，因为我们知道，CBO是使用对象统计数据（object statistics）来为所有的SQL语句选择最好的执行计划。</p>
<p>dbms_stats 应用功能包是产生统计数据较好的方法，特别对大型分区表而言。下面看一个使用 dbms_stats 的例子。</p>
<pre><code>exec dbms_stats.gather_schema_stats(
  ownname          =&gt;&#39;SCOTT&#39;,
 options            =&gt;&#39;GATHER AUTO&#39;,
  estimate_percent    =&gt; dbms_stats.auto_sample_size,
  method_opt        =&gt; &#39;for allcolumns size repeat&#39;,
  degree           =&gt; 34
   )
</code></pre>
<p>上面例子中的options参数的几个可选值需要说明一下。<br>GATHER  重新分析整个schema，产生统计数据；</p>
<p>  GATHER EMPTY 仅分析那些还没有统计数据的表；</p>
<p>  GATHER STALE 仅重新分析那些发生了10％变化的表（变化原因可能是 inserts, updates ,deletes ）</p>
<p>  GATHER AUTO 仅重新分析那些还没有统计数据和发生了10％变化的表，该选项相当于 GATHER EMPTY 和 GATHER STALE 同时使用。</p>
<p>使用 GATHER AUTO 和 GATHER STALE 两个选项需要进行监控，如果你执行了 ALTER TABLE XXX MONITORING 命令，Oracle利用 dba_tab_modifications 视图跟踪表的变化，记录了最近一次统计数据分析以来的 insert , update , delete 的准确记录数。</p>
<pre><code>SQL&gt; desc dba_tab_modifications;
 Name                    Type
 -----------------             ---------------
 TABLE_OWNER         VARCHAR2(30)
 TABLE_NAME          VARCHAR2(30)
 PARTITION_NAME       VARCHAR2(30)
 SUBPARTITION_NAME   VARCHAR2(30)
 INSERTS                NUMBER
 UPDATES               NUMBER
 DELETES               NUMBER
 TIMESTAMP            DATE
 TRUNCATED            VARCHAR2(3)
</code></pre>
<p>比较有趣的一个选项是 GATHER STALE ，比如在一个数据更新频繁的OLTP系统中，几乎所有的统计数据都会很快的过时，而我们必须记住GATHER STALE 选项是在表中10％的记录发生变化时才对该表重新分析产生统计数据，因此除了只读表以外的所有表几乎使用 GATHER STALE 选项重新分析产生统计数据，所以 GATHER STALE 选项主要还是用于一些主要是只读表组成的系统中。</p>
<p>在上面使用 dbms_stats 的例子中，我们看到了一个参数 estimate_percent ，它的值是dbms_stats.auto_sample_size, 这个参数值是 Oracle 9i 才开始使用的，这个参数值的出现极大方便了统计数据的分析产生。<br>我们知道，统计数据的质量越高，CBO产生最好执行计划的能力就越强，但是由于数据库统计采样大小的问题，对一个大型数据库系统做一个完整的统计数据分析产生将会耗时数天，最好的办法就是在高质量的统计数据和数据库统计采样大小之间得到一个平衡点。<br>在早一些的Oracle版本中，为了得到统计数据，DBA不得不猜测一个最好的数据采样大小百分比。但是从 Oracle 9i 开始，可以通过 dbms_stats 包来自己指定 estimate_percent 参数的值了，那就是dbms_stats.auto_sample_size<br>通过这种方式设置了自动采样大小以后，我们可以通过下列数据字典视图的 sample_size 字段来验证这些自动产生的统计采样大小。</p>
<pre><code>DBA_ALL_TABLES
DBA_INDEXES
DBA_IND_PARTITIONS
DBA_IND_SUBPARTITIONS
DBA_OBJECT_TABLES
DBA_PART_COL_STATISTICS
DBA_SUBPART_COL_STATISTICS
DBA_TABLES
DBA_TAB_COLS
DBA_TAB_COLUMNS
DBA_TAB_COL_STATISTICS
DBA_TAB_PARTITIONS
DBA_TAB_SUBPARTITIONS
</code></pre>
<p>使用自动统计采样以后，Oracle会根据表的大小和列值的分布在5％到20％之间取值。记住：你的统计数据质量越高，CBO作出的决定就越对你有利。</p>
<p>现在我们对CBO统计数据应该有一些了解了，下面来看看在一个成功的Oracle系统是如何管理CBO统计数据。</p>
<p>2.4.3  CBO的正确环境<br>成功使用CBO的关键是稳定性，下面是一些成功使用CBO的基本事项。</p>
<p>●只在必需的时候才进行统计数据的重新分析<br>Oracle DBA们最容易犯的一个普遍错误就是经常性的对系统的统计数据进行重新分析。记住：做这件事的唯一目的是改变SQL语句的执行计划，如果这个执行计划没有被破坏，就不要去修复它。如果你对SQL语句的性能还满意的话，重新分析产生统计数据以后可能会产生较大的性能问题，并给开发团队带来影响。实际运用中，也是极少数的Oracle系统才会周期性的对统计数据进行重新分析。<br>一般来讲，一个数据库应用系统的基本架构是不会轻易改变，大数据量的表仍然是很大，索引列的分布、基数值等等也很少变化。只有下列几种情况的数据库才可能经常对整个系统的统计数据重新分析：<br>1、用于数据分析的数据库<br>   有一些由于科学试验数据分析的数据库系统，经常会更换整个一套的试验数据，那么这种情况下当数据库重新load了一套数据以后，可以立即重新对统计数据进行分析。<br>2、高度变化的数据库<br>   这是极少数的例子，表的大小或者索引列的数据在剧烈的变化，比如一张表有100条记录，一周以后就变成10000条记录。这种情况下也可以考虑周期性的进行统计数据分析。</p>
<p>●强迫开发人员调整自己的SQL<br>很多开发人员错误的认为，他们的任务就是编写SQL语句然后从数据库中获得正确的数据。但是实际上编写出SQL语句只是开发人员一半的工作，在一个成功的Oracle应用系统中，会要求开发人员的SQL语句采用最优化的方式访问数据库，并且保证SQL语句的执行计划在新的SQL之间的可移植性。<br>令人惊讶的是，在许多Oracle应用系统中都不怎么考虑具体SQL语句的执行计划，认为CBO是很智能的，无论如何都可以为我们提供最好的SQL语句执行计划。<br>同一个查询在SQL语句中可能有不同方式的写法，而每一种写法都可能有不同的执行计划。观察下面的例子，每一个查询的结果都是一样的，但是执行计划却相去甚远。</p>
<p>– 使用了不正确的子查询</p>
<pre><code>select
  book_title
from
  book
where
  book_key not in (select book_key from sales);
 
Execution Plan
----------------------------------------------------------
0      SELECT STATEMENT Optimizer=CHOOSE (Cost=1Card=1 Bytes=64)
1    0   FILTER
2    1     TABLE ACCESS (FULL) OF &#39;BOOK&#39;(Cost=1 Card=1 Bytes=64)
3    1     TABLE ACCESS (FULL) OF &#39;SALES&#39;(Cost=1 Card=5 Bytes=25)
</code></pre>
<p>– 使用了两张表的外连接</p>
<pre><code>select
  book_title
from
  book  b,
  sales  s
where
  b.book_key = s.book_key(+) 
and
  quantity is null;

Execution Plan
----------------------------------------------------------
0   SELECT STATEMENT Optimizer=CHOOSE (Cost=3 Card=100 Bytes=8200)

1  0 FILTER
2  1   FILTER
3  2     HASH JOIN (OUTER)
4  3      TABLE ACCESS (FULL) OF &#39;BOOK&#39; (Cost=1Card=20 Bytes=1280)
5  3      TABLE ACCESS (FULL) OF &#39;SALES&#39; (Cost=1Card=100 Bytes=1800)


-- 使用了三个正确的子查询
select
  book_title
from
  book
where
  book_title not in (
               select
               distinct
                 book_title
               from
                 book,
                 sales
               where
                 book.book_key = sales.book_key
               and
                 quantity &gt; 0);

Execution Plan
----------------------------------------------------------
0   SELECT STATEMENT Optimizer=CHOOSE (Cost=1 Card=1 Bytes=59)
1  0  FILTER
2  1   TABLE ACCESS (FULL) OF &#39;BOOK&#39; (Cost=1 Card=1 Bytes=59)
3  1   FILTER
4  3     NESTED LOOPS (Cost=6 Card=1 Bytes=82)
5  4       TABLE ACCESS (FULL) OF &#39;SALES&#39;(Cost=1 Card=5 Bytes=90)
6  4       TABLE ACCESS (BY INDEX ROWID) OF&#39;BOOK&#39; (Cost=1 Card=1)
7  6         INDEX (UNIQUE SCAN)OF &#39;PK_BOOK&#39; (UNIQUE)
</code></pre>
<p>我们看到，正确的SQL语句写法产生的执行计划是如此的不同。明智的开发人员知道如何去编写能够产生最好执行计划的SQL语句，明智的Oracle应用系统也会主动训练开发人员去编写最有效的SQL语句。</p>
<p>下面是一些帮助开发人员优化SQL语句的技巧：<br>1、 使用 autotrace 和 TKPROF 功能去分析SQL语句的执行计划；<br>2、 保证所有生产环境中的SQL语句都是在测试环境中经过优化的；<br>3、 制定一个性能优化的标准，而不是只要求开发人员编写出最快的SQL语句。根据这种标准，好的开发人员应该能够写出最有效的SQL语句。</p>
<p>●谨慎管理CBO统计数据<br>成功的Oracle系统会谨慎管理他们的CBO统计数据，以保证CBO在测试环境和生产环境中以同样的方式工作。一个聪明的DBA会在得到高质量的CBO统计数据以后，把这些统计数据移植到测试环境中，这样SQL语句的执行计划在测试环境和生产环境中就是一样的了。</p>
<p>对DBA来说，一个重要的工作就是收集和发布CBO统计数据，并随时保持一套当前运行环境的最精确的统计数据。在一些情况下，可能会有不止一套的优化统计数据。比如，对OLTP运行的最好的统计数据可能对数据仓库运行却不是最好的，在这种情况下，DBA就需要保持两套统计数据，并根据不同的运行条件导入系统。</p>
<p>可以使用 dbms_stats 包中的 export_system_stats 存储过程来完成CBO统计数据的导出。下面的例子中，我们把当前CBO统计数据导出到一张名叫 stats_table_oltp的表中。<br>dbms_stats.export_system_stats(‘stats_table_oltp’)</p>
<p>导出以后，我们就可以把这张表拷贝到别的实例中，当系统的运行模式改变以后，使用 dbms_stats 包中的 import_system_stats 存储过程来完成CBO统计数据的导入。<br>dbms_stats.import_system_stats(‘stats_table_oltp’)</p>
<p>●千万不要随便改动CBO参数的值<br>改动CBO相关参数的值是非常危险的，因为一个小小的改动可能就会对整个系统的执行性能带来极大的负面影响，只有在经过严格的系统测试以后才能改动这些参数的值。可能带来极大影响的参数值包括：optimizer_mode, optimizer_index_cost_adj, andoptimizer_index_caching。而其他参数，比如 hash_area_size ,sort_area_size，参数值的改变就不是那么危险了，可以在会话级进行改变以帮助CBO优化查询。</p>
<p>●保证静态的执行计划<br>成功的CBO应用会通过谨慎管理统计数据来锁定SQL执行计划，同时保证存储的优化计划的稳定性，或者在具体的SQL语句中加入一些细节上的提示。<br>记住：重新分析一个系统的统计数据，可能会导致成千上万的SQL语句改变其执行计划。许多Oracle应用系统要求所有的SQL语句在测试环境中经过验证，保证在功能上和生产环境是一致的。</p>
<p>2.4.4  CBO的思考<br>尽管我们已经对CBO的不少细节有了了解，但是由于随着Oracle新版本的不断推出，CBO变得越来越强大，同时也越来越复杂，我们仍然有许多关于CBO的知识需要学习。<br>下面是一些关于CBO调整的提纲性的建议，供准备进行CBO调整的DBA们思考。</p>
<p>●DBA可以提供一些Oracle参数的配置对CBO进行控制，但是只能在有限的环境下谨慎的改变这些参数；</p>
<p>●CBO依靠统计数据来产生SQL语句的优化的执行计划，可以通过 dbms_stats 包来分析、产生统计数据；</p>
<p>●DBA们的一项重要任务就是收集、管理CBO统计数据，这些数据可以被收集、存储，也可以在相关的实例中进行移植，以保证执行计划的连贯性。</p>
<p>●在没有使用export_system_stats 存储过程导出原来的统计数据以前，重新对系统的统计数据进行分析是十分危险的，因为成千上万的SQL语句的执行计划将可能全部改变，而你却不能恢复原来的 SQL性能。只有在系统的数据发生巨大变化时，才可能需要对整个系统的统计数据进行重新分析。</p>
<p>本小节是关于CBO的一些技术讨论，原文来自 Donald K. Burleson 在OTN上的一篇文章，具体URL路径是：<br><a href="http://otn.oracle.com/oramag/webcolumns/2003/techarticles/burleson_cbo_pt1.html">http://otn.oracle.com/oramag/webcolumns/2003/techarticles/burleson_cbo_pt1.html</a><br><a href="https://blog.csdn.net/Oracle_zsq/article/details/79956538">https://blog.csdn.net/Oracle_zsq/article/details/79956538</a>
 </p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Java突击：03-Thread</title>
    <url>/2023/04/15/Java%E7%AA%81%E5%87%BB%EF%BC%9A03-Thread/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JAVA 多线程并发<br>4.1.1. JAVA 并发知识库 </p>
<p>4.1.2. JAVA 线程实现/创建方式<br>4.1.2.1. 继承 Thread 类<br>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。</p>
<pre><code>public class MyThread extends Thread &#123; 
 public void run() &#123; 
 System.out.println(&quot;MyThread.run()&quot;); 
 &#125; 
&#125; 
MyThread myThread1 = new MyThread(); 
myThread1.start(); 
</code></pre>
<p>4.1.2.2. 实现 Runnable 接口。<br>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。 </p>
<pre><code>public class MyThread extends OtherClass implements Runnable &#123; 
 public void run() &#123; 
 System.out.println(&quot;MyThread.run()&quot;); 
 &#125; 
&#125;
</code></pre>
<p>//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例： </p>
<pre><code>MyThread myThread = new MyThread(); 
Thread thread = new Thread(myThread); 
thread.start(); 
</code></pre>
<p>//事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用</p>
<pre><code>target.run() 
public void run() &#123; 
 if (target != null) &#123; 
 target.run(); 
 &#125; 
&#125; 
</code></pre>
<p>4.1.2.3. ExecutorService、Callable<Class>、Future 有返回值线程<br>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。 </Class></p>
<pre><code>//创建一个线程池 
 ExecutorService pool = Executors.newFixedThreadPool(taskSize); 
 // 创建多个有返回值的任务 
 List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); 
 for (int i = 0; i &lt; taskSize; i++) &#123; 
 Callable c = new MyCallable(i + &quot; &quot;); 
 // 执行任务并获取 Future 对象 
 Future f = pool.submit(c); 
 list.add(f); 
 &#125; 
 // 关闭线程池 
 pool.shutdown(); 
 // 获取所有并发任务的运行结果 
 for (Future f : list) &#123; 
 // 从 Future 对象上获取任务的返回值，并输出到控制台 
 System.out.println(&quot;res：&quot; + f.get().toString()); 
 &#125; 
 
</code></pre>
<p>4.1.2.4. 基于线程池的方式<br>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。 </p>
<pre><code>// 创建线程池 
 ExecutorService threadPool = Executors.newFixedThreadPool(10); 
 while(true) &#123; 
 threadPool.execute(new Runnable() &#123; // 提交多个线程任务，并执行 
 @Override 
 public void run() &#123; 
 System.out.println(Thread.currentThread().getName() + &quot; is running ..&quot;); 
 try &#123; 
 Thread.sleep(3000); 
 &#125; catch (InterruptedException e) &#123; 
 e.printStackTrace(); 
 &#125; 
 &#125; 
 &#125;); 
 &#125; 
&#125; 
</code></pre>
<p>4.1.3. 4 种线程池<br> Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。 </p>
<p>4.1.3.1. newCachedThreadPool<br>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 </p>
<p>4.1.3.2. newFixedThreadPool<br>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 </p>
<p>4.1.3.3. newScheduledThreadPool<br>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。  </p>
<pre><code>ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3); 
 scheduledThreadPool.schedule(newRunnable()&#123; 
 @Override 
 public void run() &#123; 
 System.out.println(&quot;延迟三秒&quot;); 
 &#125; 
 &#125;, 3, TimeUnit.SECONDS); 
scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123; 
 @Override 
 public void run() &#123; 
 System.out.println(&quot;延迟 1 秒后每三秒执行一次&quot;); 
 &#125; 
 &#125;,1,3,TimeUnit.SECONDS); 
</code></pre>
<p>4.1.3.4. newSingleThreadExecutor<br>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！  </p>
<p>4.1.4. 线程生命周期(状态)<br>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。<br>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p>
<p>4.1.4.1. 新建状态（NEW）<br>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值 </p>
<p>4.1.4.2. 就绪状态（RUNNABLE）：<br>当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。 </p>
<p>4.1.4.3. 运行状态（RUNNING）：<br>如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。 </p>
<p>4.1.4.4. 阻塞状态（BLOCKED）：<br>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。<br>直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<p>等待阻塞（o.wait-&gt;等待对列）：<br>运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。</p>
<p>同步阻塞(lock-&gt;锁池)<br>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。 </p>
<p>其他阻塞(sleep/join)<br>运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。 </p>
<p>4.1.4.5. 线程死亡（DEAD）<br>线程会以下面三种方式结束，结束后就是死亡状态。 </p>
<p>正常结束 </p>
<ol>
<li>run()或 call()方法执行完成，线程正常结束。 </li>
</ol>
<p>异常结束<br>2. 线程抛出一个未捕获的 Exception 或 Error。 </p>
<p>调用 stop<br>3. 直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p>
<p> 4.1.5. 终止线程 4 种方式<br>4.1.5.1. 正常运行结束<br> 程序运行结束，线程自动结束。 </p>
<p>4.1.5.2. 使用退出标志退出线程 </p>
<p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的<br>运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：<br>最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while<br>循环是否退出，代码示例： </p>
<pre><code>public class ThreadSafe extends Thread &#123; 
 public volatile boolean exit = false; 
 public void run() &#123; 
 while (!exit)&#123; 
 //do something 
 &#125; 
 &#125; 
&#125; 
</code></pre>
<p>定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit时，使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。</p>
<p>4.1.5.3. Interrupt 方法结束线程 </p>
<p>使用 interrupt()方法来中断线程有两种情况： </p>
<ol>
<li><p>线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。<br>阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。 </p>
</li>
<li><p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p>
<p> public class ThreadSafe extends Thread {<br>  public void run() {<br>  while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出<br>  try{<br>  Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出<br>  }catch(InterruptedException e){<br>  e.printStackTrace();<br>  break;//捕获到异常之后，执行 break 跳出循环<br>  }<br>  }<br>  }<br> } </p>
</li>
</ol>
<p>4.1.5.4. stop 方法终止线程（线程不安全） </p>
<p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。 </p>
<p>4.1.6. sleep 与 wait 区别 </p>
<ol>
<li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 </li>
<li>在调用 sleep()方法的过程中，线程不会释放对象锁。 </li>
<li>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 </li>
<li>1.7. start 与 run 区别 </li>
<li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 </li>
<li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 </li>
<li>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。 </li>
</ol>
<p>4.1.8. JAVA 后台线程 </p>
<ol>
<li>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。 </li>
<li>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 </li>
<li>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。 </li>
<li>在 Daemon 线程中产生的新线程也是 Daemon 的。 </li>
<li>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。 </li>
<li>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 </li>
<li>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。<br>当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。 </li>
</ol>
<p>4.1.9. JAVA 锁<br>4.1.9.1. 乐观锁 </p>
<p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。<br>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 </p>
<p>4.1.9.2. 悲观锁 </p>
<p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。<br>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 </p>
<p>4.1.9.3. 自旋锁 </p>
<p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<br>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 </p>
<p>自旋锁的优缺点<br>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！<br>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，<br>其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；自旋锁时间阈值（1.6 引入了适应性自旋锁）<br>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！  </p>
<p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。 </p>
<p>自旋锁的开启<br>JDK1.6 中-XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数；<br>JDK1.7 后，去掉此参数，由 jvm 控制； </p>
<p>4.1.9.4. Synchronized 同步锁 </p>
<p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。<br>Synchronized 作用范围 </p>
<ol>
<li>作用于方法时，锁住的是对象的实例(this)； </li>
<li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； </li>
<li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。<br>Synchronized 核心组件 </li>
</ol>
<ol>
<li>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里； </li>
<li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； </li>
<li>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中； </li>
<li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck； </li>
<li>Owner：当前已经获取到所资源的线程被称为 Owner； </li>
<li>!Owner：当前释放锁的线程。<br>Synchronized 实现 </li>
</ol>
<ol>
<li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。 </li>
<li>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。 </li>
<li>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。 </li>
<li>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。 </li>
<li>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。 </li>
<li>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。<br>参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">https://blog.csdn.net/zqz_zqz/article/details/70233767</a> </li>
<li>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的 </li>
<li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 </li>
<li>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 </li>
<li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； </li>
<li>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。 </li>
</ol>
<p>4.1.9.5. ReentrantLock<br>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。 </p>
<p>Lock 接口的主要方法 </p>
<ol>
<li>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </li>
<li>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </li>
<li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生. </li>
<li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 </li>
<li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。 </li>
<li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9 </li>
<li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10 </li>
<li>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法 </li>
<li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </li>
<li>hasQueuedThreads()：是否有线程等待此锁 </li>
<li>isFair()：该锁是否公平锁 </li>
<li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true </li>
<li>isLock()：此锁是否有任意线程占用 </li>
<li>lockInterruptibly（）：如果当前线程未被中断，获取锁 </li>
<li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 </li>
<li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。 </li>
</ol>
<p>非公平锁<br>       JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。<br>公平锁<br>       公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 </p>
<p>ReentrantLock 与 synchronized </p>
<ol>
<li>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。 </li>
<li>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。 </li>
</ol>
<p>ReentrantLock 实现 </p>
<pre><code>public class MyService &#123; 
 private Lock lock = new ReentrantLock(); 
 //Lock lock=new ReentrantLock(true);//公平锁 
 //Lock lock=new ReentrantLock(false);//非公平锁 
 private Condition condition=lock.newCondition();//创建 Condition 
 public void testMethod() &#123; 
 try &#123; 
 lock.lock();//lock 加锁 
 //1：wait 方法等待： 
 //System.out.println(&quot;开始 wait&quot;); 
 condition.await(); 
//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁 
 //:2：signal 方法唤醒 
 condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程 
 for (int i = 0; i &lt; 5; i++) &#123; 
 System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()+ (&quot; &quot; + (i + 1))); 
 &#125; 
 &#125; catch (InterruptedException e) &#123; 
 e.printStackTrace(); 
 &#125; 
 finally 
&#123; 
 lock.unlock(); 
 &#125; 
 &#125; 
&#125;
</code></pre>
<p>Condition 类和 Object 类锁方法区别区别 </p>
<ol>
<li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效 </li>
<li>Condition 类的 signal 方法和 Object 类的 notify 方法等效 </li>
<li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 </li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的 </li>
</ol>
<p>tryLock 和 lock 和 lockInterruptibly 的区别 </p>
<ol>
<li>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false </li>
<li>lock 能获得锁就返回 true，不能的话一直等待获得锁 </li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。 </li>
</ol>
<p>4.1.9.6. Semaphore 信号量 </p>
<p> Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池 实现互斥锁（计数器为 1）<br>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。<br>代码实现<br>它的用法如下：</p>
<pre><code>// 创建一个计数阈值为 5 的信号量对象 
// 只能 5 个线程同时访问 
Semaphore semp = new Semaphore(5); 
try &#123; // 申请许可 
semp.acquire(); 
try &#123; 
// 业务逻辑 
&#125; catch (Exception e) &#123; 
&#125; finally &#123; 
// 释放许可 
semp.release(); 
&#125; 
&#125; catch (InterruptedException e) &#123; 
&#125;
</code></pre>
<p>Semaphore 与 ReentrantLock </p>
<p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。<br>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。<br>Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。 </p>
<p>4.1.9.7. AtomicInteger </p>
<p>首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<V>将一个对象的所有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。<br>通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentantLock 的好几倍。 </V></p>
<p>4.1.9.8. 可重入锁（递归锁） </p>
<p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<p>4.1.9.9. 公平锁与非公平锁 </p>
<p>公平锁（Fair）<br>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </p>
<p>非公平锁（Nonfair）<br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 </p>
<ol>
<li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 </li>
<li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 </li>
</ol>
<p>4.1.9.10. ReadWriteLock 读写锁 </p>
<p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。<br>读锁<br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁<br>写锁<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>Java 中读写锁有个接口 java.util.concurrent.locks.ReadWriteLock ，也有具体的实现ReentrantReadWriteLock。 </p>
<p>4.1.9.11. 共享锁和独占锁 </p>
<p>java 并发包提供的加锁模式分为独占锁和共享锁。 </p>
<p>独占锁<br>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 </p>
<p>共享锁<br>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 </li>
<li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。 </li>
</ol>
<p>4.1.9.12. 重量级锁（Mutex Lock） </p>
<p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。<br>JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。 </p>
<p>4.1.9.13. 轻量级锁 </p>
<p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。 </p>
<p>锁升级<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场<br>景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 </p>
<p>4.1.9.14. 偏向锁 </p>
<p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。<br>上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。 </p>
<p>4.1.9.15. 分段锁 </p>
<p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践 </p>
<p>4.1.9.16. 锁优化 </p>
<p>减少锁持有时间<br>只用在有线程安全要求的程序上加锁 </p>
<p>减小锁粒度<br>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<br>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。 </p>
<p>锁分离<br>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] </p>
<p>JDK 并发包<br>1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据 </p>
<p>锁粗化<br>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。 </p>
<p>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。<br>参考：<a href="https://www.jianshu.com/p/39628e1180a9">https://www.jianshu.com/p/39628e1180a9</a> </p>
<p>4.1.10. 线程基本方法<br>线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。  </p>
<p> 4.1.10.1. 线程等待（wait） </p>
<p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。 </p>
<p>4.1.10.2. 线程睡眠（sleep） </p>
<p>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态 </p>
<p>4.1.10.3. 线程让步（yield） </p>
<p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。 </p>
<p>4.1.10.4. 线程中断（interrupt） </p>
<p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。 </p>
<ol>
<li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。 </p>
</li>
<li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 </p>
</li>
<li><p>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 </p>
</li>
<li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。 </p>
</li>
</ol>
<p>4.1.10.5. Join 等待其他线程终止 </p>
<p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 </p>
<p>4.1.10.6. 为什么要用 join()方法？ </p>
<p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。</p>
<pre><code>System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;); 
 Thread6 thread1 = new Thread6(); 
 thread1.setName(&quot;线程 B&quot;); 
 thread1.join(); 
System.out.println(&quot;这时 thread1 执行完毕之后才能执行主线程&quot;); 
</code></pre>
<p>4.1.10.7. 线程唤醒（notify） </p>
<p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。 </p>
<p>4.1.10.8. 其他方法： </p>
<ol>
<li>sleep()：强迫一个线程睡眠Ｎ毫秒。 </li>
<li>isAlive()： 判断一个线程是否存活。 </li>
<li>join()： 等待线程终止。 </li>
<li>activeCount()： 程序中活跃的线程数。 </li>
<li>enumerate()： 枚举程序中的线程。 </li>
<li>currentThread()： 得到当前线程。 </li>
<li>isDaemon()： 一个线程是否为守护线程。 </li>
<li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </li>
<li>setName()： 为线程设置一个名称。 </li>
<li>wait()： 强迫一个线程等待。</li>
<li>notify()： 通知一个线程继续运行。 </li>
<li>setPriority()： 设置一个线程的优先级。 </li>
<li>getPriority():：获得一个线程的优先级。 </li>
</ol>
<p>4.1.11. 线程上下文切换<br>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。 </p>
<p>  4.1.11.1. 进程 </p>
<p>（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。 </p>
<p>4.1.11.2. 上下文 </p>
<p>是指某一时间点 CPU 寄存器和程序计数器的内容。 </p>
<p>4.1.11.3. 寄存器 </p>
<p>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。 </p>
<p>4.1.11.4. 程序计数器 </p>
<p>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。 </p>
<p>4.1.11.5. PCB-“切换桢” </p>
<p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。 </p>
<p>4.1.11.6. 上下文切换的活动： </p>
<ol>
<li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。 </li>
<li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 </li>
<li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。 </li>
</ol>
<p>4.1.11.7. 引起线程上下文切换的原因 </p>
<ol>
<li>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； </li>
<li>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务； </li>
<li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务； </li>
<li>用户代码挂起当前任务，让出 CPU 时间； </li>
<li>硬件中断； </li>
</ol>
<p>4.1.12. 同步锁与死锁<br>4.1.12.1. 同步锁 </p>
<p>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。 </p>
<p>4.1.12.2. 死锁 </p>
<p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 </p>
<p>4.1.13. 线程池原理 </p>
<p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。 </p>
<p>4.1.13.1. 线程复用 </p>
<p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。 </p>
<p>4.1.13.2. 线程池的组成 </p>
<p>一般的线程池主要分为以下 4 个组成部分：  </p>
<ol>
<li><p>线程池管理器：用于创建并管理线程池 </p>
</li>
<li><p>工作线程：线程池中的线程 </p>
</li>
<li><p>任务接口：每个任务必须实现的接口，用于工作线程调度其运行 </p>
</li>
<li><p>任务队列：用于存放待处理的任务，提供一种缓冲机制<br>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。  ThreadPoolExecutor 的构造方法如下：</p>
<p> public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,<br> TimeUnit unit, BlockingQueue<Runnable> workQueue) {<br>  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>  Executors.defaultThreadFactory(), defaultHandler);<br> } </Runnable></p>
</li>
<li><p>corePoolSize：指定了线程池中的线程数量。 </p>
</li>
<li><p>maximumPoolSize：指定了线程池中的最大线程数量。 </p>
</li>
<li><p>keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。 </p>
</li>
<li><p>unit：keepAliveTime 的单位。 </p>
</li>
<li><p>workQueue：任务队列，被提交但尚未被执行的任务。 </p>
</li>
<li><p>threadFactory：线程工厂，用于创建线程，一般用默认的即可。 </p>
</li>
<li><p>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。 </p>
</li>
</ol>
<p>4.1.13.3. 拒绝策略 </p>
<p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。<br>JDK 内置的拒绝策略如下： </p>
<ol>
<li>AbortPolicy ： 直接抛出异常，阻止系统正常运行。 </li>
<li>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 </li>
<li>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 </li>
<li>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。<br>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。 </li>
</ol>
<p>4.1.13.4. Java 线程池工作过程 </p>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 </li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 </li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。 </li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 </li>
</ol>
<p>4.1.14. JAVA 阻塞队列原理<br>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况： </p>
<ol>
<li><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。 </p>
</li>
<li><p>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</p>
</li>
<li><p>1.14.1. 阻塞队列的主要方法</p>
</li>
</ol>
<p>抛出异常：抛出一个异常；<br>特殊值：返回一个特殊值（null 或 false,视情况而定）<br>则塞：在成功操作之前，一直阻塞线程<br>超时：放弃前只在最大的时间内阻塞 </p>
<p>插入操作： </p>
<p>1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。<br>2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。<br>3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要） </p>
<pre><code>public void put(E paramE) throws InterruptedException &#123; 
 checkNotNull(paramE); 
 ReentrantLock localReentrantLock = this.lock; 
 localReentrantLock.lockInterruptibly(); 
 try &#123; 
 while (this.count == this.items.length) 
 this.notFull.await();//如果队列满了，则线程阻塞等待 
 enqueue(paramE); 
 
 localReentrantLock.unlock(); 
 &#125; finally &#123; 
 localReentrantLock.unlock(); 
 &#125; 
 &#125; 
 
</code></pre>
<p>4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。  </p>
<p>获取数据操作： </p>
<p>1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;<br>2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。<br>3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。<br>4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 </p>
<p>4.1.14.2. Java 中的阻塞队列 </p>
<ol>
<li>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 </li>
<li>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 </li>
<li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列。 </li>
<li>SynchronousQueue：不存储元素的阻塞队列。 </li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列  </li>
</ol>
<p>4.1.14.3. ArrayBlockingQueue（公平、非公平） </p>
<p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列： </p>
<pre><code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true); 
</code></pre>
<p>4.1.14.4. LinkedBlockingQueue（两个独立锁提高并发） </p>
<p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 </p>
<p>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 </p>
<p>4.1.14.5. PriorityBlockingQueue（compareTo 排序实现优先） </p>
<p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 </p>
<p>4.1.14.6. DelayQueue（缓存失效、定时任务 ） </p>
<p>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景： </p>
<ol>
<li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。 </li>
<li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。 </li>
</ol>
<p>4.1.14.7. SynchronousQueue（不存储数据、可用于传递数据） </p>
<p>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。<br>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用， SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和<br>ArrayBlockingQueue。 </p>
<p>4.1.14.8. LinkedTransferQueue </p>
<p>是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。 </p>
<ol>
<li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。 </li>
<li>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。<br>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 </li>
</ol>
<p>4.1.14.9. LinkedBlockingDeque </p>
<p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。<br>双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，<br>peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同<br>于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。 </p>
<p>4.1.15. CyclicBarrier、CountDownLatch、Semaphore 的用法<br>4.1.15.1. CountDownLatch（线程计数器 ） </p>
<p>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch<br>来实现这种功能了。 </p>
<pre><code>final CountDownLatch latch = new CountDownLatch(2); 
 new Thread()&#123;public void run() &#123; 
System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;); 
 Thread.sleep(3000); 
 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;); 
 latch.countDown(); 
&#125;;&#125;.start(); 
 new Thread()&#123; public void run() &#123; 
System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;); 
 Thread.sleep(3000); 
 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;); 
 latch.countDown(); 
 &#125;;&#125;.start(); 
 System.out.println(&quot;等待 2 个子线程执行完毕...&quot;); 
 latch.await(); 
 System.out.println(&quot;2 个子线程已经执行完毕&quot;); 
 System.out.println(&quot;继续执行主线程&quot;); 
 &#125; 
</code></pre>
<p>4.1.15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行） </p>
<p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。<br>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本： </p>
<ol>
<li>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务； </li>
<li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</li>
</ol>
<p>具体使用如下，另外 CyclicBarrier 是可以重用的。</p>
<pre><code>public static void main(String[] args) &#123; 
 int N = 4; 
 CyclicBarrier barrier = new CyclicBarrier(N); 
 for(int i=0;i&lt;N;i++) 
 new Writer(barrier).start(); 
 &#125; 
 static class Writer extends Thread&#123; 
 private CyclicBarrier cyclicBarrier; 
 public Writer(CyclicBarrier cyclicBarrier) &#123; 
 this.cyclicBarrier = cyclicBarrier; 
 &#125; 
 @Override 
 public void run() &#123; 
 try &#123; 
 Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作 
System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;); 
 cyclicBarrier.await(); 
 &#125; catch (InterruptedException e) &#123; 
 e.printStackTrace(); 
 &#125;catch(BrokenBarrierException e)&#123; 
 e.printStackTrace(); 
 &#125; 
 System.out.println(&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;); 
 &#125; 
 &#125; 
</code></pre>
<p>4.1.15.3. Semaphore（信号量-控制同时访问的线程个数） </p>
<p>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>Semaphore 类中比较重要的几个方法： </p>
<ol>
<li><p>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 </p>
</li>
<li><p>public void acquire(int permits):获取 permits 个许可 </p>
</li>
<li><p>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 </p>
</li>
<li><p>public void release(int permits) { }:释放 permits 个许可上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法 </p>
</li>
<li><p>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p>
</li>
<li><p>还可以通过 availablePermits()方法得到可用的许可数目。<br>例子：若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现： </p>
<p> int N = 8; //工人数<br>  Semaphore semaphore = new Semaphore(5); //机器数目<br>  for(int i=0;i&lt;N;i++)<br>  new Worker(i,semaphore).start();<br>  }<br>  static class Worker extends Thread{<br>  private int num;<br>  private Semaphore semaphore;<br>  public Worker(int num,Semaphore semaphore){<br>  this.num = num;<br>  this.semaphore = semaphore;<br>  } </p>
<p>  @Override<br>  public void run() {<br>  try {<br>  semaphore.acquire();<br>  System.out.println(“工人”+this.num+”占用一个机器在生产…”);<br>  Thread.sleep(2000);<br>  System.out.println(“工人”+this.num+”释放出机器”);<br>  semaphore.release();<br>  } catch (InterruptedException e) {<br>  e.printStackTrace();<br>  }<br>  } </p>
</li>
</ol>
<p>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；<br>CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；<br>而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。<br>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<p>4.1.16. volatile 关键字的作用（变量可见性、禁止重排序）<br>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。 </p>
<p>变量可见性<br>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。 </p>
<p>禁止重排序<br> volatile 禁止了指令重排。 </p>
<p>比 sychronized 更轻量级的同步锁<br>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。 </p>
<p> 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 </p>
<p>适用场景<br>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场<br>景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<br> （1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。<br>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。 </p>
<p>4.1.17. 如何在两个线程之间共享数据<br>Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法：<br>将数据抽象成一个类，并将数据的操作作为这个类的方法 </p>
<ol>
<li><p>将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到<br>同步，只要在方法上加”synchronized“</p>
<p> public class MyData {<br>  private int j=0;<br> public synchronized void add(){<br>  j++;<br> System.out.println(“线程”+Thread.currentThread().getName()+”j 为：”+j);<br> }<br> public synchronized void dec(){<br>  j–;<br>  System.out.println(“线程”+Thread.currentThread().getName()+”j 为：”+j);<br>  }<br>  public int getData(){<br>  return j;<br>  }<br> }<br> public class AddRunnable implements Runnable{<br>  MyData data;<br>  public AddRunnable(MyData data){<br>  this.data= data;<br>  }<br> public void run() {<br>  data.add();<br>  }<br>  }<br> public class DecRunnable implements Runnable {<br>  MyData data;<br>  public DecRunnable(MyData data){<br>  this.data = data;<br>  }<br>  public void run() {<br>  data.dec();<br>  }<br> }<br>  public static void main(String[] args) {<br>  MyData data = new MyData();<br>  Runnable add = new AddRunnable(data);<br>  Runnable dec = new DecRunnable(data);<br>  for(int i=0;i&lt;2;i++){<br>  new Thread(add).start();<br>  new Thread(dec).start();<br>  } </p>
</li>
</ol>
<p>Runnable 对象作为一个类的内部类 </p>
<ol start="2">
<li><p>将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。</p>
<p> public class MyData {<br>  private int j=0;<br>  public synchronized void add(){<br>  j++;<br>  System.out.println(“线程”+Thread.currentThread().getName()+”j 为：”+j);<br>  }<br>  public synchronized void dec(){<br>  j–;<br>  System.out.println(“线程”+Thread.currentThread().getName()+”j 为：”+j);<br>  }<br>  public int getData(){<br>  return j; }<br> }<br> public class TestThread {<br>  public static void main(String[] args) {<br>  final MyData data = new MyData();<br>  for(int i=0;i&lt;2;i++){<br>  new Thread(new Runnable(){<br>  public void run() {<br>  data.add();<br>  }<br>  }).start();<br>  new Thread(new Runnable(){<br>  public void run() {<br>  data.dec();<br>  }<br>  }).start();<br>  }<br>  }<br> } </p>
</li>
</ol>
<p>4.1.18. ThreadLocal 作用（线程本地存储）<br>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br>ThreadLocalMap（线程的一个属性） </p>
<ol>
<li>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 </li>
<li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 </li>
<li>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义 ThreadLocal.ThreadLocalMap threadLocals = null;</li>
</ol>
<p>使用场景<br>最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。 </p>
<pre><code>private static final ThreadLocal threadSession = new ThreadLocal(); 
public static Session getSession() throws InfrastructureException &#123; 
 Session s = (Session) threadSession.get(); 
 try &#123; 
 if (s == null) &#123; 
 s = getSessionFactory().openSession(); 
 threadSession.set(s); 
 &#125; 
 &#125; catch (HibernateException ex) &#123; 
 throw new InfrastructureException(ex); 
 &#125; 
 return s; 
&#125; 
</code></pre>
<p>4.1.19. synchronized 和 ReentrantLock 的区别<br>4.1.19.1. 两者的共同点： </p>
<ol>
<li>都是用来协调多线程对共享对象、变量的访问 </li>
<li>都是可重入锁，同一线程可以多次获得同一个锁 </li>
<li>都保证了可见性和互斥性 </li>
</ol>
<p>4.1.19.2. 两者的不同点： </p>
<ol>
<li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 </li>
<li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 </li>
<li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 </li>
<li>ReentrantLock 可以实现公平锁 </li>
<li>ReentrantLock 通过 Condition 可以绑定多个条件 </li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略 </li>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 </li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 </li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 </li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 </li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。 </li>
</ol>
<p>4.1.20. ConcurrentHashMap 并发<br>4.1.20.1. 减小锁粒度 </p>
<p>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。 </p>
<p>4.1.20.2. ConcurrentHashMap 分段锁 </p>
<p>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。<br>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p>
<p>4.1.21. Java 中用到的线程调度<br>4.1.21.1. 抢占式调度：<br>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。 </p>
<p>4.1.21.2. 协同式调度： </p>
<p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。  </p>
<p>4.1.21.3. JVM 的线程调度实现（抢占式调度） </p>
<p>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。 </p>
<p>4.1.21.4. 线程让出 cpu 的情况： </p>
<ol>
<li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。 </li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。 </li>
<li>当前运行线程结束，即运行完 run()方法里面的任务。 </li>
</ol>
<p>4.1.22. 进程调度算法<br>4.1.22.1. 优先调度算法 </p>
<ol>
<li>先来先服务调度算法（FCFS）<br>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机， 使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。 </li>
<li>短作业(进程)优先调度算法<br>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。 </li>
</ol>
<p>4.1.22.2. 高优先权优先调度算法 </p>
<p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。 </p>
<ol>
<li>非抢占式优先权算法<br>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 </li>
<li>抢占式优先权调度算法<br>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。<br>2．高响应比优先调度算法<br>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行 得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时 间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的 变化规律可描述为：</li>
</ol>
<p> (1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。<br> (2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。<br> (3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。 </p>
<p>4.1.22.3. 基于时间片的轮转调度算法 </p>
<ol>
<li><p>时间片轮转法<br>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度 时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行 的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行， 并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执 行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处 理机执行时间。 </p>
</li>
<li><p>多级反馈队列调度算法<br>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二 个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各 不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的 时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长 一倍。<br>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当 轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时 尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果 它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个 长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。<br>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时， 才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优 先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即 由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。  在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间 时，便能够较好的满足各种类型用户的需要。 </p>
</li>
</ol>
<p>4.1.23. 什么是 CAS（比较并交换-乐观锁机制-锁自旋）<br>4.1.23.1. 概念及特性 </p>
<p>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。<br>当且仅当 V 值等 于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。<br>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时 使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂 起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理， CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 </p>
<p>4.1.23.2. 原子包 java.util.concurrent.atomic（锁自旋） </p>
<p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就 是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个 线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等 到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。 相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切 换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码：</p>
<pre><code>public class AtomicInteger extends Number implements java.io.Serializable &#123; 
 private volatile int value; 
public final int get() &#123; 
 return value; 
 &#125; 
 public final int getAndIncrement() &#123; 
 for (;;) &#123; //CAS 自旋，一直尝试，直达成功 
 int current = get(); 
 int next = current + 1; 
 if (compareAndSet(current, next)) 
 return current; 
 &#125; 
 &#125; 
 public final boolean compareAndSet(int expect, int update) &#123; 
 return unsafe.compareAndSwapInt(this, valueOffset, expect, update); 
 &#125; 
&#125; 
</code></pre>
<p>getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行 CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成 CPU 指令的操作。 </p>
<p> 4.1.23.3. ABA 问题 </p>
<p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时 刻比较并替换，那么在这个时间差类会导致数据的变化。<br>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操 作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过 程就是没有问题的。<br>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修 改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本 号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问 题，因为版本号只会增加不会减少。 </p>
<p>4.1.24. 什么是 AQS（抽象的队列同步器）<br>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问 共享资源的同步器框架，许多同步类实现都依赖于它，如常用的 ReentrantLock/Semaphore/CountDownLatch。 </p>
<p>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:<br>    getState()<br>    setState()<br>    compareAndSetState() </p>
<p>AQS 定义两种资源共享方式<br>    Exclusive 独占资源-ReentrantLock<br>    Exclusive（独占，只有一个线程能执行，如 ReentrantLock）<br>    Share 共享资源-Semaphore/CountDownLatch<br>    Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。 </p>
<p>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个 接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成 abstract ，是因为独占模式下只用实现 tryAcquire-tryRelease ，而共享模式下只用实现 tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模 式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实 现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/ 唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： </p>
<p>1． isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。<br>2． tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。<br>3． tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。<br>4． tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>5． tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。 </p>
<p>同步器的实现是 ABS 核心（state 资源状态计数）<br>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失 败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放 锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意， 获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。<br>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与 线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程 就会从 await()函数返回，继续后余动作。<br>ReentrantReadWriteLock 实现独占和共享两种方式<br>————————————————<br>版权声明：本文为CSDN博主「Y·C」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_54853465/article/details/125463693">https://blog.csdn.net/m0_54853465/article/details/125463693</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java突击：02-List</title>
    <url>/2023/04/14/Java%E7%AA%81%E5%87%BB%EF%BC%9A02-List/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ArrayList和LinkedList的区别？分别用在什么场景？"><a href="#ArrayList和LinkedList的区别？分别用在什么场景？" class="headerlink" title="ArrayList和LinkedList的区别？分别用在什么场景？"></a>ArrayList和LinkedList的区别？分别用在什么场景？</h1><p>答：</p>
<p>①ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。<br>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列<br>②当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>③当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。<br>④从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。<br>⑤ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。</p>
<p>场景：<br>链表，插入删除快，查找修改慢。 适用于频繁增删的场景。<br>数组，查找快，插入删除慢。 适用于频繁查找和修改的场景。</p>
<p>3.1. 接口继承关系和实现<br>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。 </p>
<ol>
<li><p>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 </p>
</li>
<li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </p>
</li>
<li><p>Map：是映射表的基础接口 </p>
</li>
<li><ol start="2">
<li>List<br>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。 </li>
</ol>
</li>
<li><p>2.1. ArrayList（数组）<br>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进<br>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 </p>
</li>
</ol>
<p>3.2.2. Vector（数组实现、线程同步）<br>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 </p>
<p>3.2.3. LinkList（链表）<br>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 </p>
<p>3.3. Set<br>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>法。</p>
<p>3.3.1.1. HashSet（Hash 表）<br>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。<br>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 </p>
<p>3.3.1.2. TreeSet（二叉树） </p>
<ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。 </li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 </li>
</ol>
<p>3.3.1.3. LinkHashSet（HashSet+LinkedHashMap）<br> 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。<br> LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 </p>
<p>3.4. Map</p>
<p> 3.4.1. HashMap（数组+链表+红黑树）<br>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 </p>
<p>3.4.1.1. JAVA7 实现<br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 </p>
<ol>
<li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，等于 capacity * loadFactor  </li>
</ol>
<p>3.4.1.2. JAVA8 实现 </p>
<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 </p>
<p>3.4.2. ConcurrentHashMap<br>3.4.2.1. Segment 段 </p>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。 </p>
<p>3.4.2.2. 线程安全（Segment 继承 ReentrantLock 加锁） </p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。  </p>
<p>3.4.2.3. 并行度（默认 16） </p>
<p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p>
<p>3.4.2.4. Java8 实现 （引入了红黑树） </p>
<p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。  </p>
<p>3.4.3. HashTable（线程安全）<br>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 </p>
<p>3.4.4. TreeMap（可排序）<br>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。<br>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a> </p>
<p>3.4.5. LinkHashMap（记录插入顺序）<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Java突击：01-JVM</title>
    <url>/2023/04/13/Java%E7%AA%81%E5%87%BB%EF%BC%9A01-JVM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JVM面试题</p>
<h1 id="1、内存模型以及分区，需要详细到每个区放什么。"><a href="#1、内存模型以及分区，需要详细到每个区放什么。" class="headerlink" title="1、内存模型以及分区，需要详细到每个区放什么。"></a>1、内存模型以及分区，需要详细到每个区放什么。</h1><p>JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面， class 类信息常量池（static 常量和 static 变量）等放在方法区 new:</p>
<ul>
<li>方法区：<br>主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。</li>
<li>堆：<br>初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。</li>
<li>栈：<br>栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。</li>
<li>本地方法栈：<br>主要为 Native 方法服务程序计数器：记录当前线程执行的行号</li>
</ul>
<h1 id="2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。"><a href="#2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。" class="headerlink" title="2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。"></a>2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</h1><p>堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包 含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候， 就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</p>
<h1 id="3-GC-的两种判定方法"><a href="#3-GC-的两种判定方法" class="headerlink" title="3. GC 的两种判定方法"></a>3. GC 的两种判定方法</h1><p>引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A） 的情况。引用链法： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GCROOT 就说明，不能到达 GC ROOT 就说明可以回收。</p>
<h1 id="4-Minor-GC-与-Full-GC-分别在什么时候发生？"><a href="#4-Minor-GC-与-Full-GC-分别在什么时候发生？" class="headerlink" title="4. Minor GC 与 Full GC 分别在什么时候发生？"></a>4. Minor GC 与 Full GC 分别在什么时候发生？</h1><p>首先区分一下Minor GC和Full GC。<br>Minor GC是新生代GC，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死的，所以Minor GC非常平凡，一般回收速度也比较i快。</p>
<p>Major GC/Full GC 是老年代GC，指的是发生在老年代的GC，出现Major GC一般经常会伴有Minor GC，Major GC的速度比Minor GC慢的多。</p>
<p>何时发生？<br>(1)Minor GC发生：当jvm无法为新的对象分配空间的时候就会发生Minor gc，所以分配对象的频率越高，也就越容易发生Minor gc。<br>(2)Full GC：发生GC有两种情况：<br>①当老年代无法分配内存的时候，会导致MinorGC。<br>②当发生Minor GC的时候可能触发Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次Minor GC以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生Full GC。</p>
<h1 id="5-类加载的几个过程："><a href="#5-类加载的几个过程：" class="headerlink" title="5. 类加载的几个过程："></a>5. 类加载的几个过程：</h1><p>加载、验证、准备、解析、初始化。然后是使用和卸载了</p>
<p>通过全限定名来加载生成 class 对象到内存中，然后进行验证这个 class 文件，包括文件格式校验、元数据验证，字节码校验等。准备是对这个对象分配内存。解析是将符号引用转化为直接引用（指针引用），初始化就是开始执行构造器的代码</p>
<h1 id="6-JVM-内存分哪几个区，每个区的作用是什么"><a href="#6-JVM-内存分哪几个区，每个区的作用是什么" class="headerlink" title="6.JVM 内存分哪几个区，每个区的作用是什么"></a>6.JVM 内存分哪几个区，每个区的作用是什么</h1><p>java 虚拟机主要分为以下几个区:</p>
<ul>
<li><p>方法区：<br>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。该区域是被线程共享的。方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p>
</li>
<li><p>虚拟机栈:<br>虚拟机栈也就是我们平常所称的栈内存,它为 java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。虚拟机栈是线程私有的，它的生命周期与线程相同。局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p>
</li>
<li><p>本地方法栈：<br>本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</p>
</li>
</ul>
<p>*堆<br>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p>
<p>*程序计数器<br>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码，指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。</p>
<h1 id="7-如和判断一个对象是否存活-或者-GC-对象的判定方法）"><a href="#7-如和判断一个对象是否存活-或者-GC-对象的判定方法）" class="headerlink" title="7.如和判断一个对象是否存活?(或者 GC 对象的判定方法）"></a>7.如和判断一个对象是否存活?(或者 GC 对象的判定方法）</h1><p>判断一个对象是否存活有两种方法:</p>
<p>1.引用计数法<br>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.<br>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p>
<p>2.可达性算法(引用链法)<br>该算法的思想是：从一个被称为 GC Roots的对象开始向下搜索，如果一个对象到 GCRoots 没有任何引用链相连时，则说明此对象不可用。<br>在 java 中可以作为 GC Roots 的对象有以下几种:<br>虚拟机栈中引用的对象方法区类静态属性引用的对象方法区常量池引用的对象本地方法栈 JNI 引用的对象<br>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记<br>如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。<br>如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 FQueue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</p>
<h1 id="8-java-中垃圾收集的方法有哪些"><a href="#8-java-中垃圾收集的方法有哪些" class="headerlink" title="8.java 中垃圾收集的方法有哪些?"></a>8.java 中垃圾收集的方法有哪些?</h1><p>标记-清除:<br>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想是从根对象开始遍历所有可达对象，并将其标记为“非垃圾”，然后清除未被标记的对象，即“垃圾”。具体来说，标记清除算法包含以下两个阶段：</p>
<p>标记阶段：从根对象开始遍历所有可达对象，并将其标记为“非垃圾”。<br>清除阶段：扫描整个堆，将未被标记的对象进行回收（或者放入空闲链表等待下一次分配）。</p>
<p>通过这种方式，标记清除算法可以有效地回收不再使用的内存空间，提高程序的内存利用效率。这种方法很简单，但是会有两个主要问题：<br>1.效率不高，标记和清除的效率都很低；<br>2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。</p>
<p>复制算法:<br>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。<br>于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。<br>每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)</p>
<p>标记-整理：<br>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</p>
<p>分代收集：<br>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理或者 标记-清除。</p>
<h1 id="9-什么是类加载器，类加载器有哪些"><a href="#9-什么是类加载器，类加载器有哪些" class="headerlink" title="9.什么是类加载器，类加载器有哪些?"></a>9.什么是类加载器，类加载器有哪些?</h1><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<p>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH） 来加载 Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</p>
<h1 id="10-类加载器双亲委派模型机制？"><a href="#10-类加载器双亲委派模型机制？" class="headerlink" title="10. 类加载器双亲委派模型机制？"></a>10. 类加载器双亲委派模型机制？</h1><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h1 id="11-什么情况下会发生栈内存溢出？"><a href="#11-什么情况下会发生栈内存溢出？" class="headerlink" title="11.什么情况下会发生栈内存溢出？"></a>11.什么情况下会发生栈内存溢出？</h1><p>1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；<br>2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；<br>3、调整参数-xss去调整jvm栈的大小</p>
<h1 id="12-怎么打破双亲委派模型？"><a href="#12-怎么打破双亲委派模型？" class="headerlink" title="12.怎么打破双亲委派模型？"></a>12.怎么打破双亲委派模型？</h1><p>自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法；</p>
<h1 id="13-强引用、软应用、弱引用、虚引用的区别？"><a href="#13-强引用、软应用、弱引用、虚引用的区别？" class="headerlink" title="13.强引用、软应用、弱引用、虚引用的区别？"></a>13.强引用、软应用、弱引用、虚引用的区别？</h1><p>强引用：<br>强引用是我们使用最广泛的引用，如果一个对象具有强引用，那么垃圾回收期绝对不会回收它，当内存空间不足时，垃圾回收器宁愿抛出OutOfMemoryError，也不会回收具有强引用的对象；我们可以通过显示的将强引用对象置为null，让gc认为该对象不存在引用，从而来回收它；</p>
<p>软引用：<br>软应用是用来描述一些有用但不是必须的对象，在java中用SoftReference来表示，当一个对象只有软应用时，只有当内存不足时，才会回收它；<br>软引用可以和引用队列联合使用，如果软引用所引用的对象被垃圾回收器所回收了，虚拟机会把这个软引用加入到与之对应的引用队列中；</p>
<p>弱引用：<br>弱引用是用来描述一些可有可无的对象，在java中用WeakReference来表示，在垃圾回收时，一旦发现一个对象只具有软引用的时候，无论当前内存空间是否充足，都会回收掉该对象；<br>弱引用可以和引用队列联合使用，如果弱引用所引用的对象被垃圾回收了，虚拟机会将该对象的引用加入到与之关联的引用队列中；</p>
<p>虚引用：<br>虚引用就是一种可有可无的引用，无法用来表示对象的生命周期，任何时候都可能被回收，虚引用主要使用来跟踪对象被垃圾回收的活动，虚引用和软引用与弱引用的区别在于：虚引用必须和引用队列联合使用；在进行垃圾回收的时候，如果发现一个对象只有虚引用，那么就会将这个对象的引用加入到与之关联的引用队列中，程序可以通过发现一个引用队列中是否已经加入了虚引用，来了解被引用的对象是否需要被进行垃圾回收；</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JVM在一些互联网大厂是面试必问的一个技术点，所以在面试时一定要注重重点，想一些高并发高可用的技术。面试时要掌握节奏，说一些让面试官眼前一亮的技术，有些基础的东西能少说就少说，毕竟面试官面了这么多早就听够了，越是稀少的越是能激发面试官的兴趣，然后掌握在自己的节奏中。</p>
<h1 id="1、Java-是如何实现跨平台的？"><a href="#1、Java-是如何实现跨平台的？" class="headerlink" title="1、Java 是如何实现跨平台的？"></a>1、Java 是如何实现跨平台的？</h1><p>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p>
<p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p>
<h1 id="2、什么是-JVM-？"><a href="#2、什么是-JVM-？" class="headerlink" title="2、什么是 JVM ？"></a>2、什么是 JVM ？</h1><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p>
<p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。<br>JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h1 id="3、JVM-由哪些部分组成？"><a href="#3、JVM-由哪些部分组成？" class="headerlink" title="3、JVM 由哪些部分组成？"></a>3、JVM 由哪些部分组成？</h1><p>解析：这是对 JVM 体系结构的考察</p>
<p>答：JVM 的结构基本上由 4 部分组成：</p>
<p>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p>
<p>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p>
<p>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p>
<p>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</p>
<h1 id="4、类加载器是有了解吗？"><a href="#4、类加载器是有了解吗？" class="headerlink" title="4、类加载器是有了解吗？"></a>4、类加载器是有了解吗？</h1><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p>
<p>答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p>
<p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<h1 id="5、面试官：Java-虚拟机是如何判定两个-Java-类是相同的？"><a href="#5、面试官：Java-虚拟机是如何判定两个-Java-类是相同的？" class="headerlink" title="5、面试官：Java 虚拟机是如何判定两个 Java 类是相同的？"></a>5、面试官：Java 虚拟机是如何判定两个 Java 类是相同的？</h1><p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p>
<h1 id="6、类似-Xms、-Xmn这些参数的含义：答："><a href="#6、类似-Xms、-Xmn这些参数的含义：答：" class="headerlink" title="6、类似-Xms、-Xmn这些参数的含义：答："></a>6、类似-Xms、-Xmn这些参数的含义：答：</h1><p>堆内存分配：<br>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br>非堆内存分配：<br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>-Xmn2G：设置年轻代大小为2G。<br>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>(1) 基本概念： </p>
<p> JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 </p>
<p>(2) 运行过程：<br>   我们都知道Java源文件，通过编译器，能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。 </p>
<p>也就是如下：    </p>
<p> ① Java源文件—-&gt;编译器—-&gt;字节码文件<br> ② 字节码文件—-&gt;JVM—-&gt;机器码<br> 每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p>
<h2 id="2-1-线程"><a href="#2-1-线程" class="headerlink" title="2.1. 线程"></a>2.1. 线程</h2><p>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。<br>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。<br>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。 </p>
<p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p>
<p>虚拟机线程（VM thread）<br>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</p>
<p>周期性任务线程<br>这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</p>
<p>GC 线程<br>这些线程支持 JVM 中不同的垃圾回收活动。 </p>
<p>编译器线程<br>这些线程在运行时将字节码动态编译成本地平台相关的机器码。 </p>
<p>信号分发线程<br>这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</p>
<h2 id="2-2-JVM-内存区域"><a href="#2-2-JVM-内存区域" class="headerlink" title="2.2. JVM 内存区域"></a>2.2. JVM 内存区域</h2><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。<br>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。  </p>
<p>线程共享区域随虚拟机的启动/关闭而创建/销毁。<br>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p>
<h3 id="2-2-1-程序计数器-线程私有"><a href="#2-2-1-程序计数器-线程私有" class="headerlink" title="2.2.1. 程序计数器(线程私有)"></a>2.2.1. 程序计数器(线程私有)</h3><pre><code>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。 
正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。 
这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。  
</code></pre>
<h3 id="2-2-2-虚拟机栈-线程私有"><a href="#2-2-2-虚拟机栈-线程私有" class="headerlink" title="2.2.2. 虚拟机栈(线程私有)"></a>2.2.2. 虚拟机栈(线程私有)</h3><pre><code>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 
栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。  
</code></pre>
<h3 id="2-2-3-本地方法区-线程私有"><a href="#2-2-3-本地方法区-线程私有" class="headerlink" title="2.2.3. 本地方法区(线程私有)"></a>2.2.3. 本地方法区(线程私有)</h3><pre><code>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 
</code></pre>
<h3 id="2-2-4-堆（Heap-线程共享）-运行时数据区"><a href="#2-2-4-堆（Heap-线程共享）-运行时数据区" class="headerlink" title="2.2.4. 堆（Heap-线程共享）-运行时数据区"></a>2.2.4. 堆（Heap-线程共享）-运行时数据区</h3><pre><code>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。
</code></pre>
<h3 id="2-2-5-方法区-永久代（线程共享）"><a href="#2-2-5-方法区-永久代（线程共享）" class="headerlink" title="2.2.5. 方法区/永久代（线程共享）"></a>2.2.5. 方法区/永久代（线程共享）</h3><pre><code>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。 
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池 （Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。
</code></pre>
<h2 id="2-3-JVM-运行时内存"><a href="#2-3-JVM-运行时内存" class="headerlink" title="2.3. JVM 运行时内存"></a>2.3. JVM 运行时内存</h2><pre><code>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。 
</code></pre>
<h3 id="2-3-1-新生代"><a href="#2-3-1-新生代" class="headerlink" title="2.3.1. 新生代"></a>2.3.1. 新生代</h3><pre><code>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。 
</code></pre>
<p>2.3.1.1. Eden 区<br>    Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 </p>
<p>2.3.1.2. ServivorFrom<br>    上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 </p>
<p>2.3.1.3. ServivorTo<br>    保留了一次 MinorGC 过程中的幸存者。 </p>
<p>2.3.1.4. MinorGC 的过程（复制-&gt;清空-&gt;互换） </p>
<pre><code>MinorGC 采用复制算法。 

1：eden、servicorFrom 复制到 ServicorTo，年龄+1 
首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）； 

2：清空 eden、servicorFrom 
然后，清空 Eden 和 ServicorFrom 中的对象； 

3：ServicorTo 和 ServicorFrom 互换 
最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。 
</code></pre>
<h3 id="2-3-2-老年代"><a href="#2-3-2-老年代" class="headerlink" title="2.3.2. 老年代"></a>2.3.2. 老年代</h3><pre><code>主要存放应用程序中生命周期长的内存对象。 
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。 
MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。 
</code></pre>
<h3 id="2-3-3-永久代"><a href="#2-3-3-永久代" class="headerlink" title="2.3.3. 永久代"></a>2.3.3. 永久代</h3><pre><code>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 
</code></pre>
<p>2.3.3.1. JAVA8 与元数据<br>    在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>
<h2 id="2-4-垃圾回收与算法"><a href="#2-4-垃圾回收与算法" class="headerlink" title="2.4. 垃圾回收与算法"></a>2.4. 垃圾回收与算法</h2><h3 id="2-4-1-如何确定垃圾"><a href="#2-4-1-如何确定垃圾" class="headerlink" title="2.4.1. 如何确定垃圾"></a>2.4.1. 如何确定垃圾</h3><p>2.4.1.1. 引用计数法<br>       在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。 </p>
<p>2.4.1.2. 可达性分析 </p>
<pre><code> 为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。 
</code></pre>
<h3 id="2-4-2-标记清除算法（Mark-Sweep）"><a href="#2-4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="2.4.2. 标记清除算法（Mark-Sweep）"></a>2.4.2. 标记清除算法（Mark-Sweep）</h3><pre><code>  最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图 

  从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。 
</code></pre>
<h3 id="2-4-3-复制算法（copying）"><a href="#2-4-3-复制算法（copying）" class="headerlink" title="2.4.3. 复制算法（copying）"></a>2.4.3. 复制算法（copying）</h3><pre><code>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：  

这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。 
</code></pre>
<h3 id="2-4-4-标记整理算法-Mark-Compact"><a href="#2-4-4-标记整理算法-Mark-Compact" class="headerlink" title="2.4.4. 标记整理算法(Mark-Compact)"></a>2.4.4. 标记整理算法(Mark-Compact)</h3><pre><code>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：
</code></pre>
<h3 id="2-4-5-分代收集算法"><a href="#2-4-5-分代收集算法" class="headerlink" title="2.4.5. 分代收集算法"></a>2.4.5. 分代收集算法</h3><pre><code>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。
</code></pre>
<p>2.4.5.1. 新生代与复制算法</p>
<pre><code>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。  
</code></pre>
<p>2.4.5.2. 老年代与标记复制算法  </p>
<pre><code>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 

1. JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 
2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。 
3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。 
4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 
5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 
6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。
</code></pre>
<h2 id="2-5-JAVA-四中引用类型"><a href="#2-5-JAVA-四中引用类型" class="headerlink" title="2.5. JAVA 四中引用类型"></a>2.5. JAVA 四中引用类型</h2><h3 id="2-5-1-强引用"><a href="#2-5-1-强引用" class="headerlink" title="2.5.1. 强引用"></a>2.5.1. 强引用</h3><pre><code>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。 
</code></pre>
<h3 id="2-5-2-软引用"><a href="#2-5-2-软引用" class="headerlink" title="2.5.2. 软引用"></a>2.5.2. 软引用</h3><pre><code>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 
</code></pre>
<h3 id="2-5-3-弱引用"><a href="#2-5-3-弱引用" class="headerlink" title="2.5.3. 弱引用"></a>2.5.3. 弱引用</h3><pre><code>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
</code></pre>
<h3 id="2-5-4-虚引用"><a href="#2-5-4-虚引用" class="headerlink" title="2.5.4. 虚引用"></a>2.5.4. 虚引用</h3><pre><code>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。 
</code></pre>
<h2 id="2-6-GC-分代收集算法-VS-分区收集算法"><a href="#2-6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="2.6. GC 分代收集算法 VS 分区收集算法"></a>2.6. GC 分代收集算法 VS 分区收集算法</h2><h3 id="2-6-1-分代收集算法"><a href="#2-6-1-分代收集算法" class="headerlink" title="2.6.1. 分代收集算法"></a>2.6.1. 分代收集算法</h3><pre><code>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法 
</code></pre>
<p>2.6.1.1. 在新生代-复制算法<br>    每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. </p>
<p>2.6.1.2. 在老年代-标记整理算法 </p>
<pre><code>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.  
</code></pre>
<h3 id="2-6-2-分区收集算法"><a href="#2-6-2-分区收集算法" class="headerlink" title="2.6.2. 分区收集算法"></a>2.6.2. 分区收集算法</h3><pre><code>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。 
</code></pre>
<h2 id="2-7-GC-垃圾收集器"><a href="#2-7-GC-垃圾收集器" class="headerlink" title="2.7. GC 垃圾收集器"></a>2.7. GC 垃圾收集器</h2><pre><code>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下： 
</code></pre>
<h3 id="2-7-1-Serial-垃圾收集器（单线程、复制算法）"><a href="#2-7-1-Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="2.7.1. Serial 垃圾收集器（单线程、复制算法）"></a>2.7.1. Serial 垃圾收集器（单线程、复制算法）</h3><pre><code>Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。 Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。 
</code></pre>
<h3 id="2-7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#2-7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="2.7.2. ParNew 垃圾收集器（Serial+多线程）"></a>2.7.2. ParNew 垃圾收集器（Serial+多线程）</h3><pre><code>ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。 
ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】 
ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。 
</code></pre>
<h3 id="2-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#2-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）"></a>2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）</h3><pre><code>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。 
</code></pre>
<h3 id="2-7-4-Serial-Old-收集器（单线程标记整理算法-）"><a href="#2-7-4-Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="2.7.4. Serial Old 收集器（单线程标记整理算法 ）"></a>2.7.4. Serial Old 收集器（单线程标记整理算法 ）</h3><pre><code>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。 
在 Server 模式下，主要有两个用途： 
1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。 
2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。 
新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：

新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图： 
</code></pre>
<h3 id="2-7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#2-7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="2.7.5. Parallel Old 收集器（多线程标记整理算法）"></a>2.7.5. Parallel Old 收集器（多线程标记整理算法）</h3><pre><code>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。 

在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 ParallelScavenge和年老代 Parallel Old 收集器的搭配策略。 
新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：  
</code></pre>
<h3 id="2-7-6-CMS-收集器（多线程标记清除算法）"><a href="#2-7-6-CMS-收集器（多线程标记清除算法）" class="headerlink" title="2.7.6. CMS 收集器（多线程标记清除算法）"></a>2.7.6. CMS 收集器（多线程标记清除算法）</h3><pre><code>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 
最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 
CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： 
</code></pre>
<p>2.7.6.1. 初始标记 </p>
<p>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p>
<p>2.7.6.2. 并发标记 </p>
<p>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 </p>
<p>2.7.6.3. 重新标记 </p>
<p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 </p>
<p>2.7.6.4. 并发清除 </p>
<p>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 </p>
<p>CMS 收集器工作过程：</p>
<h3 id="2-7-7-G1-收集器"><a href="#2-7-7-G1-收集器" class="headerlink" title="2.7.7. G1 收集器"></a>2.7.7. G1 收集器</h3><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是： </p>
<ol>
<li>基于标记-整理算法，不产生内存碎片。 </li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。 </li>
</ol>
<h2 id="2-8-JAVA-IO-NIO"><a href="#2-8-JAVA-IO-NIO" class="headerlink" title="2.8. JAVA IO/NIO"></a>2.8. JAVA IO/NIO</h2><h3 id="2-8-1-阻塞-IO-模型"><a href="#2-8-1-阻塞-IO-模型" class="headerlink" title="2.8.1. 阻塞 IO 模型"></a>2.8.1. 阻塞 IO 模型</h3><p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。 </p>
<h3 id="2-8-2-非阻塞-IO-模型"><a href="#2-8-2-非阻塞-IO-模型" class="headerlink" title="2.8.2. 非阻塞 IO 模型"></a>2.8.2. 非阻塞 IO 模型</h3><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下： </p>
<p>while(true){<br> data = socket.read();<br> if(data!= error){<br> //处理数据<br> break;<br> }<br>}<br>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。 </p>
<h3 id="2-8-3-多路复用-IO-模型"><a href="#2-8-3-多路复用-IO-模型" class="headerlink" title="2.8.3. 多路复用 IO 模型"></a>2.8.3. 多路复用 IO 模型</h3><pre><code>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。 
另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。 
不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 
</code></pre>
<h3 id="2-8-4-信号驱动-IO-模型"><a href="#2-8-4-信号驱动-IO-模型" class="headerlink" title="2.8.4. 信号驱动 IO 模型"></a>2.8.4. 信号驱动 IO 模型</h3><pre><code>   在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。 
</code></pre>
<h3 id="2-8-5-异步-IO-模型"><a href="#2-8-5-异步-IO-模型" class="headerlink" title="2.8.5. 异步 IO 模型"></a>2.8.5. 异步 IO 模型</h3><pre><code>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。 
也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。 

   注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。 更多参考： http://www.importnew.com/19816.html 
</code></pre>
<h3 id="2-8-6-JAVA-IO-包"><a href="#2-8-6-JAVA-IO-包" class="headerlink" title="2.8.6. JAVA IO 包"></a>2.8.6. JAVA IO 包</h3><p>2.8.2. JAVA NIO<br>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 </p>
<p>NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 </p>
<p>2.8.2.1. NIO 的缓冲区</p>
<p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的<br>数据。 </p>
<p>2.8.2.2. NIO 的非阻塞 </p>
<p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h3 id="2-8-3-Channel"><a href="#2-8-3-Channel" class="headerlink" title="2.8.3. Channel"></a>2.8.3. Channel</h3><p>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有： </p>
<ol>
<li>FileChannel </li>
<li>DatagramChannel </li>
<li>SocketChannel </li>
<li>ServerSocketChannel </li>
</ol>
<p>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。<br>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。 </p>
<h3 id="2-8-4-Buffer"><a href="#2-8-4-Buffer" class="headerlink" title="2.8.4. Buffer"></a>2.8.4. Buffer</h3><p>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。 </p>
<pre><code>   上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。 
    在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：
</code></pre>
<p>ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer</p>
<h3 id="2-8-5-Selector"><a href="#2-8-5-Selector" class="headerlink" title="2.8.5. Selector"></a>2.8.5. Selector</h3><pre><code>  Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。
</code></pre>
<h2 id="2-9-JVM-类加载机制"><a href="#2-9-JVM-类加载机制" class="headerlink" title="2.9. JVM 类加载机制"></a>2.9. JVM 类加载机制</h2><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。</p>
<p>2.9.1.1. 加载 </p>
<p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 </p>
<p>2.9.1.2. 验证 </p>
<p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p>
<p>2.9.1.3. 准备 </p>
<p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br>public static int v = 8080;<br>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器<client>方法之中。<br>但是注意如果声明为：<br>public static final int v = 8080;<br>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。 </client></p>
<p>2.9.1.4. 解析 </p>
<p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：</p>
<ol>
<li>CONSTANT_Class_info </li>
<li>CONSTANT_Field_info </li>
<li>CONSTANT_Method_info </li>
</ol>
<p>等类型的常量。 </p>
<p>2.9.1.5. 符号引用 </p>
<p>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 </p>
<p>2.9.1.6. 直接引用 </p>
<p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 </p>
<p>2.9.1.7. 初始化 </p>
<p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 </p>
<p>2.9.1.8. 类构造器<client> </client></p>
<p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。<br>注意以下几种情况不会执行类初始化： </client></client></client></client></client></p>
<ol>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 </li>
<li>定义对象数组，不会触发该类的初始化。 </li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 </li>
<li>通过类名获取 Class 对象，不会触发类的初始化。 </li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 </li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 </li>
</ol>
<h3 id="2-9-2-类加载器"><a href="#2-9-2-类加载器" class="headerlink" title="2.9.2. 类加载器"></a>2.9.2. 类加载器</h3><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器： </p>
<p>2.9.2.1. 启动类加载器(Bootstrap ClassLoader) </p>
<ol>
<li>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。 </li>
</ol>
<p>2.9.2.2. 扩展类加载器(Extension ClassLoader) </p>
<ol start="2">
<li>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。 </li>
</ol>
<p>2.9.2.3. 应用程序类加载器(Application ClassLoader)： </p>
<ol start="3">
<li>负责加载用户路径（classpath）上的类库。<br>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。   </li>
</ol>
<h3 id="2-9-3-双亲委派"><a href="#2-9-3-双亲委派" class="headerlink" title="2.9.3. 双亲委派"></a>2.9.3. 双亲委派</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。<br>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。  </p>
<h3 id="2-9-4-OSGI（动态模型系统）"><a href="#2-9-4-OSGI（动态模型系统）" class="headerlink" title="2.9.4. OSGI（动态模型系统）"></a>2.9.4. OSGI（动态模型系统）</h3><p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。 </p>
<p>2.9.4.1. 动态改变构造 </p>
<p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。 </p>
<p>2.9.4.2. 模块化编程与热插拔 </p>
<p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。<br>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。  </p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>kiwix</title>
    <url>/2023/04/12/kiwix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天给大家分享一款离线版维基百科工具。</p>
<h1 id="Kiwix"><a href="#Kiwix" class="headerlink" title="Kiwix"></a>Kiwix</h1><p>Kiwix是一款离线网页浏览器，它是为维基百科离线化而设计的。</p>
<p>用户不需要连接因特网，就可以直接访问/随身携带完整的维基百科，因为所有的资料都储存在你的电脑、U盘等存储。</p>
<p>下载链接: <a href="https://www.kiwix.org/en/download/">https://www.kiwix.org/en/download/</a> </p>
<h1 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h1><p>在使用Kiwix之前，我们需要先前往Kiwix的数据库页面，下载数据包。</p>
<p>资料地址：<a href="https://download.kiwix.org/zim/wikipedia/">https://download.kiwix.org/zim/wikipedia/</a></p>
<p>我们可以用浏览器的「Ctrl F」快捷键，比如想找中文维基百科的全部内容，搜「_zh_all」就能直接定位找到；想搜索计算机相关的，就搜「computer」。</p>
<p>kwⅸ提供体育、化学、物理、历史等等不同的分类。如果设备的空间不够，可以直接下载自己感兴趣的文件。</p>
<p>“zh”表示中文zim文件。</p>
<ul>
<li>mini：默认完整版本，包含除视频和音频外所有内容。文件内容最完整，文件也最大。</li>
<li>maxi：和maxi版本相比，此版本缺少图片资料，因此占用空间比maxi版本小。约省75%存储。</li>
<li>nopic：只有文章介绍和信息框，约省95%存储，适合内存较紧张的设备使用。</li>
</ul>
<p>因此所有zim中，“all_maxi”的文件最大，不过也最完整，比如zh_all_maxi有21G，推荐pc端使用。</p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>wiki</tag>
        <tag>百科</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门14：Windows下环境配置</title>
    <url>/2023/04/11/GO%E5%85%A5%E9%97%A814%EF%BC%9AWindows%E4%B8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>安装包下载地址为：<a href="https://go.dev/dl/%E3%80%82">https://go.dev/dl/。</a></p>
<p>如果打不开可以使用这个地址：<a href="https://golang.google.cn/dl/%E3%80%82">https://golang.google.cn/dl/。</a></p>
<h1 id="Windows-系统下安装"><a href="#Windows-系统下安装" class="headerlink" title="Windows 系统下安装"></a>Windows 系统下安装</h1><p>Windows 下可以使用 .msi 后缀(在下载列表中可以找到该文件，如go1.4.2.windows-amd64.msi)的安装包来安装。</p>
<p>默认情况下 .msi 文件会安装在 c:\Go 目录下。你可以将 c:\Go\bin 目录添加到 Path 环境变量中。添加后你需要重启命令窗口才能生效。</p>
<p>环境变量设置好后，可以通过 go env 命令来进行测试。</p>
<pre><code>C:\Users\Administrator&gt;go env
set GO111MODULE=
set GOARCH=amd64
set GOBIN=
set GOCACHE=C:\Users\Administrator\AppData\Local\go-build
set GOENV=C:\Users\Administrator\AppData\Roaming\go\env
set GOEXE=.exe
set GOFLAGS=
set GOHOSTARCH=amd64
set GOHOSTOS=windows
set GONOPROXY=
set GONOSUMDB=
set GOOS=windows
set GOPATH=C:\Users\Administrator\go
set GOPRIVATE=
set GOPROXY=https://proxy.golang.org,direct
set GOROOT=c:\go
. . .
</code></pre>
<p>上面只显示了部分结果，如果执行go env 命令后，出现类似上面的结果，说明我们的Go开发包已经安装成功了。</p>
<h2 id="配置GOPROXY"><a href="#配置GOPROXY" class="headerlink" title="配置GOPROXY"></a>配置GOPROXY</h2><p>Go1.12版本之后，开始使用go mod模式来管理依赖环境了</p>
<p>由于国内访问不到默认的GOPROXY配置链接，所以我们需要换一个PROXY，这里推荐使用 <a href="https://goproxy.io/">https://goproxy.io</a> 或 <a href="https://goproxy.cn/">https://goproxy.cn</a> 。</p>
<p>可以执行下面的命令修改GOPROXY：</p>
<pre><code>go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>
<h2 id="GO-MOD设置"><a href="#GO-MOD设置" class="headerlink" title="GO MOD设置"></a>GO MOD设置</h2><p>要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。</p>
<pre><code>GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。
GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。
GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。
</code></pre>
<p>通过以下命令修改</p>
<pre><code>go env -w GO111MODULE=on
</code></pre>
<p>使用go module模式新建项目时，我们需要通过go mod init 项目名命令对项目进行初始化，该命令会在项目根目录下生成go.mod文件。例如，我们使用hello作为我们第一个Go项目的名称，执行如下命令。</p>
<pre><code>go mod init hello
</code></pre>
<p>运行之前可以使用​go mod tidy​命令将所需依赖添加到go.mod文件中，并且能去掉项目中不需要的依赖。</p>
<h1 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h1><p>创建工作目录 C:&gt;Go_WorkSpace。</p>
<p>文件名: test.go，代码如下：</p>
<pre><code>package main

import &quot;fmt&quot;

func main() &#123;
   fmt.Println(&quot;Hello, World!&quot;)
&#125;
</code></pre>
<p>使用 go 命令执行以上代码输出结果如下：</p>
<pre><code>C:\Go_WorkSpace&gt;go run test.go

Hello, World!
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门13：结构体、数组、切片</title>
    <url>/2023/04/10/GO%E5%85%A5%E9%97%A813%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组如作为函数参数，需要转为切片。<br>GO语言的切片等价于其他语言的vector。</p>
<pre><code>package main

import &quot;fmt&quot;

type Books struct &#123;
    title   string
    author  string
    subject string
    book_id int
&#125;

func main() &#123;
    var Book1 Books /* 声明 Book1 为 Books 类型 */
    var Book2 Books /* 声明 Book2 为 Books 类型 */

    /* book 1 描述 */
    Book1.title = &quot;Go 语言&quot;
    Book1.author = &quot;www.runoob.com&quot;
    Book1.subject = &quot;Go 语言教程&quot;
    Book1.book_id = 6495407

    /* book 2 描述 */
    Book2.title = &quot;Python 教程&quot;
    Book2.author = &quot;www.runoob.com&quot;
    Book2.subject = &quot;Python 语言教程&quot;
    Book2.book_id = 6495700

    var BookArr [2]Books
    BookArr[0] = Book1
    BookArr[1] = Book2

    var BookSlice []Books
    BookSlice = append(BookSlice, Book1, Book2)
    BookSlice = append(BookSlice, Books&#123;&quot;Go++ 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)

    /* 打印 Book1 信息 */
    printBook(&amp;Book1)
    printBook(&amp;Book2)
    printBooks(BookArr[:])
    printBooks(BookSlice)
&#125;

func printBook(book *Books) &#123;
    fmt.Println(&quot;printBook----&quot;)
    fmt.Printf(&quot;Book title : %s\n&quot;, book.title)
    fmt.Printf(&quot;Book author : %s\n&quot;, book.author)
    fmt.Printf(&quot;Book subject : %s\n&quot;, book.subject)
    fmt.Printf(&quot;Book book_id : %d\n&quot;, book.book_id)
    fmt.Println()
&#125;

func printBooks(arr []Books) &#123;
    fmt.Println(&quot;printBooks----&quot;)
    for i := 0; i &lt; len(arr); i++ &#123;
        book := arr[i]
        fmt.Printf(&quot;Book title : %s\n&quot;, book.title)
        fmt.Printf(&quot;Book author : %s\n&quot;, book.author)
        fmt.Printf(&quot;Book subject : %s\n&quot;, book.subject)
        fmt.Printf(&quot;Book book_id : %d\n&quot;, book.book_id)
    &#125;
    fmt.Println()
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门12：字符串替换</title>
    <url>/2023/04/09/GO%E5%85%A5%E9%97%A812%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、引入strings包</p>
<pre><code>import &quot;strings&quot;
</code></pre>
<p>2、func Replace</p>
<pre><code>func Replace(s, old, new string, n int) string
</code></pre>
<p>在s字符串中，把old字符串替换为new字符串，n表示替换的次数，小于0表示全部替换</p>
<pre><code>//替换两次
fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;k&quot;, &quot;ky&quot;, 2)) 
//全部替换
fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;oink&quot;, &quot;moo&quot;, -1))

//输出结果
oinky oinky oink
moo moo moo
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle判断字段中是否包含中文及取出中文的方法</title>
    <url>/2023/04/08/Oracle%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E4%B8%AD%E6%96%87%E5%8F%8A%E5%8F%96%E5%87%BA%E4%B8%AD%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、问题说明"><a href="#一、问题说明" class="headerlink" title="一、问题说明"></a>一、问题说明</h1><p>在处理数据的时候，需要判断某个字段字符串中是否有中文，若有则取出中文。</p>
<h1 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h1><p>首先如何判断某个字段字符串中是否有中文。这里介绍三种方法：</p>
<h2 id="1、采用ASCIISTR函数"><a href="#1、采用ASCIISTR函数" class="headerlink" title="1、采用ASCIISTR函数"></a>1、采用ASCIISTR函数</h2><pre><code>--查询字段中含有中文
SELECT jldw FROM t_tz_sjclgx WHERE ASCIISTR(jldw) LIKE &#39;%\%&#39;
</code></pre>
<p>说明：ASCIISTR函数用于返回字符的ASCII形式的字符串；非ASCII的字符被转化为\xxxx的形式。换句话说：如果字符中包含中文，则必定会有\xxxx的字符。</p>
<p>所以，我们直接利用ASCIISTR函数匹配’&#39;即可判断。</p>
<h2 id="2、采用length和lengthb的原理"><a href="#2、采用length和lengthb的原理" class="headerlink" title="2、采用length和lengthb的原理"></a>2、采用length和lengthb的原理</h2><pre><code>--查询字段中含有中文
SELECT jldw FROM t_tz_sjclgx WHERE LENGTHB(jldw)&lt;&gt;LENGTH(jldw)
</code></pre>
<p>说明：中文下length返回的是字符个数，中文占1字符，lengthb返回的是字节个数，中文占2字节，根据中文的特性即可解决。</p>
<h2 id="3、使用CONVERT函数判别"><a href="#3、使用CONVERT函数判别" class="headerlink" title="3、使用CONVERT函数判别"></a>3、使用CONVERT函数判别</h2><pre><code>--查询字段中含有中文
SELECT jldw FROM t_tz_sjclgx WHERE jldw &lt;&gt; CONVERT(jldw,&#39;ZHS16GBK&#39;,&#39;UTF8&#39;);
</code></pre>
<p>说明：CONVERT(要转换的字符串,目标字符集,原字符集)，CONVERT函数用于转换字符串的字符集；所以我们可以利用中文的字符集是utf-8来判断。</p>
<h1 id="三、提取中文"><a href="#三、提取中文" class="headerlink" title="三、提取中文"></a>三、提取中文</h1><p>上面介绍了如何判断某个字段字符串中是否有中文，在成功判断字段中是否有中文之后；那么该如何取出字段中的中文呢？</p>
<p>这里介绍一种快速准确的办法：</p>
<pre><code>create or replace function getCustText(custName varchar2)
  return varchar2 is
  Result       varchar2(100); --返回的结果字符串
  tmp_custName varchar2(100); --临时变量
  count_str    number; --字符串中字符的个数
  i            number := 1; --循环变量
  str_ascii    number; --当前等待判断字符的ascii码
  current_char varchar2(10); --当前等待判断的字符
begin
  select length(custName) into count_str from dual; --取出待处理字符串的长度
  while i &lt; count_str loop
    ---根据待处理字符串长度（counts）?，逐个字符判断处理
    current_char := substr(custName, i, 1);
    select ASCII(current_char) into str_ascii from dual;
    if str_ascii &gt; 45216 then
      tmp_custName := tmp_custName || current_char;
    end if;
    i := i + 1;
  end loop;
  Result := tmp_custName;
  return(Result);
end getCustText;
</code></pre>
<p>函数创建成功后，直接传jldw调用就可获取该字符的中文了。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门10：字符串拼接</title>
    <url>/2023/04/07/GO%E5%85%A5%E9%97%A811%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拼接</p>
<pre><code>func main() &#123;
    s1 := &quot;hello&quot;
    s2 := &quot;word&quot;
    s3 := s1 + s2
    fmt.Print(s3) //s3 = &quot;helloword&quot;
&#125;
</code></pre>
<p>Sprintf函数</p>
<pre><code>s1 := &quot;hello&quot;
s2 := &quot;word&quot;
s3 := fmt.Sprintf(&quot;%s%s&quot;, s1, s2) //s3 = &quot;helloword&quot;
</code></pre>
<p>Join函数</p>
<p>使用Join函数我们需要先引入strings包才能调用Join函数。Join函数会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，如果没有的话效率也不高。我一般用来切片转字符串使用。</p>
<pre><code>s1 := &quot;hello&quot;
s2 := &quot;word&quot;
var str []string = []string&#123;s1, s2&#125;
s3 := strings.Join(str, &quot;&quot;)
fmt.Print(s3)
</code></pre>
<p>buffer.Buildbuffer.WriteString函数</p>
<pre><code>s1 := &quot;hello&quot;
s2 := &quot;word&quot;
var bt bytes.Buffer
bt.WriteString(s1)
bt.WriteString(s2)
s3 := bt.String()
fmt.Println(s3)
</code></pre>
<p>buffer.Builder函数</p>
<pre><code>s1 := &quot;hello&quot;
s2 := &quot;word&quot;
var build strings.Builder
build.WriteString(s1)
build.WriteString(s2)
s3 := build.String()
fmt.Println(s3)
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门10：移除所有空格</title>
    <url>/2023/04/06/GO%E5%85%A5%E9%97%A810%EF%BC%9A%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Golang unicode.IsSpace() Function with Examples<br>Golang | unicode.IsSpace() Function: Here, we are going to learn about the IsSpace() function of the unicode package with its usages, syntax, and examples.<br>Submitted by IncludeHelp, on September 17, 2021<br>unicode.IsSpace()<br>The IsSpace() function is an inbuilt function of the unicode package which is used to check whether the given rune r is a space character as defined by Unicode’s White Space property.</p>
<p>It accepts one parameter (r rune) and returns true if rune r is a space character; false, otherwise.</p>
<p>Syntax:</p>
<pre><code>func IsSpace(r rune) bool
</code></pre>
<p>Parameter(s):</p>
<pre><code>r : Rune type value to be checked whether it is a space character or not.
</code></pre>
<p>Return Value:</p>
<p>The return type of the unicode.IsSpace() function is a bool, it returns true if rune r is a space character; false, otherwise.</p>
<p>Example 1:</p>
<pre><code>// Golang program to demonstrate the
// example of unicode.IsSpace() Function

package main

import (
    &quot;fmt&quot;
    &quot;unicode&quot;
)

func main() &#123;
    fmt.Println(&quot;unicode.IsSpace(&#39; &#39;):&quot;,
        unicode.IsSpace(&#39; &#39;))
    fmt.Println(&quot;unicode.IsSpace(&#39;\\t&#39;):&quot;,
        unicode.IsSpace(&#39;\t&#39;))
    fmt.Println(&quot;unicode.IsSpace(&#39;\\v&#39;):&quot;,
        unicode.IsSpace(&#39;\v&#39;))
    fmt.Println(&quot;unicode.IsSpace(&#39;\\f&#39;):&quot;,
        unicode.IsSpace(&#39;\f&#39;))
    fmt.Println(&quot;unicode.IsSpace(&#39;\\r&#39;)&quot;,
        unicode.IsSpace(&#39;\r&#39;))
    fmt.Println(&quot;unicode.IsSpace(&#39;G&#39;):&quot;,
        unicode.IsSpace(&#39;G&#39;))
    fmt.Println(&quot;unicode.IsSpace(&#39;\\a&#39;):&quot;,
        unicode.IsSpace(&#39;\a&#39;))
&#125;
</code></pre>
<p>Output:</p>
<pre><code>unicode.IsSpace(&#39; &#39;): true
unicode.IsSpace(&#39;\t&#39;): true
unicode.IsSpace(&#39;\v&#39;): true
unicode.IsSpace(&#39;\f&#39;): true
unicode.IsSpace(&#39;\r&#39;) true
unicode.IsSpace(&#39;G&#39;): false
unicode.IsSpace(&#39;\a&#39;): false
</code></pre>
<p>Example 2:</p>
<pre><code>// Golang program to demonstrate the
// example of unicode.IsSpace() Function

package main

import (
    &quot;fmt&quot;
    &quot;unicode&quot;
)

func main() &#123;
    var r rune
    var result bool

    r = &#39; &#39;
    result = unicode.IsSpace(r)
    if result == true &#123;
        fmt.Printf(&quot;%c (%x) is a space character.\n&quot;, r, r)
    &#125; else &#123;
        fmt.Printf(&quot;%c (%x) is not a space character.\n&quot;, r, r)
    &#125;

    r = &#39;A&#39;
    result = unicode.IsSpace(r)
    if result == true &#123;
        fmt.Printf(&quot;%c (%x) is a space character.\n&quot;, r, r)
    &#125; else &#123;
        fmt.Printf(&quot;%c (%x) is not a space character.\n&quot;, r, r)
    &#125;

    r = &#39;\t&#39;
    result = unicode.IsSpace(r)
    if result == true &#123;
        fmt.Printf(&quot;%c (%x) is a space character.\n&quot;, r, r)
    &#125; else &#123;
        fmt.Printf(&quot;%c (%x) is not a space character.\n&quot;, r, r)
    &#125;
&#125;
</code></pre>
<p>Output:</p>
<pre><code>  (20) is a space character.
A (41) is not a space character.
     (9) is a space character.
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门09：HTTP</title>
    <url>/2023/04/05/GO%E5%85%A5%E9%97%A809%EF%BC%9AHTTP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>POSTMAN可以看请求的代码实现，GO参考：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
  &quot;strings&quot;
  &quot;net/http&quot;
  &quot;io/ioutil&quot;
)

func main() &#123;

  url := &quot;http://192.168.2.198:27001/server/external&quot;
  method := &quot;POST&quot;

  payload := strings.NewReader(&quot;sysParams=%7B%22route%22%3A%22DefectController_getDevice%22%2C%22params%22%3A%7B%22deviceType%22%3A%22byq%22%2C%22objId%22%3A%22ffb950f8-3be3-456f-99e1-a5b5f505a80c%22%2C%22auth%22%3A%22all%22%2C%22uploadType%22%3A%22out%22%7D%7D&amp;code=crm&amp;token=0049D6EA-0D13-4890-BD6D-CF53873CD33C&quot;)

  client := &amp;http.Client &#123;
  &#125;
  req, err := http.NewRequest(method, url, payload)

  if err != nil &#123;
    fmt.Println(err)
    return
  &#125;
  req.Header.Add(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)
  req.Header.Add(&quot;Cache-Control&quot;, &quot;no-cache&quot;)
  req.Header.Add(&quot;Postman-Token&quot;, &quot;b2b58722-bac9-4a03-bee8-0e8378d0ec75&quot;)

  res, err := client.Do(req)
  if err != nil &#123;
    fmt.Println(err)
    return
  &#125;
  defer res.Body.Close()

  body, err := ioutil.ReadAll(res.Body)
  if err != nil &#123;
    fmt.Println(err)
    return
  &#125;
  fmt.Println(string(body))
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门08：写文件</title>
    <url>/2023/04/04/GO%E5%85%A5%E9%97%A808%EF%BC%9A%E5%86%99%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go语言的 os 包下有一个 OpenFile 函数，其原型如下所示：<br>func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</p>
<p>其中 name 是文件的文件名，如果不是在当前路径下运行需要加上具体路径；flag 是文件的处理参数，为 int 类型，根据系统的不同具体值可能有所不同，但是作用是相同的。</p>
<p>下面列举了一些常用的 flag 文件处理参数：<br>    O_RDONLY：只读模式打开文件；<br>    O_WRONLY：只写模式打开文件；<br>    O_RDWR：读写模式打开文件；<br>    O_APPEND：写操作时将数据附加到文件尾部（追加）；<br>    O_CREATE：如果不存在将创建一个新文件；<br>    O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；<br>    O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；<br>    O_TRUNC：如果可能，在打开时清空文件。</p>
<h1 id="创建一个新文件，写入内容-5-句-“hello-Golang”"><a href="#创建一个新文件，写入内容-5-句-“hello-Golang”" class="headerlink" title="创建一个新文件，写入内容 5 句 “hello, Golang”"></a>创建一个新文件，写入内容 5 句 “hello, Golang”</h1><pre><code>package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)
func main() &#123;
    //创建一个新文件，写入内容 5句 &quot;hello, Golang&quot;
    //1 .打开文件 d:/abc.txt
    filePath := &quot;d:/abc.txt&quot;
    file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_CREATE, 0666)
    if err != nil &#123;
        fmt.Printf(&quot;open file err=%v\n&quot;, err)
        return
    &#125;
    //及时关闭file句柄
    defer file.Close()
    //准备写入5句 &quot;hello, Golang&quot;
    str := &quot;hello,Golang\r\n&quot; // \r\n 表示换行
    //写入时，使用带缓存的 *Writer
    writer := bufio.NewWriter(file)
    for i := 0; i &lt; 5; i++ &#123;
        writer.WriteString(str)
    &#125;
    //因为writer是带缓存，因此在调用WriterString方法时，其实
    //内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据
    //真正写入到文件中， 否则文件中会没有数据!!!
    writer.Flush()
&#125;
</code></pre>
<h1 id="打开一个存在的文件中，将原来的内容覆盖成新的内容-10-句-“你好，Golang-”"><a href="#打开一个存在的文件中，将原来的内容覆盖成新的内容-10-句-“你好，Golang-”" class="headerlink" title="打开一个存在的文件中，将原来的内容覆盖成新的内容 10 句 “你好，Golang!”"></a>打开一个存在的文件中，将原来的内容覆盖成新的内容 10 句 “你好，Golang!”</h1><pre><code>package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)

func main() &#123;
    //打开一个存在的文件中，将原来的内容覆盖成新的内容10句 &quot;你好，Golang!&quot;

    //创建一个新文件，写入内容 5句 &quot;hello, Golang&quot;
    //1 .打开文件已经存在文件, d:/abc.txt
    filePath := &quot;d:/abc.txt&quot;
    file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_TRUNC, 0666)
    if err != nil &#123;
        fmt.Printf(&quot;open file err=%v\n&quot;, err)
        return
    &#125;
    //及时关闭file句柄
    defer file.Close()
    //准备写入5句 &quot;你好,Golang!&quot;
    str := &quot;你好,Golang!\r\n&quot; // \r\n 表示换行
    //写入时，使用带缓存的 *Writer
    writer := bufio.NewWriter(file)
    for i := 0; i &lt; 10; i++ &#123;
        writer.WriteString(str)
    &#125;
    //因为writer是带缓存，因此在调用WriterString方法时，其实
    //内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据
    //真正写入到文件中， 否则文件中会没有数据!!!
    writer.Flush()

&#125;
</code></pre>
<h1 id="打开一个存在的文件，在原来的内容追加内容-‘ABC-ENGLISH-’"><a href="#打开一个存在的文件，在原来的内容追加内容-‘ABC-ENGLISH-’" class="headerlink" title="打开一个存在的文件，在原来的内容追加内容 ‘ABC! ENGLISH!’"></a>打开一个存在的文件，在原来的内容追加内容 ‘ABC! ENGLISH!’</h1><pre><code>package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)

func main() &#123;
    //打开一个存在的文件，在原来的内容追加内容 &#39;ABC! ENGLISH!&#39;
    //1 .打开文件已经存在文件, d:/abc.txt
    filePath := &quot;d:/abc.txt&quot;
    file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_APPEND, 0666)
    if err != nil &#123;
        fmt.Printf(&quot;open file err=%v\n&quot;, err)
        return
    &#125;
    //及时关闭file句柄
    defer file.Close()
    //准备写入5句 &quot;你好,Golang!&quot;
    str := &quot;ABC,ENGLISH!\r\n&quot; // \r\n 表示换行
    //写入时，使用带缓存的 *Writer
    writer := bufio.NewWriter(file)
    for i := 0; i &lt; 10; i++ &#123;
        writer.WriteString(str)
    &#125;
    //因为writer是带缓存，因此在调用WriterString方法时，其实
    //内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据
    //真正写入到文件中， 否则文件中会没有数据!!!
    writer.Flush()
&#125;
</code></pre>
<h1 id="打开一个存在的文件，将原来的内容读出显示在终端，并且追加-5-句”hello-Golang-”"><a href="#打开一个存在的文件，将原来的内容读出显示在终端，并且追加-5-句”hello-Golang-”" class="headerlink" title="打开一个存在的文件，将原来的内容读出显示在终端，并且追加 5 句”hello,Golang!”"></a>打开一个存在的文件，将原来的内容读出显示在终端，并且追加 5 句”hello,Golang!”</h1><pre><code>package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
    &quot;io&quot;
)

func main() &#123;  
    //打开一个存在的文件，将原来的内容读出显示在终端，并且追加5句&quot;hello,Golang!&quot;
    //1 .打开文件已经存在文件, d:/abc.txt
    filePath := &quot;d:/abc.txt&quot;
    file, err := os.OpenFile(filePath, os.O_RDWR | os.O_APPEND, 0666)
    if err != nil &#123;
        fmt.Printf(&quot;open file err=%v\n&quot;, err)
        return
    &#125;
    //及时关闭file句柄
    defer file.Close()

    //先读取原来文件的内容，并显示在终端.
    reader := bufio.NewReader(file)
    for &#123;
        str, err := reader.ReadString(&#39;\n&#39;)
        if err == io.EOF &#123; //如果读取到文件的末尾
            break
        &#125;
        //显示到终端
        fmt.Print(str)
    &#125;

    //准备写入5句 &quot;你好,Golang!&quot;
    str := &quot;hello,Golang!\r\n&quot; // \r\n 表示换行
    //写入时，使用带缓存的 *Writer
    writer := bufio.NewWriter(file)
    for i := 0; i &lt; 5; i++ &#123;
        writer.WriteString(str)
    &#125;
    //因为writer是带缓存，因此在调用WriterString方法时，其实
    //内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据
    //真正写入到文件中， 否则文件中会没有数据!!!
    writer.Flush()
&#125;
</code></pre>
<h1 id="将一个文件的内容，写入到另外一个文件。注：这两个文件已经存在了"><a href="#将一个文件的内容，写入到另外一个文件。注：这两个文件已经存在了" class="headerlink" title="将一个文件的内容，写入到另外一个文件。注：这两个文件已经存在了"></a>将一个文件的内容，写入到另外一个文件。注：这两个文件已经存在了</h1><p>说明：使用 ioutil.ReadFile / ioutil.WriteFile 完成写文件的任务.</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
)
func main() &#123;
    //将d:/abc.txt 文件内容导入到  e:/kkk.txt
    //1. 首先将  d:/abc.txt 内容读取到内存
    //2. 将读取到的内容写入 e:/kkk.txt
    file1Path := &quot;d:/abc.txt&quot;
    file2Path := &quot;e:/kkk.txt&quot;
    data, err := ioutil.ReadFile(file1Path)
    if err != nil &#123;
        //说明读取文件有错误
        fmt.Printf(&quot;read file err=%v\n&quot;, err)
        return
    &#125;
    err = ioutil.WriteFile(file2Path, data, 0666)
    if err != nil &#123;
        fmt.Printf(&quot;write file error=%v\n&quot;, err)
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门07：读文件</title>
    <url>/2023/04/03/GO%E5%85%A5%E9%97%A807%EF%BC%9A%E8%AF%BB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当文件过大，不适合一次性载入内存，且文件每行都包含特定信息时，我们就需要逐行读取文件来保证程序的性能；</p>
<p>Go 语言有三种逐行读取文件的方法，依次是：</p>
<pre><code>* ReadString
* ReadLine
* Scanner
</code></pre>
<p>下面分别介绍它们的用法</p>
<h1 id="1、ReadString"><a href="#1、ReadString" class="headerlink" title="1、ReadString"></a>1、ReadString</h1><p>ReadString 是一个位于 bufio 包的方法</p>
<p>func (b *Reader) ReadString(delim byte) (string, error)<br>ReadString 从输入中读取数据，直到分隔符出现，返回包括分割符在内的字符串。如果 ReadString 在找到一个分割符之前就遇到了错误，它会返回已读取的数据和错误本身。注意，这里需要裁切掉末尾的换行符</p>
<pre><code>import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func main() &#123;
    fileObj, _ := os.Open(&quot;file.txt&quot;)
    defer fileObj.Close()
    reader := bufio.NewReader(fileObj)

    for &#123;
        if str, ok := readline(reader); ok &#123;
            fmt.Println(str)
            continue
        &#125;
        break
    &#125;
&#125;

func readline(fi *bufio.Reader) (string, bool) &#123;
    s, err := fi.ReadString(&#39;\n&#39;)
    if err != nil &#123;
        return &quot;&quot;, false
    &#125;
    return strings.Trim(s, &quot;\r\n&quot;), true
&#125;
</code></pre>
<p>更多示例参考 Golang Reader.ReadString Examples</p>
<h1 id="2、ReadLine"><a href="#2、ReadLine" class="headerlink" title="2、ReadLine"></a>2、ReadLine</h1><p> 不介绍，这个是 bufio 实现 ReadString 的方法，但是注释上已经写了不建议使用</p>
<h1 id="3、Scanner"><a href="#3、Scanner" class="headerlink" title="3、Scanner"></a>3、Scanner</h1><p>下面就是这次的主角 Scanner 工具，它也是 bufio 包下的一个工具，从字面意思来看是一个扫描器、扫描仪。</p>
<p>所用是不停的从一个 reader 中读取数据兵缓存在内存中，还提供了一个注入函数用来自定义分割符。库中还提供了4个预定义分割方法。</p>
<pre><code>* ScanLines：以换行符分割（&#39;n&#39;）
* ScanWords：返回通过“空格”分词的单词
* ScanRunes：返回单个 UTF-8 编码的 rune 作为一个 token
* ScanBytes：返回单个字节作为一个 token
</code></pre>
<p>使用例：</p>
<pre><code>package main
 
import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;bufio&quot;
)

func main() &#123;
    fp,err := os.Open(&quot;file.txt&quot;)
    if err!=nil&#123;
        fmt.Println(err) //打开文件错误
        return 
    &#125;

    buf := bufio.NewScanner(fp)
    for &#123;
        if !buf.Scan() &#123;
            break //文件读完了,退出for
        &#125;
        line := buf.Text() //获取每一行
        fmt.Println(line)   
    &#125;
&#125;
</code></pre>
<h2 id="从指定行号开始读取"><a href="#从指定行号开始读取" class="headerlink" title="从指定行号开始读取"></a>从指定行号开始读取</h2><p>bufio.Scanner 默认不保存行号，所以这里需要简单拓展一下，这里使用 Seeker 接口来用做读取的偏移量</p>
<p>这里不使用默认的切割函数自定义一个 bufio.SplitFunc，这个函数签名为：</p>
<pre><code>type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
</code></pre>
<p>它返回的 advance 表示前进了多少位，token 表示本次切割从起点到终点所包含的内容，所以这里直接利用原本的 ScanLines 进行拓展。</p>
<pre><code>func withScanner(input io.ReadSeeker, start int64) error &#123;
    fmt.Println(&quot;--SCANNER, start:&quot;, start)
    if _, err := input.Seek(start, 0); err != nil &#123;
        return err
    &#125;
    scanner := bufio.NewScanner(input)

    pos := start
    scanLines := func(data []byte, atEOF bool) (advance int, token []byte, err error) &#123;
        advance, token, err = bufio.ScanLines(data, atEOF)
        pos += int64(advance)
        return
    &#125;
    scanner.Split(scanLines)

    for scanner.Scan() &#123;
        fmt.Printf(&quot;Pos: %d, Scanned: %s\n&quot;, pos, scanner.Text())
    &#125;
    return scanner.Err()
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门05：解析JSON</title>
    <url>/2023/04/02/GO%E5%85%A5%E9%97%A806%EF%BC%9A%E8%A7%A3%E6%9E%90JSON/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><pre><code>JSON解析三种方法：
* 直接解析成 map[string]interface&#123;&#125;
* 解析成对象
* 读取单个key
</code></pre>
<h1 id="示例代码1："><a href="#示例代码1：" class="headerlink" title="示例代码1："></a>示例代码1：</h1><pre><code>package main

import (
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;github.com/tidwall/gjson&quot;
)

// 嵌套一个对象
type Info struct &#123;
    Age int `json:&quot;age&quot;`
&#125;

var info = Info&#123;Age: 12&#125;

// 嵌套一个对象数组
type Extra struct &#123;
    Address string `json:&quot;address&quot;`
&#125;

// 定义需要反序列化的结构体
type UserRequest struct &#123;
    Name     string  `json:&quot;userName&quot;`  // 通过tag里面的json，来指定json字符串中该字段的值从那里解析，不需要和字段名一样
    NickName string  `json:&quot;nick_name&quot;` // 如果没对应上，解析不了
    info     Info    `json:&quot;info&quot;`      // 小写私有的，故反序列化失效，该字段永远为空
    Extra    []Extra `json:&quot;extra&quot;`
&#125;

func main() &#123;
    jsonStr := `
    &#123;
        &quot;userName&quot;:&quot;admin&quot;,
        &quot;nick_name&quot;:&quot;管理员&quot;,
        &quot;info&quot;:&#123;
           &quot;age&quot;:18
        &#125;,
        &quot;extra&quot;:[
           &#123;
              &quot;address&quot;:&quot;上海市&quot;
           &#125;,
           &#123;
              &quot;address&quot;:&quot;北京市&quot;
           &#125;
        ]
     &#125;`

    // 方式一：序列化成map，经常使用
    anyMap := make(map[string]interface&#123;&#125;, 0)
    if err := json.Unmarshal([]byte(jsonStr), &amp;anyMap); err != nil &#123;
        panic(err)
    &#125;
    log.Println(&quot;Unmarshal to map result:&quot;, anyMap)

    // 方式二：反序列化成对象，经常使用
    req := UserRequest&#123;&#125;
    if err := json.Unmarshal([]byte(jsonStr), &amp;req); err != nil &#123;
        panic(err)
    &#125;
    log.Println(&quot;Unmarshal to struct:&quot;, req)

    // 方式三：不反序列化，只读取单个key，经常使用。适合特别复杂的json字符串，或者有多种if else结构的场景
    userName := gjson.Get(jsonStr, &quot;userName&quot;)
    nickName := gjson.Get(jsonStr, &quot;nick_name&quot;)
    age := gjson.Get(jsonStr, &quot;info.age&quot;).Int()

    // 取得extra数组0位置的对象
    address1 := gjson.Get(jsonStr, &quot;extra&quot;).Array()[1]
    log.Println(&quot;get raw value by key:&quot;, userName, nickName, age, address1.Get(&quot;address&quot;))
&#125;
</code></pre>
<p>原文链接：<a href="https://blog.csdn.net/xmcy001122/article/details/126835290">https://blog.csdn.net/xmcy001122/article/details/126835290</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门06：MAP集合</title>
    <url>/2023/04/01/GO%E5%85%A5%E9%97%A805%EF%BC%9AMAP%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Map 是一种无序的键值对的集合。<br>Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。<br>Map 是无序的，遍历 Map 时返回的键值对的顺序是不确定的。<br>在获取 Map 的值时，如果键不存在，返回该类型的零值，例如 int 类型的零值是 0，string 类型的零值是 “”。<br>Map 是引用类型，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。</p>
<h1 id="定义-Map"><a href="#定义-Map" class="headerlink" title="定义 Map"></a>定义 Map</h1><p>可以使用内建函数 make 或使用 map 关键字来定义 Map:</p>
<pre><code>/* 使用 make 函数 */
map_variable := make(map[KeyType]ValueType, initialCapacity)
</code></pre>
<p>其中 KeyType 是键的类型，ValueType 是值的类型，initialCapacity 是可选的参数，用于指定 Map 的初始容量。Map 的容量是指 Map 中可以保存的键值对的数量，当 Map 中的键值对数量达到容量时，Map 会自动扩容。如果不指定 initialCapacity，Go 语言会根据实际情况选择一个合适的值。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><pre><code>package main

import &quot;fmt&quot;

func main() &#123;
    var siteMap map[string]string /*创建集合 */
    siteMap = make(map[string]string)

    /* map 插入 key - value 对,各个国家对应的首都 */
    siteMap [ &quot;Google&quot; ] = &quot;谷歌&quot;
    siteMap [ &quot;Runoob&quot; ] = &quot;菜鸟教程&quot;
    siteMap [ &quot;Baidu&quot; ] = &quot;百度&quot;
    siteMap [ &quot;Wiki&quot; ] = &quot;维基百科&quot;

    /*使用键输出地图值 */
    for site := range siteMap &#123;
        fmt.Println(site, &quot;首都是&quot;, siteMap [site])
    &#125;

    /*查看元素在集合中是否存在 */
    name, ok := siteMap [ &quot;Facebook&quot; ] /*如果确定是真实的,则存在,否则不存在 */
    /*fmt.Println(capital) */
    /*fmt.Println(ok) */
    if (ok) &#123;
        fmt.Println(&quot;Facebook 的 站点是&quot;, name)
    &#125; else &#123;
        fmt.Println(&quot;Facebook 站点不存在&quot;)
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门04：结构体</title>
    <url>/2023/03/31/GO%E5%85%A5%E9%97%A804%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-语言结构体"><a href="#Go-语言结构体" class="headerlink" title="Go 语言结构体"></a>Go 语言结构体</h1><p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。</p>
<p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>
<p>结构体表示一项记录，比如保存图书馆的书籍记录，每本书有以下属性：</p>
<pre><code>Title ：标题
Author ： 作者
Subject：学科
ID：书籍ID
</code></pre>
<h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h1><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p>
<pre><code>type struct_variable_type struct &#123;
   member definition
   member definition
   ...
   member definition
&#125;
</code></pre>
<p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p>
<pre><code>variable_name := structure_variable_type &#123;value1, value2...valuen&#125;
或
variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;
</code></pre>
<p>实例如下：</p>
<pre><code>package main

import &quot;fmt&quot;

type Books struct &#123;
   title string
   author string
   subject string
   book_id int
&#125;


func main() &#123;

    // 创建一个新的结构体
    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)

    // 也可以使用 key =&gt; value 格式
    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程&quot;, book_id: 6495407&#125;)

    // 忽略的字段为 0 或 空
   fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;&#125;)
&#125;
</code></pre>
<p>输出结果为：</p>
<pre><code>&#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;
&#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;
&#123;Go 语言 www.runoob.com  0&#125;
</code></pre>
<h1 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h1><p>如果要访问结构体成员，需要使用点号 . 操作符，格式为：</p>
<pre><code>结构体.成员名
</code></pre>
<p>结构体类型变量使用 struct 关键字定义，实例如下：</p>
<pre><code>package main

import &quot;fmt&quot;

type Books struct &#123;
   title string
   author string
   subject string
   book_id int
&#125;

func main() &#123;
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = &quot;Go 语言&quot;
   Book1.author = &quot;www.runoob.com&quot;
   Book1.subject = &quot;Go 语言教程&quot;
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = &quot;Python 教程&quot;
   Book2.author = &quot;www.runoob.com&quot;
   Book2.subject = &quot;Python 语言教程&quot;
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   fmt.Printf( &quot;Book 1 title : %s\n&quot;, Book1.title)
   fmt.Printf( &quot;Book 1 author : %s\n&quot;, Book1.author)
   fmt.Printf( &quot;Book 1 subject : %s\n&quot;, Book1.subject)
   fmt.Printf( &quot;Book 1 book_id : %d\n&quot;, Book1.book_id)

   /* 打印 Book2 信息 */
   fmt.Printf( &quot;Book 2 title : %s\n&quot;, Book2.title)
   fmt.Printf( &quot;Book 2 author : %s\n&quot;, Book2.author)
   fmt.Printf( &quot;Book 2 subject : %s\n&quot;, Book2.subject)
   fmt.Printf( &quot;Book 2 book_id : %d\n&quot;, Book2.book_id)
&#125;
</code></pre>
<p>以上实例执行运行结果为：</p>
<pre><code>Book 1 title : Go 语言
Book 1 author : www.runoob.com
Book 1 subject : Go 语言教程
Book 1 book_id : 6495407
Book 2 title : Python 教程
Book 2 author : www.runoob.com
Book 2 subject : Python 语言教程
Book 2 book_id : 6495700
</code></pre>
<h1 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h1><p>你可以像其他数据类型一样将结构体类型作为参数传递给函数。并以以上实例的方式访问结构体变量：</p>
<pre><code>package main

import &quot;fmt&quot;

type Books struct &#123;
   title string
   author string
   subject string
   book_id int
&#125;

func main() &#123;
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = &quot;Go 语言&quot;
   Book1.author = &quot;www.runoob.com&quot;
   Book1.subject = &quot;Go 语言教程&quot;
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = &quot;Python 教程&quot;
   Book2.author = &quot;www.runoob.com&quot;
   Book2.subject = &quot;Python 语言教程&quot;
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   printBook(Book1)

   /* 打印 Book2 信息 */
   printBook(Book2)
&#125;

func printBook( book Books ) &#123;
   fmt.Printf( &quot;Book title : %s\n&quot;, book.title)
   fmt.Printf( &quot;Book author : %s\n&quot;, book.author)
   fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject)
   fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id)
&#125;
</code></pre>
<p>以上实例执行运行结果为：</p>
<pre><code>Book title : Go 语言
Book author : www.runoob.com
Book subject : Go 语言教程
Book book_id : 6495407
Book title : Python 教程
Book author : www.runoob.com
Book subject : Python 语言教程
Book book_id : 6495700
</code></pre>
<h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><p>你可以定义指向结构体的指针类似于其他指针变量，格式如下：</p>
<pre><code>var struct_pointer *Books
</code></pre>
<p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p>
<pre><code>struct_pointer = &amp;Book1
</code></pre>
<p>使用结构体指针访问结构体成员，使用 “.” 操作符：</p>
<pre><code>struct_pointer.title
</code></pre>
<p>接下来让我们使用结构体指针重写以上实例，代码如下：</p>
<pre><code>package main

import &quot;fmt&quot;

type Books struct &#123;
   title string
   author string
   subject string
   book_id int
&#125;

func main() &#123;
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = &quot;Go 语言&quot;
   Book1.author = &quot;www.runoob.com&quot;
   Book1.subject = &quot;Go 语言教程&quot;
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = &quot;Python 教程&quot;
   Book2.author = &quot;www.runoob.com&quot;
   Book2.subject = &quot;Python 语言教程&quot;
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   printBook(&amp;Book1)

   /* 打印 Book2 信息 */
   printBook(&amp;Book2)
&#125;
func printBook( book *Books ) &#123;
   fmt.Printf( &quot;Book title : %s\n&quot;, book.title)
   fmt.Printf( &quot;Book author : %s\n&quot;, book.author)
   fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject)
   fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id)
&#125;
</code></pre>
<p>以上实例执行运行结果为：</p>
<pre><code>Book title : Go 语言
Book author : www.runoob.com
Book subject : Go 语言教程
Book book_id : 6495407
Book title : Python 教程
Book author : www.runoob.com
Book subject : Python 语言教程
Book book_id : 6495700
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门03：关系运算符</title>
    <url>/2023/03/30/GO%E5%85%A5%E9%97%A803%EF%BC%9A%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><pre><code>关系运算符
</code></pre>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><pre><code>package main

import &quot;fmt&quot;

func main() &#123;
   var a int = 21
   var b int = 10

   if( a == b ) &#123;
      fmt.Printf(&quot;第一行 - a 等于 b\n&quot; )
   &#125; else &#123;
      fmt.Printf(&quot;第一行 - a 不等于 b\n&quot; )
   &#125;
   if ( a &lt; b ) &#123;
      fmt.Printf(&quot;第二行 - a 小于 b\n&quot; )
   &#125; else &#123;
      fmt.Printf(&quot;第二行 - a 不小于 b\n&quot; )
   &#125;
   
   if ( a &gt; b ) &#123;
      fmt.Printf(&quot;第三行 - a 大于 b\n&quot; )
   &#125; else &#123;
      fmt.Printf(&quot;第三行 - a 不大于 b\n&quot; )
   &#125;
   /* Lets change value of a and b */
   a = 5
   b = 20
   if ( a &lt;= b ) &#123;
      fmt.Printf(&quot;第四行 - a 小于等于 b\n&quot; )
   &#125;
   if ( b &gt;= a ) &#123;
      fmt.Printf(&quot;第五行 - b 大于等于 a\n&quot; )
   &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门02：for循环</title>
    <url>/2023/03/29/GO%E5%85%A5%E9%97%A802%EF%BC%9Afor%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><pre><code>for循环
break
</code></pre>
<h1 id="示例代码1："><a href="#示例代码1：" class="headerlink" title="示例代码1："></a>示例代码1：</h1><pre><code>package main

import &quot;fmt&quot;

func main() &#123;
   strings := []string&#123;&quot;google&quot;, &quot;runoob&quot;&#125;
   for i, s := range strings &#123;
      fmt.Println(i, s)
   &#125;
&#125;
</code></pre>
<h1 id="示例代码2："><a href="#示例代码2：" class="headerlink" title="示例代码2："></a>示例代码2：</h1><pre><code>package main

import &quot;fmt&quot;

func main() &#123;
    arr := [5]int&#123;1, 2, 3, 4, 5&#125;
    sum := 0
    for i := 0; i &lt;= len(arr); i++ &#123;
        sum += i
    &#125;
    fmt.Println(sum)
&#125;
</code></pre>
<h1 id="示例代码3："><a href="#示例代码3：" class="headerlink" title="示例代码3："></a>示例代码3：</h1><pre><code>package main

import &quot;fmt&quot;

func main() &#123;

   var a int = 10
   
   for a &lt; 20 &#123;
      fmt.Printf(&quot;a = : %d\n&quot;, a);
      a++;
      if a &gt; 15 &#123;
         break;
      &#125;
   &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO入门01：Hello World!</title>
    <url>/2023/03/28/GO%E5%85%A5%E9%97%A801%EF%BC%9AHello-World/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>入门示例代码：</p>
<pre><code>package main

import &quot;fmt&quot;

func main() &#123;
    fmt.Println(&quot;Hello, World!&quot;)
&#125;
</code></pre>
<p>执行命令：</p>
<pre><code>$ go run hello.go
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>java读取JSON文件的多种方式</title>
    <url>/2023/03/27/java%E8%AF%BB%E5%8F%96JSON%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开发过程中有时会遇到需要读取本地.json文件的需求，通常会自己写Reader代码去读，但是这么做写出来的代码有些繁琐（需要关流、创建StringBuilder对象等操作）。最近发现几个小工具可以让需求代码变得更加简洁。</p>
<h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h1><p>json文件：D:\test.json</p>
<pre><code>&#123;
    &quot;ID&quot;: 10001,
    &quot;detail&quot;: &quot;detail&quot;,
    &quot;json_format_version&quot;: 1.0,
    &quot;other_info&quot;: &#123;
        &quot;array_one&quot;: [
            [855, 410],
            [854, 411],
            [847, 411],
            [846, 410],
            [845, 410],
            [844, 409]
        ],
        &quot;array_two&quot;: [
            [832, 303],
            [829, 303],
            [828, 302],
            [825, 302],
            [824, 301]
        ],
        &quot;array_three&quot;: [
            [1013, 224],
            [1012, 225],
            [1010, 225],
            [1009, 226],
            [1023, 224]
        ],
        &quot;point&quot;: [853, 310],
        &quot;boolean&quot;: true
    &#125;
&#125;
</code></pre>
<h1 id="1-使用FileReader读取json文件"><a href="#1-使用FileReader读取json文件" class="headerlink" title="1.使用FileReader读取json文件"></a>1.使用FileReader读取json文件</h1><h2 id="1-1、添加依赖"><a href="#1-1、添加依赖" class="headerlink" title="1.1、添加依赖"></a>1.1、添加依赖</h2><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
       &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
       &lt;version&gt;2.0.12&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="1-2源代码"><a href="#1-2源代码" class="headerlink" title="1.2源代码"></a>1.2源代码</h2><p>import com.alibaba.fastjson.JSON;</p>
<p>import java.io.*;</p>
<p>public class ReadLocalJsonFileDemo {<br>    publicstatic void main(String[] args) throws IOException {<br>        Filefile = new File(“D:\test.json”);<br>       readerMethod(file);</p>
<pre><code>&#125;

privatestatic void readerMethod(File file) throws IOException &#123;
   FileReader fileReader = new FileReader(file);
    Readerreader = new InputStreamReader(new FileInputStream(file), &quot;Utf-8&quot;);
    int ch= 0;
   StringBuffer sb = new StringBuffer();
    while((ch = reader.read()) != -1) &#123;
       sb.append((char) ch);
    &#125;
   fileReader.close();
   reader.close();
    StringjsonStr = sb.toString();
   System.out.println(JSON.parseObject(jsonStr));
&#125;
</code></pre>
<p>}</p>
<h2 id="1-3-控制台输出"><a href="#1-3-控制台输出" class="headerlink" title="1.3.控制台输出"></a>1.3.控制台输出</h2><p>{“other_info”:{“array_two”:[[832,303],[829,303],[828,302],[825,302],[824,301]],”array_three”:[[1013,224],[1012,225],[1010,225],[1009,226],[1023,224]],”boolean”:true,”array_one”:[[855,410],[854,411],[847,411],[846,410],[845,410],[844,409]],”point”:[853,310]},”ID”:10001,”detail”:”detail”,”json_format_version”:1.0}</p>
<h1 id="2-使用jacksonAPI读取json文件"><a href="#2-使用jacksonAPI读取json文件" class="headerlink" title="2.使用jacksonAPI读取json文件"></a>2.使用jacksonAPI读取json文件</h1><h2 id="2-1、添加依赖"><a href="#2-1、添加依赖" class="headerlink" title="2.1、添加依赖"></a>2.1、添加依赖</h2><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
       &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
       &lt;version&gt;2.13.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="2-2源代码"><a href="#2-2源代码" class="headerlink" title="2.2源代码"></a>2.2源代码</h2><p>import com.fasterxml.jackson.databind.ObjectMapper;</p>
<p>import java.io.File;<br>import java.io.IOException;<br>import java.util.Map;</p>
<p>public class ReadLocalJsonFileDemo {<br>    publicstatic void main(String[] args) throws IOException {<br>        Filefile = new File(“D:\test.json”);<br>       jacksonMethod(file);<br>    }</p>
<pre><code>privatestatic void jacksonMethod(File file) throws IOException &#123;
   ObjectMapper objectMapper = new ObjectMapper();
   System.out.println(objectMapper.readValue(file, Map.class));
&#125;
</code></pre>
<p>}</p>
<h2 id="2-3-控制台输出"><a href="#2-3-控制台输出" class="headerlink" title="2.3.控制台输出"></a>2.3.控制台输出</h2><p>{ID=10001,detail=detail, json_format_version=1.0, other_info={array_one=[[855, 410],[854, 411], [847, 411], [846, 410], [845, 410], [844, 409]], array_two=[[832,303], [829, 303], [828, 302], [825, 302], [824, 301]], array_three=[[1013,224], [1012, 225], [1010, 225], [1009, 226], [1023, 224]], point=[853, 310],boolean=true}}</p>
<h1 id="3-使用nio读取json文件"><a href="#3-使用nio读取json文件" class="headerlink" title="3.使用nio读取json文件"></a>3.使用nio读取json文件</h1><h2 id="3-1、添加依赖"><a href="#3-1、添加依赖" class="headerlink" title="3.1、添加依赖"></a>3.1、添加依赖</h2><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
       &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
       &lt;version&gt;2.0.12&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="3-2源代码"><a href="#3-2源代码" class="headerlink" title="3.2源代码"></a>3.2源代码</h2><p>import com.alibaba.fastjson.JSONObject;</p>
<p>import java.io.File;<br>import java.io.IOException;<br>import java.nio.file.Files;<br>import java.nio.file.Paths;</p>
<p>public class ReadLocalJsonFileDemo {<br>    publicstatic void main(String[] args) throws IOException {<br>        Filefile = new File(“D:\test.json”);<br>       nioMethod(file);<br>    }</p>
<pre><code>privatestatic void nioMethod(File file) throws IOException &#123;
    StringjsonString = new String(Files.readAllBytes(Paths.get(file.getPath())));
   System.out.println(JSONObject.parseObject(jsonString));
&#125;
</code></pre>
<p>}</p>
<h2 id="3-3-控制台输出"><a href="#3-3-控制台输出" class="headerlink" title="3.3.控制台输出"></a>3.3.控制台输出</h2><p>{“other_info”:{“array_two”:[[832,303],[829,303],[828,302],[825,302],[824,301]],”array_three”:[[1013,224],[1012,225],[1010,225],[1009,226],[1023,224]],”boolean”:true,”array_one”:[[855,410],[854,411],[847,411],[846,410],[845,410],[844,409]],”point”:[853,310]},”ID”:10001,”detail”:”detail”,”json_format_version”:1.0}</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>maven中quickstart与webapp的区别</title>
    <url>/2023/03/26/maven%E4%B8%ADquickstart%E4%B8%8Ewebapp%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Archetype"><a href="#Archetype" class="headerlink" title="Archetype"></a>Archetype</h1><p>骨架的意思。简单的说，Archetype是Maven工程的模板工具包。一个Archetype定义了要做的相同类型事情的初始样式或模型。这个名称给我们提供来了一个一致的生成Maven工程的方式。Archetype会帮助作者给用户创建Maven工程模板，并给用户提供生成相关工程模板版本的参数化方法。</p>
<p>使用Archetype提供的好的方法，是开发者能够使用最佳实践来快速的构建和组织一致化的工程。在Maven工程中，我们努力使用Archetype来尽可能快的给用户提供示例工程，同时也会把Maven的最佳实践介绍给新的用户。一个新的用户可以使用工作中的Maven工作作为跳板来研究更过的Maven中功能。我们也可以使用Archetype的添加机制，这样就意味着允许我们抓取Archetype中项目片段，并把它们添加到既存的工程中。Maven网站的Archetype就是很好的例子。例如，你可以使用“quick start archetype”来生成一个工程，然后就可以通过其中既存的“site archetype”来快速的创建一个网址工程。你能够使用Archetype来做很多这样的事情。</p>
<p>在你的团队中可能想要标准化的J2EE开发，这需要你提供EJBs、或者是WARs、或者是Web services的原型。一旦在你团队资源库中创建和部署这些原型，它们就可以在你团队内共享使用。</p>
<h1 id="如何使用Archetype"><a href="#如何使用Archetype" class="headerlink" title="如何使用Archetype"></a>如何使用Archetype</h1><p>要基于Archetype来创建一个新的工程，需要像下面示例这样来调用：</p>
<p>mvn archetype:generate</p>
<h1 id="已有的Archetypes"><a href="#已有的Archetypes" class="headerlink" title="已有的Archetypes"></a>已有的Archetypes</h1><p>Archetype ID   说明<br>maven-archetype-archetype  一个样例原型<br>maven-archetype-j2ee-simple    简单的J2EE应用程序样例<br>maven-archetype-mojo    Maven插件样本的示例<br>maven-archetype-plugin    Maven插件样本<br>maven-archetype-plugin-site    Mave插件网站的样例<br>maven-archetype-portlet    JSR-268门户样例<br>maven-archetype-quickstart    Maven工程样例<br>maven-archetype-simple    一个简单的Maven工程<br>maven-archetype-site    Maven网站的样例，它演示了对诸如APT、XDoc和FML等文档类型的支持，并演示了如果把网站国际化（i18n）<br>maven-archetype-site-simple    Maven网站样例<br>maven-archetype-webapp    Maven的Webapp工程样例</p>
<h1 id="常用Archetype"><a href="#常用Archetype" class="headerlink" title="常用Archetype"></a>常用Archetype</h1><ul>
<li><p>1，maven-archetype-quickstart<br>默认的Archetype,基本内容包括：<br>一个包含junit依赖声明的pom.xml<br>src/main/java主代码目录及一个名为App的类<br>src/test/java测试代码目录及一个名为AppTest的测试用例</p>
</li>
<li><p>2，maven-archetype-webapp<br>一个最简单的Maven war项目模板，当需要快速创建一个Web应用的时候可以使用它。生成的项目内容包括：<br>一个packaging为war且带有junit依赖声明的pom.xml<br>src/main/webapp/目录<br>src/main/webapp/index.jsp文件<br>src/main/webapp/WEB-INF/web.xml文件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>MAVEN</tag>
      </tags>
  </entry>
  <entry>
    <title>Notepad++免安装版注册右键菜单</title>
    <url>/2023/03/25/Notepad-%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在免安装版目录打开管理员命令窗口cmd</p>
<p>注册<br>regsvr32 NppShell_06.dll</p>
<p>反注册<br>regsvr32 NppShell_06.dll /u</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中最方便的Unicode转换方法</title>
    <url>/2023/03/24/JAVA%E4%B8%AD%E6%9C%80%E6%96%B9%E4%BE%BF%E7%9A%84Unicode%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="在命令行界面用native2ascii工具"><a href="#在命令行界面用native2ascii工具" class="headerlink" title="在命令行界面用native2ascii工具"></a>在命令行界面用native2ascii工具</h1><ul>
<li><p>1.将汉字转为Unicode:<br>C:\Program   Files\Java\jdk1.5.0_04\bin&gt;native2ascii<br>测试<br>\u6d4b\u8bd5  </p>
</li>
<li><p>2.将Unicode转换为汉字:<br>C:\Program   Files\Java\jdk1.5.0_04\bin&gt;native2ascii   -reverse<br>\u6d4b\u8bd5<br>测试</p>
</li>
</ul>
<h1 id="native2ascii深入"><a href="#native2ascii深入" class="headerlink" title="native2ascii深入"></a>native2ascii深入</h1><p>java 自带的一个native2ascii.exe是一个很好的转码工具，在bin目录下。如果你的properties中有汉字，需要转成unicode . 则把含有汉字的properties拷贝到bin 目录下， 然后在cmd里面进入bin目录，输入：native2ascii -encoding  utf-8  Language-ext_zh_CN.properties.native Language-ext_zh_CN.properties就ok了。Language-ext_zh_CN.properties是转码后的文件。</p>
<p>在做Java开发的时候，常常会出现一些乱码，或者无法正确识别或读取的文件，比如常见的validator验 证用的消息资源 （properties） 文件就需要进行Unicode重新编码。<br>原因是java默认的编码方式为Unicode，而我们的计算机系统编码 常常是GBK等编码。需要将系统的编码转换为java正确识别的编码问题就解决了。</p>
<ul>
<li><p>1、native2ascii简介<br>native2ascii 是sun java sdk提供的一个工具。用来将别的文本类文件（比如*.txt,<em>.ini,</em>.properties,*.java等等）编码转为Unicode编码。 为什么要进行转码，原因在于程序的国际化。Unicode编码的定义：Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。它为每 种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。随着计算 机工作能力的增强，Unicode也在面世以来的十多年里得到普及。（声明：Unicode编码定义来自互联网）。</p>
</li>
<li><p>2、获取native2ascii<br>安装了jdk后，假如你是在windows上安装，那么在jdk的安装目录下，会有一个bin目录，其中native2ascii.exe正是。</p>
</li>
<li><p>3、native2ascii的命令行的命名格式：</p>
</li>
</ul>
<p>native2ascii -[options] [inputfile [outputfile]]</p>
<p>说明：<br>-[options]：表示命令开关，有两个选项可供选择<br>-reverse：将Unicode编码转为本地或者指定编码，不指定编码情况下，将转为本地编码。<br>-encoding encoding_name：转换为指定编码，encoding_name为编码名称。<br>[inputfile [outputfile]]<br>inputfile：表示输入文件全名。<br>outputfile：输出文件名。如果缺少此参数，将输出到控制台。</p>
<ul>
<li>4、最佳实践<br>首先将JDK的bin目录加入系统变量path。在盘下建立一个test目录，在test目录里建立一个zh.txt文件，文件内容为：“熔岩”，打开“命令行提示符”，并进入C:\test目录下。下面就可以按照说明一步一步来操作，注意观察其中编码的变化。</li>
</ul>
<p>** 1)将zh.txt转换为Unicode编码，输出文件到u.txt<br>native2ascii zh.txt u.txt<br>打开u.txt，内容为“\u7194\u5ca9”。</p>
<p>** 2)将zh.txt转换为Unicode编码，输出到控制台<br>C:\test&gt;native2ascii zh.txt<br>\u7194\u5ca9<br>可以看到，控制台输出了“\u7194\u5ca9”。</p>
<p>** 3)将zh.txt转换为ISO8859-1编码，输出文件到i.txt<br>native2ascii -encoding ISO8859-1 zh.txt i.txt<br>打开i.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。</p>
<p>** 4)将u.txt转换为本地编码，输出到文件u_nv.txt<br>native2ascii -reverse u.txt u_nv.txt<br>打开u_nv.txt文件，内容为“熔岩”。</p>
<p>** 5)将u.txt转换为本地编码，输出到控制台<br>C:\test&gt;native2ascii -reverse u.txt<br>熔岩<br>可以看到，控制台输出了“熔岩”。</p>
<p>** 6)将i.txt转换为本地编码，输出到i_nv.txt<br>native2ascii -reverse i.txt i_nv.txt<br>打开i_nv.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。发现转码前后完全一样的。也就是说，等于没有转，或者说思想糊涂，对命名没有理解。。</p>
<p>** 7)将i.txt转换为GBK编码，输出到i_gbk.txt<br>native2ascii -reverse -encoding GBK i.txt i_gbk.txt<br>打开i_gbk.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。发现转码前后完全一样的。也就是说，等于没有转，或者说思想糊涂，对命名没有理解。</p>
<p>** 8)将u_nv.txt转码到本地编码GBK，输出到控制台<br>C:\test&gt;native2ascii -reverse -encoding ISO8859-1 i.txt<br>熔岩<br>从这个结果看，目标达到到了，编码i.txt为ISO8859-1，转为本地编码后内容为“熔岩”。从这里应该意识到，native2ascii -reverse命令中-encoding指定的编码为源文件的编码格式。而在native2ascii 命令中-encoding指定的编码为（生成的)目标文件的编码格式。这一点非常的重要！切记！！<br>继续探索，新建文件12a.txt，内容“12axyz”。看看纯字母数字的编码又如何。</p>
<p>** 9)将纯字母数字的文本文件12a.txt转换为Unicode编码<br>native2ascii 12a.txt 12a_nv.txt<br>打开12a_nv.txt文件，内容为“12axyz”。<br>继续测试，转为ISO8859-1编码看看<br>C:\test&gt;native2ascii -encoding ISO8859-1 12a.txt<br>12axyz<br>结果还是没有转码。</p>
<p>从结果可以得出结论：对于纯数字和字母的文本类型件，转码前后的内容是一样的。</p>
<ul>
<li>5、总结<br>native2ascii 是一个非常的好转码工具，并且转码是可逆的！而其真正的含义并非本地编码——&gt;转码为ASCII码，而是一个通用的文本文件编码转换工具。在做编码 转换的时候有两类指定编码的情形，分别指输出文件编码和输入文件编码，具体可以看看最佳实践部分。</li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>黑果小兵github</title>
    <url>/2023/03/23/%E9%BB%91%E6%9E%9C%E5%B0%8F%E5%85%B5github/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/daliansky">https://github.com/daliansky</a><br><a href="https://blog.daliansky.net/">https://blog.daliansky.net</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos2.2.1版本及以后开启了默认鉴权</title>
    <url>/2023/03/22/nacos2-2-1%E7%89%88%E6%9C%AC%E5%8F%8A%E4%BB%A5%E5%90%8E%E5%BC%80%E5%90%AF%E4%BA%86%E9%BB%98%E8%AE%A4%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nacos 2.2.1版本及以后开启了默认鉴权，需要填写jwt key，不填写key后果，启动报错</p>
<pre><code>org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat
</code></pre>
<p>参照 <a href="https://nacos.io/zh-cn/docs/v2/guide/user/auth.html">nacos鉴权文档</a> 说明，修改application.properties中secret.key配置，即可本地单机正常启动。</p>
<pre><code>### 2.1.0 版本后
nacos.core.auth.plugin.nacos.token.secret.key=VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>cargo基础命令</title>
    <url>/2023/03/21/cargo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code># 查看cargo版本
cargo --version

# 新建项目
cargo new &lt;project_name&gt;

# 构建项目
cargo build

# 运行项目
cargo run

# 检查项目
cargo check

# 查看帮助
cargo -h
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust配置cargo国内镜像</title>
    <url>/2023/03/20/rust%E9%85%8D%E7%BD%AEcargo%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在用户主目录的 .cargo 目录下新建一个文件，命名为 config（没有扩展名），并输入以下内容：</p>
<pre><code>[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = &#39;ustc&#39;

## 二选择一
## replace-with = &#39;XXX&#39; 选择配置

# 中国科学技术大学
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

# 清华大学
[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rustup常用命令</title>
    <url>/2023/03/19/rustup%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code># 查看rustc版本
rustc --version

# 显示当前安装的工具链信息
rustup show
# 检查安装更新
rustup update
# 卸载
rustup self uninstall
# 设置当前默认工具链
rustup default stable-x86_64-pc-windows-gnu
# 查看帮助
rustup -h

# --------------------------&gt;配置工具链
# 查看工具链
rustup toolchain list
# 安装工具链
rustup toolchain install stable-x86_64-pc-windows-gnu
# 卸载工具链
rustup toolchain uninstall stable-x86_64-pc-windows-gnu
# 设置自定义工具链
rustup toolchain link &lt;toolchain-name&gt; &quot;&lt;toolchain-path&gt;&quot;

# --------------------------&gt;配置一个目录以及其子目录的默认工具链
# 查看已设置的默认工具链
rustup override list
# 设置该目录以及其子目录的默认工具链
rustup override set &lt;toolchain&gt; --path &lt;path&gt;
# 取消目录以及其子目录的默认工具链
rustup override unset --path &lt;path&gt;

# --------------------------&gt;配置工具链的可用目标
# 查看目标列表
rustup target list
# 安装目标
rustup target add &lt;target&gt;
# 卸载目标
rustup target remove &lt;target&gt;
# 为特定工具链安装目标
rustup target add --toolchain &lt;toolchain&gt; &lt;target&gt;

# --------------------------&gt;配置 rustup 安装的组件
# 查看可用组件
rustup component list
# 安装组件
rustup component add &lt;component&gt;
# 卸载组件
rustup component remove &lt;component&gt;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust国内镜像地址</title>
    <url>/2023/03/18/rust%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ustup-init 为在线安装工具，默认的安装源为国外的站点，网速较慢，可设置环境变量，使其从国内镜像中下载。</p>
<p>在系统环境变量中添加如下变量（二选一即可）：</p>
<h3 id="下面的配置-二选一即可"><a href="#下面的配置-二选一即可" class="headerlink" title="下面的配置 二选一即可"></a>下面的配置 二选一即可</h3><h1 id="中国科学技术大学"><a href="#中国科学技术大学" class="headerlink" title="中国科学技术大学"></a>中国科学技术大学</h1><p>RUSTUP_DIST_SERVER=<a href="https://mirrors.ustc.edu.cn/rust-static">https://mirrors.ustc.edu.cn/rust-static</a><br>RUSTUP_UPDATE_ROOT=<a href="https://mirrors.ustc.edu.cn/rust-static/rustup">https://mirrors.ustc.edu.cn/rust-static/rustup</a></p>
<h1 id="清华大学"><a href="#清华大学" class="headerlink" title="清华大学"></a>清华大学</h1><p>RUSTUP_DIST_SERVER=<a href="https://mirrors.tuna.tsinghua.edu.cn/rustup">https://mirrors.tuna.tsinghua.edu.cn/rustup</a><br>RUSTUP_UPDATE_ROOT=<a href="https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup">https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL逻辑删除的表的唯一约束的控制</title>
    <url>/2023/03/17/PostgreSQL%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%E7%9A%84%E8%A1%A8%E7%9A%84%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>很多时候，当我们的数据很重要，删除采用的是逻辑删除，仅仅是在记录上指定一个删除标记；这个时候，我们又需要该表的某一字段唯一（未删除的保持唯一，已经有删除标记的行不管），仅仅是采用数据库本身的check unique就不行了。
</code></pre>
<p>   现在开始讲一种解决方案:</p>
<ol>
<li><p>建表<br>postgres=# create table person(id serial,name character varying,delete_flag integer not null default 0);</p>
</li>
<li><p>查看表结构<br>postgres=# \d person</p>
<pre><code>                          Table &quot;public.person&quot;
</code></pre>
<p>Column    |       Type        |                      Modifiers                     </p>
</li>
</ol>
<p>————-+——————-+———————————————-<br> id          | integer           | not null default nextval(‘person_id_seq’::regclass)<br> name        | character varying |<br> delete_flag | integer           | not null default 0</p>
<ol start="3">
<li><p>创建function<br>CREATE OR REPLACE FUNCTION check_person_name_unique( p_name character varying, flag integer)<br>RETURNS boolean AS<br>$BODY$<br>declare<br> count integer:=0;<br>begin<br> if(flag=1) then</p>
<pre><code> return true; 
</code></pre>
<p> end if;<br> select count(0) from person where name=p_name and delete_flag=0 into count;<br> if count&gt;0 then</p>
<pre><code> return false;
</code></pre>
<p> elseif count=0 then</p>
<pre><code> return true;
</code></pre>
<p> end if;<br>end;<br>$BODY$<br>LANGUAGE plpgsql VOLATILE;</p>
</li>
<li><p>应用到表上<br>postgres=# alter table person add CONSTRAINT check_unique CHECK (check_person_name_unique(name, delete_flag));</p>
</li>
<li><p>插入测试数据<br>postgres=# insert into person(name) values(‘zhangsan’);<br>INSERT 0 1<br>postgres=# insert into person(name) values(‘zhangsan’);<br>ERROR:  new row for relation “person” violates check constraint “check_unique”<br>DETAIL:  Failing row contains (2, zhangsan, 0).<br>插入两条相同的违反了唯一约束</p>
</li>
<li><p>现在把记录更新 delete_flag=1;<br>postgres=# select * from person;<br>id |   name   | delete_flag </p>
</li>
</ol>
<p>—-+———-+————-<br>  1 | zhangsan |           0<br>(1 row)<br>postgres=# update person person set delete_flag=1;<br>UPDATE 1<br>postgres=# select * from person;<br> id |   name   | delete_flag<br>—-+———-+————-<br>  1 | zhangsan |           1<br>(1 row)</p>
<ol start="7">
<li><p>再插入名字相同的<br>postgres=# insert into person(name) values(‘zhangsan’);<br>INSERT 0 1<br>插入成功</p>
</li>
<li><p>查看数据<br>postgres=# select * from person;<br>id |   name   | delete_flag </p>
</li>
</ol>
<p>—-+———-+————-<br>  1 | zhangsan |           1<br>  3 | zhangsan |           0<br>(2 rows)</p>
<p>这样就可以保证逻辑删除的记录的唯一性。<br>————————————————<br>版权声明：本文为CSDN博主「金一白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/luojinbai/article/details/43670233">https://blog.csdn.net/luojinbai/article/details/43670233</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL修改表常用命令操作</title>
    <url>/2023/03/16/PostgreSQL%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补充：PostgreSQL修改表(alter table语句)</p>
<p>PostgreSQL ALTER TABLE命令用于添加，删除或修改现有表中的列。您还可以使用ALTER TABLE命令在现有表上添加和删除各种约束。</p>
<p>语法：</p>
<p>使用ALTER TABLE语句在现有表中添加新列：</p>
<p>ALTER TABLE table_name ADD column_name datatype;</p>
<p>现有表中ALTER TABLE到DROP COLUMN(删除某个字段)：</p>
<p>ALTER TABLE table_name DROP COLUMN column_name;</p>
<p>ALTER TABLE更改表中列的DATA TYPE(修改字段类型)：</p>
<p>ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype;</p>
<p>ALTER TABLE向表中的列添加NOT NULL约束：</p>
<p>ALTER TABLE table_name MODIFY column_name datatype NOT NULL;</p>
<p>ALTER TABLE添加唯一约束ADD UNIQUE CONSTRAINT到表中：</p>
<p>ALTER TABLE table_name ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2…);</p>
<p>ALTER TABLE将“检查约束”添加到表中：</p>
<p>ALTER TABLE table_name ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);</p>
<p>ALTER TABLE添加主键ADD PRIMARY KEY约束：</p>
<p>ALTER TABLE table_name ADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2…);</p>
<p>使用ALTER TABLE从表中删除约束(DROP CONSTRAINT)：</p>
<p>ALTER TABLE table_name DROP CONSTRAINT MyUniqueConstraint;</p>
<p>使用ALTER TABLE从表中删除主键约束(DROP PRIMARY KEY)约束：</p>
<p>ALTER TABLE table_name DROP CONSTRAINT MyPrimaryKey;</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL修改表字段常用命令操作</title>
    <url>/2023/03/15/PostgreSQL%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>–数据库、模式、表名 “identities”.”Test”.”tab_test”</p>
<p>–修改字段名</p>
<p>ALTER TABLE “identities”.”Test”.”tab_test” RENAME “u_name” to realname ;</p>
<p>–添加字段</p>
<p>ALTER TABLE “identities”.”Test”.”tab_test” ADD COLUMN updcontent VARCHAR(50);</p>
<p>–添加字段 给默认值</p>
<p>ALTER TABLE “identities”.”Test”.”tab_test” ADD COLUMN utype INT DEFAULT(1);</p>
<p>–字段注解</p>
<p>COMMENT ON COLUMN “identities”.”Test”.”tab_test”.”utype” IS ‘类型 1为普通 2为高级’;</p>
<p>–修改字段类型</p>
<p>ALTER TABLE “identities”.”Test”.”tab_test” alter COLUMN utype type VARCHAR(50) ;</p>
<p>–删除非空约束</p>
<p>ALTER TABLE “identities”.”Test”.”tab_test” ALTER COLUMN realname drop not NULL;</p>
<p>–添加主键</p>
<p>ALTER TABLE “identities”.”Test”.”tab_test” ADD PRIMARY KEY (“id”);</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSql常用ALTER语句</title>
    <url>/2023/03/14/PostgreSQL%E5%B8%B8%E7%94%A8ALTER%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>数据库操作</p>
<p>  ALTER DATABASE name ALLOW_CONNECTIONS true|false;<br>  ALTER DATABASE name CONNECTION LIMIT connlimit;<br>  ALTER DATABASE name CONNECTION IS_TEMPLATE true|false;<br>  ALTER DATABASE name RENAME TO new_name;<br>  ALTER DATABASE name OWNER TO new_owner;<br>  ALTER DATABASE name SET TABLESPACE new_tablespace;<br>  ALTER DATABASE name SET configuration_parameter {TO|=} {value|DEFAULT};<br>  ALTER DATABASE name SET configuration_parameter FROM CURRENT;<br>  ALTER DATABASE name RESET configuration_parameter;<br>  ALTER DATABASE name RESET ALL;</p>
</li>
<li><p>用户角色操作</p>
<p>  ALTER ROLE|USER role_name WITH PASSWORD ‘password’;<br>  ALTER ROLE|USER role_name WITH PASSWORD NULL;<br>  ALTER ROLE|USER role_name VALID UNTIL ‘May 4 12:00:00 2015 +1’;<br>  ALTER ROLE|USER role_name VALID UNTIL ‘infinity’;<br>  ALTER ROLE|USER role_name CREATEROLE CREATEDB;<br>  ALTER ROLE|USER role_name SET maintenance_work_mem = 100000;<br>  ALTER ROLE|USER role_name {IN DATABASE name} SET configuration_parameter {TO|=} {value|DEFAULT};<br>  ALTER ROLE|USER role_name {IN DATABASE name} SET configuration_parameter FROM CURRENT;<br>  ALTER ROLE|USER role_name {IN DATABASE name} RESET configuration_parameter;<br>  ALTER ROLE|USER role_name {IN DATABASE name} RESET ALL;</p>
</li>
<li><p>SCHEMA 操作</p>
<p>  ALTER SCHEMA schema_name RENAME TO new_name;<br>  ALTER SCHEMA schema_name OWNER TO new_owner;</p>
</li>
<li><p>表操作</p>
<p>  ALTER TABLE table_name RENAME TO new_name;<br>  ALTER TABLE table_name SET SCHEMA new_schema;<br>  ALTER TABLE table_name OWNER TO role_name;<br>  ALTER TABLE table_name SET TABLESPACE tablespace_name;<br>  ALTER TABLE table_name ADD column_name datatype;<br>  ALTER TABLE table_name DROP column_name;<br>  ALTER TABLE table_name ALTER column_name TYPE datatype;<br>  ALTER TABLE table_name RENAME column_name TO new_column_name;<br>  ALTER TABLE table_name ALTER column_name {SET|DROP} NOT NULL;<br>  ALTER TABLE table_name ALTER column_name SET DEFAULT expression;<br>  ALTER TABLE table_name RENAME CONSTRAINT constraint_name TO new_constraint_name;<br>  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY(id);<br>  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE(id);<br>  ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK(id &gt; 100);<br>  ALTER TABLE table_name ADD CONSTRAINT constraint_name FOREIGN KEY(id) REFERENCES reftable(id);<br>  ALTER TABLE table_name DROP CONSTRAINT constraint_name;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgresql更改字段默认值、设置字段默认值、删除字段默认值</title>
    <url>/2023/03/13/PostgreSQL%E6%9B%B4%E6%94%B9%E5%AD%97%E6%AE%B5%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%81%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%81%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Postgresql更改字段默认值：<br>alter table  t_report ALTER   COLUMN reportno set DEFAULT  gen_random_uuid();  </p>
<p>Postgresql添加字段默认值：<br>ALTER TABLE tablename ADD COLUMN name1 INTEGER  DEFAULT 1;</p>
<p>Postgresql删除字段默认值：<br>ALTER TABLE tablename ALTER COLUMN name1 DROP DEFAULT;</p>
<p>Postgresql删除字段：<br>ALTER TABLE tablename  DROP COLUMN if exists name1 ;</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot逻辑删除之基本条件</title>
    <url>/2023/03/12/SpringBoot%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot 配置方式：</p>
<p>application.yml 加入配置(如果你的默认值和mp默认的一样,该配置可无):</p>
<pre><code>mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
</code></pre>
<p>Postgresql更改字段默认值：</p>
<pre><code>alter table sys_user ALTER COLUMN deleted set DEFAULT 0; 
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue正则验证（二）</title>
    <url>/2023/03/11/vue%E6%AD%A3%E5%88%99%E9%AA%8C%E8%AF%81%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>验证数字的正则表达式集</p>
<pre><code>验证数字：^[0-9]*$
验证n位的数字：^\d&#123;n&#125;$
验证至少n位数字：^\d&#123;n,&#125;$
验证m-n位的数字：^\d&#123;m,n&#125;$
验证零和非零开头的数字：^(0|[1-9][0-9]*)$
验证有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$
验证有1-3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$
验证非零的正整数：^\+?[1-9][0-9]*$
验证非零的负整数：^\-[1-9][0-9]*$
验证非负整数（正整数 + 0） ^\d+$
验证非正整数（负整数 + 0） ^((-\d+)|(0+))$
验证长度为3的字符：^.&#123;3&#125;$
验证由26个英文字母组成的字符串：^[A-Za-z]+$
验证由26个大写英文字母组成的字符串：^[A-Z]+$
验证由26个小写英文字母组成的字符串：^[a-z]+$
验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
验证由数字、26个英文字母或者下划线组成的字符串：^\w+$
验证用户密码:^[a-zA-Z]\w&#123;5,17&#125;$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。
验证是否含有 ^%&amp;&#39;,;=?$\&quot; 等字符：[^%&amp;&#39;,;=?$\x22]+
验证汉字：^[\u4e00-\u9fa5],&#123;0,&#125;$
验证Email地址：^\w+[-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$
验证电话号码：^(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-)?\d&#123;7,8&#125;$：--正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。
验证身份证号（15位或18位数字）：^\d&#123;15&#125;|\d&#123;&#125;18$
验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12”
验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。
整数：^-?\d+$
非负浮点数（正浮点数 + 0）：^\d+(\.\d+)?$
正浮点数 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
非正浮点数（负浮点数 + 0） ^((-\d+(\.\d+)?)|(0+(\.0+)?))$
负浮点数 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
浮点数 ^(-?\d+)(\.\d+)?$
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>软件开发</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue正则验证（一）</title>
    <url>/2023/03/10/vue%E6%AD%A3%E5%88%99%E9%AA%8C%E8%AF%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>vue的常用数据验证规则：</p>
<pre><code>1. 手机号：
    var validateMobilePhone = (rule, value, callback) =&gt; &#123;
            if (value === &#39;&#39;) &#123;
              callback(new Error(&#39;手机号不可为空&#39;));
            &#125; else &#123;
              if (value !== &#39;&#39;) &#123; 
                var reg=/^1[3456789]\d&#123;9&#125;$/;
                if(!reg.test(value))&#123;
                  callback(new Error(&#39;请输入有效的手机号码&#39;));
                &#125;
              &#125;
              callback();
            &#125;
          &#125;;
2. 邮箱：
    var validateEmail = (rule, value, callback) =&gt; &#123;
            if (value === &#39;&#39;) &#123;
              callback(new Error(&#39;请正确填写邮箱&#39;));
            &#125; else &#123;
              if (value !== &#39;&#39;) &#123; 
                var reg=/^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
                if(!reg.test(value))&#123;
                  callback(new Error(&#39;请输入有效的邮箱&#39;));
                &#125;
              &#125;
              callback();
            &#125;
          &#125;;
3. 密码：
    var validatePass = (rule, value, callback) =&gt; &#123;
            if (value === &#39;&#39;) &#123;
              callback(new Error(&#39;密码格式不正确&#39;));
            &#125; else if(value.length &lt; 6)&#123;
              callback(new Error(&#39;密码长度最小6位&#39;));
            &#125;else&#123;
              callback();
            &#125;
          &#125;;
4. 固定电话：
    var validatePhone = (rule, value, callback) =&gt; &#123;
            if (value === &#39;&#39;) &#123;
              callback(new Error(&#39;电话不可为空&#39;));
            &#125; else &#123;
              if (value !== &#39;&#39;) &#123; 
                var reg =/^((0\d&#123;2,3&#125;-\d&#123;7,8&#125;)|(1[3584]\d&#123;9&#125;))$/;
                if(!reg.test(value))&#123;
                  callback(new Error(&#39;请输入正确的座机号格式为：0000-0000000&#39;));
                &#125;
              &#125;
              callback();
            &#125;
          &#125;;
5. 微信号：
    var validateWeixin = (rule, value, callback) =&gt; &#123;
            if (value === &#39;&#39;) &#123;
              callback(new Error(&#39;微信号不能为空&#39;));
            &#125;else&#123;
              var reg= /^[a-zA-Z][a-zA-Z0-9_-]&#123;5,19&#125;$/;
              if(!reg.test(value))&#123;
                callback(new Error(&#39;请输入正确的微信号码&#39;));
              &#125;else&#123;
                callback();
              &#125;
            &#125; 
          &#125;;
6. IP地址：
     var validateIP(rule, value, callback) &#123;
        if(value &amp;&amp; &quot;...&quot; === value)&#123;
            callback(new Error(&#39;请输入IP地址&#39;))
        &#125;if (value &amp;&amp; !(/((25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))\.)&#123;3&#125;(25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))/).test(value)) &#123;
          callback(new Error(&#39;IP地址不规范&#39;))
        &#125; else &#123;
          callback()
        &#125;
      &#125;
7. 身份证号：
    var  validateIDCard(rule, value, callback) &#123;
        if (value &amp;&amp; (!(/\d&#123;17&#125;[\d|x]|\d&#123;15&#125;/).test(value) || (value.length !== 15 &amp;&amp; value.length !== 18))) &#123;
          callback(new Error(&#39;身份证号码不规范&#39;))
        &#125; else &#123;
          callback()
        &#125;
      &#125;
8. 正整数：
    var validateIntegerP(rule, value, callback) &#123;
        if (value &amp;&amp; !(/^[1-9]\d*$/).test(value)) &#123;
          callback(new Error(&#39;只能填写正整数&#39;))
        &#125; else &#123;
          callback()
        &#125;
      &#125;
    //负整数 /^-[1-9]\d*$/
9. 电脑MAC地址：
     var validateMac (rule, value, callback) &#123;
        let temp = /[A-Fa-f0-9]&#123;2&#125;-[A-Fa-f0-9]&#123;2&#125;-[A-Fa-f0-9]&#123;2&#125;-[A-Fa-f0-9]&#123;2&#125;-[A-Fa-f0-9]    &#123;2&#125;-[A-Fa-f0-9]&#123;2&#125;/;
        if (!temp.test(value)) &#123;
          callback(new Error(&#39;请输入xx-xx-xx-xx-xx-xx形式的MAC地址！&#39;));
        &#125; else&#123;
          callback();
        &#125;
      &#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域处理</title>
    <url>/2023/03/09/%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>注意事项：</p>
<ul>
<li>import org.springframework.web.filter.CorsFilter;</li>
<li>configuration.addAllowedOriginPattern(“*”);</li>
</ul>
<p>示例代码：</p>
<pre><code>package com.energy.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class MyCorsConfig &#123;

//    @Bean
//    public CorsFilter corsFilter()&#123;
//        CorsConfiguration configuration = new CorsConfiguration();
//        configuration.addAllowedOriginPattern(&quot;*&quot;);
//        configuration.setAllowCredentials(true);
//        configuration.addAllowedMethod(&quot;*&quot;);
//        configuration.addAllowedHeader(&quot;*&quot;);
//
//        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
//        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;,configuration);
//
//        return  new CorsFilter(urlBasedCorsConfigurationSource);
//    &#125;

//-------------------------------------------------------------

//    private CorsConfiguration buildConfig() &#123;
//        CorsConfiguration corsConfiguration = new CorsConfiguration();
//        corsConfiguration.addAllowedOriginPattern(&quot;*&quot;); // 允许任何域名使用
//        corsConfiguration.addAllowedHeader(&quot;*&quot;); // 允许任何头
//        corsConfiguration.addAllowedMethod(&quot;*&quot;); // 允许任何方法（post、get等）
//        corsConfiguration.setAllowCredentials(true);
//        return corsConfiguration;
//    &#125;
//
//    @Bean
//    public CorsFilter corsFilter() &#123;
//        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
//        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig());
//        return new CorsFilter(source);
//    &#125;

//-------------------------------------------------------------

    @Bean
    public CorsFilter corsFilter() &#123;
        final UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
        final CorsConfiguration corsConfiguration = new CorsConfiguration();
        /*是否允许请求带有验证信息*/
        corsConfiguration.setAllowCredentials(true);
        /*允许访问的客户端域名*/
        corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);
        /*允许服务端访问的客户端请求头*/
        corsConfiguration.addAllowedHeader(&quot;*&quot;);
        /*允许访问的方法名,GET POST等*/
        corsConfiguration.addAllowedMethod(&quot;*&quot;);
        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);
        return new CorsFilter(urlBasedCorsConfigurationSource);
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>跨域处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot+Postgresql+FastAutoGenerator（二）</title>
    <url>/2023/03/08/Springboot-Postgresql-FastAutoGenerator-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>执行日志如下，SQL语句备用：</p>
<pre><code>14:55:09.076 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================准备生成文件...==========================
14:55:10.014 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 执行SQL:

SELECT A.tablename, obj_description(relfilenode, &#39;pg_class&#39;) AS comments FROM pg_tables A, pg_class B WHERE A.schemaname=&#39;system&#39; AND A.tablename = B.relname AND tablename IN (&#39;sys_role_menu&#39;,&#39;sys_user_role&#39;,&#39;sys_user&#39;,&#39;sys_menu&#39;,&#39;sys_role&#39;)

14:55:10.029 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 返回记录数:5,耗时(ms):19
14:55:10.076 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 执行SQL:
SELECT
   A.attname AS name,format_type (A.atttypid,A.atttypmod) AS type,col_description (A.attrelid,A.attnum) AS comment,
     D.column_default,
   CASE WHEN length(B.attname) &gt; 0 THEN &#39;PRI&#39; ELSE &#39;&#39; END AS key
FROM
   pg_attribute A
LEFT JOIN (
    SELECT
        pg_attribute.attname
    FROM
        pg_index,
        pg_class,
        pg_attribute
    WHERE
        pg_class.oid =&#39;&quot;sys_menu&quot;&#39; :: regclass
    AND pg_index.indrelid = pg_class.oid
    AND pg_attribute.attrelid = pg_class.oid
    AND pg_attribute.attnum = ANY (pg_index.indkey)
) B ON A.attname = b.attname
INNER JOIN pg_class C on A.attrelid = C.oid
INNER JOIN information_schema.columns D on A.attname = D.column_name
WHERE A.attrelid =&#39;&quot;sys_menu&quot;&#39; :: regclass AND A.attnum&gt; 0 AND NOT A.attisdropped AND D.table_name = &#39;sys_menu&#39;
ORDER BY A.attnum;

14:55:10.107 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 返回记录数:10,耗时(ms):31
14:55:10.107 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 执行SQL:

SELECT
   A.attname AS name,format_type (A.atttypid,A.atttypmod) AS type,col_description (A.attrelid,A.attnum) AS comment,
     D.column_default,
   CASE WHEN length(B.attname) &gt; 0 THEN &#39;PRI&#39; ELSE &#39;&#39; END AS key
FROM
   pg_attribute A
LEFT JOIN (
    SELECT
        pg_attribute.attname
    FROM
        pg_index,
        pg_class,
        pg_attribute
    WHERE
        pg_class.oid =&#39;&quot;sys_role&quot;&#39; :: regclass
    AND pg_index.indrelid = pg_class.oid
    AND pg_attribute.attrelid = pg_class.oid
    AND pg_attribute.attnum = ANY (pg_index.indkey)
) B ON A.attname = b.attname
INNER JOIN pg_class C on A.attrelid = C.oid
INNER JOIN information_schema.columns D on A.attname = D.column_name
WHERE A.attrelid =&#39;&quot;sys_role&quot;&#39; :: regclass AND A.attnum&gt; 0 AND NOT A.attisdropped AND D.table_name = &#39;sys_role&#39;
ORDER BY A.attnum;

14:55:10.123 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 返回记录数:3,耗时(ms):5
14:55:10.123 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 执行SQL:

SELECT
   A.attname AS name,format_type (A.atttypid,A.atttypmod) AS type,col_description (A.attrelid,A.attnum) AS comment,
     D.column_default,
   CASE WHEN length(B.attname) &gt; 0 THEN &#39;PRI&#39; ELSE &#39;&#39; END AS key
FROM
   pg_attribute A
LEFT JOIN (
    SELECT
        pg_attribute.attname
    FROM
        pg_index,
        pg_class,
        pg_attribute
    WHERE
        pg_class.oid =&#39;&quot;sys_role_menu&quot;&#39; :: regclass
    AND pg_index.indrelid = pg_class.oid
    AND pg_attribute.attrelid = pg_class.oid
    AND pg_attribute.attnum = ANY (pg_index.indkey)
) B ON A.attname = b.attname
INNER JOIN pg_class C on A.attrelid = C.oid
INNER JOIN information_schema.columns D on A.attname = D.column_name
WHERE A.attrelid =&#39;&quot;sys_role_menu&quot;&#39; :: regclass AND A.attnum&gt; 0 AND NOT A.attisdropped AND D.table_name = &#39;sys_role_menu&#39;
ORDER BY A.attnum;

14:55:10.123 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 返回记录数:3,耗时(ms):5
14:55:10.139 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 执行SQL:

SELECT
   A.attname AS name,format_type (A.atttypid,A.atttypmod) AS type,col_description (A.attrelid,A.attnum) AS comment,
     D.column_default,
   CASE WHEN length(B.attname) &gt; 0 THEN &#39;PRI&#39; ELSE &#39;&#39; END AS key
FROM
   pg_attribute A
LEFT JOIN (
    SELECT
        pg_attribute.attname
    FROM
        pg_index,
        pg_class,
        pg_attribute
    WHERE
        pg_class.oid =&#39;&quot;sys_user&quot;&#39; :: regclass
    AND pg_index.indrelid = pg_class.oid
    AND pg_attribute.attrelid = pg_class.oid
    AND pg_attribute.attnum = ANY (pg_index.indkey)
) B ON A.attname = b.attname
INNER JOIN pg_class C on A.attrelid = C.oid
INNER JOIN information_schema.columns D on A.attname = D.column_name
WHERE A.attrelid =&#39;&quot;sys_user&quot;&#39; :: regclass AND A.attnum&gt; 0 AND NOT A.attisdropped AND D.table_name = &#39;sys_user&#39;
ORDER BY A.attnum;

14:55:10.139 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 返回记录数:11,耗时(ms):6
14:55:10.139 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 执行SQL:

SELECT
   A.attname AS name,format_type (A.atttypid,A.atttypmod) AS type,col_description (A.attrelid,A.attnum) AS comment,
     D.column_default,
   CASE WHEN length(B.attname) &gt; 0 THEN &#39;PRI&#39; ELSE &#39;&#39; END AS key
FROM
   pg_attribute A
LEFT JOIN (
    SELECT
        pg_attribute.attname
    FROM
        pg_index,
        pg_class,
        pg_attribute
    WHERE
        pg_class.oid =&#39;&quot;sys_user_role&quot;&#39; :: regclass
    AND pg_index.indrelid = pg_class.oid
    AND pg_attribute.attrelid = pg_class.oid
    AND pg_attribute.attnum = ANY (pg_index.indkey)
) B ON A.attname = b.attname
INNER JOIN pg_class C on A.attrelid = C.oid
INNER JOIN information_schema.columns D on A.attname = D.column_name
WHERE A.attrelid =&#39;&quot;sys_user_role&quot;&#39; :: regclass AND A.attnum&gt; 0 AND NOT A.attisdropped AND D.table_name = &#39;sys_user_role&#39;
ORDER BY A.attnum;

14:55:10.154 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.PostgreSqlQuery - 返回记录数:3,耗时(ms):5

14:55:10.373 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================文件生成完成！！！==========================

Process finished with exit code 0
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot+Postgresql+FastAutoGenerator（一）</title>
    <url>/2023/03/07/Springboot-Postgresql-FastAutoGenerator-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Postgreql默认是public，需要手动指定schema。<br>URL指定schema也不行，必须单独构造一个DataSourceConfig.Builder进行指定。</p>
<pre><code>package com.goland.gis;

import com.baomidou.mybatisplus.generator.FastAutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.OutputFile;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

import java.util.Collections;

public class CodeGenerator &#123;

    public static void main(String[] args) &#123;

        String url =&quot;jdbc:postgresql://localhost:5432/power?currentSchema=system&quot;;
        String username = &quot;postgres&quot;;
        String password = &quot;postgres&quot;;

        String moduleName = &quot;sys&quot;;
        String mapperLocation = &quot;E:\\Java\\work4\\grid\\gis\\src\\main\\resources\\mapper\\&quot; + moduleName;
        String tableNames = &quot;sys_user,sys_menu,sys_role,sys_role_menu,sys_user_role&quot;;

        DataSourceConfig.Builder builderOutSide = new DataSourceConfig.Builder(url, username, password);
        builderOutSide.schema(&quot;system&quot;);

        FastAutoGenerator.create(builderOutSide)
                .globalConfig(builder -&gt; &#123;
                    builder.author(&quot;zhangsmile1893&quot;) // 设置作者
                            //.enableSwagger() // 开启 swagger 模式
                            //.fileOverride() // 覆盖已生成文件
                            .outputDir(&quot;E:\\Java\\work4\\grid\\gis\\src\\main\\java&quot;); // 指定输出目录
                &#125;)
                .packageConfig(builder -&gt; &#123;
                    builder.parent(&quot;com.goland.gis&quot;) // 设置父包名
                            .moduleName(moduleName) // 设置父包模块名
                            .pathInfo(Collections.singletonMap(OutputFile.xml, mapperLocation)); // 设置mapperXml生成路径
                &#125;)
                .strategyConfig(builder -&gt; &#123;
                    builder.addInclude(tableNames) // 设置需要生成的表名
                            .addTablePrefix(&quot;sys_&quot;); // 设置过滤表前缀
                &#125;)
                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                .execute();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据库模式切换问题</title>
    <url>/2023/03/06/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在流行的数据库都有 Schema 的概念，一般作为数据库对象(表，函数，存储过程等)的命名空间。所以在数据库端往往存在实例/数据库/Schema 这样层级划分。对于DB2 和 Oracle 用客户端创建一个新的数据库并非易事，灵活的在数据库中较轻量的划分隔离空间的办法因数据库类型而异。</p>
<p>MySQL： Mysql 的体系架构是单实例多库，一个用户可以访问多个数据库，然后指定当前数据库写 SQL 的时候就不用带上数据库名，MySQL 中 database 和 schema是一个概念，它靠 database 来隔离数据库对象。创建数据库(create database)，create schema 是 create database 的别名。</p>
<p>PostgreSQL： create database 创建新的数据库，或在当前数据库下用 create schema 创建 schema。PostgreSQL 的函数或存储过程中对未指定 schema 的数据库对象的访问的规则是在调用时动态绑定到当前会话中的 schema。</p>
<p>达梦 8： 达梦的体系架构是单库多实例的，也就是没有多个数据库的概念，从 Mysql转到达梦，就需要建多个用户+表空间来对应 Mysql的多个数据库。每个用户有一个默认的同名的模式，访问自己模式下的表、视图等不需要加模式名，访问其他模式下的对象需要加上模式名。</p>
<p>Oracle： create schema 较麻烦，涉及到 authorization。但可以通过 create user 创建新用户后就有了对应的新 schema。Oracle 中采取用户来隔离数据库对象。</p>
<p>实际应用过程中研发交付团队可能使用模式来进行租户间的数据隔离或根据业务功能划分不同的模式，这里就涉及一个服务需要同时连接并查询多种模式的问题，<br>一种方案是直接在 sql 中的表名前添加模式名前缀，这种适合一句 sql 需要跨多个模式进行联合查询的场景，属于定制型 sql。<br>一种方案是在会话层面指定模式，这样 sql中的表名不需要指定默认的前缀，对于不在当前模式下的表才需要添加模式前缀，这种适合多模式下相同表名存储数据的切换。</p>
<p>MySQL 的连接串直接指定具体数据库，其实已经是会话层面的模式切换</p>
<p>PostgreSQL 的连接串在没有指定当前模式下，例如<br>jdbc:postgresql://localhost:5432/postgresql 默认使用的是 postgresql 数据库的 public模式。</p>
<p>PostgreSQL 从 9.4 版本开始通过关键字 currentSchema 指定模式<br>jdbc:postgresql://localhost:5432/postgresql?currentSchema=myschema</p>
<p>旧版本通过 searchpath 指定<br>jdbc:postgresql://localhost:5432/postgresql?searchpath=myschema</p>
<p>达梦 8 的连接串在没有指定当前模式时，使用的是与用户同名的模式，可通过scheme 指定当前模式，例如：<br>jdbc:dm://localhost:5236?schema=myschema</p>
<p>————————————————<br>版权声明：本文为CSDN博主「雪影风痕」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_48805880/article/details/128385835">https://blog.csdn.net/m0_48805880/article/details/128385835</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot连接PostgreSQL</title>
    <url>/2023/03/05/SpringBoot%E8%BF%9E%E6%8E%A5PostgreSQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>1 yml配置</p>
</li>
<li><ul>
<li><p>1.1 不指定schema的情况下，使用公共的schema</p>
<pre><code> spring:
   datasource:
     driver-class-name: org.postgresql.Driver
     url: jdbc:postgresql://localhost:5432/database
     username: xxx
     password: xxx
 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><p>1.2 指定schema的情况下</p>
<pre><code> spring:
   datasource:
     driver-class-name: org.postgresql.Driver
     url: jdbc:postgresql://localhost:5432/database?currentSchema=schema
     username: xxx
     password: xxx
 
</code></pre>
</li>
</ul>
</li>
<li><p>2 版本影响 </p>
</li>
<li><ul>
<li><p>postgresql 9.3 及以前的版本指定方式</p>
<p> spring.datasource.url=jdbc:postgresql://localhost:5432/postgresql?searchpath=newschema</p>
</li>
</ul>
</li>
<li><ul>
<li><p>postgresql 9.4 及以后的版本指定方式</p>
<p> spring.datasource.url=jdbc:postgresql://localhost:5432/postgresql?currentSchema=newschema </p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS Environment variables</title>
    <url>/2023/03/04/QGIS-Environment-variables/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>You can configure some aspects of QGIS Server by setting environment variables.</p>
<p>According to the HTTP server and how you run QGIS Server, there are several ways to define these variables. This is fully described in Apache HTTP Server.</p>
<p>名称</p>
<p>Description</p>
<p>Default</p>
<p>Services</p>
<p>QGIS_OPTIONS_PATH</p>
<p>Specifies the path to the directory with settings. It works the same way as QGIS application –optionspath option. It is looking for settings file in <QGIS_OPTIONS_PATH>/QGIS/QGIS3.ini.</QGIS_OPTIONS_PATH></p>
<p>‘’</p>
<p>All</p>
<p>QGIS_PLUGINPATH</p>
<p>Useful if you are using Python plugins for the server, this sets the folder that is searched for Python plugins.</p>
<p>‘’</p>
<p>All</p>
<p>QGIS_PROJECT_FILE</p>
<p>The .qgs or .qgz project file, normally passed as a parameter in the query string (with MAP), you can also set it as an environment variable (for example by using mod_rewrite Apache module).</p>
<p>Note that you may also indicate a project stored in PostgreSQL, e.g. postgresql://localhost:5432?sslmode=disable&amp;dbname=mydb&amp;schema=myschema&amp;project=myproject.</p>
<p>‘’</p>
<p>All</p>
<p>QGIS_SERVER_API_RESOURCES_DIRECTORY</p>
<p>Base directory for all OGC API (such as OAPIF/WFS3) static resources (HTML templates, CSS, JS, …)</p>
<p>depends on packaging</p>
<p>WFS</p>
<p>QGIS_SERVER_API_WFS3_MAX_LIMIT</p>
<p>Maximum value for limit in a features request.</p>
<p>10000</p>
<p>WFS</p>
<p>QGIS_SERVER_CACHE_DIRECTORY</p>
<p>Specifies the network cache directory on the filesystem.</p>
<p>cache in profile directory</p>
<p>All</p>
<p>QGIS_SERVER_CACHE_SIZE</p>
<p>Sets the network cache size in MB.</p>
<p>50 MB</p>
<p>All</p>
<p>QGIS_SERVER_DISABLE_GETPRINT</p>
<p>This is an option at the project level to improve project read time by disabling loading of layouts.</p>
<p>Activating this option disables the QGIS WMS GetPrint request. Set this QGIS project flag to not load layouts.</p>
<p>false</p>
<p>WMS</p>
<p>QGIS_SERVER_IGNORE_BAD_LAYERS</p>
<p>“Bad” layers are layers that cannot be loaded. The default behavior of QGIS Server is to consider the project as not available if it contains a bad layer.</p>
<p>The default behavior can be overridden by setting this variable to 1 or true. In this case, “bad” layers will just be ignored, and the project will be considered valid and available.</p>
<p>false</p>
<p>All</p>
<p>QGIS_SERVER_LANDING_PAGE_PREFIX</p>
<p>Prefix of the path component of the landing page base URL</p>
<p>“”</p>
<p>All</p>
<p>QGIS_SERVER_LANDING_PAGE_PROJECTS_DIRECTORIES</p>
<p>Directories used by the landing page service to find .qgs and .qgz projects</p>
<p>“”</p>
<p>All</p>
<p>QGIS_SERVER_LANDING_PAGE_PROJECTS_PG_CONNECTIONS</p>
<p>PostgreSQL connection strings used by the landing page service to find projects</p>
<p>“”</p>
<p>All</p>
<p>QGIS_SERVER_LOG_FILE</p>
<p>Specify path and filename. Make sure that server has proper permissions for writing to file. File should be created automatically, just send some requests to server. If it’s not there, check permissions.</p>
<p>警告</p>
<p>QGIS_SERVER_LOG_FILE is deprecated since QGIS 3.4, use QGIS_SERVER_LOG_STDERR instead. File logging support will be removed in QGIS 4.0.</p>
<p>‘’</p>
<p>All</p>
<p>QGIS_SERVER_LOG_LEVEL</p>
<p>Specify desired log level. Available values are:</p>
<p>0 or INFO (log all requests)</p>
<p>1 or WARNING</p>
<p>2 or CRITICAL (log just critical errors, suitable for production purposes)</p>
<p>0</p>
<p>All</p>
<p>QGIS_SERVER_LOG_PROFILE</p>
<p>Add detailed profile information to the logs, only effective when QGIS_SERVER_LOG_LEVEL=0</p>
<p>false</p>
<p>All</p>
<p>QGIS_SERVER_LOG_STDERR</p>
<p>Activate logging to stderr. This variable has no effect when QGIS_SERVER_LOG_FILE is set.</p>
<p>0 or false (case insensitive)</p>
<p>1 or true (case insensitive)</p>
<p>false</p>
<p>All</p>
<p>QGIS_SERVER_MAX_THREADS</p>
<p>Number of threads to use when parallel rendering is activated. If value is -1 it uses the number of processor cores.</p>
<p>-1</p>
<p>All</p>
<p>QGIS_SERVER_OVERRIDE_SYSTEM_LOCALE</p>
<p>Sets LOCALE to be used by QGIS server. The default value is empty (no override).</p>
<p>Example: de_CH.utf8</p>
<p>‘’</p>
<p>All</p>
<p>QGIS_SERVER_PARALLEL_RENDERING</p>
<p>Activates parallel rendering for WMS GetMap requests. It’s disabled (false) by default. Available values are:</p>
<p>0 or false (case insensitive)</p>
<p>1 or true (case insensitive)</p>
<p>false</p>
<p>WMS</p>
<p>QGIS_SERVER_SHOW_GROUP_SEPARATOR</p>
<p>Defines whether a group separator (e.g. thousand separator) should be used for numeric values (e.g. in GetFeatureInfo responses). The default value is 0.</p>
<p>0 or false (case insensitive)</p>
<p>1 or true (case insensitive)</p>
<p>false</p>
<p>WMS</p>
<p>QGIS_SERVER_TRUST_LAYER_METADATA</p>
<p>This is an option at the project level to improve project read time by using the vector layer extents defined in the project metadata and disabling the check for PostgreSQL/PostGIS layer primary key uniqueness.</p>
<p>Trusting layer metadata can be forced by setting this variable to 1 or true. The vector layer’s extent will then be the one defined in the project, and the PostgreSQL/PostGIS layer’s primary key defined in the data source is considered as unique without a check.</p>
<p>Do not use it if layers’ extent is not fixed during the project’s use.</p>
<p>false</p>
<p>All</p>
<p>QGIS_SERVER_WMS_MAX_HEIGHT / QGIS_SERVER_WMS_MAX_WIDTH</p>
<p>Maximum height/width for a WMS request. The most conservative between this and the project one is used. If the value is -1, it means that there is no maximum set.</p>
<p>-1</p>
<p>WMS</p>
<p>QUERY_STRING</p>
<p>The query string, normally passed by the web server. This variable can be useful while testing QGIS server binary from the command line.</p>
<p>For example for testing a GetCapabilities request on the command line to a project that also requires a PostgreSQL connection defined in a pg_service.conf file:</p>
<p>PGSERVICEFILE=/etc/pg_service.conf <br>QUERY_STRING=”MAP=/home/projects/world.qgs&amp;SERVICE=WMS&amp;REQUEST=GetCapabilities” <br>/usr/lib/cgi-bin/qgis_mapserv.fcgi<br>The result should be either the content of the GetCapabilities response or, if something is wrong, an error message.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>How QGIS Serve a project</title>
    <url>/2023/03/03/How-QGIS-Serve-a-project/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Now that QGIS Server is installed and running, we just have to use it.</p>
<p>Obviously, we need a QGIS project to work on. Of course, you can fully customize your project by defining contact information, precise some restrictions on CRS or even exclude some layers. Everything you need to know about that is described later in Configure your project.</p>
<p>But for now, we are going to use a simple project already configured and previously downloaded in /home/qgis/projects/world.qgs, as described above.</p>
<p>By opening the project and taking a quick look on layers, we know that 4 layers are currently available:</p>
<p>airports<br>places<br>countries<br>countries_shapeburst</p>
<p>You don’t have to understand the full request for now but you may retrieve a map with some of the previous layers thanks to QGIS Server by doing something like this in your web browser to retrieve the countries layer:</p>
<pre><code>http://qgis.demo/qgisserver?
  MAP=/home/qgis/projects/world.qgs&amp;
  LAYERS=countries&amp;
  SERVICE=WMS&amp;
  VERSION=1.3.0&amp;
  REQUEST=GetMap&amp;
  CRS=EPSG:4326&amp;
  WIDTH=400&amp;
  HEIGHT=200&amp;
  BBOX=-90,-180,90,180
</code></pre>
<p>If you obtain the next image, then QGIS Server is running correctly:</p>
<p>Note that you may define QGIS_PROJECT_FILE environment variable to use a project by default instead of giving a MAP parameter (see Environment variables).</p>
<p>For example with spawn-fcgi:</p>
<p>export QGIS_PROJECT_FILE=/home/qgis/projects/world.qgs<br>spawn-fcgi -f /usr/lib/bin/cgi-bin/qgis_mapserv.fcgi <br>           -s /var/run/qgisserver.socket <br>           -U www-data -G www-data -n</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS Server Installation on Windows</title>
    <url>/2023/03/02/QGIS-Server-Installation-on-Windows/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>QGIS Server can also be installed on Windows systems using the 64 bit version of the OSGeo4W network installer (<a href="https://qgis.org/en/site/forusers/download.html">https://qgis.org/en/site/forusers/download.html</a>).</p>
<h1 id="A-simple-procedure-is-the-following"><a href="#A-simple-procedure-is-the-following" class="headerlink" title="A simple procedure is the following:"></a>A simple procedure is the following:</h1><ul>
<li><p>Download and run the OSGeo4W installer</p>
</li>
<li><p>Follow the “Advanced Install” and install the QGIS Desktop, QGIS Server apache and mod_fcgid packages.</p>
</li>
<li><p>Apache is not directly installed as a service on Windows. You need to:</p>
</li>
</ul>
<p>** Right-click the OSGeo4W.bat file at the root of the C:\OSGeo4W64\ folder (if the default installation paths have been used) and select Run as administrator</p>
<p>** In the console, run apache-install.bat, which will output</p>
<pre><code>&gt; apache-install.bat
Installing the &#39;Apache OSGeo4W Web Server&#39; service
The &#39;Apache OSGeo4W Web Server&#39; service is successfully installed.
Testing httpd.conf....
Errors reported here must be corrected before the service can be started.
...
</code></pre>
<p>The service is started as you can notice in the report. But the server may fail to run due to missing custom configuration.</p>
<ul>
<li>Edit the C:\OSGeo4w64\apps\apache\conf\httpd.conf file with the following changes (various other combinations are possible):</li>
</ul>
<p>** (Optional) Customize the address to listen to using an IP and/or port, You can and add as many entries as you wish.</p>
<p>*** Existing config<br>    Listen ${SRVPORT}</p>
<p>*** Replacement<br>    Listen localhost:8080</p>
<p>** Indicate where to find the script files<br>*** Existing config<br>    ScriptAlias /cgi-bin/ “${SRVROOT}/cgi-bin/“</p>
<p>*** Replacement<br>    ScriptAlias /cgi-bin/ “C:/OSGeo4W64/apps/qgis/bin/“</p>
<p>** Provide permissions on the script folder<br>*** Existing config<br>&lt;Directory “${SRVROOT}/cgi-bin”&gt;<br>    AllowOverride None<br>    Options None<br>    Require all granted<br></p>
<p>*** Replacement<br>&lt;Directory “C:/OSGeo4W64/apps/qgis/bin”&gt;<br>    SetHandler cgi-script<br>    AllowOverride None<br>    Options ExecCGI<br>    Require all granted<br></p>
<p>** Enable file extensions to use for script files. Uncomment and complete<br>*** Existing config<br>    #AddHandler cgi-script .cgi<br>*** Replacement<br>    AddHandler cgi-script .cgi .exe</p>
<p>** Add more OSGeo4W custom configuration variables</p>
<p>*** Existing config<br>    # parse OSGeo4W apache conf files<br>    IncludeOptional “C:/OSGeo4W64/httpd.d/httpd_*.conf”<br>*** Replacement<br>    # parse OSGeo4W apache conf files<br>    IncludeOptional “C:/OSGeo4W64/httpd.d/httpd_*.conf”<br>    SetEnv GDAL_DATA “C:/OSGeo4W64/share/gdal”<br>    SetEnv QGIS_AUTH_DB_DIR_PATH “C:/OSGeo4W64/apps/qgis/resources”</p>
<p>** Restart the Apache web server</p>
<pre><code>&gt; apache-restart.bat
</code></pre>
<ul>
<li>Open browser window to testing a GetCapabilities request to QGIS Server. Replace localhost:8080 with the IP and port you set to listen.</li>
</ul>
<p><a href="http://localhost:8080/cgi-bin/qgis_mapserv.fcgi.exe?SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetCapabilities">http://localhost:8080/cgi-bin/qgis_mapserv.fcgi.exe?SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetCapabilities</a></p>
<p>A XML file with the capabilities should be returned. Your server is ready to use.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL Connection URIs</title>
    <url>/2023/03/01/PostgreSQL-Connection-URIs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>The general form for a connection URI is:</p>
<pre><code>postgresql://[userspec@][hostspec][/dbname][?paramspec]
</code></pre>
<p>where userspec is:</p>
<pre><code>user[:password]
</code></pre>
<p>and hostspec is:</p>
<pre><code>[host][:port][,...]
</code></pre>
<p>and paramspec is:</p>
<pre><code>name=value[&amp;...]
</code></pre>
<p>The URI scheme designator can be either postgresql:// or postgres://. Each of the remaining URI parts is optional. The following examples illustrate valid URI syntax:</p>
<pre><code>postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
</code></pre>
<p>Values that would normally appear in the hierarchical part of the URI can alternatively be given as named parameters. For example:</p>
<pre><code>postgresql:///mydb?host=localhost&amp;port=5433
</code></pre>
<p>All named parameters must match key words listed in Section 34.1.2, except that for compatibility with JDBC connection URIs, instances of ssl=true are translated into sslmode=require.</p>
<p>The connection URI needs to be encoded with percent-encoding if it includes symbols with special meaning in any of its parts. Here is an example where the equal sign (=) is replaced with %3D and the space character with %20:</p>
<pre><code>postgresql://user@localhost:5433/mydb?options=-c%20synchronous_commit%3Doff
</code></pre>
<p>The host part may be either a host name or an IP address. To specify an IPv6 address, enclose it in square brackets:</p>
<pre><code>postgresql://[2001:db8::1234]/database
</code></pre>
<p>The host part is interpreted as described for the parameter host. In particular, a Unix-domain socket connection is chosen if the host part is either empty or looks like an absolute path name, otherwise a TCP/IP connection is initiated. Note, however, that the slash is a reserved character in the hierarchical part of the URI. So, to specify a non-standard Unix-domain socket directory, either omit the host part of the URI and specify the host as a named parameter, or percent-encode the path in the host part of the URI:</p>
<pre><code>postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</code></pre>
<p>It is possible to specify multiple host components, each with an optional port component, in a single URI. A URI of the form postgresql://host1:port1,host2:port2,host3:port3/ is equivalent to a connection string of the form host=host1,host2,host3 port=port1,port2,port3. As further described below, each host will be tried in turn until a connection is successfully established.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL Password File</title>
    <url>/2023/02/28/PostgreSQL-Password-File/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>The file .pgpass in a user’s home directory can contain passwords to be used if the connection requires a password (and no password has been specified otherwise). On Microsoft Windows the file is named %APPDATA%\postgresql\pgpass.conf (where %APPDATA% refers to the Application Data subdirectory in the user’s profile). Alternatively, the password file to use can be specified using the connection parameter passfile or the environment variable PGPASSFILE.</p>
<p>This file should contain lines of the following format:</p>
<p>hostname:port:database:username:password<br>(You can add a reminder comment to the file by copying the line above and preceding it with #.) Each of the first four fields can be a literal value, or *, which matches anything. The password field from the first line that matches the current connection parameters will be used. (Therefore, put more-specific entries first when you are using wildcards.) If an entry needs to contain : or , escape this character with . The host name field is matched to the host connection parameter if that is specified, otherwise to the hostaddr parameter if that is specified; if neither are given then the host name localhost is searched for. The host name localhost is also searched for when the connection is a Unix-domain socket connection and the host parameter matches libpq’s default socket directory path. In a standby server, a database field of replication matches streaming replication connections made to the primary server. The database field is of limited usefulness otherwise, because users have the same password for all databases in the same cluster.</p>
<p>On Unix systems, the permissions on a password file must disallow any access to world or group; achieve this by a command such as chmod 0600 ~/.pgpass. If the permissions are less strict than this, the file will be ignored. On Microsoft Windows, it is assumed that the file is stored in a directory that is secure, so no special permissions check is made.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL Parameter Key Words</title>
    <url>/2023/02/27/PostgreSQL-Parameter-Key-Words/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>The currently recognized parameter key words are:</p>
<p>host<br>Name of host to connect to. If a host name looks like an absolute path name, it specifies Unix-domain communication rather than TCP/IP communication; the value is the name of the directory in which the socket file is stored. (On Unix, an absolute path name begins with a slash. On Windows, paths starting with drive letters are also recognized.) If the host name starts with @, it is taken as a Unix-domain socket in the abstract namespace (currently supported on Linux and Windows). The default behavior when host is not specified, or is empty, is to connect to a Unix-domain socket in /tmp (or whatever socket directory was specified when PostgreSQL was built). On Windows and on machines without Unix-domain sockets, the default is to connect to localhost.</p>
<p>A comma-separated list of host names is also accepted, in which case each host name in the list is tried in order; an empty item in the list selects the default behavior as explained above. See Section 34.1.1.3 for details.</p>
<p>hostaddr<br>Numeric IP address of host to connect to. This should be in the standard IPv4 address format, e.g., 172.28.40.9. If your machine supports IPv6, you can also use those addresses. TCP/IP communication is always used when a nonempty string is specified for this parameter. If this parameter is not specified, the value of host will be looked up to find the corresponding IP address — or, if host specifies an IP address, that value will be used directly.</p>
<p>Using hostaddr allows the application to avoid a host name look-up, which might be important in applications with time constraints. However, a host name is required for GSSAPI or SSPI authentication methods, as well as for verify-full SSL certificate verification. The following rules are used:</p>
<p>If host is specified without hostaddr, a host name lookup occurs. (When using PQconnectPoll, the lookup occurs when PQconnectPoll first considers this host name, and it may cause PQconnectPoll to block for a significant amount of time.)</p>
<p>If hostaddr is specified without host, the value for hostaddr gives the server network address. The connection attempt will fail if the authentication method requires a host name.</p>
<p>If both host and hostaddr are specified, the value for hostaddr gives the server network address. The value for host is ignored unless the authentication method requires it, in which case it will be used as the host name.</p>
<p>Note that authentication is likely to fail if host is not the name of the server at network address hostaddr. Also, when both host and hostaddr are specified, host is used to identify the connection in a password file (see Section 34.16).</p>
<p>A comma-separated list of hostaddr values is also accepted, in which case each host in the list is tried in order. An empty item in the list causes the corresponding host name to be used, or the default host name if that is empty as well. See Section 34.1.1.3 for details.</p>
<p>Without either a host name or host address, libpq will connect using a local Unix-domain socket; or on Windows and on machines without Unix-domain sockets, it will attempt to connect to localhost.</p>
<p>port<br>Port number to connect to at the server host, or socket file name extension for Unix-domain connections. If multiple hosts were given in the host or hostaddr parameters, this parameter may specify a comma-separated list of ports of the same length as the host list, or it may specify a single port number to be used for all hosts. An empty string, or an empty item in a comma-separated list, specifies the default port number established when PostgreSQL was built.</p>
<p>dbname<br>The database name. Defaults to be the same as the user name. In certain contexts, the value is checked for extended formats; see Section 34.1.1 for more details on those.</p>
<p>user<br>PostgreSQL user name to connect as. Defaults to be the same as the operating system name of the user running the application.</p>
<p>password<br>Password to be used if the server demands password authentication.</p>
<p>passfile<br>Specifies the name of the file used to store passwords (see Section 34.16). Defaults to ~/.pgpass, or %APPDATA%\postgresql\pgpass.conf on Microsoft Windows. (No error is reported if this file does not exist.)</p>
<p>channel_binding<br>This option controls the client’s use of channel binding. A setting of require means that the connection must employ channel binding, prefer means that the client will choose channel binding if available, and disable prevents the use of channel binding. The default is prefer if PostgreSQL is compiled with SSL support; otherwise the default is disable.</p>
<p>Channel binding is a method for the server to authenticate itself to the client. It is only supported over SSL connections with PostgreSQL 11 or later servers using the SCRAM authentication method.</p>
<p>connect_timeout<br>Maximum time to wait while connecting, in seconds (write as a decimal integer, e.g., 10). Zero, negative, or not specified means wait indefinitely. The minimum allowed timeout is 2 seconds, therefore a value of 1 is interpreted as 2. This timeout applies separately to each host name or IP address. For example, if you specify two hosts and connect_timeout is 5, each host will time out if no connection is made within 5 seconds, so the total time spent waiting for a connection might be up to 10 seconds.</p>
<p>client_encoding<br>This sets the client_encoding configuration parameter for this connection. In addition to the values accepted by the corresponding server option, you can use auto to determine the right encoding from the current locale in the client (LC_CTYPE environment variable on Unix systems).</p>
<p>options<br>Specifies command-line options to send to the server at connection start. For example, setting this to -c geqo=off sets the session’s value of the geqo parameter to off. Spaces within this string are considered to separate command-line arguments, unless escaped with a backslash (); write \ to represent a literal backslash. For a detailed discussion of the available options, consult Chapter 20.</p>
<p>application_name<br>Specifies a value for the application_name configuration parameter.</p>
<p>fallback_application_name<br>Specifies a fallback value for the application_name configuration parameter. This value will be used if no value has been given for application_name via a connection parameter or the PGAPPNAME environment variable. Specifying a fallback name is useful in generic utility programs that wish to set a default application name but allow it to be overridden by the user.</p>
<p>keepalives<br>Controls whether client-side TCP keepalives are used. The default value is 1, meaning on, but you can change this to 0, meaning off, if keepalives are not wanted. This parameter is ignored for connections made via a Unix-domain socket.</p>
<p>keepalives_idle<br>Controls the number of seconds of inactivity after which TCP should send a keepalive message to the server. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket, or if keepalives are disabled. It is only supported on systems where TCP_KEEPIDLE or an equivalent socket option is available, and on Windows; on other systems, it has no effect.</p>
<p>keepalives_interval<br>Controls the number of seconds after which a TCP keepalive message that is not acknowledged by the server should be retransmitted. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket, or if keepalives are disabled. It is only supported on systems where TCP_KEEPINTVL or an equivalent socket option is available, and on Windows; on other systems, it has no effect.</p>
<p>keepalives_count<br>Controls the number of TCP keepalives that can be lost before the client’s connection to the server is considered dead. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket, or if keepalives are disabled. It is only supported on systems where TCP_KEEPCNT or an equivalent socket option is available; on other systems, it has no effect.</p>
<p>tcp_user_timeout<br>Controls the number of milliseconds that transmitted data may remain unacknowledged before a connection is forcibly closed. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket. It is only supported on systems where TCP_USER_TIMEOUT is available; on other systems, it has no effect.</p>
<p>replication<br>This option determines whether the connection should use the replication protocol instead of the normal protocol. This is what PostgreSQL replication connections as well as tools such as pg_basebackup use internally, but it can also be used by third-party applications. For a description of the replication protocol, consult Section 55.4.</p>
<p>The following values, which are case-insensitive, are supported:</p>
<p>true, on, yes, 1<br>The connection goes into physical replication mode.</p>
<p>database<br>The connection goes into logical replication mode, connecting to the database specified in the dbname parameter.</p>
<p>false, off, no, 0<br>The connection is a regular one, which is the default behavior.</p>
<p>In physical or logical replication mode, only the simple query protocol can be used.</p>
<p>gssencmode<br>This option determines whether or with what priority a secure GSS TCP/IP connection will be negotiated with the server. There are three modes:</p>
<p>disable<br>only try a non-GSSAPI-encrypted connection</p>
<p>prefer (default)<br>if there are GSSAPI credentials present (i.e., in a credentials cache), first try a GSSAPI-encrypted connection; if that fails or there are no credentials, try a non-GSSAPI-encrypted connection. This is the default when PostgreSQL has been compiled with GSSAPI support.</p>
<p>require<br>only try a GSSAPI-encrypted connection</p>
<p>gssencmode is ignored for Unix domain socket communication. If PostgreSQL is compiled without GSSAPI support, using the require option will cause an error, while prefer will be accepted but libpq will not actually attempt a GSSAPI-encrypted connection.</p>
<p>sslmode<br>This option determines whether or with what priority a secure SSL TCP/IP connection will be negotiated with the server. There are six modes:</p>
<p>disable<br>only try a non-SSL connection</p>
<p>allow<br>first try a non-SSL connection; if that fails, try an SSL connection</p>
<p>prefer (default)<br>first try an SSL connection; if that fails, try a non-SSL connection</p>
<p>require<br>only try an SSL connection. If a root CA file is present, verify the certificate in the same way as if verify-ca was specified</p>
<p>verify-ca<br>only try an SSL connection, and verify that the server certificate is issued by a trusted certificate authority (CA)</p>
<p>verify-full<br>only try an SSL connection, verify that the server certificate is issued by a trusted CA and that the requested server host name matches that in the certificate</p>
<p>See Section 34.19 for a detailed description of how these options work.</p>
<p>sslmode is ignored for Unix domain socket communication. If PostgreSQL is compiled without SSL support, using options require, verify-ca, or verify-full will cause an error, while options allow and prefer will be accepted but libpq will not actually attempt an SSL connection.</p>
<p>Note that if GSSAPI encryption is possible, that will be used in preference to SSL encryption, regardless of the value of sslmode. To force use of SSL encryption in an environment that has working GSSAPI infrastructure (such as a Kerberos server), also set gssencmode to disable.</p>
<p>requiressl<br>This option is deprecated in favor of the sslmode setting.</p>
<p>If set to 1, an SSL connection to the server is required (this is equivalent to sslmode require). libpq will then refuse to connect if the server does not accept an SSL connection. If set to 0 (default), libpq will negotiate the connection type with the server (equivalent to sslmode prefer). This option is only available if PostgreSQL is compiled with SSL support.</p>
<p>sslcompression<br>If set to 1, data sent over SSL connections will be compressed. If set to 0, compression will be disabled. The default is 0. This parameter is ignored if a connection without SSL is made.</p>
<p>SSL compression is nowadays considered insecure and its use is no longer recommended. OpenSSL 1.1.0 disables compression by default, and many operating system distributions disable it in prior versions as well, so setting this parameter to on will not have any effect if the server does not accept compression. PostgreSQL 14 disables compression completely in the backend.</p>
<p>If security is not a primary concern, compression can improve throughput if the network is the bottleneck. Disabling compression can improve response time and throughput if CPU performance is the limiting factor.</p>
<p>sslcert<br>This parameter specifies the file name of the client SSL certificate, replacing the default ~/.postgresql/postgresql.crt. This parameter is ignored if an SSL connection is not made.</p>
<p>sslkey<br>This parameter specifies the location for the secret key used for the client certificate. It can either specify a file name that will be used instead of the default ~/.postgresql/postgresql.key, or it can specify a key obtained from an external “engine” (engines are OpenSSL loadable modules). An external engine specification should consist of a colon-separated engine name and an engine-specific key identifier. This parameter is ignored if an SSL connection is not made.</p>
<p>sslpassword<br>This parameter specifies the password for the secret key specified in sslkey, allowing client certificate private keys to be stored in encrypted form on disk even when interactive passphrase input is not practical.</p>
<p>Specifying this parameter with any non-empty value suppresses the Enter PEM pass phrase: prompt that OpenSSL will emit by default when an encrypted client certificate key is provided to libpq.</p>
<p>If the key is not encrypted this parameter is ignored. The parameter has no effect on keys specified by OpenSSL engines unless the engine uses the OpenSSL password callback mechanism for prompts.</p>
<p>There is no environment variable equivalent to this option, and no facility for looking it up in .pgpass. It can be used in a service file connection definition. Users with more sophisticated uses should consider using OpenSSL engines and tools like PKCS#11 or USB crypto offload devices.</p>
<p>sslrootcert<br>This parameter specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server’s certificate will be verified to be signed by one of these authorities. The default is ~/.postgresql/root.crt.</p>
<p>sslcrl<br>This parameter specifies the file name of the SSL server certificate revocation list (CRL). Certificates listed in this file, if it exists, will be rejected while attempting to authenticate the server’s certificate. If neither sslcrl nor sslcrldir is set, this setting is taken as ~/.postgresql/root.crl.</p>
<p>sslcrldir<br>This parameter specifies the directory name of the SSL server certificate revocation list (CRL). Certificates listed in the files in this directory, if it exists, will be rejected while attempting to authenticate the server’s certificate.</p>
<p>The directory needs to be prepared with the OpenSSL command openssl rehash or c_rehash. See its documentation for details.</p>
<p>Both sslcrl and sslcrldir can be specified together.</p>
<p>sslsni<br>If set to 1 (default), libpq sets the TLS extension “Server Name Indication” (SNI) on SSL-enabled connections. By setting this parameter to 0, this is turned off.</p>
<p>The Server Name Indication can be used by SSL-aware proxies to route connections without having to decrypt the SSL stream. (Note that this requires a proxy that is aware of the PostgreSQL protocol handshake, not just any SSL proxy.) However, SNI makes the destination host name appear in cleartext in the network traffic, so it might be undesirable in some cases.</p>
<p>requirepeer<br>This parameter specifies the operating-system user name of the server, for example requirepeer=postgres. When making a Unix-domain socket connection, if this parameter is set, the client checks at the beginning of the connection that the server process is running under the specified user name; if it is not, the connection is aborted with an error. This parameter can be used to provide server authentication similar to that available with SSL certificates on TCP/IP connections. (Note that if the Unix-domain socket is in /tmp or another publicly writable location, any user could start a server listening there. Use this parameter to ensure that you are connected to a server run by a trusted user.) This option is only supported on platforms for which the peer authentication method is implemented; see Section 21.9.</p>
<p>ssl_min_protocol_version<br>This parameter specifies the minimum SSL/TLS protocol version to allow for the connection. Valid values are TLSv1, TLSv1.1, TLSv1.2 and TLSv1.3. The supported protocols depend on the version of OpenSSL used, older versions not supporting the most modern protocol versions. If not specified, the default is TLSv1.2, which satisfies industry best practices as of this writing.</p>
<p>ssl_max_protocol_version<br>This parameter specifies the maximum SSL/TLS protocol version to allow for the connection. Valid values are TLSv1, TLSv1.1, TLSv1.2 and TLSv1.3. The supported protocols depend on the version of OpenSSL used, older versions not supporting the most modern protocol versions. If not set, this parameter is ignored and the connection will use the maximum bound defined by the backend, if set. Setting the maximum protocol version is mainly useful for testing or if some component has issues working with a newer protocol.</p>
<p>krbsrvname<br>Kerberos service name to use when authenticating with GSSAPI. This must match the service name specified in the server configuration for Kerberos authentication to succeed. (See also Section 21.6.) The default value is normally postgres, but that can be changed when building PostgreSQL via the –with-krb-srvnam option of configure. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (POSTGRES).</p>
<p>gsslib<br>GSS library to use for GSSAPI authentication. Currently this is disregarded except on Windows builds that include both GSSAPI and SSPI support. In that case, set this to gssapi to cause libpq to use the GSSAPI library for authentication instead of the default SSPI.</p>
<p>service<br>Service name to use for additional parameters. It specifies a service name in pg_service.conf that holds additional connection parameters. This allows applications to specify only a service name so connection parameters can be centrally maintained. See Section 34.17.</p>
<p>target_session_attrs<br>This option determines whether the session must have certain properties to be acceptable. It’s typically used in combination with multiple host names to select the first acceptable alternative among several hosts. There are six modes:</p>
<p>any (default)<br>any successful connection is acceptable</p>
<p>read-write<br>session must accept read-write transactions by default (that is, the server must not be in hot standby mode and the default_transaction_read_only parameter must be off)</p>
<p>read-only<br>session must not accept read-write transactions by default (the converse)</p>
<p>primary<br>server must not be in hot standby mode</p>
<p>standby<br>server must be in hot standby mode</p>
<p>prefer-standby<br>first try to find a standby server, but if none of the listed hosts is a standby server, try again in any mode</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL Service connection file</title>
    <url>/2023/02/26/PostgreSQL-Service-connection-file/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>The service connection file allows PostgreSQL connection parameters to be associated with a single service name. That service name can then be specified by a client and the associated settings will be used.</p>
<p>It’s called .pg_service.conf under *nix systems (GNU/Linux, macOS etc.) and pg_service.conf on Windows.</p>
<p>The service file can look like this:</p>
<pre><code>[water_service]
host=192.168.0.45
port=5433
dbname=gisdb
user=paul
password=paulspass

[wastewater_service]
host=dbserver.com
dbname=water
user=waterpass
</code></pre>
<p>*备注</p>
<p>There are two services in the above example: water_service and wastewater_service. You can use these to connect from QGIS, pgAdmin, etc. by specifying only the name of the service you want to connect to (without the enclosing brackets). If you want to use the service with psql you need to do something like export PGSERVICE=water_service before doing your psql commands.</p>
<p>You can find all the PostgreSQL parameters  [here][<a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS]">https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS]</a> </p>
<p>*备注</p>
<p>If you don’t want to save the passwords in the service file you can use the [.pg_pass][<a href="https://www.postgresql.org/docs/current/libpq-pgpass.html]">https://www.postgresql.org/docs/current/libpq-pgpass.html]</a> option.</p>
<p>On *nix operating systems (GNU/Linux, macOS etc.) you can save the .pg_service.conf file in the user’s home directory and PostgreSQL clients will automatically be aware of it. For example, if the logged user is web, .pg_service.conf should be saved in the /home/web/ directory in order to directly work (without specifying any other environment variables).</p>
<p>You can specify the location of the service file by creating a PGSERVICEFILE environment variable (e.g. run the export PGSERVICEFILE=/home/web/.pg_service.conf command under your *nix OS to temporarily set the PGSERVICEFILE variable)</p>
<p>You can also make the service file available system-wide (all users) either by placing the .pg_service.conf file in pg_config –sysconfdir or by adding the PGSYSCONFDIR environment variable to specify the directory containing the service file. If service definitions with the same name exist in the user and the system file, the user file takes precedence.</p>
<p>*警告</p>
<p>There are some caveats under Windows:</p>
<p>The service file should be saved as pg_service.conf and not as .pg_service.conf.</p>
<p>The service file should be saved in Unix format in order to work. One way to do it is to open it with Notepad++ and Edit ► EOL Conversion ► UNIX Format ► File save.</p>
<p>You can add environmental variables in various ways; a tested one, known to work reliably, is Control Panel ► System and Security ► System ► Advanced system settings ► Environment Variables adding PGSERVICEFILE with the path - e.g. C:\Users\John\pg_service.conf</p>
<p>After adding an environment variable you may also need to restart the computer.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows上使用pg_service.conf配置服务连接PostgreSQL数据库</title>
    <url>/2023/02/25/%E5%9C%A8windows%E4%B8%8A%E4%BD%BF%E7%94%A8pg-service-conf%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E8%BF%9E%E6%8E%A5PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在windows上使用PostgreSQL的连接服务文件(Connection Service File)连接到数据库中。</p>
<p>参考：<a href="https://www.postgresql.org/docs/11/libpq-pgservice.html">https://www.postgresql.org/docs/11/libpq-pgservice.html</a></p>
<p>作者注：<br>PostgreSQL的连接服务文件(Connection Service File)存放了ip地址，数据库名，端口号等信息，作用类似于Oracle database的tnsnames.ora文件。</p>
<pre><code>C:\&gt;set lc_messages=C
C:\&gt;d:\postgresql\pg11.5\bin\pg_config --sysconfdir
d:/postgresql/pg11.5/etc
 
C:\&gt;d:\postgresql\pg11.5\bin\pg_config
BINDIR = d:/postgresql/pg11.5/bin
DOCDIR = d:/postgresql/pg11.5/doc
HTMLDIR = d:/postgresql/pg11.5/doc
INCLUDEDIR = d:/postgresql/pg11.5/include
PKGINCLUDEDIR = d:/postgresql/pg11.5/include
INCLUDEDIR-SERVER = d:/postgresql/pg11.5/include/server
LIBDIR = d:/postgresql/pg11.5/lib
PKGLIBDIR = d:/postgresql/pg11.5/lib
LOCALEDIR = d:/postgresql/pg11.5/share/locale
MANDIR = d:/postgresql/pg11.5/man
SHAREDIR = d:/postgresql/pg11.5/share
SYSCONFDIR = d:/postgresql/pg11.5/etc
PGXS = d:/postgresql/pg11.5/lib/pgxs/src/makefiles/pgxs.mk
CONFIGURE = --enable-thread-safety --enable-nls --with-ldap --with-openssl --with-ossp-uuid --with-libxml --with-libxslt --with-icu --with-tcl --with-perl --with-python
CC = not recorded
CPPFLAGS = not recorded
CFLAGS = not recorded
CFLAGS_SL = not recorded
LDFLAGS = not recorded
LDFLAGS_EX = not recorded
LDFLAGS_SL = not recorded
LIBS = not recorded
VERSION = PostgreSQL 11.5
</code></pre>
<p>注意上面的输出：SYSCONFDIR = d:/postgresql/pg11.5/etc</p>
<p>在SYSCONFDIR = d:/postgresql/pg11.5/etc下建立名为pg_service.conf的文件（该文件的模板存放在SHAREDIR = d:/postgresql/pg11.5/share 目录中，可copy过来）</p>
<p>pg_service.conf的文件内容如下：</p>
<pre><code>#
#    Connection configuration file
#
# A service is a set of named connection parameters.  You may specify
# multiple services in this file.  Each starts with a service name in
# brackets.  Subsequent lines have connection configuration parameters of
# the pattern &quot;param=value&quot; or LDAP URLs starting with &quot;ldap://&quot;
# to look up such parameters.  A sample configuration for postgres is
# included in this file.  Lines beginning with &#39;#&#39; are comments.
#
# Copy this to your sysconf directory (typically /usr/local/pgsql/etc) and
# rename it pg_service.conf.
#
#
#[postgres service name]
[pg12bt2-cluster]  ---&gt;&gt;&gt;这个是服务名，请自行定义，在psql连接时使用。
host=192.168.80.187
dbname=postgres
user=pg12bt2
port=7432
</code></pre>
<p>下面做登录测试：</p>
<pre><code>C:\&gt;d:\postgresql\pg11.5\bin\psql service=pg12bt2-cluster
用户 pg12bt2 的口令：
psql (11.5, 服务器 12beta2)
警告：psql 主版本11,服务器主版本为12.
     一些psql功能可能无法正常使用.
输入 &quot;help&quot; 来获取帮助信息.

postgres=# \q
</code></pre>
<p>注意：<br>1.PostgreSQL的连接服务文件(Connection Service File)中的关键字清单见：<br><a href="https://www.postgresql.org/docs/11/libpq-connect.html#LIBPQ-PARAMKEYWORDS">https://www.postgresql.org/docs/11/libpq-connect.html#LIBPQ-PARAMKEYWORDS</a><br>2.psql登录方式不止“psql service=pg12bt2-cluster”，<br>其他的登录方式请见：<br><a href="https://www.postgresql.org/docs/11/libpq-pgservice.html">https://www.postgresql.org/docs/11/libpq-pgservice.html</a><br><a href="https://www.cybertec-postgresql.com/en/pg_service-conf-the-forgotten-config-file/">https://www.cybertec-postgresql.com/en/pg_service-conf-the-forgotten-config-file/</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「msdnchina」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/msdnchina/article/details/100933935">https://blog.csdn.net/msdnchina/article/details/100933935</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>the ability to create a file called pg_service.conf</title>
    <url>/2023/02/24/the-ability-to-create-a-file-called-pg-service-conf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Once in a while I am rediscovering features in PostgreSQL, which have been there for many many years but which are so rarely used that people tend not to talk about them. One of those (in my experience) rarely used features is the ability to create a file called pg_service.conf.</p>
<p>The basic idea is to configure services in a config file and address them without having to worry about host, port, user and so on.</p>
<p>A simple pg_service.conf file</p>
<p>How does that work? Well, here is an example:</p>
<pre><code>iMac:~ hs$ cat .pg_service.conf
 
# a sample service
[hansservice]
host=localhost
port=5432
dbname=test
user=hs
password=abc
 
[paulservice]
host=192.168.0.45
port=5432
dbname=xyz
user=paul
password=cde
</code></pre>
<p>In this case two services have been defined. Note that PostgreSQL uses a standard .ini-file format. Inside a section you can use all connection parameters available in PostgreSQL (a full list can be found here: <a href="http://www.postgresql.org/docs/9.5/static/libpq-connect.html#LIBPQ-PARAMKEYWORDS">http://www.postgresql.org/docs/9.5/static/libpq-connect.html#LIBPQ-PARAMKEYWORDS</a>).</p>
<p>The first important thing is that a service can be referenced by name. The way to do that is to set an environment variable:</p>
<pre><code>iMac:~ hs$ export PGSERVICE=hansservice
</code></pre>
<p>A connection can now be established without passing parameters to psql:</p>
<pre><code>iMac:~ hs$ psql
psql (9.5.0)
Type &quot;help&quot; for help.
 
test=#
</code></pre>
<p>Actually a pg_service.conf file is a pretty convenient thing to have. Maybe I should reconsider my behavior and use this thing more often.</p>
<p>this paper from <a href="https://www.cybertec-postgresql.com/en/pg_service-conf-the-forgotten-config-file/">https://www.cybertec-postgresql.com/en/pg_service-conf-the-forgotten-config-file/</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS服务器从Postgresql数据库读取项目</title>
    <url>/2023/02/23/QGIS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8EPostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%8F%96%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你可以使用存储在数据库中的项目文件（在我的情况下是postgres）。我是怎么做到的。</p>
<p>我在包含数据库连接凭据的主目录中创建了一个pg_service文件，让我们仅指定服务名称即可连接到数据库，例如，使用psql可以psql service=myservicename 在nginx上连接并设置fastcgi参数 fastcgi_param PGSERVICEFILE /home/qgis/.pg_service.conf;</p>
<p>我从qgis桌面连接到postgres数据库，并指定了我在服务文件中设置的服务名称。</p>
<p>已将项目文件保存在数据库中。通过这样做，该项目文件将包含通过服务名称进行的数据库连接。</p>
<p>为项目名称设置fastcgi_param<br>location / {<br>    add_header ‘Access-Control-Allow-Origin’ ‘*’;<br>    add_header ‘Access-Control-Allow-Methods’ ‘GET, POST, OPTIONS’;<br>    add_header ‘Access-Control-Allow-Headers’ ‘DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range’;<br>    add_header ‘Access-Control-Expose-Headers’ ‘Content-Length,Content-Range’;<br>    gzip off;<br>    include fastcgi_params;<br>    fastcgi_param QGIS_PROJECT_FILE postgresql:///?service=myservicename&amp;schema=public&amp;project=testproject;<br>    fastcgi_pass unix:/var/run/fcgiwrap.socket;;<br>    }</p>
<p>你可以通过url在Web应用程序的前端中设置默认的qgis项目，这并不困难。</p>
<hr>
<p>you can use project files stored in a database (in my case it is postgres). How I did it.</p>
<p>I created a pg_service file on a home directory which contains database connection credentials and let us to connect to database just specifying service name, for example using psql you can connect psql service=myservicename and set fastcgi params on nginx fastcgi_param  PGSERVICEFILE /home/qgis/.pg_service.conf;</p>
<p>I connected from qgis desktop to postgres database specifying the service name which I set in service file.</p>
<p>Saved project file in database. By doing like this project file will contain database connection via service name.</p>
<p>Set fastcgi_param for project name<br>location / {<br>    add_header ‘Access-Control-Allow-Origin’ ‘*’;<br>    add_header ‘Access-Control-Allow-Methods’ ‘GET, POST, OPTIONS’;<br>    add_header ‘Access-Control-Allow-Headers’ ‘DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range’;<br>    add_header ‘Access-Control-Expose-Headers’ ‘Content-Length,Content-Range’;<br>    gzip           off;<br>    include        fastcgi_params;<br>    fastcgi_param  QGIS_PROJECT_FILE postgresql:///?service=myservicename&amp;schema=public&amp;project=testproject;<br>    fastcgi_pass   unix:/var/run/fcgiwrap.socket;;<br>    }<br>Default qgis project you can set in frontend of your web application via url, that is not difficult.</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL-psql命令详解</title>
    <url>/2023/02/22/PostgreSQL-psql%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="psql命令"><a href="#psql命令" class="headerlink" title="psql命令"></a>psql命令</h1><p>psql是PostgreSQL的一个命令行交互式客户端工具，它具有非常丰富的功能，类似于Oracle的命令行工具sqlplus。</p>
<h2 id="元命令"><a href="#元命令" class="headerlink" title="元命令"></a>元命令</h2><ul>
<li>连接数据库</li>
</ul>
<p>连接指定服务器上的数据库</p>
<pre><code>psql -h 192.168.1.210 -p 5432 -U hr -d hr_db

-h后面的IP地址（192.168.1.210）是数据库所在的IP地址
-p后面的端口（5432）是数据库的监听端口
-U后面的参数（hr）是创建的用户名
-d后面的参数（hr_db）是创建的数据库名称
</code></pre>
<ul>
<li><p>断开psql客户端</p>
<p>  按Ctrl+D组合键</p>
<p>  \q</p>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="“-c”命令"><a href="#“-c”命令" class="headerlink" title="“\c”命令"></a>“\c”命令</h3><ul>
<li><p>查看所有数据库</p>
<p>  \l</p>
</li>
<li><p>切换数据库</p>
<p>  \c gis</p>
</li>
</ul>
<h3 id="“-d”命令"><a href="#“-d”命令" class="headerlink" title="“\d”命令"></a>“\d”命令</h3><ul>
<li><p>查看当前数据库中所有表、视图、序列</p>
<p>  \d</p>
</li>
<li><p>在”\d”命令后面接表名，则可以查看该表的表定义</p>
<p>  \d pgbench_accounts</p>
</li>
</ul>
<h3 id="“-db”命令"><a href="#“-db”命令" class="headerlink" title="“\db”命令"></a>“\db”命令</h3><ul>
<li><p>查看表空间的信息</p>
<p>  \db</p>
</li>
</ul>
<h3 id="“-dn”命令"><a href="#“-dn”命令" class="headerlink" title="“\dn”命令"></a>“\dn”命令</h3><ul>
<li><p>可以查看所有的模式信息</p>
<p>  \dn</p>
</li>
</ul>
<h3 id="“-du”命令或”-dg”命令"><a href="#“-du”命令或”-dg”命令" class="headerlink" title="“\du”命令或”\dg”命令"></a>“\du”命令或”\dg”命令</h3><ul>
<li><p>可以查看数据库中的所有角色或用户</p>
<p>  \du</p>
</li>
</ul>
<h3 id="“-x”命令"><a href="#“-x”命令" class="headerlink" title="“\x”命令"></a>“\x”命令</h3><ul>
<li><p>可以设置查询结果的输出模式</p>
<p>  \x</p>
</li>
</ul>
<h3 id="“-”命令"><a href="#“-”命令" class="headerlink" title="“?”命令"></a>“?”命令</h3><ul>
<li><p>可以查询PostgreSQL支持的所有命令</p>
<p>  ?</p>
</li>
</ul>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><ul>
<li><p>查看数据库</p>
<p>  \l </p>
</li>
<li><p>查看表定义</p>
<p>  \d tablename</p>
</li>
<li><p>查看表大小</p>
<p>  \dt+ tablename</p>
</li>
<li><p>查看索引大小</p>
<p>  \di+ tablename</p>
</li>
<li><p>查看函数代码 \sf random_range</p>
<p>  \sf functionName<br>  \sf functionName(integer,integer)</p>
</li>
<li><p>查看SQL命令语法</p>
<p>  \h<br>  \h create database</p>
</li>
<li><p>显示SQL语句执行时间，（再执行一次关闭）</p>
<p>  \timing</p>
</li>
</ul>
<h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><ul>
<li><p>获取元命令对应的SQL代码<br>psql执行元命令，实质上是转换成对应的SQL语句来执行的。如果要获取这些SQL语句，则需要在psql连接数据库时增加“-E”选项</p>
<p>  psql -h 127.0.0.1 -p 5432 -U postgres -d postgres -E </p>
</li>
<li><p>使用上下键翻动历史命令<br>psql支持使用上下键获取执行过的历史命令</p>
</li>
<li><p>自动补全功能<br>psql的自动补全功能使用起来非常方便。在执行语句时，不需要完全输入数据对象的名称，使用Tab键可以自动补全</p>
</li>
<li><p>显示SQL语句执行时间<br>使用“\timing”命令，可以打开显示SQL语句执行时间的开关。再使用一次“\timing”命令，则关掉该开关</p>
</li>
<li><p>日常维护语句<br>查询活动会话(active_session)</p>
<p>  select pid,usename,datname,query,client_addr from pg_stat_activity where pid &lt;&gt; pg_backend_pid() and state=’active’ order by query;</p>
</li>
<li><p>查询等待事件(wait_event)</p>
<p>  select wait_event_type,wait_event,state,query,a.* from pg_stat_activity a where query like ‘insert%’;</p>
</li>
</ul>
<p>————————————————<br>版权声明：本文为CSDN博主「孙霸天」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_36213352/article/details/125145033">https://blog.csdn.net/qq_36213352/article/details/125145033</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL的所有环境变量</title>
    <url>/2023/02/21/PostgreSQL%E7%9A%84%E6%89%80%E6%9C%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下列环境变量能被用于选择默认的连接参数值，如果调用代码没有直接指定值，它们将被用于PQconnectdb, PQsetdbLogin 和 PQsetdb。<br>例如，这些有助于防止数据库连接信息被硬编码到简单的客户端应用中。<br>PGHOST的行为和host连接参数相同。<br>PGHOSTADDR的行为和hostaddr连接参数相同。可以设置它来替代或者作为PGHOST的补充来防止 DNS 查找负担。<br>PGPORT的行为和port连接参数相同。<br>PGDATABASE的行为和dbname连接参数相同。<br>PGUSER的行为和user连接参数相同。 PGPASSWORD的行为和password连接参数相同。出于安全原因，我们不推荐使用这个环境变量，因为某些操作系统允许非根用户通过ps看到进程的环境变量。可以考虑使用一个口令文件（见第 33.15 节）。<br>PGPASSFILE的行为和passfile连接参数相同。<br>PGCHANNELBINDING 的行为和 channel_binding 连接参数相同.<br>PGSERVICE的行为和service连接参数相同。<br>PGSERVICEFILE指定针对每个用户的连接服务文件名。如果没有设置，默认为~/.pg_service.conf（见第 33.16 节）。<br>PGOPTIONS的行为和options连接参数相同。<br>PGAPPNAME的行为和application_name连接参数相同。<br>PGSSLMODE的行为和sslmode连接参数相同。 PGREQUIRESSL的行为和requiressl连接参数相同。为了支持PGSSLMODE变量，这个环境变量已被废弃。同时设置两个变量会抑制这一个的效果。 PGSSLCOMPRESSION的行为和sslcompression连接参数相同。<br>PGSSLCERT的行为和sslcert连接参数相同。<br>PGSSLKEY的行为和sslkey连接参数相同。<br>PGSSLROOTCERT的行为和sslrootcert连接参数相同。<br>PGSSLCRL的行为和sslcrl连接参数相同。<br>PGREQUIREPEER的行为和requirepeer连接参数相同。<br>PGSSLMINPROTOCOLVERSION 的行为和 ssl_min_protocol_version 连接参数相同。<br>PGSSLMAXPROTOCOLVERSION 行为和 ssl_min_protocol_version 连接参数相同。<br>PGGSSENCMODE 的行为和 gssencmode连接参数相同。<br>PGKRBSRVNAME的行为和krbsrvname连接参数相同。<br>PGGSSLIB的行为和gsslib连接参数相同。<br>PGCONNECT_TIMEOUT的行为和connect_timeout连接参数相同。<br>PGCLIENTENCODING的行为和client_encoding连接参数相同。<br>PGTARGETSESSIONATTRS的行为和target_session_attrs连接参数相同。 </p>
<p>下面的环境变量可用来为每一个PostgreSQL会话指定默认行为（为每一个用户或每一个数据库设置默认行为的方法还可见ALTER ROLE和ALTER DATABASE命令）。<br>PGDATESTYLE设置日期/时间表示的默认风格（等同于SET datestyle TO …）。 PGTZ设置默认的时区（等同于SET timezone TO …）。<br>PGGEQO为遗传查询优化器设置默认模式（等同于SET geqo TO …）。 这些环境变量的正确值可参考SQL 命令 SET。 </p>
<p>下面的环境变量决定libpq的内部行为，它们会覆盖编译在程序中的默认值。 PGSYSCONFDIR设置包含pg_service.conf文件以及未来版本中可能出现的其他系统范围配置文件的目录。 PGLOCALEDIR设置包含用于消息本地化的locale文件的目录。</p>
<p>————————————————<br>版权声明：本文为「小麦苗DBA宝典(<a href="http://www.xmmup.com)」的原创文章,遵循cc/">www.xmmup.com)」的原创文章，遵循CC</a> 4.0 BY -SA版权协议，转载请附上原文出处链接及本声明。<br>转载请保留原文链接: <a href="https://www.xmmup.com/pgdesuoyouhuanjingbianliang.html">https://www.xmmup.com/pgdesuoyouhuanjingbianliang.html</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt播放视频报错</title>
    <url>/2023/02/20/Qt%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先，对于这个问题，编译也能通过，但是运行就会出错：</p>
<p>DirectShowPlayerService::doRender: Unresolved error code 0x80040266</p>
<p>原因：Qt 中的多媒体播放，底层是使用 DirectShowPlayerService，所以安装一个 DirectShow 解码器，例如 LAV Filters，就可以解决运行出错问题。</p>
<p>下载并安装 LAVFilters：<a href="https://github.com/Nevcairiel/LAVFilters/releases">https://github.com/Nevcairiel/LAVFilters/releases</a></p>
<p>installer 方式直接按步骤安装<br>压缩包方式解压右键以管理员运行 install_video.bat 文件<br>最后，重启电脑<br>————————————————<br>版权声明：本文为CSDN博主「tianyvHon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_44916154/article/details/121755328">https://blog.csdn.net/weixin_44916154/article/details/121755328</a></p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>依赖配置</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL数据库免密登录配置</title>
    <url>/2023/02/19/PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PG数据库在登录的时候，需要显示输入密码，因此在很多维护操作中都不方便，比如：定时的VACUUM脚本、定时备份脚本等。PG不能像MySQL那样可以在命令中直接输入密码。</p>
<p>本文梳理了以下几种PG配置免密的方法。</p>
<h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><ul>
<li>方法一：设置pg_hab.conf 认证方式为trust</li>
</ul>
<p>示例：</p>
<pre><code>#Type database user address method
host all postgres 127.0.0.1/32 trust
</code></pre>
<p>该方式最不安全，导致通过指定IP连接数据库的连接都可以任意登录数据，毫无安全保障。禁止在生产环境使用。</p>
<ul>
<li>方法二：设置PG环境变量PGPASSWORD</li>
</ul>
<p>PGPASSWORD是PostgreSQL系统环境变量，在客户端设置后再远程连接数据库时，将优先使用这个密码。</p>
<p>示例：</p>
<pre><code>[postgres@PG-1 ~]$ export PGPASSWORD=root
[postgres@PG-1 ~]$ psql -U postgres -h 127.0.0.1 -p 5432
Timing is on.
Border style is 2.
Null display is &quot;NULL&quot;.
psql (13.2)
Type &quot;help&quot; for help.
</code></pre>
<p>此时数据库登录时，不在提示输入用户密码</p>
<ul>
<li>方法三：设置环境变量PGSERVICE</li>
</ul>
<p>pg_service.conf 通过定义服务文件的方式，可以对多个数据库进行免密登录。</p>
<p>示例：</p>
<pre><code>vi /home/postgres/.pg_service.conf
[backup]
hostaddr=127.0.0.1
port=5432
user=postgres
dbname=postgres
password=root
connect_timeout=10
[postgres@PG-1 ~]$ export PGSERVICE=backup
[postgres@PG-1 ~]$ psql -h 127.0.0.1 -p 5432 -U postgres
Timing is on.
Border style is 2.
Null display is &quot;NULL&quot;.
psql (13.2)
Type &quot;help&quot; for help.
</code></pre>
<p>定义pg_service.conf文件，该文件可以包含多个模块，每个模块代表一个连接。</p>
<ul>
<li>方法四：设置.pgpass文件</li>
</ul>
<p>该文件默认在/home/postgres/，且该文件的权限要为600，如果文件权限不对，则在登录会有相应的告警输出，并要求输入用户密码。</p>
<pre><code>WARNING: password file &quot;/home/postgres/.pgpass&quot; has group or world access; permissions should be u=rw (0600) or less
Password for user postgres:
</code></pre>
<p>内容格式：</p>
<pre><code>host:port:dbname:username:password
</code></pre>
<p>示例：</p>
<pre><code>[postgres@PG-1 ~]$ cat .pgpass
127.0.0.1:5432:postgres:postgres:root
localhost:5432:postgres:postgres:root
</code></pre>
<p>文件权限：</p>
<pre><code>[postgres@PG-1 ~]$ ll -h .pgpass
-rw------- 1 postgres postgres 76 2月 24 19:26 .pgpass
</code></pre>
<p>登录：</p>
<pre><code>[postgres@PG-1 ~]$ psql -U postgres -h 127.0.0.1 -p 5432
Timing is on.
Border style is 2.
Null display is &quot;NULL&quot;.
psql (13.2)
Type &quot;help&quot; for help.
</code></pre>
<p>以上的几种免密方式，在使用pg_basebackup进行备份时都可适用。以下是相关验证：</p>
<h1 id="相关验证"><a href="#相关验证" class="headerlink" title="相关验证"></a>相关验证</h1><ul>
<li><ol>
<li>使用PGSERVICE环境变量</li>
</ol>
</li>
</ul>
<p>示例：</p>
<pre><code>export PGSERVICE=backup
pg_basebackup -D /data/aa -Fp -X stream -R -P -c fast
</code></pre>
<ul>
<li><ol start="2">
<li>使用PGPASSWORD环境变量</li>
</ol>
</li>
</ul>
<p>示例：</p>
<pre><code>export PGPASSWORD=password
pg_basebackup -D /data/bb -Fp -X stream -R -P -c fast -h 127.0.0.1 -p 5432 -U postgres
</code></pre>
<ul>
<li><ol start="3">
<li>使用.pgpass方式</li>
</ol>
</li>
</ul>
<p>示例：</p>
<pre><code>vi /home/postgres/.pgpass
127.0.0.1:5432:postgres:postgres:root
chmod 600 .pgpass
pg_basebackup -D /data/bb -Fp -X stream -R -P -c fast -h 127.0.0.1 -p 5432 -U postgres
</code></pre>
<ul>
<li><ol start="4">
<li>pg_basebackup备份使用-d参数，在连接字符串中配置连接信息</li>
</ol>
</li>
</ul>
<p>示例：</p>
<pre><code>pg_basebackup   -D /data/pgdata/ -F p -R -X stream -c fast  -U replic -d host=192.168.28.169 port=5432 password=replic dbname=postgres
</code></pre>
<p>转载自<a href="https://www.ucloud.cn/yun/129860.html">https://www.ucloud.cn/yun/129860.html</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Notepad++正则表达式</title>
    <url>/2023/02/18/Notepad-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>则表达式是一个查询的字符串，它包含一般的字符和一些特殊的字符，特殊字符可以扩展查找字符串的能力，正则表达式在查找和替换字符串的作用不可忽视，它 能很好提高工作效率。</p>
<p>EditPlus的查找，替换，文件中查找支持以下的正则表达式：</p>
<p>表达式 说明<br>/t 制表符.<br>/n 新行.<br>. 匹配任意字符.<br>| 匹配表达式左边和右边的字符. 例如, “ab|bc” 匹配 “ab” 或者 “bc”.<br>[] 匹配列表之中的任何单个字符. 例如, “[ab]” 匹配 “a” 或者 “b”. “[0-9]” 匹配任意数字.<br>[^] 匹配列表之外的任何单个字符. 例如, “[^ab]” 匹配 “a” 和 “b” 以外的字符. “[^0-9]” 匹配任意非数字字符.</p>
<ul>
<li>其左边的字符被匹配任意次(0次，或者多次). 例如 “be*” 匹配 “b”, “be” 或者 “bee”.</li>
</ul>
<ul>
<li>其左边的字符被匹配至少一次(1次，或者多次). 例如 “be+” 匹配 “be” 或者 “bee” 但是不匹配 “b”.<br>? 其左边的字符被匹配0次或者1次. 例如 “be?” 匹配 “b” 或者 “be” 但是不匹配 “bee”.<br>^ 其右边的表达式被匹配在一行的开始. 例如 “^A” 仅仅匹配以 “A” 开头的行.<br>$ 其左边的表达式被匹配在一行的结尾. 例如 “e$” 仅仅匹配以 “e” 结尾的行.<br>() 影响表达式匹配的顺序，并且用作表达式的分组标记.<br>/ 转义字符. 如果你要使用 “/“ 本身, 则应该使用 “//“.</li>
</ul>
<p>例子：</p>
<p>原始串<br>str[1]abc[991];<br>str[2]abc[992];<br>str[11]abc[993];<br>str[22]abc[994];<br>str[111]abc[995];<br>str[222]abc[996];<br>str[1111]abc[997];<br>str[2222]abc[999];</p>
<p>目标串：<br>abc[1];<br>abc[2];<br>abc[11];<br>abc[22];<br>abc[111];<br>abc[222];<br>abc[1111];<br>abc[2222];</p>
<p>处理：<br>查找串：str/[([0-9]+)/]abc/[[0-9]+/]<br>替换串：abc[/1]</p>
<p>一、包含“hello word”的行</p>
<p>^.<em>hello word.</em>$</p>
<p>二、以“hello word”开始的行</p>
<p>^hello word.*$</p>
<p>三、以“hello word”结尾的行</p>
<p>.*hello word$</p>
<p>查找目标\n([a-zA-Z0-9])</p>
<p>或者\r([a-zA-Z0-9])</p>
<p>替换目标$1(http前面的换行变成 ‘,’ ,然后再加其他的)</p>
<p>【1】正则表达式应用——替换指定内容到行尾<br>原始文本如下面两行<br>abc aaaaa<br>123 abc 444</p>
<p>希望每次遇到“abc”，则替换“abc”以及其后到行尾的内容为“abc efg”<br>即上面的文本最终替换为：<br>abc efg<br>123 abc efg</p>
<p>解决：<br>① 在替换对话框，查找内容里输入“abc.<em>”<br>② 同时勾选“正则表达式”复选框，然后点击“全部替换”按钮<br>其中，符号的含义如下：<br>“.” ＝匹配任意字符<br>“</em>” ＝匹配0次或更多</p>
<p>注意：其实就是正则表达式替换，这里只是把一些曾经提出的问题加以整理，单纯从正则表达式本身来说，就可以引申出成千上万种特例。</p>
<p>【2】正则表达式应用——数字替换<br>希望把<br>asdadas123asdasdas456asdasdasd789asdasd<br>替换为:<br>asdadas[123]asdasdas[456]asdasdasd[789]asdasd</p>
<p>在替换对话框里面，勾选“正则表达式”复选框；<br>在查找内容里面输入“[0-9][0-9][0-9]”，不含引号<br>“替换为:”里面输入“[/0/1/2]”，不含引号<br>范围为你所操作的范围，然后选择替换即可。</p>
<p>实际上这也是正则表达式的使用特例，“[0-9]”表示匹配0～9之间的任何特例，同样“[a-z]”就表示匹配a～z之间的任何特例<br>上面重复使用了“[0-9]”，表示连续出现的三个数字<br>“/0”代表第一个“[0-9]”对应的原型，“/1”代表第二个“[0-9]”对应的原型，依此类推<br>“[”、“]”为单纯的字符，表示添加“[”或“]”，如果输入“其它/0/1/2其它”，则替换结果为：</p>
<p>asdadas其它123其它asdasdas其它456其它asdasdasd其它789其它asdasd</p>
<p>功能增强（by jiuk2k）：<br>如果将查找内容“[0-9][0-9][0-9]”改为“[0-9]*[0-9]”，对应1 或 123 或 12345 或 …<br>大家根据需要定制</p>
<p>相关内容还有很多，可以自己参考正则表达式的语法仔细研究一下</p>
<p>【3】正则表达式应用——删除每一行行尾的指定字符<br>因为这几个字符在行中也是出现的,所以肯定不能用简单的替换实现<br>比如<br>12345 1265345<br>2345<br>需要删除每行末尾的“345”<br>这个也算正则表达式的用法，其实仔细看正则表达式应该比较简单，不过既然有这个问题提出，说明对正则表达式还得有个认识过程，解决方法如下<br>解决：<br>在替换对话框中，启用“正则表达式”复选框<br>在查找内容里面输入“345$”<br>这里“$”表示从行尾匹配</p>
<p>如果从行首匹配，可以用“^”来实现，不过 EditPlus 有另一个功能可以很简单的删除行首的字符串<br>a. 选择要操作的行<br>b. 编辑－格式－删除行注释<br>c. 在弹出对话框里面输入要清除的行首字符，确定</p>
<p>【4】正则表达式应用——替换带有半角括号的多行<br>几百个网页中都有下面一段代码：<br>/n<br>在替换对话框启用“正则表达式”选项，这时就可以完成替换了</p>
<p>【5】正则表达式应用——删除空行<br>启动EditPlus，打开待处理的文本类型文件。<br>①、选择“查找”菜单的“替换”命令，弹出文本替换对话框。选中“正则表达式”复选框，表明我们要在查找、替换中使用正则表达式。然后，选中“替换范围” 中的“当前文件”，表明对当前文件操作。<br>②、单击“查找内容”组合框右侧的按钮，出现下拉菜单。<br>③、下面的操作添加正则表达式，该表达式代表待查找的空行。（技巧提示：空行仅包括空格符、制表符、回车符，且必须以这三个符号之一作为一行的开头，并且 以回车符结尾，查找空行的关键是构造代表空行的正则表达式）。<br>直接在”查找”中输入正则表达式“^[ /t]<em>/n”，注意/t前有空格符。<br>（1）选择“从行首开始匹配”，“查找内容”组合框中出现字符“^”，表示待查找字符串必须出现在文本中一行的行首。<br>（2）选择“字符在范围中”，那么在“^”后会增加一对括号“[]”，当前插入点在括号中。括号在正则表达式中表示，文本中的字符匹配括号中任意一个字符 即符合查找条件。<br>（3）按一下空格键，添加空格符。空格符是空行的一个组成成分。<br>（4）选择“制表符”，添加代表制表符的“/t”。<br>（5）移动光标，将当前插入点移到“]”之后，然后选择“匹配 0 次或更多”，该操作会添加星号字符“</em>”。星号表示，其前面的括号“[]”内的空格符或制表符，在一行中出现0个或多个。<br>（6）选择“换行符”，插入“/n”，表示回车符。<br>④、“替换为”组合框保持空，表示删除查找到的内容。单击“替换”按钮逐个行删除空行，或单击“全部替换”按钮删除全部空行（注意：EditPlus有时 存在“全部替换”不能一次性完全删除空行的问题，可能是程序BUG，需要多按几次按钮）。</p>
<p>1.在汉化的时候，是否经常碰到这样的语句需要翻译：</p>
<p>Code:<br>“Error adding the post!”;<br>“Error adding the comment!”;<br>“Error adding the user!”;</p>
<p>如果有很多类似的文件一个一个翻译显然很累而且感觉很无聊。</p>
<p>其实可以这样处理，在Editplus里面用 替换 功能，在替换对话框选中“正则表达式”复选框：<br>查找原文件：</p>
<p>Code:<br>“Error adding ([^!|”|;]*)</p>
<p>替换成：</p>
<p>Code:<br>“在增加/1时发生错误</p>
<p>这样替换之后发生了什么？结果是：</p>
<p>Code:<br>“在增加the post时发生错误!”;<br>“在增加the comment时发生错误!”;<br>“在增加the user时发生错误!”;</p>
<p>ok，接下来你会怎么做？当然再替换一次把the post、the comment、the user替换成你要翻译的词。得到最后的结果：</p>
<p>Code:<br>“在增加帖子时发生错误!”;<br>“在增加评论时发生错误!”;<br>“在增加用户时发生错误!”;</p>
<p>2.要提取的单词在中间，比如：</p>
<p>Code:<br>can not be deleted because<br>can not be added because<br>can not be updating because</p>
<p>可以用这种方式：<br>在Editplus里面用 替换 功能，在替换对话框选中“正则表达式”复选框：<br>查找原文件：</p>
<p>Code:<br>can not be ([^ ]*) because</p>
<p>替换成：</p>
<p>Code:<br>无法被/1因为</p>
<p>这样替换之后发生了什么？结果是：</p>
<p>Code:<br>无法被deleted因为<br>无法被added因为<br>无法被updating因为</p>
<p>其余步骤如上。</p>
<p>在汉化量很大而且句式比较单调的情况下对效率的提高很明显！</p>
<p>解释一下：([^!|”|;]*) 的意思是 不等于 ! 和 ” 和 ; 中的任何一个，意思就是这3个字符之外的所有字符将被选中（替换区域）；<br>/1 即被选中的替换区域所在的新位置（复制到这个新位置）。</p>
<p>3.经常手工清理一行一行地删除文本文件里面的空白行，其实可以交给Editplus更好的完成，在Editplus里面用替换功能，在替换对话框选中 “正则表达式”复选框：<br>查找原文件：</p>
<p>Code:<br>^[ /t]*/n</p>
<p>替换部分为空就可以删除空白行了，执行一下看看：）</p>
<p>abandon[2’’b9nd2n]v.抛弃，放弃<br>abandonment[2’’b9nd2nm2nt]n.放弃<br>abbreviation[2bri:vi’’ei62n]n.缩写<br>abeyance[2’’bei2ns]n.缓办，中止<br>abide[2’’baid]v.遵守<br>ability[2’’biliti]n.能力<br>able[‘’eibl]adj.有能力的，能干的<br>abnormal[9b’’n0:m2l]adj.反常的，变态的<br>aboard[2’’b0:d]adv.船(车)上</p>
<p>1.<br>查找: (^[a-zA-Z0-0/-]+)(/[<em>.</em>/]+)(.*)<br>替换: @@@@@”/1″,”/2″,”/3″,<br>效果:<br>@@@@@”abandon”,”[2’’b9nd2n]“,”v.抛弃，放弃”,<br>@@@@@”abandonment”,”[2’’b9nd2nm2nt]“,”n.放弃”,<br>@@@@@”abbreviation”,”[2bri:vi’’ei62n]“,”n.缩写”,<br>@@@@@”abeyance”,”[2’’bei2ns]“,”n.缓办，中止”,<br>@@@@@”abide”,”[2’’baid]“,”v.遵守”,<br>@@@@@”ability”,”[2’’biliti]“,”n.能力”,<br>@@@@@”able”,”[‘’eibl]“,”adj.有能力的，能干的”,<br>@@@@@”abnormal”,”[9b’’n0:m2l]“,”adj.反常的，变态的”,<br>@@@@@”aboard”,”[2’’b0:d]“,”adv.船(车)上”,</p>
<p>2.<br>查找: /n<br>替换:<br>注: 要次替换内容为空<br>效果:<br>@@@@@”abandon”,”[2’’b9nd2n]“,”v.抛弃，放弃 ”,@@@@@”abandonment”,”[2’’b9nd2nm2nt]“,”n.放弃 ”,@@@@@”abbreviation”,”[2bri:vi’’ei62n]“,”n.缩写 ”,@@@@@”abeyance”,”[2’’bei2ns]“,”n.缓办，中止”,@@@@@”abide”,”[2’’baid]“,”v.遵守 ”,@@@@@”ability”,”[2’’biliti]“,”n.能力”,@@@@@”able”,”[‘’eibl]“,”adj.有能力的，能 干的 ”,@@@@@”abnormal”,”[9b’’n0:m2l]“,”adj.反常的，变态的 ”,@@@@@”aboard”,”[2’’b0:d]“,”adv.船(车)上”,@@@@@”abolish”,”[2’’b0li6]“,”v.废 除，取消”,@@@@@”abolition”,”[9b2’’li62n]“,”n.废除，取消”</p>
<p>3.<br>查找: @@@@@<br>替换: /n<br>效果:<br>“abandon”,”[2’’b9nd2n]“,”v.抛弃，放弃”,<br>“abandonment”,”[2’’b9nd2nm2nt]“,”n.放弃”,<br>“abbreviation”,”[2bri:vi’’ei62n]“,”n.缩写”,<br>“abeyance”,”[2’’bei2ns]“,”n.缓办，中止”,<br>“abide”,”[2’’baid]“,”v.遵守”,<br>“ability”,”[2’’biliti]“,”n.能力”,<br>“able”,”[‘’eibl]“,”adj.有能力的，能干的”,<br>“abnormal”,”[9b’’n0:m2l]“,”adj.反常的，变态的”,<br>“aboard”,”[2’’b0:d]“,”adv.船(车)上”,<br>“abolish”,”[2’’b0li6]“,”v.废除，取消”,</p>
<ol start="4">
<li>任务完成</li>
</ol>
<p>一、删除空行（不包括有空格类符号的空行）<br>1、\r\n转义符替换<br>按ctrl+h，跳出搜索替换框，把查找模式定义为扩展（\n，\r…）<br>查找目标：\r\n\r\n<br>替换为：\r\n</p>
<p>有编程基础的读者应该知道是什么意思了。</p>
<p>2、Textfx插件<br>先选中要删部分文本内容，如果是整个文件那就全选Ctrl+A，然后使用Notepad++自带的Textfx插件，在长长的列表中找到Delete Blank Lines，点击即可。</p>
<p>注意Notepad++的正则表达式与转义符等之间不兼容，所以局限性较大，不可以直接用正则表达式替换。</p>
<p>二、删除有空格的空行<br>1、先删除空格，后删除空行<br>如何删除只有空格行的空格？<br>在菜单编辑中找到Blank Operations（行编辑），点击移除行尾空白，再用上面的方法删除空行。</p>
<p>2、使用正则表达式删除空格行空格<br>替换中查找模式选择正则表达式^ +$，替换为空（就是什么都不填），再用上面的方法删除空行。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看雷电模拟器里的sqilte数据</title>
    <url>/2023/02/18/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%9B%B7%E7%94%B5%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%87%8C%E7%9A%84sqilte%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>C:\Users\zhang&gt;

d:
D:\&gt;

cd D:\DevTools\LeiDian\LDPlayer64
D:\DevTools\LeiDian\LDPlayer64&gt;

adb shell

aosp:/ # cd /data/media/0/Android/data/io.dcloud.HBuilder/apps/HBuilder/doc
cd /data/media/0/Android/data/io.dcloud.HBuilder/apps/HBuilder/doc

aosp:/data/media/0/Android/data/io.dcloud.HBuilder/apps/HBuilder/doc #
sqlite3 test.db

sqlite3 test.db
SQLite version 3.9.2 2017-07-21 07:45:23
Enter &quot;.help&quot; for usage hints.
sqlite&gt;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>APP</tag>
        <tag>雷电模拟器</tag>
        <tag>sqilte</tag>
      </tags>
  </entry>
  <entry>
    <title>maven镜像库最佳配置</title>
    <url>/2023/02/17/maven%E9%95%9C%E5%83%8F%E5%BA%93%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>&lt;mirror&gt;
    &lt;id&gt;aliyunmaven&lt;/id&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;name&gt;阿里云公共仓库&lt;/name&gt;
    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
&lt;/mirror&gt;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>MAVEN</tag>
        <tag>OJDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm中的文件模版变量</title>
    <url>/2023/02/17/PyCharm%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%A8%A1%E7%89%88%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>$&#123;PROJECT_NAME&#125; - 当前的项目名
$&#123;NAME&#125; - 在文件创建过程中，新文件对话框的命名
$&#123;USER&#125; - 当前的登录用户
$&#123;DATE&#125; - 现在的系统日期
$&#123;TIME&#125; - 现在的系统时间
$&#123;YEAR&#125; - 当前年份
$&#123;MONTH&#125; - 当前月份
$&#123;DAY&#125; - 当前月份中的第几日
$&#123;HOUR&#125; - 现在的小时
$&#123;MINUTE&#125; - 现在的分钟
$&#123;PRODUCT_NAME&#125; - IDE创建文件的名称
$&#123;MONTH_NAME_SHORT&#125; - 月份的前三个字母缩写
$&#123;MONTH_NAME_FULL&#125; - 完整的月份名

 
</code></pre>
<p>示例：</p>
<pre><code>#-*- coding = utf-8 -*-
#@Time : $&#123;DATE&#125; $&#123;TIME&#125;
#@Author : YourName
#@File : $&#123;NAME&#125;.py
#@Software : $&#123;PRODUCT_NAME&#125;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>查看PostgreSQL序列最后值的方法</title>
    <url>/2023/02/16/%E6%9F%A5%E7%9C%8BPostgreSQL%E5%BA%8F%E5%88%97%E6%9C%80%E5%90%8E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>SELECT SCHEMANAME AS SCHEMA,SEQUENCENAME AS SEQUENCE,LAST_VALUE FROM PG_SEQUENCES

SELECT * FROM ALL_BOU1_4L_GID_SEQ;

SELECT CURRVAL(&#39;ALL_BOU1_4L_GID_SEQ&#39;);

SELECT NEXTVAL(&#39;ALL_BOU1_4L_GID_SEQ&#39;);
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL备份与恢复</title>
    <url>/2023/02/16/PostgreSQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（一）备份数据库，步骤如下：<br>（1）开始-运行-cmd 弹出dos控制台；然后 在控制台里，进入PostgreSQL安装目录bin下：<br>    cd C:\Program Files\PostgreSQL\9.0\bin<br>    pg_dump -h localhost -U postgres databasename &gt; D:\databasename.bak</p>
<p>（二）恢复数据库，步骤如下：<br>（1）预先建好数据库databasename，<br>（2）开始-运行-cmd 弹出dos控制台；然后 在控制台里，进入PostgreSQL安装目录bin下：<br>    cd C:\Program Files\PostgreSQL\9.0\bin<br>    psql -h localhost -U postgres -d databasename &lt; D:\databasename.bak</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下注册和取消PostgreSQL服务的方法</title>
    <url>/2023/02/16/windows%E4%B8%8B%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%96%E6%B6%88PostgreSQL%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h1><p>pg_ctl register [-N servicename] [-U username] [-P password] [-D datadir] [-w][-t seconds] [-o options]<br>pg_ctl unregister [-N servicename]<br>参数说明如下：<br>-N servicename：要注册的系统服务的名字。这个名字将用于服务名和 显示名。<br>-P password：用于启动服务的密码<br>-U：用于启动服务的用户名。如果是域用户，需要使用“DOMAIN\username”的格式<br>使用举例如下：<br>删除一个服务：<br>pg_ctl unregister -N postgresql-9.2<br>增加一个服务：<br>pg_ctl register -D “C:\Program Files\Postgresql\9.2\data”</p>
<h1 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h1><p>重新注册服务，其实比重新安装还简单了；执行命令就可以了，<br>第一步：进入到数据库的安装目录，cd D:\PostgreSQL\bin；<br>第二部：执行服务注册：pg_ctl register -N pg921 -D D:\PostgreSQL\data -S auto -w -t 10 -l D:/PostgreSQL/pg921.log -o “-p 5432”,<br>-N pg921 代表注册服务的名称 ，-D代表数据库文件目录 ，-S代表服务启动方式auto自动，demand手动，-o “-p 5432”指启动服务端口；（可以通过pg_ctl –help命令查看使用方法）<br>第三步：启动服务，net start pg921；<br>通过上面的的方法就成功的注册了服务器，以后每次开机都可以使用数据库了；<br>但是postgresql自带的一个管理工具pgAdmin3还是不能正常使用，需要我们配置，配置方法见下图：<br>注意：服务项不需要填写，主机填写localhost，如果填写真实的ip，必须在数据库配置文件中配置ip权限，否则不能连接；</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Enabling PostGIS</title>
    <url>/2023/02/16/Enabling-PostGIS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PostGIS is an optional extension that must be enabled in EVERY database you want to use it in.</p>
<pre><code>CREATE EXTENSION postgis;
-- in PostGIS 3, postgis_raster is a separate extension from postgis
-- so do this in addition if you are experimenting PostGIS 3+
CREATE EXTENSION postgis_raster;
 
CREATE EXTENSION postgis_sfcgal;
CREATE EXTENSION address_standardizer;
CREATE EXTENSION fuzzystrmatch;
CREATE EXTENSION postgis_topology;
CREATE EXTENSION postgis_tiger_geocoder;

-- If you want to use pgrouting, download the respective one for your PostgreSQL
CREATE EXTENSION pgrouting;
</code></pre>
<hr>
<pre><code>-- Enable PostGIS (as of 3.0 contains just geometry/geography)
CREATE EXTENSION postgis;
-- enable raster support (for 3+)
CREATE EXTENSION postgis_raster;
-- Enable Topology
CREATE EXTENSION postgis_topology;
-- Enable PostGIS Advanced 3D
-- and other geoprocessing algorithms
-- sfcgal not available with all distributions
CREATE EXTENSION postgis_sfcgal;
-- fuzzy matching needed for Tiger
CREATE EXTENSION fuzzystrmatch;
-- rule based standardizer
CREATE EXTENSION address_standardizer;
-- example rule data set
CREATE EXTENSION address_standardizer_data_us;
-- Enable US Tiger Geocoder
CREATE EXTENSION postgis_tiger_geocoder;
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>PostGIS</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu20.04安装Idea详细教程</title>
    <url>/2023/02/15/Ubuntu20-04%E5%AE%89%E8%A3%85Idea%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="官网下载压缩包"><a href="#官网下载压缩包" class="headerlink" title="官网下载压缩包"></a>官网下载压缩包</h1><p><a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a> </p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><pre><code>sudo tar -zxvf ideaIU-2020.2.3.tar.gz -C /opt 
cd idea-IU-202.7660.26/bin/
./idea.sh 
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ubuntu</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Geowebcache瓦片的自更新</title>
    <url>/2023/02/15/Geowebcache%E7%93%A6%E7%89%87%E7%9A%84%E8%87%AA%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/u013323965/article/details/71480810">https://blog.csdn.net/u013323965/article/details/71480810</a>  转载</p>
<p>问题来源<br>如果有一种图层，它的支撑数据是不断变化的，但使用wms加载太慢（gwc/service/wms也一样），影响体验，那么有没有办法，加载事先切好的瓦片，再自更新更换的部分？<br>解决方式<br>geoserver官网上提供的两种方式(guava是自带的，而另一种则需要使用社区封装好的依赖包)，但两种都试过了，貌似都没有什么效果，也可能是我的方法不对，望大神指点</p>
<p>利用gwc自带的配置进行瓦片时效的调整，用这种方式，本人确实在时长之外感受到了瓦片的变化。</p>
<p>GWC瓦片配置步骤<br>以防有人不记得所配置的路径，特地介绍了如何找到配置路径，打开geoserver，进入主页，修改地址子路径为gwc(如localhost:8080/geoserver/gwc)。</p>
<p>在xml中添加需要的图层，结构可自行百度geowebcache.xml，有详细的结构，这里不重复，在<layers>下添加所需的wmsLayer.</layers></p>
<p>然后在第一步的网址里加子路径demo，选中Reload Configuration，进行配置的重新读取<br>继续下来，要注意的是，配置文件的图层很可能被原来配置的同名图层给顶替掉了，导致结果没有发生变化，这里要删除掉原有图层才能看到GWC图层，如图，图标可以区分，很明显框起来的就是通过配置生成的图层，这个图层可以自更新瓦片。</p>
<p>注意<br>最大的注意事项就是注意有没有顶替现象</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Geowebcache</tag>
        <tag>瓦片自更新</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统如何查看端口被占用、杀进程</title>
    <url>/2023/02/14/windows%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E3%80%81%E6%9D%80%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、首先是启动windows的命令窗口，按键盘上的windows+R，然后在输入框中输入cmd，既可以启动命令窗口</p>
<p>2、进入windows命令窗口之后，输入命令，输入netstat -ano然后回车，就可以看到系统当前所有的端口使用情况。</p>
<p>3、通过命令查找某一特定端口，在命令窗口中输入命令中输入netstat -ano |findstr “端口号”，然后回车就可以看到这个端口被哪个应用占用。</p>
<p>4、查看到对应的进程id之后，就可以通过id查找对应的进程名称，使用命令tasklist |findstr “进程id号”</p>
<p>5、通过命令杀掉进程，或者是直接根据进程的名称杀掉所有的进程，，在命令框中输入如下命令taskkill /f /t /im “进程id或者进程名称”</p>
<p>6、杀掉对应的进程id或者是进程名称之后，然后再通过查找命令，查找对应的端口，现在就可以看到这个端口没有被其他应用所占用。</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat修改默认访问项目名称和项目发布路径</title>
    <url>/2023/02/14/tomcat%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E5%92%8C%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Tomcat默认的而发布路径为 tomcat/webapps/目录，如果想修改发布路径，找到tomcat/conf/server.xml文件，有以下两种方式：</p>
<h1 id="方式一：修改默认appBase"><a href="#方式一：修改默认appBase" class="headerlink" title="方式一：修改默认appBase"></a>方式一：修改默认appBase</h1><p>默认：</p>
<pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<p>webapps存放web应用，这个目录下有一些默认的项目，在tomcat启动的时候会跟着一起加载。<br>如果不想删除这些项目，可以把tomcat发布的路径修改到其他地方。<br>修改里面这一行的appBase为其他路径即可。</p>
<pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;/root/webfile/webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<h1 id="方式二：保持appBase不变，增加其他发布路径"><a href="#方式二：保持appBase不变，增加其他发布路径" class="headerlink" title="方式二：保持appBase不变，增加其他发布路径"></a>方式二：保持appBase不变，增加其他发布路径</h1><p>在<Host>节点下增加<Context>节点,并设置path、docBase、reloadable属性，示例如下。</Context></Host></p>
<pre><code>&lt;Context path=&quot;&quot; docBase=&quot;/root/webfile/web&quot; reloadable=&quot;true&quot;/&gt;
&lt;Context docBase=&quot;/root/pismarket-api&quot; path=&quot;/api&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; privileged=&quot;true&quot; /&gt;
</code></pre>
<p>各属性说明如下：</p>
<ul>
<li>docBase</li>
</ul>
<p>就是你部署项目的实际路径。可以指定web应用程序的文档根目录或者war文件的路径名，你可以指定目录或war文件的绝对路径名，也可以指定相对于Host元素的appBase目录的相对路径名。</p>
<ul>
<li>path</li>
</ul>
<p>就是你要访问的相对路径，或者叫web应用的上下文路径。</p>
<ul>
<li>reloadable</li>
</ul>
<p>热部署。如果设置为true，则tomcat服务器在运行时，会监视WEB-INF/classes和WEB-INF/lib目录下类的改变，如果发现有类被更新，tomcat服务器将自动重新加载该web应用程序。这个特性在应用程序的开发阶段非常有用，但是它需要额外的运行时开销，所以在产品发布时不建议使用。该属性的默认值是false</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>windows命令行查看文件的MD5、SHA1、SHA256</title>
    <url>/2023/02/14/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84MD5%E3%80%81SHA1%E3%80%81SHA256/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>win10打开Powershell，命令格式certutil -hashfile  &lt;文件名&gt;  &lt;hash类型&gt;</p>
<p>样例：</p>
<pre><code>certutil -hashfile D:\test.txt MD5
certutil -hashfile D:\test.txt SHA1
certutil -hashfile D:\test.txt SHA256
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>MD5</tag>
        <tag>SHA1</tag>
        <tag>SHA256</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下查看tomcat占用端口</title>
    <url>/2023/02/13/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8Btomcat%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、先查看tomcat的进程号</p>
<p>ps -ef | grep tomcat*</p>
<p>后面带*号，是为了查看多个tomcat，例如tomcat6，tomcat7。</p>
<p>2、根据进程号查看端口号</p>
<p>netstat -anop | grep 15161</p>
<p>可以看到8865、8866、8867端口号被占用</p>
<p>3、此外，还可以通过端口号，查看其所属的进程号相关信息</p>
<p>查找到两种方式：</p>
<p>（1）lsof -i: 8866</p>
<p>（2）netstat -tunlp|grep 端口号，用于查看指定端口号的进程情况，</p>
<p>如查看22端口的情况，netstat -tunlp|grep 22</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下修改tomcat端口号</title>
    <url>/2023/02/13/Linux%E4%B8%8B%E4%BF%AE%E6%94%B9tomcat%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、首先cd进tomcat目录里的conf文件夹，vi打开server.xml配置文件</p>
<pre><code>[root@localhost soft]# ls
download redis solrhome tomcat-sina-8081 tomcat-souhu-8082
jdk redis-3.0.0.gem tomcat tomcat-solr zookeeper-3.4.6
[root@localhost soft]# cd tomcat-solr/
[root@localhost tomcat-solr]# cd conf/
[root@localhost conf]# ls
Catalina catalina.properties logging.properties tomcat-users.xml
catalina.policy context.xml server.xml web.xml
[root@localhost conf]# vim server.xml
</code></pre>
<p>2、改动之一<br>8005改成了8885</p>
<pre><code>&lt;Server port=”8885″ shutdown=”SHUTDOWN”&gt;
&lt;!– Security listener. Documentation at /docs/config/listeners.html
&lt;Listener className=”org.apache.catalina.security.SecurityListener” /&gt;
</code></pre>
<p>3、改动之二<br>8080改成了8888</p>
<pre><code>&lt;Connector port=”8888″ protocol=”HTTP/1.1″
connectionTimeout=”20000″
redirectPort=”8443″ /&gt;
</code></pre>
<p>4、改动之三<br>8009改成了8889</p>
<pre><code>&lt;!– Define an AJP 1.3 Connector on port 8009 –&gt;
&lt;Connector port=”8889″ protocol=”AJP/1.3″ redirectPort=”8443″ /&gt;
</code></pre>
<p>5、wq保存退出</p>
<p>6、最后在tomcat的bin目录./startup.sh启动一下试试：OK</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下启动tomcat服务</title>
    <url>/2023/02/13/Linux%E4%B8%8B%E5%90%AF%E5%8A%A8tomcat%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux下tomcat服务的启动、关闭与错误跟踪，使用PuTTy远程连接到服务器以后，通常通过以下几种方式启动关闭tomcat服务：<br>1、切换到tomcat主目录下的bin目录（cd usr/local/tomcat/bin）<br>2，启动tomcat服务<br>方式一：直接启动 ./startup.sh<br>方式二：作为服务启动 nohup ./startup.sh &amp;<br>方式三：控制台动态输出方式启动 ./catalina.sh run 动态地显示tomcat后台的控制台输出信息,Ctrl+C后退出并关闭服务<br>解释：<br>通过方式一、方式三启动的tomcat有个弊端，当客户端连接断开的时候，tomcat服务也会立即停止，通过方式二可以作为linux服务一直运行<br>通过方式一、方式二方式启动的tomcat，其日志会写到相应的日志文件中，而不能动态地查看tomcat控制台的输出信息与错误情况，通过方式三可以以控制台模式启动tomcat服务，<br>直接看到程序运行时后台的控制台输出信息，不必每次都要很麻烦的打开catalina.out日志文件进行查看，这样便于跟踪查阅后台输出信息。tomcat控制台信息包括log4j和System.out.println()等输出的信息。<br>3、关闭tomcat服务<br>./shutdown.sh</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>dell笔记本重装系统后耳机插入无声音解决办法</title>
    <url>/2023/02/13/dell%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%80%B3%E6%9C%BA%E6%8F%92%E5%85%A5%E6%97%A0%E5%A3%B0%E9%9F%B3%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>dell笔记本重装系统后回自动安装驱动，但是声卡是不完全匹配的，会导致耳机插入无声音，解决办法如下：</p>
<p>从dell官网找到适配笔记本的驱动，再下载声卡驱动Realtek-High-Definition-Audio-Driver-xxxxxxxxxxxxx.exe。<br>手动点击安装，按要求重启电脑。完成安装后，看见Waves MaxxAudioPro即可。</p>
<p>此时插入耳机一般会有弹框要求选择插入设备类型，选择耳机或耳麦即可。<br>如果没有，则到Waves MaxxAudioPro“回放-高级”，勾选“连接设备弹出选择框”</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>DELL</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记本安装FME</title>
    <url>/2023/02/12/%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85FME/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先，笔记本都会出现两个Ethernet Address，然后用引号括起来，用其中一个就好，不需要引号<br>地址后面还要跟端口（27001~27009）<br>详细步骤如下：<br>1、安装软件本体（fme-desktop-b16492-win-x64.msi）及license管理器（fme-flexnet-win-x64.msi）；<br>2、在FlexServer安装目录下打开lmtools.exe打开System Settings选项卡查看信息，安装包文件夹dummy.txt 第一行 SERVER 后面填写计算机名+空格+网卡MAC（如有引号将几个MAC括起来，填写其中一个即可，不要引号）+空格+端口号（27001-27009）；<br>3、完成后运行makekey.bat 生成safe.lic 大小2.几K，如超过5k则信息错误；<br>4、复制safe.lic 至FlexServer安装目录下 ，打开lmtools.exe，Strat/Stop/Reread选项卡，先Stop Server，再Start Server，再ReRead License File；<br>5、打开软件后选Float方式，然后填入计算机名，激活即可</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>FME</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle RAC建表空间</title>
    <url>/2023/02/12/Oracle-RAC%E5%BB%BA%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、建表空间</p>
<p>1、RAC</p>
<pre><code>create tablespace TS_YYYY datafile size 500M autoextend on next 50M maxsize unlimited;
</code></pre>
<p>2、单实例</p>
<pre><code>create tablespace TS_YYYY datafile ‘/u01/app/oracle/oradata/pmsgeo/yxyk.dbf’ size 500M autoextend on next 50M maxsize unlimited;
</code></pre>
<p>二、建用户</p>
<pre><code>create user yxyk identified by yyyy default tablespace TS_YYYY;
</code></pre>
<p>三、赋权限</p>
<pre><code>grant connect,resource to yyyy;
grant debug connect session to yyyy;
grant create any sequence to yyyy;
grant create any table to yyyy;
grant delete any table to yyyy;
grant insert any table to yyyy;
grant select any table to yyyy;
grant unlimited tablespace to yyyy;
grant execute any procedure to yyyy;
grant update any table to yyyy;
grant create any view to yyyy;
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql改密码</title>
    <url>/2023/02/12/MySql%E6%94%B9%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="root密码测试只能一句一句的改。"><a href="#root密码测试只能一句一句的改。" class="headerlink" title="root密码测试只能一句一句的改。"></a>root密码测试只能一句一句的改。</h1><pre><code>alter user ‘root’@’localhost’ identified by ‘MySql@123’;
alter user ‘root’@’127.0.01’ identified by ‘MySql@123’;
alter user ‘root’@’::1′ identified by ‘MySql@123’;
</code></pre>
<h1 id="Reset-the-MySQL-MariaDB-Root-Password"><a href="#Reset-the-MySQL-MariaDB-Root-Password" class="headerlink" title="Reset the MySQL/MariaDB Root Password"></a>Reset the MySQL/MariaDB Root Password</h1><p>By default, the MySQL/MariaDB installation that ships with XAMPP has an empty root password. This is a serious security risk, especially if you plan to use XAMPP in production scenarios.</p>
<p>To change the MySQL/MariaDB root password, follow these steps:</p>
<p>Ensure that the MySQL/MariaDB server is running.<br>Open your Windows command prompt by clicking the “Shell” button in the XAMPP control panel.</p>
<p><img src="https://c2.im5i.com/2023/02/12/nxDoU.png" alt="nxDoU.png"></p>
<p>Use the mysqladmin command-line utility to alter the MySQL/MariaDB password, using the following syntax:</p>
<pre><code>mysqladmin --user=root password &quot;newpassword&quot;
</code></pre>
<p>For example, to change the MySQL/MariaDB root password from its default empty value to the password gue55me, you would execute:</p>
<pre><code>mysqladmin --user=root password &quot;gue55me&quot;
</code></pre>
<p><img src="https://c2.im5i.com/2023/02/12/nxaOw.png" alt="nxaOw.png"></p>
<p>Or, if a password has already been previously set and you’d like to change it to a new one, you can use the following syntax:</p>
<pre><code>mysqladmin --user=root --password=oldpassword password &quot;newpassword&quot;
</code></pre>
<p>For example, to change the root password from 12345 to gue55me, you would execute:</p>
<pre><code>mysqladmin --user=root --password=12345 password &quot;gue55me&quot;
</code></pre>
<p>Test that your password change has been accepted, by attempting to connect to the MySQL/MariaDB server using the mysql command-line client in the same directory. For example, you could use the command below to connect to the server and return the results of a calculation:</p>
<pre><code>mysql --user=root --password=gue55me -e &quot;SELECT 1+1&quot;
</code></pre>
<p><img src="https://c2.im5i.com/2023/02/12/nx0J8.png" alt="nx0J8.png"></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven不能加载ojdbc14.jar的解决方法</title>
    <url>/2023/02/12/Maven%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BDojdbc14-jar%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先电脑上得安装好maven。<br>1、先下载ojdbc14-10.2.0.4.0.jar。也可以本机或其他服务器安装的Oracle目录中寻找。<br>2、将ojdbc14-10.2.0.4.0.jar放到指定目录中，这里放在C:\mm\ojdbc14-10.2.0.4.0.jar下的。<br>3、打开 cmd运行</p>
<pre><code>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=C:\mm\ojdbc14-10.2.0.4.0.jar
</code></pre>
<p>4、如下在pom.xml文件中添加引用</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.oracle&lt;/groupId&gt;
    &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;
    &lt;version&gt;10.2.0.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>MAVEN</tag>
        <tag>OJDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>sanfran_urbansim地图可视化报错解决办法</title>
    <url>/2023/02/11/sanfran-urbansim%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>装anacond3，urabansim，下载sanfran_urbansim</p>
<p>命令行ipython notebook启动后，执行Exploration.ipynb调取地图出不了图。</p>
<p>分析后发现是dframe_explorer.html的问题，</p>
<p>其中调取angular.min.js改为如下即可。</p>
<script src="https://cdn.staticfile.org/angular.js/1.0.7/angular.min.js"></script>

<p>过滤条件筛选也会报错，下一步处理。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>urbansim</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下安装Redis</title>
    <url>/2023/02/11/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>微软出品：最新版本3.2.100</p>
<p><a href="https://github.com/MSOpenTech/redis">https://github.com/MSOpenTech/redis</a></p>
<p>其他衍生版本，基于微软出品：最新版本5.0.14</p>
<p><a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p><a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>三维点云格式</title>
    <url>/2023/02/10/%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>3ds (.3ds)<br>3ds是3ds max通用储存文件格式。使用的范围更宽，可被更多的软件识别使用.</p>
</li>
<li><p>amf (.amf)<br>AMF是以目前3D打印机使用的“STL”格式为基础、弥补了其弱点的数据格式，新格式能够记录颜色信息、材料信息及物体内部结构等。AMF标准基于XML（可扩展标记语言）。</p>
</li>
<li><p>3mf (.3mf)<br>由微软牵头的3MF联盟，于2015年推出全新的3D打印格式——3MF（3D Manufacturing Format）,相较于STL格式，3MF档案格式能够更完整地描述3D模型，除了几何信息外，还可以保持内部信息、颜色、材料、纹理等其它特征。3MF同样也是一种基于XML的数据格式。</p>
</li>
<li><p>assimp &amp; assimp2json (.assimp |.json)<br>Assimp是一个强大的模型加载和转换库，支持多种格式的加载和转换，可通过c++进行调用开发。assimp2json顾名思义就是assimp格式的json格式导出。</p>
</li>
<li><p>awd (.awd)<br>AWD是一种用于三维场景的二进制格式，并且通常与AWD引擎一起使用。</p>
</li>
<li><p>Babylon (.babylon)<br>微软的基于webgl的开发框架. Babylon.js</p>
</li>
<li><p>BVH (.bvh)<br>BVH是BioVision等设备对人体运动进行捕获后产生文件格式的文件扩展名,BVH文件包含角色的骨骼和肢体关节旋转数据。BVH 是一种通用的人体特征动画文件格式,，广泛地被当今流行的各种动画制作软件支持。通常可从记录人类行为运动的运动捕获硬件获得。</p>
</li>
<li><p>Collada(.dae |.xml)<br>COLLADA™ 是面向交互式 3D 应用程序的基于 XML 的数字资产交换方案，使 3D 创作应用程序可以自由地交换数字资产而不损失信息 - 使多种DCC和3D处理软件包可以组合成强大的工具链管道。DAE 是纯文本的模型格式，其本质就是一个单纯的xml文件。相比fbx，对dae格式模型的载入我们拥有非常高的自由控制，这也是最复杂的地方。基本上，dae文件内一开始就把数据分成了好几大块。对我们来说最为有用的是VisualScenes(包含场景骨骼节点树)、Nodes(与VisualScenes类似，两者或互为补充)、Geometries（网格数据）、Materials/Effects/Images（材质相关信息）、Controllers（骨骼信息数据）、Animations（动画数据）、AnimationClips（全局的动画信息），其中静态模型一般也就包括VisualScenes和Geometries。(有C++API)</p>
</li>
<li><p>OpenCTM (.ctm)<br>OpenCTM格式的3D模型文件,OpenCTM 格式文件是二进制文件，相比于 stl 格式的文件，它将不承载除模型三角面片信息以外的信息,一个 OpenCTM 文件仅包含一个 Mesh,一个文件主要分成Mesh 的顶点信息和Mesh 的面片信息。(有C++API)</p>
</li>
<li><p>draco(.drc)<br>Google公司推出的3d模型压缩利器，压缩比甩gzip几条街，100M的.obj压缩后大约5M。</p>
</li>
<li><p>FBX(.fbx)<br>FBX 是 FilmBoX 这套软件所使用的格式，后改称 Motionbuilder。因为Motionbuilder扮演的是动作制作的平台，所以在前端的modeling和后端的rendering也都有赖于其它软件的配合,FBX最大的用途是用在诸如在 Max、Maya、Softimage 等软件间进行模型、材质、动作和摄影机信息的互导，这样就可以发挥 Max 和 Maya 等软件的优势。可以说，FBX 方案是非常好的互导方案。</p>
</li>
<li><p>GCode(.gcode)<br>GCODE是用于3d打印的文件，存储有3d打印机的运动命令和坐标等。</p>
</li>
<li><p>glTF (.gltf)<br>glTF是一种可以减少3D格式中与渲染无关的冗余数据并且在更加适合OpenGL簇加载的一种3D文件格式。glTF 就是三维文件的 JPEG ，三维格式的 MP3。在没有glTF的时候，大家都要花很长的的时间来处理模型的载入。此外，glTF是对近二十年来各种3D格式的总结，使用最优的数据结构，来保证最大的兼容性以及可伸缩性。这就好比是本世纪初xml的提出。glTF使用json格式进行描述，也可以编译成二进制的内容：bglTF。glTF可以包括场景、摄像机、动画等，也可以包括网格、材质、纹理，甚至包括了渲染技术（technique）、着色器以及着色器程序。同时由于json格式的特点，它支持预留一般以及特定供应商的扩展。</p>
</li>
<li><p>Clara(.json)<br>Clara.io有可建立于桌面的3D创建工具，它是一个整合性的3D内容创作软件，不仅仅是单一用途的应用程序，还是算图或layout工具，并由许多外挂模块和语法所组成。大多3D artists不需太多适应时间就可熟悉Clara.io，并获得更多的便利功能。由于Clara.io是设计在网络浏览器上运行，所以用户可随时随地接触到它，无需设定、可跨平台使用，自动存储所有的制作步骤，让你可以实时与他人协同作业，以及拥有无限制的云端运算需求。</p>
</li>
<li><p>KMZ(.kmz)<br>kmz是谷歌kml语言文件的zip压缩格式，常用于的谷歌地图文件，由kml语言编写，KML是标记语言（Keyhole Markup Language）的缩写，最初由Keyhole公司开发，是一种基于XML 语法与格式的、用于描述和保存地理信息（如点、线、图像、多边形和模型等）的编码规范，可以被 Google Earth 和 Google Maps 识别并显示。</p>
</li>
<li><p>LDraw(.mpd)<br>lego的3D模型库</p>
</li>
<li><p>LightWave(.lwo)<br>lwoss是LightWave 3D模型美国NewTek公司开发的LightWave 3D是一款高性价比的三维动画制作软件，它的功能非常强大，是业界为数不多的几款重量级三维动画软件之一。</p>
</li>
<li><p>MD2 (.md2)<br>MD2文件是QuakeП专用的文件格式，QuakeП中复杂的三维场景就是通过对它的读取产生的。</p>
</li>
<li><p>MMD(.pmd + .vmd)<br>MikuMikuDance是日本人樋口优所开发，将VOCALOID2的初音未来等角色制作3D模组的免费软件</p>
</li>
<li><p>nrrd (.nrrd)<br>NRRD格式包含了一个单独的头文件和若干个可以被结合在一起或者分开的图像文件。NRRD头文件为科学可视化和图像处理准确地表征了N维光栅信息。常用于医疗设备的多层切片数据。</p>
</li>
<li><p>obj (.obj)<br>OBJ文件是Alias|Wavefront公司为它的一套基于工作站的3D建模和动画软件”Advanced Visualizer”开发的一种标准3D模型文件格式，很适合用于3D软件模型之间的互导。目前几乎所有知名的3D软件都支持OBJ文件的读写。OBJ文件是一种文本文件，可以直接用写字板打开进行查看和编辑修改。</p>
</li>
<li><p>obj2 (.obj)<br>同上</p>
</li>
<li><p>pcd (.pcd)<br>Point Cloud Data即3d点云图像。<br>.pcd格式三维点云都可以用CloudViewer来显示，具体介绍看这里 <a href="http://nightn.com/cloudviewer/">http://nightn.com/cloudviewer/</a></p>
</li>
<li><p>PDB(.pdb)<br>PDB是protein data base 的简写，在生物学软件中，一般把蛋白质的三维结构信息用pdb文件保存。本质是一种ASICLL码文件，可以用普通的文本编辑器编辑，也可以用专业软件编辑。</p>
</li>
<li><p>PlayCanvas(.json)<br>PlayCanvas是一款开源游戏引擎，完全基于浏览器；</p>
</li>
<li><p>ply (.ply)<br>PLY 是一种电脑档案格式，全名为多边形档案（Polygon File Format）或 斯坦福三角形档案（Stanford Triangle Format）。 该格式主要用以储存立体扫描结果的三维数值，透过多边形片面的集合描述三维物体，与其他格式相较之下这是较为简单的方法。它可以储存的资讯包含颜色、透明度、表面法向量、材质座标与资料可信度，并能对多边形的正反两面设定不同的属性。作为OBJ 格式的升级版！PLY格式受 Wavefront .obj 格式的启发，但改进了Obj格式所缺少的对任意属性及群组的扩充性。因此PLY格式发明了”property”及”element”这两个关键词，来概括“顶点、面、相关资讯、群组”的概念。<br>.ply格式的三维点云，比较常见，显示使用MeshLab，直接搜索即可下载<br>三维点云都可以用CloudViewer来显示，具体介绍看这里 <a href="http://nightn.com/cloudviewer/">http://nightn.com/cloudviewer/</a></p>
</li>
<li><p>prwm(.prwm)<br>Packed Raw WebGL Model 是一种二进制的3d模型文件， 它是为web中的几何外形设计的，主要特点是解析和加载速度特别快，原理是对元素进行索引和数组话操作。 prwm</p>
</li>
<li><p>sea3d(.sea3d)<br>sea3d为游戏而生的一种开源的格式与工具，可导出动画, 纹理, 材质, 骨骼 ( Skin ), 顶点动画, 变形, 相机, 光源, 环境和辅助.</p>
</li>
<li><p>stl(.stl)<br>STL是用三角网格来表现3D CAD模型。文件格式简单，只能描述三维物体的几何信息，不支持颜色材质等信息，是计算机图形学处理CG、数字几何处理如CAD、 数字几何工业应用, 如三维打印机支持的最常见文件格式。</p>
</li>
<li><p>vrm(.vrm)<br>vrm是日本推行的3D虚拟形象的新格式标准，打造3D人形角色行业标准</p>
</li>
<li><p>vrml(.vrml)<br>VRML（Virtual Reality Modeling Language）即虚拟现实建模语言。是一种用于建立真实世界的场景模型或人们虚构的三维世界的场景建模语言，也具有平台无关性。它可以做很多事并且支持很多效果.但是事实上它并未得到广泛应用.</p>
</li>
<li><p>vtk<br>VTK，全称是Visualization Toolkit，即可视化工具包。是一个开源、跨平台、可自由获取、支持并行处理的图形应用函数库。</p>
</li>
<li><p>x<br>.x文件是微软为DX开发提供的一种3D文件.包括顶点\纹理、动作。</p>
</li>
<li><p>xyz<br>.xyz格式的三维点云可以用OpenCV生成，显示使用VTK库，需要自己编译，然后用OpenCV viz模块显示，介绍 <a href="https://blog.csdn.net/stq054188/article/details/104799702">https://blog.csdn.net/stq054188/article/details/104799702</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的几种在线地图</title>
    <url>/2023/02/10/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%A8%E7%BA%BF%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>（1）天地图：CGCS2000，2000国家大地坐标系；<br>我们其实很多时候直接用WGS84的坐标来代替CGCS2000坐标。因为CGCS2000的定义与WGS84实质一样。采用的参考椭球非常接近。扁率差异引起椭球面上的纬度和高度变化最大达0.1mm。当前测量精度范围内，可以忽略这点差异。可以说两者相容至cm级水平，但若一点的坐标精度达不到cm水平，则不认为CGCS2000和WGS84的坐标是相容的。</p>
</li>
<li><p>（2）百度地图：bd09II坐标。<br>首先了解一下火星坐标，它是在国际标准坐标WGS-84上进行的一次加密，由于国内的电子地图都要至少使用火星坐标进行一次加密，百度直接就任性一些，直接自己又研究了一套加密算法，来了个二次加密，这就是我们所熟知的百度坐标(BD-09)。</p>
</li>
<li><p>（3）高德地图：gcj02坐标，也称为火星坐标。<br>火星坐标是国家测绘局为了国家安全在原始坐标的基础上进行偏移得到的坐标，基本国内的电子地图、导航设备都是采用的这一坐标系或在这一坐标的基础上进行二次加密得到的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>各种JDK版本大集合</title>
    <url>/2023/02/09/%E5%90%84%E7%A7%8DJDK%E7%89%88%E6%9C%AC%E5%A4%A7%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>OracleJDK:<br>Oracle公司成立于1977年，是全球最大的企业级软件公司，总部位于美国加利福尼亚州的红木滩。2009年就以7.4B$收购了Sun公司。2013年超越 IBM ，成为 继 Microsoft 后全球第二大软件公司。<br>警告:生产环境中OracleJDK的使用请注意法律风险! <a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
</li>
<li><p>OpenJDK:<br>OpenJDK原是Sun Microsystems公司为Java平台构建的Java开发环境（JDK）的开源版本，完全自由，开放源码。 Sun Microsystems公司在2006年的JavaOne大会上称将对Java开放源代码，于2009年4月15日正式发布OpenJDK。 甲骨文在2010年收购Sun Microsystem之后接管了这个项目。<a href="http://openjdk.java.net/">http://openjdk.java.net</a></p>
</li>
<li><p>RedHat Open JDK:<br>RedHat开源扛把子红帽出品，值得信赖。仅有windows。Linux请从源里下载。仅更新最新维护版。<a href="https://developers.redhat.com/products/openjdk/download">https://developers.redhat.com/products/openjdk/download</a></p>
</li>
<li><p>AdoptOpenJDK:<br>2017年开始采用OpenJDK.net，建立在多个平台上普遍缺乏一个开放的、可复制的OpenJDK源代码构建和测试系统。 adoptionopenjdk为Java生态系统提供了坚如磐石的OpenJDK二进制文件，还为任何平台上的OpenJDK构建者提供了作为代码的基础设施和构建场。<a href="https://adoptopenjdk.net/">https://adoptopenjdk.net</a></p>
</li>
<li><p>Dragonwell:<br>作为OpenJDK的下游，alibaba Dragonwell是阿里巴巴内部OpenJDK定制版AJDK的开源版本，AJDK为在线电商、金融、物流做了结合业务场景的优化，运行在超大规模的，100,000+ 服务器的阿里巴巴数据中心。<br>国产之光,大家有机会还是尝试下优化的还不错，相对于OpenJDK更省内存和并发更高启动更快，作者测试过 <a href="https://github.com/alibaba/dragonwell8">https://github.com/alibaba/dragonwell8</a></p>
</li>
<li><p>GraalVM:<br>GraalVM是一个通用的虚拟机，用于运行以JavaScript、Pytho n、Ruby、R、JVM等语言编写的应用程序，如Java、Scala、Groovy、Kotlin 、Crojule和基于LLVM的语言，如C和C++。GraalVM消除了编程语言之间的隔离，并在共 享运行时启用互操作性。它可以独立运行，也可 以在OpenJDK、Node.js或Oracle数据库的上下文中运行。<a href="https://www.graalvm.org/">https://www.graalvm.org</a></p>
</li>
<li><p>ZuluJDK:<br>Azul Systems为需要为其面向网络的客 户（旅游、在线零售、游戏、SaaS）提供基于服务器的Java应 用程序的公司提供服务，满足实时业务系统（广告网络、资本市场、通信）的特定 延迟目标，确保对重要应用程序进行及时维护或安全更新，或者为嵌入式和物联网用例提 供基于Java的系统。<a href="https://www.azul.com/downloads/zulu-community/?&amp;architecture=x86-64-bit&amp;package=jdk#">https://www.azul.com/downloads/zulu-community/?&amp;architecture=x86-64-bit&amp;package=jdk#</a></p>
</li>
<li><p>Liberica:<br>Liberica是一个100% 开源Java实现。它是由BellSoft贡献的O penJDK构建的，经过了彻底的测试，并通过了OpenJDK许可下 提供的JCK。Standard为常规用途，full版本包含JavaFX，lite为精简的OpenJDK。文件体积Full &gt; Standard &gt; lite。<br><a href="https://bell-sw.com/pages/downloads/#/java-14-current">https://bell-sw.com/pages/downloads/#/java-14-current</a></p>
</li>
<li><p>SapMachine:<br>SAP SE是一家 德国跨国软件公司，它生产企业软件 来管理业务运营和客户关系。SAP总部位于德国巴登-符腾 堡的沃尔多夫，在180个国家设有区域办事处。SapMachine是OpenJDK 项目的下游版本。它用于为希望使用OpenJDK运行其应用程序的SAP客户和合作伙 伴构建和维护支持SAP的OpenJDK版本。SAP致力于确保Java平台的持续成功。<a href="https://sap.github.io/SapMachine">https://sap.github.io/SapMachine</a></p>
</li>
<li><p>Corretto:<br>Amazon Corretto是一个免费的 、多平台的、面向生产的开放Java开发工具包（OpenJDK） 发行版。Corretto提供长期支持，包括性能增强和安全修复。亚马逊在数 个生产服务上运行Corretto，并且Corretto被证明与Java SE标准兼容。使用Corretto，您 可以在流行的操作系统（包括Linux、Windows和macOS）上开发和运行Java应用程序。<a href="https://amazonaws-china.com/cn/corretto">https://amazonaws-china.com/cn/corretto</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>node-sass npm ERR! command failed 解决方法</title>
    <url>/2023/02/09/node-sass-npm-ERR-command-failed-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>直接去 GitHub 上下载 node-sass 的二进制文件，然后设置环境变量：</p>
<p>下载 node-sass 二进制 <a href="https://github.com/sass/node-sass">https://github.com/sass/node-sass</a><br>下载时，需要注意以下你的 node 版本以及对应的 NODE_MODULE_VERSION 版本，版本映射查看说明文件。</p>
<p>设置环境变量<br>    export SASS_BINARY_PATH=/yourPath/linux-x64-93_binding.node</p>
<p>执行依赖安装<br>    npm i</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>软件开发</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>arcgis online地图</title>
    <url>/2023/02/08/arcgisonline%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、esri</p>
<p><a href="https://server.arcgisonline.com/arcgis/rest/services">https://server.arcgisonline.com/arcgis/rest/services</a></p>
<p>2、ChinaOnlineCommunity地图服务</p>
<p><a href="http://map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer">http://map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStreetMap数据下载</title>
    <url>/2023/02/08/OpenStreetMap%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最小区域-国家</p>
<p><a href="https://download.geofabrik.de/">https://download.geofabrik.de/</a></p>
<p>最小区域-热点区域</p>
<p><a href="https://download.bbbike.org/">https://download.bbbike.org/</a></p>
<p>数据查看</p>
<p><a href="https://www.openstreetmap.org/">https://www.openstreetmap.org/</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>GIServer</title>
    <url>/2023/02/07/GIServer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>GIServer是一个类ArcGIS Server的GIS Server，并且首先针对REST接口进行实现，为的就是所有熟悉ArcGIS的JS/Flex/Silverlight API的人可以很容易上手来使用它。</p>
<p>通过1个试验版本和3个alpha版本，目前map service和geometry service的功能都已经实现，你完全可以把它当成ArcGIS Server来使用；同时，针对GIServer特有的编辑功能，我同时也实现了一个Flex库——agslib4giserver，这个库定义了3个Task：InsertTask、DeleteTask、ModifyTask，你可以通过这3个Task去对数据进行增删改。</p>
<p>为什么要使用GIServer？在这里我们不讨论版权和盗版的问题，仅从技术角度，我想GIServer可能会有几个地方吸引你：</p>
<p>GIServer比较轻量：它部署起来比ArcGIS Server要容易得多；特别是面对集群部署，使用GIServer需要做的就是在机器间复制一些文件。<br>GIServer的高性能：后面的图表可以说明GIServer的性能可以是ArcGIS Server的几倍到几十倍。并且，这个测试是在windows上进行的，面向unix环境GIServer有相对更出色的表现。<br>GIServer支持编辑：通过编辑功能可以让很多客户端产生的数据更新到服务器上。</p>
<p><a href="https://sourceforge.net/projects/giserver/">https://sourceforge.net/projects/giserver/</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>3S</tag>
      </tags>
  </entry>
  <entry>
    <title>3S数据集下载地址收集</title>
    <url>/2023/02/07/3S%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>Nature Earth</li>
</ul>
<p><a href="https://www.naturalearthdata.com/downloads/">https://www.naturalearthdata.com/downloads/</a></p>
<ul>
<li>GRASS GIS sample data</li>
</ul>
<p><a href="https://grass.osgeo.org/download/data/">https://grass.osgeo.org/download/data/</a></p>
<ul>
<li>阿里云的可视化平台工具</li>
</ul>
<p><a href="https://datav.aliyun.com/portal/school/atlas/area_selector">https://datav.aliyun.com/portal/school/atlas/area_selector</a></p>
]]></content>
      <categories>
        <category>知识分享</category>
      </categories>
      <tags>
        <tag>地理数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Redhat firewall开放端口</title>
    <url>/2023/02/06/Redhat-firewall%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Centos7默认安装了firewalld，如果没有安装的话，则需要YUM命令安装；firewalld与之前的iptable防火墙区别挺大。</p>
<p>安装Firewall命令：</p>
<pre><code>yum install firewalld firewalld-config
</code></pre>
<p>Firewall开启常见端口命令：</p>
<pre><code>firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --zone=public --add-port=443/tcp --permanent
firewall-cmd --zone=public --add-port=22/tcp --permanent
firewall-cmd --zone=public --add-port=21/tcp --permanent
firewall-cmd --zone=public --add-port=53/udp --permanent
</code></pre>
<p>Firewall关闭常见端口命令：</p>
<pre><code>firewall-cmd --zone=public --remove-port=80/tcp --permanent
firewall-cmd --zone=public --remove-port=443/tcp --permanent
firewall-cmd --zone=public --remove-port=22/tcp --permanent
firewall-cmd --zone=public --remove-port=21/tcp --permanent
firewall-cmd --zone=public --remove-port=53/udp --permanent
</code></pre>
<p>批量添加区间端口</p>
<pre><code>firewall-cmd --zone=public --add-port=4400-4600/udp --permanent
firewall-cmd --zone=public --add-port=4400-4600/tcp --permanent
</code></pre>
<p>查看端口列表：</p>
<pre><code>firewall-cmd --permanent --list-port
</code></pre>
<p>开启防火墙命令：</p>
<pre><code>systemctl start firewalld
</code></pre>
<p>重启防火墙命令：</p>
<pre><code>firewall-cmd --reload  或者  service firewalld restart
</code></pre>
<p>禁用防火墙</p>
<pre><code>systemctl stop firewalld
</code></pre>
<p>设置开机启动</p>
<pre><code>systemctl enable firewalld
</code></pre>
<p>停止并禁用开机启动</p>
<pre><code>sytemctl disable firewalld
</code></pre>
<p>查看状态</p>
<pre><code>systemctl status firewalld  或者  firewall-cmd --state
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>部署运维</tag>
        <tag>NGINX</tag>
        <tag>Linux</tag>
        <tag>Redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>Redhat7.5挂载iso镜像配置本地yum源安装nginx</title>
    <url>/2023/02/06/Redhat7-5%E6%8C%82%E8%BD%BDiso%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0yum%E6%BA%90%E5%AE%89%E8%A3%85nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、将iso镜像拷贝到电脑上</p>
<pre><code>mkdir /rhel #创建ios镜像存放目录，并将iso存放到该目录下
mkdir /mnt/rhel #创建ios镜像挂载目录
</code></pre>
<p>2、修改yum源的配置文件</p>
<pre><code>vi /etc/yum.repos.d/yum.repo #后缀必须为 ‘ .repo ‘否则系统无法识别

[rhel7.5]
name=rhel7.5
baseurl=file:///mnt/rhel #挂载目录
gpgcheck=0
gpgkey=file:///mnt/rhel/RPM-GPG-KEY-redhat-release #这行可以不用写
</code></pre>
<p>然后退出保存</p>
<p>3、挂载镜像</p>
<pre><code>mount /rhel/rhel-server-7.5-x86_64-dvd.iso /mnt/rhel/
</code></pre>
<p>挂载完成后使用</p>
<pre><code>df -h
</code></pre>
<p>可以看到ios已经成功挂载</p>
<p>然后我们清空本地yum的缓存</p>
<pre><code>yum clean all
</code></pre>
<p>再查看是否安装成功，列出全部yum源软件包</p>
<pre><code>yum repolist
</code></pre>
<p>可是这样的挂载只是临时的，如果关机重启后还得重新挂载<br>如何可以重启以后自动挂载呢？</p>
<p>4、修改开机引导配置文件<br>编辑/etc/fstab最后一行添加</p>
<pre><code>vi /etc/fstab
/rhel/rhel-server-7.5-x86_64-dvd.iso /mnt/rhel iso9660 loop 0 0 #切忌镜像名称不可以拼错
</code></pre>
<p>5、安装编译器</p>
<pre><code>yum install gcc

yum install gcc-c++

yum install pcre-devel

yum install zlib-devel
</code></pre>
<p>6、安装nginx</p>
<p>解压安装包 tar zxvf /nginx-1.18.0.tar.gz</p>
<p>进入安装目录 cd /nginx-1.18.0</p>
<p>执行./configure</p>
<p>执行 make</p>
<p>执行 make install</p>
<p>7、添加软连接</p>
<p>cd /lib64</p>
<p>ln -s libpcre.so.0.0.1 libpcre.so.1</p>
<p>8、nginx常用命令</p>
<p>启动：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</p>
<p>重启：/usr/local/nginx/sbin/nginx -s reload</p>
<p>停止：/usr/local/nginx/sbin/nginx -s stop</p>
<p>端口在/usr/local/nginx/conf/nginx.conf中修改</p>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
        <tag>Linux</tag>
        <tag>Redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看Redis安装目录</title>
    <url>/2023/02/06/Linux%E6%9F%A5%E7%9C%8BRedis%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果命令 which 和whereis 都找不到安装目录，可使用以下办法</p>
<pre><code>ps -ef|grep redis
</code></pre>
<p>得到了进程号 xxxx，然后</p>
<pre><code>ls -l /proc/xxxx/cwd
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>部署运维</tag>
        <tag>服务器</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云服务器安装jdk</title>
    <url>/2023/02/06/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85jdk/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官方地址，可下载JDK历史版本及当前最新版本。</p>
<p><a href="https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html">https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html</a></p>
<hr>
<p>1、先查询是否安装了Java</p>
<pre><code>[root@VM_0_16_centos ~]# java
-bash: java: command not found
</code></pre>
<p>2、假如有，就删除</p>
<pre><code>[root@VM_0_16_centos ~]# yum remove *openjdk*
</code></pre>
<p>3、下载JDK，官方下载是很慢的，可以通过国内云镜像进行下载，比如华为、网易的镜像。</p>
<p>创建下载目录，并通过华为云镜像下载</p>
<pre><code>[root@VM_0_16_centos ~]# mkdir /usr/lib/java
[root@VM_0_16_centos ~]# cd /usr/lib/java
[root@VM_0_16_centos ~]# wget https://repo.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.tar.gz
</code></pre>
<p>4、然后解压</p>
<pre><code>[root@VM_0_16_centos java]# tar -zxvf jdk-8u202-linux-x64.tar.gz
</code></pre>
<p>5、创建软链接，方便管理</p>
<pre><code>[root@VM_0_16_centos java]# ln -s /usr/lib/java/jdk1.8.0_202/ /usr/jdk
</code></pre>
<p>6、配置java环境变量，并加入下面的内容，更新配置信息</p>
<pre><code>[root@VM_0_16_centos java]# vi /etc/profile

JAVA_HOME=/usr/jdk
CLASSPATH=$JAVA_HOME/lib/
PATH=$PATH:$JAVA_HOME/bin
export PATH JAVA_HOME CLASSPATH

[root@VM_0_16_centos java]# source /etc/profile
</code></pre>
<p>7、检查java是否安装正常</p>
<pre><code>[root@VM_0_16_centos java]# java -version
java version “1.8.0_202”
Java(TM) SE Runtime Environment (build 1.8.0_202-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)
[root@VM_0_16_centos java]# javac -version
javac 1.8.0_202
</code></pre>
]]></content>
      <categories>
        <category>部署运维</category>
      </categories>
      <tags>
        <tag>腾讯云</tag>
        <tag>Linux</tag>
        <tag>JAVA</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS二次开发：QGIS3.28.0编译</title>
    <url>/2023/02/05/QGIS%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%9AQGIS3-28-0%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>qgis二次编译的方式越来越简单，下面是最新的编译配置步骤：</p>
<p>环境要求：</p>
<ul>
<li>Visual Studio 2022</li>
<li>cmake-3.22.6-windows-x86_64</li>
<li>cygwin</li>
</ul>
<p>1、新建一个批处理文件OSGeo4W-dev-2022.bat，内容如下，qgis路径请调整为本机真实路径。</p>
<pre><code>@echo off
call E:\QGIS\3.28.0\qgis-3.28.0\qgis\ms-windows\osgeo4w\msvc-env-2022.bat x86_64
@cmd
</code></pre>
<p>2、复制一份ms-windows\osgeo4w\msvc-env.bat，重命名为msvc-env-2022.bat。对其修改如下：</p>
<p><img src="https://c2.im5i.com/2023/02/05/nfV95.png" alt="msvc-env-2022.bat修改内容"></p>
<p>3、运行OSGeo4W-dev-2022.bat，命令行调用cmake-gui.exe，配置如下：</p>
<p><img src="https://c2.im5i.com/2023/02/05/nfK1G.png" alt="cmake依赖配置"></p>
<p>4、configure，generate，得到vs的工程文件。即可开始编译。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>依赖配置</tag>
        <tag>QGIS</tag>
        <tag>CMAKE</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS二次开发：打开POSTGIS图层</title>
    <url>/2023/02/04/QGIS%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%9A%E6%89%93%E5%BC%80POSTGIS%E5%9B%BE%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>核心代码如下：</p>
<pre><code>QString service = QStringLiteral(&quot;&quot;);
QString host = QStringLiteral(&quot;localhost&quot;);
QString port = QStringLiteral(&quot;5432&quot;);
QString database = QStringLiteral(&quot;postgis_25_sample&quot;);

bool useEstimatedMetadata = false;
QgsDataSourceUri::SslMode sslmode = QgsDataSourceUri::SslMode::SslDisable;

QString username = QStringLiteral(&quot;postgres&quot;);
QString password = QStringLiteral(&quot;geostar&quot;);
QString authcfg = QStringLiteral(&quot;&quot;);

QgsDataSourceUri uri;
uri.setConnection(host, port, database, username, password, sslmode, authcfg);

QString schema = QStringLiteral(&quot;china&quot;);
QString tablename = QStringLiteral(&quot;bou2_4p&quot;);
QString geometrycol = QStringLiteral(&quot;geom&quot;);

uri.setDataSource(schema, tablename, geometrycol);

QgsVectorLayer::LayerOptions options;
options.loadDefaultStyle = false;

QgsVectorLayer *vectorLayer = new QgsVectorLayer(uri.uri(false), uri.table(), &quot;postgres&quot;, options);
QgsProject::instance()-&gt;addMapLayer(vectorLayer);
m_layers.append(vectorLayer);

m_mapCanvas-&gt;setLayers(m_layers);
m_mapCanvas-&gt;setVisible(true);
m_mapCanvas-&gt;zoomToFullExtent();
m_mapCanvas-&gt;freeze(false);
</code></pre>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>QGIS</tag>
        <tag>PostGIS</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS二次开发：依赖下载配置</title>
    <url>/2023/02/03/QGIS%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%9A%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>QGIS已经升级到3.6了，每次从源码编译开始做起，生成自己的二次开发包，是件很痛苦的事情。有没有其他更便捷的方式呢？</p>
<p>其实是有的，那就是用osgeo4w-setup-x86_64.exe这样的工具直接下载QGIS项目团队提供好的二次开发包。</p>
<p>根据个人实践，推荐使用该种方案：qgis+gdal+grass。</p>
<h1 id="1、qgis"><a href="#1、qgis" class="headerlink" title="1、qgis"></a>1、qgis</h1><p><img src="https://c2.im5i.com/2023/02/03/nqaQ8.png" alt="qgis"></p>
<h1 id="2、gdal"><a href="#2、gdal" class="headerlink" title="2、gdal"></a>2、gdal</h1><p><img src="https://c2.im5i.com/2023/02/03/nq4BU.png" alt="gdal-part-1"></p>
<p><img src="https://c2.im5i.com/2023/02/03/nqzb5.png" alt="gdal-part-2"></p>
<h1 id="3、grass"><a href="#3、grass" class="headerlink" title="3、grass"></a>3、grass</h1><p><img src="https://c2.im5i.com/2023/02/03/nq0m6.png" alt="grass"></p>
<p>下载后，也可以基于此方案对QGIS进行编译，形成自己的二次开发包，或对QGIS进行深入的学习研究。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>依赖配置</tag>
        <tag>QGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>QGIS二次开发：QGIS3.0.2编译</title>
    <url>/2023/02/02/QGIS%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%9AQGIS3-0-2%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这也是很久以前整理的一个技术资料，在这里翻出来，作为存档。</p>
<h1 id="1、下载源码"><a href="#1、下载源码" class="headerlink" title="1、下载源码"></a>1、下载源码</h1><p><a href="https://qgis.org/downloads/qgis-3.2.2.tar.bz2">https://qgis.org/downloads/qgis-3.2.2.tar.bz2</a></p>
<h1 id="2、开发环境和依赖库"><a href="#2、开发环境和依赖库" class="headerlink" title="2、开发环境和依赖库"></a>2、开发环境和依赖库</h1><p>解压代码，查看INSTALL，根据4.1. Building with Microsoft Visual Studio中的说明准备开发环境和依赖库。</p>
<h2 id="2-1开发环境"><a href="#2-1开发环境" class="headerlink" title="2.1开发环境"></a>2.1开发环境</h2><p>安装如下软件</p>
<pre><code>VS2015：社区版、专业版、旗舰版都可以
QT：选择msvc2015 32bit
http://download.qt.io/official_releases/qt/5.11/5.11.2/qt-opensource-windows-x86-5.9.2.exe
qt-vsaddin：http://download.qt.io/official_releases/vsaddin/qt-vsaddin-msvc2015-2.2.1.vsix
CMake ：https://cmake.org/files/v3.7/cmake-3.7.2-win64-x64.msi
win_flex_bison-latest.zip ：https://sourceforge.net/projects/winflexbison/files/win_flex_bison-2.4.12.zip/download
OSGeo4W：http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86.exe
Ninja：https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-win.zip
Python：https://www.python.org/ftp/python/3.6.0/python-3.6.0.exe
</code></pre>
<h2 id="2-2依赖库"><a href="#2-2依赖库" class="headerlink" title="2.2依赖库"></a>2.2依赖库</h2><p>点击osgeo4w，选择下载qgis-rel-deps。假定安装目录是E:\OpenSource\QGIS\qgis-rel-deps</p>
<h2 id="2-3调整配置"><a href="#2-3调整配置" class="headerlink" title="2.3调整配置"></a>2.3调整配置</h2><p>（1）VS2015→qt vs tool→Qt Options→Qt versions，配置msvc2015.<br>（2）安装pyqt5，打开cmd<br>pip install PyQt5==5.9.2<br>（3）环境变量增加E:\QGIS\qgis-3.0.2-deps\apps\Python36，或者安装Python时选择设置环境变量。</p>
<h1 id="3、CMAKE"><a href="#3、CMAKE" class="headerlink" title="3、CMAKE"></a>3、CMAKE</h1><h2 id="3-1批处理文件"><a href="#3-1批处理文件" class="headerlink" title="3.1批处理文件"></a>3.1批处理文件</h2><p>创建一个bat批处理文件，下述内容根据实际情况修改，</p>
<pre><code>@echo off
set OSGEO4W_ROOT=E:\OpenSource\QGIS\qgis-rel-deps
call “%OSGEO4W_ROOT%\bin\o4w_env.bat”
call “%OSGEO4W_ROOT%\bin\py3_env.bat”
call “%OSGEO4W_ROOT%\bin\qt5_env.bat”

set O4W_ROOT=%OSGEO4W_ROOT:\=/%
set LIB_DIR=%O4W_ROOT%

call “C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat” x86
path %path%;C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin

path %PATH%;E:\BaseTools\cmake-3.7.2-win32-x86\bin;

@set GRASS_PREFIX=E:/QGIS/qgis-3.0.2-deps/apps/grass/grass-7.4.0
@set INCLUDE=%INCLUDE%;%OSGEO4W_ROOT%\include
@set LIB=%LIB%;%OSGEO4W_ROOT%\lib;%OSGEO4W_ROOT%\lib

set LIB=%LIB%;%OSGEO4W_ROOT%\apps\Qt5\lib;%OSGEO4W_ROOT%\lib
set INCLUDE=%INCLUDE%;%OSGEO4W_ROOT%\apps\Qt5\include;%OSGEO4W_ROOT%\include

@cmd
</code></pre>
<h2 id="3-2运行cmake-gui"><a href="#3-2运行cmake-gui" class="headerlink" title="3.2运行cmake-gui"></a>3.2运行cmake-gui</h2><p>启动VS2015的x86命令行工具，运行cmake-gui，点configure，根据提示修改依赖库的路径。注意：建议不要勾选下图中蓝色方框标志项目，涉及测试程序的代码覆盖率的工具，配置较繁琐。<br>多次configure后，generate得到工程文件。</p>
<p><img src="https://c2.im5i.com/2023/02/03/nqni3.png" alt="QGIS编译配置" title="QGIS编译配置"></p>
<h1 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h1><p>编译的时候，会出现很多该类错误<br>warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失<br>解决办法：</p>
<ul>
<li>4.1点击错误提示，打开报错的文件。</li>
<li>4.2用鼠标左键单击一下该报错文件位于编辑区的文件标签卡：</li>
<li>4.3点“文件”–&gt;“高级保存”</li>
<li>4.4根据错误提示，选择正确的格式保存。</li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>依赖配置</tag>
        <tag>QGIS</tag>
        <tag>CMAKE</tag>
      </tags>
  </entry>
  <entry>
    <title>Opticks依赖库的手动下载</title>
    <url>/2023/02/02/Opticks%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是很久以前整理的一个技术资料，估计接触的人不多了。在这里翻出来，作为存档。</p>
<p>下载Opticks的代码编译，如果用其自带的retrieve-dependencies.bat下载依赖库，提示缺少模块。</p>
<p>可以采用下面的方式，手动下载整理依赖库。</p>
<p>一、找到如下配置文件：</p>
<p><a href="https://opticks.org/downloads/ivy-repo/opticks/opticks-deps/4.12.0/opticks-deps-ivy.xml">https://opticks.org/downloads/ivy-repo/opticks/opticks-deps/4.12.0/opticks-deps-ivy.xml</a></p>
<p>打开文件，查看如下内容：</p>
<pre><code>&lt;dependency org=&quot;opticks&quot; name=&quot;boost&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;boost-binaries&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;cfitsio&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;cg&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;curl&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;doxygen&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;ehs&quot; rev=&quot;1.0.6″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;expat&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;ffmpeg&quot; rev=&quot;1.0.3″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;gdal&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;glew&quot; rev=&quot;1.1.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;graphviz&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;hdf4″ rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;hdf5″ rev=&quot;1.1.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;jpeg&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;libgeotiff&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;liblas&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;libproj&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;libtiff&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;minizip&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;opencollada&quot; rev=&quot;1.0.3″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;opencv&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;openjpeg&quot; rev=&quot;1.0.4″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;ossim&quot; rev=&quot;1.0.4″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;pcre&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;pthreads&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;qt&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;qwt&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;raptor&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;shapelib&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;szip&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;tbb&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;xerces&quot; rev=&quot;1.0.1″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;xqilla&quot; rev=&quot;1.0.2″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;yaml-cpp&quot; rev=&quot;1.0.0″/&gt;
&lt;dependency org=&quot;opticks&quot; name=&quot;zlib&quot; rev=&quot;1.0.0″/&gt;
</code></pre>
<p>这些就是opticks编译所需的依赖库，这些依赖库的地址在如下地址可以找到</p>
<pre><code>https://opticks.org/downloads/ivy-repo/opticks/
</code></pre>
<p>二、把配置文件里的依赖库名称和版本号加上上面这个地址，组合出所有依赖库的下载路径如下：</p>
<pre><code>https://opticks.org/downloads/ivy-repo/opticks/boost/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/boost-binaries/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/cfitsio/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/cg/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/curl/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/doxygen/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/ehs/1.0.6/
https://opticks.org/downloads/ivy-repo/opticks/expat/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/ffmpeg/1.0.3/
https://opticks.org/downloads/ivy-repo/opticks/gdal/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/glew/1.1.0/
https://opticks.org/downloads/ivy-repo/opticks/graphviz/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/hdf4/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/hdf5/1.1.0/
https://opticks.org/downloads/ivy-repo/opticks/jpeg/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/libgeotiff/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/liblas/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/libproj/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/libtiff/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/minizip/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/opencollada/1.0.3/
https://opticks.org/downloads/ivy-repo/opticks/opencv/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/openjpeg/1.0.4/
https://opticks.org/downloads/ivy-repo/opticks/ossim/1.0.4/
https://opticks.org/downloads/ivy-repo/opticks/pcre/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/pthreads/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/qt/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/qwt/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/raptor/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/shapelib/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/szip/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/tbb/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/xerces/1.0.1/
https://opticks.org/downloads/ivy-repo/opticks/xqilla/1.0.2/
https://opticks.org/downloads/ivy-repo/opticks/yaml-cpp/1.0.0/
https://opticks.org/downloads/ivy-repo/opticks/zlib/1.0.0/
</code></pre>
<p>将上述目录下的文件下载到本地。</p>
<p>三、本地建一个目录，存放解压后的依赖库，并在系统环境变量中添加一条配置，OPTICKSDEPENDENCIES，指向这个目录。</p>
<p>四、在这个目录下再建两个文件夹，名称分别为32和64，Win32和x64的内容分别解压到这两个目录，分别形成include，lib和bin三个下一级目录。</p>
<p>五、接着打开工程Opticks.sln，即可开始编译了。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>依赖配置</tag>
        <tag>Opticks</tag>
      </tags>
  </entry>
  <entry>
    <title>兔年大吉，开工大吉</title>
    <url>/2023/02/01/%E5%85%94%E5%B9%B4%E5%A4%A7%E5%90%89%EF%BC%8C%E5%BC%80%E5%B7%A5%E5%A4%A7%E5%90%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>2023年2月1日，新的一个工作年度算是完完全全的开始了。</p>
<p>过去的2022年，发生了许多事情，但是2022年度本身，可以说是彻彻底底的结束了。</p>
<p>新的年度既已来到，那就要定下目标，严格执行。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><h2 id="1、工作"><a href="#1、工作" class="headerlink" title="1、工作"></a>1、工作</h2><p>找到一份工作，年薪在12W-20W之间，岗位以技术岗为主，程序员或技术经理均可。</p>
<h2 id="2、技能提升"><a href="#2、技能提升" class="headerlink" title="2、技能提升"></a>2、技能提升</h2><h3 id="2-1-开发能力"><a href="#2-1-开发能力" class="headerlink" title="2.1 开发能力"></a>2.1 开发能力</h3><p>利用B站及各种网络资源，以自学方式，提升以下几种开发语言的开发能力：</p>
<ul>
<li><p>C++\QT</p>
</li>
<li><p>Java\SpringBoot</p>
</li>
<li><p>Vue\Openlayer\leaflet</p>
</li>
<li><p>Python</p>
</li>
</ul>
<h3 id="2-2-项目管理能力"><a href="#2-2-项目管理能力" class="headerlink" title="2.2 项目管理能力"></a>2.2 项目管理能力</h3><p>利用B站及各种网络资源，以自学方式，获取以下几种资格证书：</p>
<ul>
<li>信息系统项目管理师<br>（切记：时刻关注报名登记消息，不要忘了）</li>
<li>注册测绘师</li>
</ul>
<h3 id="2-3-驾照"><a href="#2-3-驾照" class="headerlink" title="2.3 驾照"></a>2.3 驾照</h3><p>争取上半年通过驾考剩余科目考试，拿到驾照，下半年通过租车方式提升车感及熟练度，能在来年春节期间驾车拜亲访友、郊游出行。</p>
<h2 id="3、锻炼身体"><a href="#3、锻炼身体" class="headerlink" title="3、锻炼身体"></a>3、锻炼身体</h2><p>参照抖音各类减肥健身视频，工作日以室内锻炼为主，周末外出有氧运动为主，减去大肚囊。</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><h2 id="做好时间规划"><a href="#做好时间规划" class="headerlink" title="做好时间规划"></a>做好时间规划</h2><h2 id="早睡早起"><a href="#早睡早起" class="headerlink" title="早睡早起"></a>早睡早起</h2><h2 id="每日做好记录"><a href="#每日做好记录" class="headerlink" title="每日做好记录"></a>每日做好记录</h2>]]></content>
      <categories>
        <category>呢喃细语</category>
      </categories>
      <tags>
        <tag>新年祝福</tag>
        <tag>年度计划</tag>
      </tags>
  </entry>
</search>
